(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/animations'), require('@angular/core'), require('@angular/forms'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('resize-observer-polyfill'), require('jszip/dist/jszip'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define('igniteui-angular', ['exports', '@angular/animations', '@angular/core', '@angular/forms', '@angular/common', 'rxjs', 'rxjs/operators', 'resize-observer-polyfill', 'jszip/dist/jszip', '@angular/platform-browser'], factory) :
    (global = global || self, factory(global['igniteui-angular'] = {}, global.ng.animations, global.ng.core, global.ng.forms, global.ng.common, global.rxjs, global.rxjs.operators, global.ResizeObserver, global.JSZip, global.ng.platformBrowser));
}(this, (function (exports, animations, core, forms, common, rxjs, operators, ResizeObserver, JSZip, platformBrowser) { 'use strict';

    ResizeObserver = ResizeObserver && ResizeObserver.hasOwnProperty('default') ? ResizeObserver['default'] : ResizeObserver;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    (function (EaseIn) {
        EaseIn[EaseIn["quad"] = "cubic-bezier(0.550, 0.085, 0.680, 0.530)"] = "quad";
        EaseIn[EaseIn["cubic"] = "cubic-bezier(0.550, 0.055, 0.675, 0.190)"] = "cubic";
        EaseIn[EaseIn["quart"] = "cubic-bezier(0.895, 0.030, 0.685, 0.220)"] = "quart";
        EaseIn[EaseIn["quint"] = "cubic-bezier(0.755, 0.050, 0.855, 0.060)"] = "quint";
        EaseIn[EaseIn["sine"] = "cubic-bezier(0.470, 0.000, 0.745, 0.715)"] = "sine";
        EaseIn[EaseIn["expo"] = "cubic-bezier(0.950, 0.050, 0.795, 0.035)"] = "expo";
        EaseIn[EaseIn["circ"] = "cubic-bezier(0.600, 0.040, 0.980, 0.335)"] = "circ";
        EaseIn[EaseIn["back"] = "cubic-bezier(0.600, -0.280, 0.735, 0.045)"] = "back";
    })(exports["ɵg"] || (exports["ɵg"] = {}));

    (function (EaseOut) {
        EaseOut[EaseOut["quad"] = "cubic-bezier(0.250, 0.460, 0.450, 0.940)"] = "quad";
        EaseOut[EaseOut["cubic"] = "cubic-bezier(0.215, 0.610, 0.355, 1.000)"] = "cubic";
        EaseOut[EaseOut["quart"] = "cubic-bezier(0.165, 0.840, 0.440, 1.000)"] = "quart";
        EaseOut[EaseOut["quint"] = "cubic-bezier(0.230, 1.000, 0.320, 1.000)"] = "quint";
        EaseOut[EaseOut["sine"] = "cubic-bezier(0.390, 0.575, 0.565, 1.000)"] = "sine";
        EaseOut[EaseOut["expo"] = "cubic-bezier(0.190, 1.000, 0.220, 1.000)"] = "expo";
        EaseOut[EaseOut["circ"] = "cubic-bezier(0.075, 0.820, 0.165, 1.000)"] = "circ";
        EaseOut[EaseOut["back"] = "cubic-bezier(0.175, 0.885, 0.320, 1.275)"] = "back";
    })(exports["ɵh"] || (exports["ɵh"] = {}));
    var EaseInOut;
    (function (EaseInOut) {
        EaseInOut[EaseInOut["quad"] = "cubic-bezier(0.455, 0.030, 0.515, 0.955)"] = "quad";
        EaseInOut[EaseInOut["cubic"] = "cubic-bezier(0.645, 0.045, 0.355, 1.000)"] = "cubic";
        EaseInOut[EaseInOut["quart"] = "cubic-bezier(0.770, 0.000, 0.175, 1.000)"] = "quart";
        EaseInOut[EaseInOut["quint"] = "cubic-bezier(0.860, 0.000, 0.070, 1.000)"] = "quint";
        EaseInOut[EaseInOut["sine"] = "cubic-bezier(0.445, 0.050, 0.550, 0.950)"] = "sine";
        EaseInOut[EaseInOut["expo"] = "cubic-bezier(1.000, 0.000, 0.000, 1.000)"] = "expo";
        EaseInOut[EaseInOut["circ"] = "cubic-bezier(0.785, 0.135, 0.150, 0.860)"] = "circ";
        EaseInOut[EaseInOut["back"] = "cubic-bezier(0.680, -0.550, 0.265, 1.550)"] = "back";
    })(EaseInOut || (EaseInOut = {}));

    var base = [
        animations.style({
            opacity: "{{startOpacity}}"
        }),
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.style({
            opacity: "{{endOpacity}}"
        }))
    ];
    var baseParams = {
        delay: '0s',
        duration: '350ms',
        easing: exports["ɵh"].sine,
        endOpacity: 1,
        startOpacity: 0
    };
    var fadeIn = animations.animation(base, {
        params: baseParams
    });
    var fadeOut = animations.animation(base, {
        params: {
            delay: '0s',
            duration: '350ms',
            easing: exports["ɵh"].sine,
            endOpacity: 0,
            startOpacity: 1
        }
    });

    var baseRecipe = [
        animations.style({
            backfaceVisibility: 'hidden',
            transformStyle: 'preserve-3d'
        }),
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.keyframes([
            animations.style({
                offset: 0,
                transform: "translateZ({{startDistance}})\n                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{startAngle}}deg)"
            }),
            animations.style({
                offset: 1,
                transform: "translateZ({{endDistance}})\n                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{endAngle}}deg)"
            })
        ]))
    ];
    var baseParams$1 = {
        delay: '0s',
        duration: '600ms',
        easing: exports["ɵh"].quad,
        endAngle: 180,
        endDistance: '0px',
        rotateX: 1,
        rotateY: 0,
        rotateZ: 0,
        startAngle: 0,
        startDistance: '0px'
    };
    var flipTop = animations.animation(baseRecipe, {
        params: __assign({}, baseParams$1)
    });
    var flipBottom = animations.animation(baseRecipe, {
        params: __assign(__assign({}, baseParams$1), { endAngle: -180 })
    });
    var flipLeft = animations.animation(baseRecipe, {
        params: __assign(__assign({}, baseParams$1), { rotateX: 0, rotateY: 1 })
    });
    var flipRight = animations.animation(baseRecipe, {
        params: __assign(__assign({}, baseParams$1), { endAngle: -180, rotateX: 0, rotateY: 1 })
    });
    var flipHorFwd = animations.animation(baseRecipe, {
        params: __assign(__assign({}, baseParams$1), { endDistance: '170px' })
    });
    var flipHorBck = animations.animation(baseRecipe, {
        params: __assign(__assign({}, baseParams$1), { endDistance: '-170px' })
    });
    var flipVerFwd = animations.animation(baseRecipe, {
        params: __assign(__assign({}, baseParams$1), { endDistance: '170px', rotateX: 0, rotateY: 1 })
    });
    var flipVerBck = animations.animation(baseRecipe, {
        params: __assign(__assign({}, baseParams$1), { endDistance: '-170px', rotateX: 0, rotateY: 1 })
    });

    var baseRecipe$1 = [
        animations.style({
            opacity: "{{startOpacity}}",
            transform: "rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{startAngle}}deg)",
            transformOrigin: "{{xPos}} {{yPos}}"
        }),
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.style({
            offset: 0,
            opacity: "{{endOpacity}}",
            transform: "rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{endAngle}}deg)",
            transformOrigin: "{{xPos}} {{yPos}}"
        }))
    ];
    var baseInParams = {
        delay: '0s',
        duration: '600ms',
        easing: exports["ɵh"].quad,
        endAngle: 0,
        endOpacity: 1,
        rotateX: 0,
        rotateY: 0,
        rotateZ: 1,
        startAngle: -360,
        startOpacity: 0,
        xPos: 'center',
        yPos: 'center'
    };
    var baseOutParams = __assign(__assign({}, baseInParams), { easing: exports["ɵg"].quad, endOpacity: 0, startOpacity: 1 });
    var rotateInCenter = animations.animation(baseRecipe$1, {
        params: __assign({}, baseInParams)
    });
    var rotateOutCenter = animations.animation(baseRecipe$1, {
        params: __assign({}, baseOutParams)
    });
    var rotateInTop = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { xPos: 'top' })
    });
    var rotateOutTop = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { xPos: 'top' })
    });
    var rotateInRight = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { xPos: 'right' })
    });
    var rotateOutRight = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { xPos: 'right' })
    });
    var rotateInBottom = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { xPos: 'bottom' })
    });
    var rotateOutBottom = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { xPos: 'bottom' })
    });
    var rotateInLeft = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { xPos: 'left' })
    });
    var rotateOutLeft = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { xPos: 'left' })
    });
    var rotateInTr = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { xPos: 'right', yPos: 'top' })
    });
    var rotateOutTr = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { xPos: 'right', yPos: 'top' })
    });
    var rotateInBr = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { xPos: 'right', yPos: 'bottom' })
    });
    var rotateOutBr = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { xPos: 'right', yPos: 'bottom' })
    });
    var rotateInBl = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { xPos: 'left', yPos: 'bottom' })
    });
    var rotateOutBl = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { xPos: 'left', yPos: 'bottom' })
    });
    var rotateInTl = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { xPos: 'left', yPos: 'top' })
    });
    var rotateOutTl = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { xPos: 'left', yPos: 'top' })
    });
    var rotateInDiagonal1 = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { rotateX: 1, rotateY: 1, rotateZ: 0 })
    });
    var rotateOutDiagonal1 = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { rotateX: 1, rotateY: 1, rotateZ: 0 })
    });
    var rotateInDiagonal2 = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { rotateX: -1, rotateY: 1, rotateZ: 0 })
    });
    var rotateOutDiagonal2 = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { rotateX: -1, rotateY: 1, rotateZ: 0 })
    });
    var rotateInHor = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { rotateX: 0, rotateY: 1, rotateZ: 0 })
    });
    var rotateOutHor = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { rotateX: 0, rotateY: 1, rotateZ: 0 })
    });
    var rotateInVer = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseInParams), { rotateX: 1, rotateY: 0, rotateZ: 0 })
    });
    var rotateOutVer = animations.animation(baseRecipe$1, {
        params: __assign(__assign({}, baseOutParams), { rotateX: 1, rotateY: 0, rotateZ: 0 })
    });

    var baseRecipe$2 = [
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.keyframes([
            animations.style({
                offset: 0,
                transform: "rotate(0deg) translate{{direction}}(0)",
                transformOrigin: "{{xPos}} {{yPos}}"
            }),
            animations.style({
                offset: 0.1,
                transform: "rotate({{endAngle}}deg) translate{{direction}}(-{{startDistance}})"
            }),
            animations.style({
                offset: 0.2,
                transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
            }),
            animations.style({
                offset: 0.3,
                transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
            }),
            animations.style({
                offset: 0.4,
                transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
            }),
            animations.style({
                offset: 0.5,
                transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
            }),
            animations.style({
                offset: 0.6,
                transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
            }),
            animations.style({
                offset: 0.7,
                transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
            }),
            animations.style({
                offset: 0.8,
                transform: "rotate(-{{endAngle}}deg) translate{{direction}}({{endDistance}})"
            }),
            animations.style({
                offset: 0.9,
                transform: "rotate({{endAngle}}deg) translate{{direction}}(-{{endDistance}})"
            }),
            animations.style({
                offset: 1,
                transform: "rotate(0deg) translate{{direction}}(0)",
                transformOrigin: "{{xPos}} {{yPos}}"
            })
        ]))
    ];
    var baseParams$2 = {
        delay: '0s',
        direction: 'X',
        duration: '800ms',
        easing: EaseInOut.quad,
        endAngle: 0,
        endDistance: '8px',
        startAngle: 0,
        startDistance: '10px',
        xPos: 'center',
        yPos: 'center'
    };
    var shakeHor = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { direction: 'X' })
    });
    var shakeVer = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { direction: 'Y' })
    });
    var shakeTop = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'top' })
    });
    var shakeBottom = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'bottom' })
    });
    var shakeRight = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'center' })
    });
    var shakeLeft = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'center' })
    });
    var shakeCenter = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { direction: 'Y', endAngle: 8, endDistance: '0', startAngle: 10, startDistance: '0', xPos: 'center', yPos: 'center' })
    });
    var shakeTr = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'top' })
    });
    var shakeBr = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'bottom' })
    });
    var shakeBl = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'bottom' })
    });
    var shakeTl = animations.animation(baseRecipe$2, {
        params: __assign(__assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'top' })
    });

    var heartbeatBase = [
        animations.style({
            animationTimingFunction: "ease-out",
            transform: "scale(1)",
            transformOrigin: "center center"
        }),
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.keyframes([
            animations.style({
                animationTimingFunction: "ease-in",
                offset: 0.1,
                transform: "scale(0.91)"
            }),
            animations.style({
                animationTimingFunction: "ease-out",
                offset: 0.17,
                transform: "scale(0.98)"
            }),
            animations.style({
                animationTimingFunction: "ease-in",
                offset: 0.33,
                transform: "scale(0.87)"
            }),
            animations.style({
                animationTimingFunction: "ease-out",
                offset: 0.45,
                transform: "scale(1)"
            })
        ]))
    ];
    var heartbeatParams = {
        delay: '0s',
        duration: '1.5s',
        easing: 'ease-in-out'
    };
    var pulsateBase = [
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.keyframes([
            animations.style({
                offset: 0,
                transform: "scale({{fromScale}})"
            }),
            animations.style({
                offset: 0.5,
                transform: "scale({{toScale}})"
            }),
            animations.style({
                offset: 1,
                transform: "scale({{fromScale}})"
            })
        ]))
    ];
    var pulsateParams = {
        delay: '0s',
        duration: '.5s',
        easing: 'ease-in-out',
        fromScale: 1,
        toScale: 1.1
    };
    var blinkBase = [
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.keyframes([
            animations.style({
                offset: 0,
                opacity: .8,
                transform: "scale({{fromScale}})"
            }),
            animations.style({
                offset: 0.8,
                opacity: 0,
                transform: "scale({{midScale}})"
            }),
            animations.style({
                offset: 1,
                opacity: 0,
                transform: "scale({{toScale}})"
            })
        ]))
    ];
    var blinkParams = {
        delay: '0s',
        duration: '.8s',
        easing: 'ease-in-out',
        fromScale: .2,
        midScale: 1.2,
        toScale: 2.2
    };
    var pulsateFwd = animations.animation(pulsateBase, {
        params: __assign({}, pulsateParams)
    });
    var pulsateBck = animations.animation(pulsateBase, {
        params: __assign(__assign({}, pulsateParams), { toScale: .9 })
    });
    var heartbeat = animations.animation(heartbeatBase, {
        params: __assign({}, heartbeatParams)
    });
    var blink = animations.animation(blinkBase, {
        params: __assign({}, blinkParams)
    });

    var base$1 = [
        animations.style({
            opacity: "{{startOpacity}}",
            transform: "scale{{direction}}({{fromScale}})",
            transformOrigin: "{{xPos}} {{yPos}}"
        }),
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.style({
            opacity: "{{endOpacity}}",
            transform: "scale{{direction}}({{toScale}})",
            transformOrigin: "{{xPos}} {{yPos}}"
        }))
    ];
    var baseInParams$1 = {
        delay: '0s',
        direction: '',
        duration: '350ms',
        easing: exports["ɵh"].quad,
        endOpacity: 1,
        fromScale: .5,
        startOpacity: 0,
        toScale: 1,
        xPos: '50%',
        yPos: '50%'
    };
    var baseOutParams$1 = __assign(__assign({}, baseInParams$1), { easing: exports["ɵh"].sine, endOpacity: 0, fromScale: 1, startOpacity: 1, toScale: .5 });
    var scaleInCenter = animations.animation(base$1, { params: baseInParams$1 });
    var scaleInBl = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { xPos: '0', yPos: '100%' })
    });
    var scaleInVerCenter = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { direction: 'Y', fromScale: .4 })
    });
    var scaleInTop = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { xPos: '50%', yPos: '0' })
    });
    var scaleInLeft = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { xPos: '0', yPos: '50%' })
    });
    var scaleInVerTop = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { direction: 'Y', fromScale: .4, xPos: '100%', yPos: '0' })
    });
    var scaleInTr = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { xPos: '100%', yPos: '0' })
    });
    var scaleInTl = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { xPos: '0', yPos: '0' })
    });
    var scaleInVerBottom = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { direction: 'Y', fromScale: .4, xPos: '0', yPos: '100%' })
    });
    var scaleInRight = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { xPos: '100%', yPos: '50%' })
    });
    var scaleInHorCenter = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { direction: 'X', fromScale: .4 })
    });
    var scaleInBr = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { xPos: '100%', yPos: '100%' })
    });
    var scaleInHorLeft = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { direction: 'X', fromScale: .4, xPos: '0', yPos: '0' })
    });
    var scaleInBottom = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { xPos: '50%', yPos: '100%' })
    });
    var scaleInHorRight = animations.animation(base$1, {
        params: __assign(__assign({}, baseInParams$1), { direction: 'X', fromScale: .4, xPos: '100%', yPos: '100%' })
    });
    var scaleOutCenter = animations.animation(base$1, { params: baseOutParams$1 });
    var scaleOutBl = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { xPos: '0', yPos: '100%' })
    });
    var scaleOutBr = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { xPos: '100%', yPos: '100%' })
    });
    var scaleOutVerCenter = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { direction: 'Y', toScale: .3 })
    });
    var scaleOutVerTop = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { direction: 'Y', toScale: .3, xPos: '100%', yPos: '0' })
    });
    var scaleOutVerBottom = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { direction: 'Y', toScale: .3, xPos: '0', yPos: '100%' })
    });
    var scaleOutTop = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { xPos: '50%', yPos: '0' })
    });
    var scaleOutLeft = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { xPos: '0', yPos: '50%' })
    });
    var scaleOutTr = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { xPos: '100%', yPos: '0' })
    });
    var scaleOutTl = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { xPos: '0', yPos: '0' })
    });
    var scaleOutRight = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { xPos: '100%', yPos: '50%' })
    });
    var scaleOutBottom = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { xPos: '50%', yPos: '100%' })
    });
    var scaleOutHorCenter = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { direction: 'X', toScale: .3 })
    });
    var scaleOutHorLeft = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { direction: 'X', toScale: .3, xPos: '0', yPos: '0' })
    });
    var scaleOutHorRight = animations.animation(base$1, {
        params: __assign(__assign({}, baseOutParams$1), { direction: 'X', toScale: .3, xPos: '100%', yPos: '100%' })
    });

    var base$2 = [
        animations.style({
            opacity: "{{startOpacity}}",
            transform: "{{fromPosition}}"
        }),
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.style({
            opacity: "{{endOpacity}}",
            transform: "{{toPosition}}"
        }))
    ];
    var baseInParams$2 = {
        delay: '0s',
        duration: '350ms',
        easing: exports["ɵh"].quad,
        endOpacity: 1,
        fromPosition: 'translateY(-500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    };
    var baseOutParams$2 = {
        delay: '0s',
        duration: '350ms',
        easing: exports["ɵg"].quad,
        endOpacity: 0,
        fromPosition: 'translateY(0)',
        startOpacity: 1,
        toPosition: 'translateY(-500px)'
    };
    var slideInTop = animations.animation(base$2, { params: baseInParams$2 });
    var slideInLeft = animations.animation(base$2, {
        params: {
            delay: '0s',
            duration: '350ms',
            easing: exports["ɵh"].quad,
            endOpacity: 1,
            fromPosition: 'translateX(-500px)',
            startOpacity: 0,
            toPosition: 'translateY(0)'
        }
    });
    var slideInRight = animations.animation(base$2, {
        params: {
            delay: '0s',
            duration: '350ms',
            easing: exports["ɵh"].quad,
            endOpacity: 1,
            fromPosition: 'translateX(500px)',
            startOpacity: 0,
            toPosition: 'translateY(0)'
        }
    });
    var slideInBottom = animations.animation(base$2, {
        params: {
            delay: '0s',
            duration: '350ms',
            easing: exports["ɵh"].quad,
            endOpacity: 1,
            fromPosition: 'translateY(500px)',
            startOpacity: 0,
            toPosition: 'translateY(0)'
        }
    });
    var slideInTr = animations.animation(base$2, {
        params: __assign(__assign({}, baseInParams$2), { fromPosition: 'translateY(-500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
    });
    var slideInTl = animations.animation(base$2, {
        params: __assign(__assign({}, baseInParams$2), { fromPosition: 'translateY(-500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
    });
    var slideInBr = animations.animation(base$2, {
        params: __assign(__assign({}, baseInParams$2), { fromPosition: 'translateY(500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
    });
    var slideInBl = animations.animation(base$2, {
        params: __assign(__assign({}, baseInParams$2), { fromPosition: 'translateY(500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
    });
    var slideOutTop = animations.animation(base$2, { params: baseOutParams$2 });
    var slideOutRight = animations.animation(base$2, {
        params: __assign(__assign({}, baseOutParams$2), { toPosition: 'translateX(500px)' })
    });
    var slideOutBottom = animations.animation(base$2, {
        params: {
            delay: '0s',
            duration: '350ms',
            easing: exports["ɵg"].quad,
            endOpacity: 0,
            fromPosition: 'translateY(0)',
            startOpacity: 1,
            toPosition: 'translateY(500px)'
        }
    });
    var slideOutLeft = animations.animation(base$2, {
        params: __assign(__assign({}, baseOutParams$2), { toPosition: 'translateX(-500px)' })
    });
    var slideOutTr = animations.animation(base$2, {
        params: __assign(__assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(500px)' })
    });
    var slideOutBr = animations.animation(base$2, {
        params: __assign(__assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(500px)' })
    });
    var slideOutBl = animations.animation(base$2, {
        params: __assign(__assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(-500px)' })
    });
    var slideOutTl = animations.animation(base$2, {
        params: __assign(__assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(-500px)' })
    });

    var swingBase = [
        animations.style({
            opacity: "{{startOpacity}}",
            transform: "rotate{{direction}}({{startAngle}}deg)",
            transformOrigin: "{{xPos}} {{yPos}}"
        }),
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.style({
            opacity: "{{endOpacity}}",
            transform: "rotate{{direction}}({{endAngle}}deg)",
            transformOrigin: "{{xPos}} {{yPos}}"
        }))
    ];
    var swingParams = {
        delay: '0s',
        direction: 'X',
        duration: '.5s',
        easing: exports["ɵh"].back,
        endAngle: 0,
        endOpacity: 1,
        startAngle: -100,
        startOpacity: 0,
        xPos: 'top',
        yPos: 'center'
    };
    var swingOutParams = __assign(__assign({}, swingParams), { duration: '.55s', easing: exports["ɵg"].back, endAngle: 70, endOpacity: 0, startAngle: 0, startOpacity: 1 });
    var swingInTopFwd = animations.animation(swingBase, {
        params: __assign({}, swingParams)
    });
    var swingInRightFwd = animations.animation(swingBase, {
        params: __assign(__assign({}, swingParams), { direction: 'Y', xPos: 'center', yPos: 'right' })
    });
    var swingInBottomFwd = animations.animation(swingBase, {
        params: __assign(__assign({}, swingParams), { startAngle: 100, xPos: 'bottom' })
    });
    var swingInLeftFwd = animations.animation(swingBase, {
        params: __assign(__assign({}, swingParams), { direction: 'Y', startAngle: 100, xPos: 'center', yPos: 'left' })
    });
    var swingInTopBck = animations.animation(swingBase, {
        params: __assign(__assign({}, swingParams), { duration: '.6s', startAngle: 70 })
    });
    var swingInRightBck = animations.animation(swingBase, {
        params: __assign(__assign({}, swingParams), { direction: 'Y', duration: '.6s', startAngle: 70, xPos: 'center', yPos: 'right' })
    });
    var swingInBottomBck = animations.animation(swingBase, {
        params: __assign(__assign({}, swingParams), { duration: '.6s', startAngle: -70, xPos: 'bottom' })
    });
    var swingInLeftBck = animations.animation(swingBase, {
        params: __assign(__assign({}, swingParams), { direction: 'Y', duration: '.6s', startAngle: -70, xPos: 'center', yPos: 'left' })
    });
    var swingOutTopFwd = animations.animation(swingBase, {
        params: __assign({}, swingOutParams)
    });
    var swingOutRightFwd = animations.animation(swingBase, {
        params: __assign(__assign({}, swingOutParams), { direction: 'Y', xPos: 'center', yPos: 'right' })
    });
    var swingOutBottomFwd = animations.animation(swingBase, {
        params: __assign(__assign({}, swingOutParams), { endAngle: -70, xPos: 'bottom' })
    });
    var swingOutLefttFwd = animations.animation(swingBase, {
        params: __assign(__assign({}, swingOutParams), { direction: 'Y', endAngle: -70, xPos: 'center', yPos: 'left' })
    });
    var swingOutTopBck = animations.animation(swingBase, {
        params: __assign(__assign({}, swingOutParams), { duration: '.45s', endAngle: -100 })
    });
    var swingOutRightBck = animations.animation(swingBase, {
        params: __assign(__assign({}, swingOutParams), { direction: 'Y', duration: '.45s', endAngle: -100, xPos: 'center', yPos: 'right' })
    });
    var swingOutBottomBck = animations.animation(swingBase, {
        params: __assign(__assign({}, swingOutParams), { duration: '.45s', endAngle: 100, xPos: 'bottom' })
    });
    var swingOutLeftBck = animations.animation(swingBase, {
        params: __assign(__assign({}, swingOutParams), { direction: 'Y', duration: '.45s', endAngle: 100, xPos: 'center', yPos: 'left' })
    });

    var base$3 = [
        animations.style({
            opacity: "{{ startOpacity }}",
            height: "{{ startHeight }}"
        }),
        animations.animate("{{duration}} {{delay}} {{easing}}", animations.style({
            opacity: "{{ endOpacity }}",
            height: "{{ endHeight }}"
        }))
    ];
    var baseParams$3 = {
        delay: '0s',
        duration: '350ms',
        easing: exports["ɵg"].quad,
        startOpacity: 0,
        endOpacity: 1,
        startHeight: '',
        endHeight: ''
    };
    var growVerIn = animations.animation(base$3, {
        params: __assign(__assign({}, baseParams$3), { easing: exports["ɵh"].quad, startOpacity: 0, endOpacity: 1, startHeight: '0px', endHeight: '*' })
    });
    var growVerOut = animations.animation(base$3, {
        params: __assign(__assign({}, baseParams$3), { easing: exports["ɵh"].quad, startOpacity: 1, endOpacity: 0, startHeight: '*', endHeight: '0px' })
    });

    /**
     * Common service to be injected between components where those implementing common
     * ToggleView interface can register and toggle directives can call their methods.
     * TODO: Track currently active? Events?
     */
    var IgxNavigationService = /** @class */ (function () {
        function IgxNavigationService() {
            this.navs = {};
        }
        IgxNavigationService.prototype.add = function (id, navItem) {
            this.navs[id] = navItem;
        };
        IgxNavigationService.prototype.remove = function (id) {
            delete this.navs[id];
        };
        IgxNavigationService.prototype.get = function (id) {
            if (id) {
                return this.navs[id];
            }
        };
        IgxNavigationService.prototype.toggle = function (id) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.navs[id]) {
                return (_a = this.navs[id]).toggle.apply(_a, __spread(args));
            }
        };
        IgxNavigationService.prototype.open = function (id) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.navs[id]) {
                return (_a = this.navs[id]).open.apply(_a, __spread(args));
            }
        };
        IgxNavigationService.prototype.close = function (id) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (this.navs[id]) {
                return (_a = this.navs[id]).close.apply(_a, __spread(args));
            }
        };
        IgxNavigationService = __decorate([
            core.Injectable()
        ], IgxNavigationService);
        return IgxNavigationService;
    }());

    /**
     * Directive that can toggle targets through provided NavigationService.
     *
     * Usage:
     * ```
     * <button igxNavToggle="ID"> Toggle </button>
     * ```
     * Where the `ID` matches the ID of compatible `IToggleView` component.
     */
    var IgxNavigationToggleDirective = /** @class */ (function () {
        function IgxNavigationToggleDirective(nav) {
            this.state = nav;
        }
        IgxNavigationToggleDirective.prototype.toggleNavigationDrawer = function () {
            this.state.toggle(this.target, true);
        };
        IgxNavigationToggleDirective.ctorParameters = function () { return [
            { type: IgxNavigationService }
        ]; };
        __decorate([
            core.Input('igxNavToggle')
        ], IgxNavigationToggleDirective.prototype, "target", void 0);
        __decorate([
            core.HostListener('click')
        ], IgxNavigationToggleDirective.prototype, "toggleNavigationDrawer", null);
        IgxNavigationToggleDirective = __decorate([
            core.Directive({ selector: '[igxNavToggle]' })
        ], IgxNavigationToggleDirective);
        return IgxNavigationToggleDirective;
    }());
    /**
     * Directive that can close targets through provided NavigationService.
     *
     * Usage:
     * ```
     * <button igxNavClose="ID"> Close </button>
     * ```
     * Where the `ID` matches the ID of compatible `IToggleView` component.
     */
    var IgxNavigationCloseDirective = /** @class */ (function () {
        function IgxNavigationCloseDirective(nav) {
            this.state = nav;
        }
        IgxNavigationCloseDirective.prototype.closeNavigationDrawer = function () {
            this.state.close(this.target, true);
        };
        IgxNavigationCloseDirective.ctorParameters = function () { return [
            { type: IgxNavigationService }
        ]; };
        __decorate([
            core.Input('igxNavClose')
        ], IgxNavigationCloseDirective.prototype, "target", void 0);
        __decorate([
            core.HostListener('click')
        ], IgxNavigationCloseDirective.prototype, "closeNavigationDrawer", null);
        IgxNavigationCloseDirective = __decorate([
            core.Directive({ selector: '[igxNavClose]' })
        ], IgxNavigationCloseDirective);
        return IgxNavigationCloseDirective;
    }());
    /**
     * @hidden
     */
    var IgxNavigationModule = /** @class */ (function () {
        function IgxNavigationModule() {
        }
        IgxNavigationModule = __decorate([
            core.NgModule({
                declarations: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                exports: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                providers: [IgxNavigationService]
            })
        ], IgxNavigationModule);
        return IgxNavigationModule;
    }());

    /**
     *@hidden
     */
    function cloneArray(array, deep) {
        var arr = [];
        if (!array) {
            return arr;
        }
        var i = array.length;
        while (i--) {
            arr[i] = deep ? cloneValue(array[i]) : array[i];
        }
        return arr;
    }
    /**
     * Doesn't clone leaf items
     * @hidden
     */
    function cloneHierarchicalArray(array, childDataKey) {
        var e_1, _a;
        var result = [];
        if (!array) {
            return result;
        }
        try {
            for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
                var item = array_1_1.value;
                var clonedItem = cloneValue(item);
                if (Array.isArray(item[childDataKey])) {
                    clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
                }
                result.push(clonedItem);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    /**
     * Deep clones all first level keys of Obj2 and merges them to Obj1
     * @param obj1 Object to merge into
     * @param obj2 Object to merge from
     * @returns Obj1 with merged cloned keys from Obj2
     * @hidden
     */
    function mergeObjects(obj1, obj2) {
        var e_2, _a;
        if (!isObject(obj1)) {
            throw new Error("Cannot merge into " + obj1 + ". First param must be an object.");
        }
        if (!isObject(obj2)) {
            return obj1;
        }
        try {
            for (var _b = __values(Object.keys(obj2)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                obj1[key] = cloneValue(obj2[key]);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return obj1;
    }
    /**
     * Creates deep clone of provided value.
     * Supports primitive values, dates and objects.
     * If passed value is array returns shallow copy of the array.
     * @param value value to clone
     * @returns Deep copy of provided value
     *@hidden
     */
    function cloneValue(value) {
        var e_3, _a;
        if (isDate(value)) {
            return new Date(value.getTime());
        }
        if (Array.isArray(value)) {
            return __spread(value);
        }
        if (value instanceof Map || value instanceof Set) {
            return value;
        }
        if (isObject(value)) {
            var result = {};
            try {
                for (var _b = __values(Object.keys(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    result[key] = cloneValue(value[key]);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return result;
        }
        return value;
    }
    /**
     * Checks if provided variable is Object
     * @param value Value to check
     * @returns true if provided variable is Object
     *@hidden
     */
    function isObject(value) {
        return value && value.toString() === '[object Object]';
    }
    /**
     * Checks if provided variable is Date
     * @param value Value to check
     * @returns true if provided variable is Date
     *@hidden
     */
    function isDate(value) {
        return Object.prototype.toString.call(value) === '[object Date]';
    }
    /**
     * Checks if the two passed arguments are equal
     * Currently supports date objects
     * @param obj1
     * @param obj2
     * @returns: `boolean`
     * @hidden
     */
    function isEqual(obj1, obj2) {
        if (isDate(obj1) && isDate(obj2)) {
            return obj1.getTime() === obj2.getTime();
        }
        return obj1 === obj2;
    }
    /**
     *@hidden
    * Returns the actual size of the node content, using Range
    * ```typescript
    * let range = document.createRange();
    * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
    *
    * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
    * ```
     */
    function getNodeSizeViaRange(range, node) {
        var overflow = null;
        if (!isFirefox()) {
            overflow = node.style.overflow;
            // we need that hack - otherwise content won't be measured correctly in IE/Edge
            node.style.overflow = 'visible';
        }
        range.selectNodeContents(node);
        var width = range.getBoundingClientRect().width;
        if (!isFirefox()) {
            // we need that hack - otherwise content won't be measured correctly in IE/Edge
            node.style.overflow = overflow;
        }
        return width;
    }
    /**
     *@hidden
    * Returns the actual size of the node content, using Canvas
    * ```typescript
    * let ctx = document.createElement('canvas').getContext('2d');
    * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
    *
    * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
    * ```
     */
    function getNodeSizeViaCanvas(canvas2dCtx, node) {
        var s = this.grid.document.defaultView.getComputedStyle(node);
        // need to set the font to get correct width
        canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
        return canvas2dCtx.measureText(node.textContent).width;
    }
    /**
     *@hidden
     */
    function isIE() {
        return navigator.appVersion.indexOf('Trident/') > 0;
    }
    /**
     *@hidden
     */
    function isEdge() {
        var edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
        return edgeBrowser;
    }
    /**
     *@hidden
     */
    function isFirefox() {
        var firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
        return firefoxBrowser;
    }
    /**
     * @hidden
     */
    var PlatformUtil = /** @class */ (function () {
        function PlatformUtil(platformId) {
            this.platformId = platformId;
            this.isBrowser = common.isPlatformBrowser(this.platformId);
            this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
        }
        PlatformUtil.ctorParameters = function () { return [
            { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
        ]; };
        PlatformUtil.ɵprov = core["ɵɵdefineInjectable"]({ factory: function PlatformUtil_Factory() { return new PlatformUtil(core["ɵɵinject"](core.PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
        PlatformUtil = __decorate([
            core.Injectable({ providedIn: 'root' }),
            __param(0, core.Inject(core.PLATFORM_ID))
        ], PlatformUtil);
        return PlatformUtil;
    }());
    /**
     * @hidden
     */
    function isLeftClick(event) {
        return event.button === 0;
    }
    /** @hidden */
    function isNavigationKey(key) {
        return [
            'down',
            'up',
            'left',
            'right',
            'arrowdown',
            'arrowup',
            'arrowleft',
            'arrowright',
            'home',
            'end',
            'space',
            'spacebar',
            ' '
        ].indexOf(key) !== -1;
    }
    /**
     *@hidden
     */
    function flatten(arr) {
        var result = [];
        arr.forEach(function (el) {
            result.push(el);
            if (el.children) {
                var children = Array.isArray(el.children) ? el.children : el.children.toArray();
                result = result.concat(flatten(children));
            }
        });
        return result;
    }
    var NAVIGATION_KEYS = new Set([
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ]);
    var ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
    var ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
    var SUPPORTED_KEYS = new Set(__spread(Array.from(NAVIGATION_KEYS), ['tab', 'enter', 'f2', 'escape', 'esc']));
    /**
     * @hidden
     * @internal
     *
     * Creates a new ResizeObserver on `target` and returns it as an Observable.
     * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
     * Related issue: https://github.com/angular/angular/issues/31712
     */
    function resizeObservable(target) {
        return new rxjs.Observable(function (observer) {
            var instance = new ResizeObserver(function (entries) {
                observer.next(entries);
            });
            instance.observe(target);
            var unsubscribe = function () { return instance.disconnect(); };
            return unsubscribe;
        });
    }

    /**
     * Represents sorting expressions.
     */

    (function (SortingDirection) {
        SortingDirection[SortingDirection["None"] = 0] = "None";
        SortingDirection[SortingDirection["Asc"] = 1] = "Asc";
        SortingDirection[SortingDirection["Desc"] = 2] = "Desc";
    })(exports.SortingDirection || (exports.SortingDirection = {}));

    function isHierarchyMatch(h1, h2) {
        if (h1.length !== h2.length) {
            return false;
        }
        return h1.every(function (level, index) {
            return level.fieldName === h2[index].fieldName && level.value === h2[index].value;
        });
    }
    function getHierarchy(gRow) {
        var hierarchy = [];
        if (gRow !== undefined && gRow.expression) {
            hierarchy.push({ fieldName: gRow.expression.fieldName, value: gRow.value });
            while (gRow.groupParent) {
                gRow = gRow.groupParent;
                hierarchy.unshift({ fieldName: gRow.expression.fieldName, value: gRow.value });
            }
        }
        return hierarchy;
    }

    var DefaultSortingStrategy = /** @class */ (function () {
        function DefaultSortingStrategy() {
        }
        DefaultSortingStrategy.instance = function () {
            return this._instance || (this._instance = new this());
        };
        DefaultSortingStrategy.prototype.sort = function (data, fieldName, dir, ignoreCase, valueResolver) {
            var _this = this;
            var key = fieldName;
            var reverse = (dir === exports.SortingDirection.Desc ? -1 : 1);
            var cmpFunc = function (obj1, obj2) {
                return _this.compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver);
            };
            return this.arraySort(data, cmpFunc);
        };
        DefaultSortingStrategy.prototype.compareValues = function (a, b) {
            var an = (a === null || a === undefined);
            var bn = (b === null || b === undefined);
            if (an) {
                if (bn) {
                    return 0;
                }
                return -1;
            }
            else if (bn) {
                return 1;
            }
            return a > b ? 1 : a < b ? -1 : 0;
        };
        DefaultSortingStrategy.prototype.compareObjects = function (obj1, obj2, key, reverse, ignoreCase, valueResolver) {
            var a = valueResolver(obj1, key);
            var b = valueResolver(obj2, key);
            if (ignoreCase) {
                a = a && a.toLowerCase ? a.toLowerCase() : a;
                b = b && b.toLowerCase ? b.toLowerCase() : b;
            }
            return reverse * this.compareValues(a, b);
        };
        DefaultSortingStrategy.prototype.arraySort = function (data, compareFn) {
            return data.sort(compareFn);
        };
        DefaultSortingStrategy._instance = null;
        return DefaultSortingStrategy;
    }());
    var NoopSortingStrategy = /** @class */ (function () {
        function NoopSortingStrategy() {
        }
        NoopSortingStrategy.instance = function () {
            return this._instance || (this._instance = new NoopSortingStrategy());
        };
        NoopSortingStrategy.prototype.sort = function (data, expressions) {
            return data;
        };
        NoopSortingStrategy._instance = null;
        return NoopSortingStrategy;
    }());
    var IgxSorting = /** @class */ (function () {
        function IgxSorting() {
        }
        IgxSorting.prototype.sort = function (data, expressions) {
            return this.sortDataRecursive(data, expressions);
        };
        IgxSorting.prototype.groupedRecordsByExpression = function (data, index, expression) {
            var i;
            var groupval;
            var res = [];
            var key = expression.fieldName;
            var len = data.length;
            res.push(data[index]);
            groupval = this.getFieldValue(data[index], key);
            index++;
            var comparer = expression.groupingComparer || DefaultSortingStrategy.instance().compareValues;
            for (i = index; i < len; i++) {
                if (comparer(this.getFieldValue(data[i], key), groupval) === 0) {
                    res.push(data[i]);
                }
                else {
                    break;
                }
            }
            return res;
        };
        IgxSorting.prototype.sortDataRecursive = function (data, expressions, expressionIndex) {
            if (expressionIndex === void 0) { expressionIndex = 0; }
            var i;
            var j;
            var expr;
            var gbData;
            var gbDataLen;
            var exprsLen = expressions.length;
            var dataLen = data.length;
            expressionIndex = expressionIndex || 0;
            if (expressionIndex >= exprsLen || dataLen <= 1) {
                return data;
            }
            expr = expressions[expressionIndex];
            if (!expr.strategy) {
                expr.strategy = DefaultSortingStrategy.instance();
            }
            data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue);
            if (expressionIndex === exprsLen - 1) {
                return data;
            }
            // in case of multiple sorting
            for (i = 0; i < dataLen; i++) {
                gbData = this.groupedRecordsByExpression(data, i, expr);
                gbDataLen = gbData.length;
                if (gbDataLen > 1) {
                    gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1);
                }
                for (j = 0; j < gbDataLen; j++) {
                    data[i + j] = gbData[j];
                }
                i += gbDataLen - 1;
            }
            return data;
        };
        IgxSorting.prototype.groupDataRecursive = function (data, state, level, parent, metadata, grid, groupsRecords, fullResult) {
            if (grid === void 0) { grid = null; }
            if (groupsRecords === void 0) { groupsRecords = []; }
            if (fullResult === void 0) { fullResult = { data: [], metadata: [] }; }
            var expressions = state.expressions;
            var expansion = state.expansion;
            var i = 0;
            var result = [];
            var _loop_1 = function () {
                var e_1, _a;
                var group = this_1.groupedRecordsByExpression(data, i, expressions[level]);
                var groupRow = {
                    expression: expressions[level],
                    level: level,
                    records: cloneArray(group),
                    value: group[0][expressions[level].fieldName],
                    groupParent: parent,
                    groups: [],
                    height: grid ? grid.renderedRowHeight : null
                };
                if (parent) {
                    parent.groups.push(groupRow);
                }
                else {
                    groupsRecords.push(groupRow);
                }
                var hierarchy = getHierarchy(groupRow);
                var expandState = expansion.find(function (s) {
                    return isHierarchyMatch(s.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy);
                });
                var expanded = expandState ? expandState.expanded : state.defaultExpanded;
                var recursiveResult = void 0;
                result.push(groupRow);
                metadata.push(null);
                fullResult.data.push(groupRow);
                fullResult.metadata.push(null);
                if (level < expressions.length - 1) {
                    recursiveResult = this_1.groupDataRecursive(group, state, level + 1, groupRow, expanded ? metadata : [], grid, groupsRecords, fullResult);
                    if (expanded) {
                        result = result.concat(recursiveResult);
                    }
                }
                else {
                    try {
                        for (var group_1 = (e_1 = void 0, __values(group)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
                            var groupItem = group_1_1.value;
                            fullResult.metadata.push(groupRow);
                            fullResult.data.push(groupItem);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (group_1_1 && !group_1_1.done && (_a = group_1.return)) _a.call(group_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    if (expanded) {
                        metadata.push.apply(metadata, __spread(fullResult.metadata.slice(fullResult.metadata.length - group.length)));
                        result.push.apply(result, __spread(fullResult.data.slice(fullResult.data.length - group.length)));
                    }
                }
                i += group.length;
            };
            var this_1 = this;
            while (i < data.length) {
                _loop_1();
            }
            return result;
        };
        IgxSorting.prototype.getFieldValue = function (obj, key) {
            return obj[key];
        };
        return IgxSorting;
    }());
    var IgxDataRecordSorting = /** @class */ (function (_super) {
        __extends(IgxDataRecordSorting, _super);
        function IgxDataRecordSorting() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxDataRecordSorting.prototype.getFieldValue = function (obj, key) {
            return obj.data[key];
        };
        return IgxDataRecordSorting;
    }(IgxSorting));

    var IgxGrouping = /** @class */ (function (_super) {
        __extends(IgxGrouping, _super);
        function IgxGrouping() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxGrouping.prototype.groupBy = function (data, state, grid, groupsRecords, fullResult) {
            if (fullResult === void 0) { fullResult = { data: [], metadata: [] }; }
            var metadata = [];
            var grouping = this.groupDataRecursive(data, state, 0, null, metadata, grid, groupsRecords, fullResult);
            return {
                data: grouping,
                metadata: metadata
            };
        };
        return IgxGrouping;
    }(IgxSorting));


    (function (PagingError) {
        PagingError[PagingError["None"] = 0] = "None";
        PagingError[PagingError["IncorrectPageIndex"] = 1] = "IncorrectPageIndex";
        PagingError[PagingError["IncorrectRecordsPerPage"] = 2] = "IncorrectRecordsPerPage";
    })(exports.PagingError || (exports.PagingError = {}));


    (function (FilteringLogic) {
        FilteringLogic[FilteringLogic["And"] = 0] = "And";
        FilteringLogic[FilteringLogic["Or"] = 1] = "Or";
    })(exports.FilteringLogic || (exports.FilteringLogic = {}));


    (function (FilteringExpressionsTreeType) {
        FilteringExpressionsTreeType[FilteringExpressionsTreeType["Regular"] = 0] = "Regular";
        FilteringExpressionsTreeType[FilteringExpressionsTreeType["Advanced"] = 1] = "Advanced";
    })(exports.FilteringExpressionsTreeType || (exports.FilteringExpressionsTreeType = {}));
    var FilteringExpressionsTree = /** @class */ (function () {
        function FilteringExpressionsTree(operator, fieldName) {
            /**
             * Sets/gets the filtering operands.
             * ```typescript
             * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
             * const expression = [
             * {
             *   condition: IgxStringFilteringOperand.instance().condition('contains'),
             *   fieldName: 'Column Field',
             *   searchVal: 'Value',
             *   ignoreCase: false
             * }];
             * gridExpressionsTree.filteringOperands.push(expression);
             * this.grid.filteringExpressionsTree = gridExpressionsTree;
             * ```
             * ```typescript
             * let filteringOperands = gridExpressionsTree.filteringOperands;
             * ```
             * @memberof FilteringExpressionsTree
             */
            this.filteringOperands = [];
            this.operator = operator;
            this.fieldName = fieldName;
        }
        /**
         * Checks if filtering expressions tree is empty.
         * @param expressionTree filtering expressions tree.
         */
        FilteringExpressionsTree.empty = function (expressionTree) {
            return !expressionTree || !expressionTree.filteringOperands || !expressionTree.filteringOperands.length;
        };
        /**
         * Returns the filtering expression for a column with the provided fieldName.
         * ```typescript
         * let filteringExpression = gridExpressionTree.find('Column Field');
         * ```
         * @memberof FilteringExpressionsTree
         */
        FilteringExpressionsTree.prototype.find = function (fieldName) {
            var index = this.findIndex(fieldName);
            if (index > -1) {
                return this.filteringOperands[index];
            }
            return null;
        };
        /**
         * Returns the index of the filtering expression for a column with the provided fieldName.
         * ```typescript
         * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
         * ```
         * @memberof FilteringExpressionsTree
         */
        FilteringExpressionsTree.prototype.findIndex = function (fieldName) {
            var expr;
            for (var i = 0; i < this.filteringOperands.length; i++) {
                expr = this.filteringOperands[i];
                if (expr instanceof FilteringExpressionsTree) {
                    if (this.isFilteringExpressionsTreeForColumn(expr, fieldName)) {
                        return i;
                    }
                }
                else {
                    if (expr.fieldName === fieldName) {
                        return i;
                    }
                }
            }
            return -1;
        };
        FilteringExpressionsTree.prototype.isFilteringExpressionsTreeForColumn = function (expressionsTree, fieldName) {
            if (expressionsTree.fieldName === fieldName) {
                return true;
            }
            var expr;
            for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
                expr = expressionsTree.filteringOperands[i];
                if ((expr instanceof FilteringExpressionsTree)) {
                    return this.isFilteringExpressionsTreeForColumn(expr, fieldName);
                }
                else {
                    return expr.fieldName === fieldName;
                }
            }
            return false;
        };
        return FilteringExpressionsTree;
    }());

    var NoopFilteringStrategy = /** @class */ (function () {
        function NoopFilteringStrategy() {
        }
        NoopFilteringStrategy.instance = function () {
            return this._instance || (this._instance = new NoopFilteringStrategy());
        };
        NoopFilteringStrategy.prototype.filter = function (data, expressionsTree, advancedExpressionsTree) {
            return data;
        };
        NoopFilteringStrategy._instance = null;
        return NoopFilteringStrategy;
    }());
    var BaseFilteringStrategy = /** @class */ (function () {
        function BaseFilteringStrategy() {
        }
        BaseFilteringStrategy.prototype.findMatchByExpression = function (rec, expr) {
            var cond = expr.condition;
            var val = this.getFieldValue(rec, expr.fieldName);
            return cond.logic(val, expr.searchVal, expr.ignoreCase);
        };
        BaseFilteringStrategy.prototype.matchRecord = function (rec, expressions) {
            if (expressions) {
                if (expressions instanceof FilteringExpressionsTree) {
                    var expressionsTree = expressions;
                    var operator = expressionsTree.operator;
                    var matchOperand = void 0, operand = void 0;
                    if (expressionsTree.filteringOperands && expressionsTree.filteringOperands.length) {
                        for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
                            operand = expressionsTree.filteringOperands[i];
                            matchOperand = this.matchRecord(rec, operand);
                            // Return false if at least one operand does not match and the filtering logic is And
                            if (!matchOperand && operator === exports.FilteringLogic.And) {
                                return false;
                            }
                            // Return true if at least one operand matches and the filtering logic is Or
                            if (matchOperand && operator === exports.FilteringLogic.Or) {
                                return true;
                            }
                        }
                        return matchOperand;
                    }
                    return true;
                }
                else {
                    var expression = expressions;
                    return this.findMatchByExpression(rec, expression);
                }
            }
            return true;
        };
        return BaseFilteringStrategy;
    }());
    var FilteringStrategy = /** @class */ (function (_super) {
        __extends(FilteringStrategy, _super);
        function FilteringStrategy() {
            return _super.call(this) || this;
        }
        FilteringStrategy.instance = function () {
            return this._instace || (this._instace = new this());
        };
        FilteringStrategy.prototype.filter = function (data, expressionsTree, advancedExpressionsTree) {
            var i;
            var rec;
            var len = data.length;
            var res = [];
            if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
                return data;
            }
            for (i = 0; i < len; i++) {
                rec = data[i];
                if (this.matchRecord(rec, expressionsTree) && this.matchRecord(rec, advancedExpressionsTree)) {
                    res.push(rec);
                }
            }
            return res;
        };
        FilteringStrategy.prototype.getFieldValue = function (rec, fieldName) {
            return rec[fieldName];
        };
        FilteringStrategy._instace = null;
        return FilteringStrategy;
    }(BaseFilteringStrategy));


    (function (TransactionType) {
        TransactionType["ADD"] = "add";
        TransactionType["DELETE"] = "delete";
        TransactionType["UPDATE"] = "update";
    })(exports.TransactionType || (exports.TransactionType = {}));

    /**
     * @hidden
     */

    (function (DataType) {
        DataType["String"] = "string";
        DataType["Number"] = "number";
        DataType["Boolean"] = "boolean";
        DataType["Date"] = "date";
    })(exports.DataType || (exports.DataType = {}));
    /**
     * @hidden
     */
    var DataUtil = /** @class */ (function () {
        function DataUtil() {
        }
        DataUtil.sort = function (data, expressions, sorting) {
            if (sorting === void 0) { sorting = new IgxSorting(); }
            return sorting.sort(data, expressions);
        };
        DataUtil.treeGridSort = function (hierarchicalData, expressions, sorting, parent) {
            if (sorting === void 0) { sorting = new IgxDataRecordSorting(); }
            var res = [];
            hierarchicalData.forEach(function (hr) {
                var rec = DataUtil.cloneTreeGridRecord(hr);
                rec.parent = parent;
                if (rec.children) {
                    rec.children = DataUtil.treeGridSort(rec.children, expressions, sorting, rec);
                }
                res.push(rec);
            });
            res = DataUtil.sort(res, expressions, sorting);
            return res;
        };
        DataUtil.cloneTreeGridRecord = function (hierarchicalRecord) {
            var rec = {
                rowID: hierarchicalRecord.rowID,
                data: hierarchicalRecord.data,
                children: hierarchicalRecord.children,
                isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
                level: hierarchicalRecord.level,
                expanded: hierarchicalRecord.expanded
            };
            return rec;
        };
        DataUtil.group = function (data, state, grid, groupsRecords, fullResult) {
            if (grid === void 0) { grid = null; }
            if (groupsRecords === void 0) { groupsRecords = []; }
            if (fullResult === void 0) { fullResult = { data: [], metadata: [] }; }
            var grouping = new IgxGrouping();
            groupsRecords.splice(0, groupsRecords.length);
            return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
        };
        DataUtil.page = function (data, state) {
            if (!state) {
                return data;
            }
            var len = data.length;
            var index = state.index;
            var res = [];
            var recordsPerPage = state.recordsPerPage;
            state.metadata = {
                countPages: 0,
                countRecords: data.length,
                error: exports.PagingError.None
            };
            if (index < 0 || isNaN(index)) {
                state.metadata.error = exports.PagingError.IncorrectPageIndex;
                return res;
            }
            if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
                state.metadata.error = exports.PagingError.IncorrectRecordsPerPage;
                return res;
            }
            state.metadata.countPages = Math.ceil(len / recordsPerPage);
            if (!len) {
                return data;
            }
            if (index >= state.metadata.countPages) {
                state.metadata.error = exports.PagingError.IncorrectPageIndex;
                return res;
            }
            return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
        };
        DataUtil.filter = function (data, state) {
            if (!state.strategy) {
                state.strategy = new FilteringStrategy();
            }
            return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
        };
        DataUtil.correctPagingState = function (state, length) {
            var maxPage = Math.ceil(length / state.recordsPerPage) - 1;
            if (!isNaN(maxPage) && state.index > maxPage) {
                state.index = maxPage;
            }
        };
        DataUtil.getHierarchy = function (gRow) {
            return getHierarchy(gRow);
        };
        DataUtil.isHierarchyMatch = function (h1, h2) {
            return isHierarchyMatch(h1, h2);
        };
        /**
         * Merges all changes from provided transactions into provided data collection
         * @param data Collection to merge
         * @param transactions Transactions to merge into data
         * @param primaryKey Primary key of the collection, if any
         * @param deleteRows Should delete rows with DELETE transaction type from data
         * @returns Provided data collections updated with all provided transactions
         */
        DataUtil.mergeTransactions = function (data, transactions, primaryKey, deleteRows) {
            if (deleteRows === void 0) { deleteRows = false; }
            data.forEach(function (item, index) {
                var rowId = primaryKey ? item[primaryKey] : item;
                var transaction = transactions.find(function (t) { return t.id === rowId; });
                if (transaction && transaction.type === exports.TransactionType.UPDATE) {
                    data[index] = transaction.newValue;
                }
            });
            if (deleteRows) {
                transactions
                    .filter(function (t) { return t.type === exports.TransactionType.DELETE; })
                    .forEach(function (t) {
                    var index = primaryKey ? data.findIndex(function (d) { return d[primaryKey] === t.id; }) : data.findIndex(function (d) { return d === t.id; });
                    if (0 <= index && index < data.length) {
                        data.splice(index, 1);
                    }
                });
            }
            data.push.apply(data, __spread(transactions
                .filter(function (t) { return t.type === exports.TransactionType.ADD; })
                .map(function (t) { return t.newValue; })));
            return data;
        };
        /**
         * Merges all changes from provided transactions into provided hierarchical data collection
         * @param data Collection to merge
         * @param transactions Transactions to merge into data
         * @param childDataKey Data key of child collections
         * @param primaryKey Primary key of the collection, if any
         * @param deleteRows Should delete rows with DELETE transaction type from data
         * @returns Provided data collections updated with all provided transactions
         */
        DataUtil.mergeHierarchicalTransactions = function (data, transactions, childDataKey, primaryKey, deleteRows) {
            var e_1, _a;
            if (deleteRows === void 0) { deleteRows = false; }
            var _loop_1 = function (transaction) {
                if (transaction.path) {
                    var parent_1 = this_1.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                    var collection = parent_1 ? parent_1[childDataKey] : data;
                    switch (transaction.type) {
                        case exports.TransactionType.ADD:
                            //  if there is no parent this is ADD row at root level
                            if (parent_1 && !parent_1[childDataKey]) {
                                parent_1[childDataKey] = collection = [];
                            }
                            collection.push(transaction.newValue);
                            break;
                        case exports.TransactionType.UPDATE:
                            var updateIndex = collection.findIndex(function (x) { return x[primaryKey] === transaction.id; });
                            if (updateIndex !== -1) {
                                collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                            }
                            break;
                        case exports.TransactionType.DELETE:
                            if (deleteRows) {
                                var deleteIndex = collection.findIndex(function (r) { return r[primaryKey] === transaction.id; });
                                if (deleteIndex !== -1) {
                                    collection.splice(deleteIndex, 1);
                                }
                            }
                            break;
                    }
                }
                else {
                    //  if there is no path this is ADD row in root. Push the newValue to data
                    data.push(transaction.newValue);
                }
            };
            var this_1 = this;
            try {
                for (var transactions_1 = __values(transactions), transactions_1_1 = transactions_1.next(); !transactions_1_1.done; transactions_1_1 = transactions_1.next()) {
                    var transaction = transactions_1_1.value;
                    _loop_1(transaction);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (transactions_1_1 && !transactions_1_1.done && (_a = transactions_1.return)) _a.call(transactions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return data;
        };
        DataUtil.parseValue = function (dataType, value) {
            if (dataType === exports.DataType.Number) {
                value = parseFloat(value);
            }
            return value;
        };
        DataUtil.findParentFromPath = function (data, primaryKey, childDataKey, path) {
            var e_2, _a;
            var collection = data;
            var result;
            var _loop_2 = function (id) {
                result = collection && collection.find(function (x) { return x[primaryKey] === id; });
                if (!result) {
                    return "break";
                }
                collection = result[childDataKey];
            };
            try {
                for (var path_1 = __values(path), path_1_1 = path_1.next(); !path_1_1.done; path_1_1 = path_1.next()) {
                    var id = path_1_1.value;
                    var state_1 = _loop_2(id);
                    if (state_1 === "break")
                        break;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (path_1_1 && !path_1_1.done && (_a = path_1.return)) _a.call(path_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        };
        return DataUtil;
    }());

    /**
     * @hidden
     */
    var ExportUtilities = /** @class */ (function () {
        function ExportUtilities() {
        }
        ExportUtilities.getKeysFromData = function (data) {
            var length = data.length;
            if (length === 0) {
                return [];
            }
            var dataEntry = data[0];
            var dataEntryMiddle = data[Math.floor(length / 2)];
            var dataEntryLast = data[length - 1];
            var keys1 = Object.keys(dataEntry);
            var keys2 = Object.keys(dataEntryMiddle);
            var keys3 = Object.keys(dataEntryLast);
            var keys = new Set(keys1.concat(keys2).concat(keys3));
            return !ExportUtilities.isSpecialData(data) ? Array.from(keys) : ['Column 1'];
        };
        ExportUtilities.saveBlobToFile = function (blob, fileName) {
            var a = document.createElement('a');
            if (window.navigator && window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveOrOpenBlob(blob, fileName);
            }
            else {
                var url = window.URL.createObjectURL(blob);
                a.download = fileName;
                a.href = url;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }
        };
        ExportUtilities.stringToArrayBuffer = function (s) {
            var buf = new ArrayBuffer(s.length);
            var view = new Uint8Array(buf);
            for (var i = 0; i !== s.length; ++i) {
                /* tslint:disable no-bitwise */
                view[i] = s.charCodeAt(i) & 0xFF;
                /* tslint:enable no-bitwise */
            }
            return buf;
        };
        ExportUtilities.isSpecialData = function (data) {
            var dataEntry = data[0];
            return (typeof dataEntry === 'string' ||
                typeof dataEntry === 'number' ||
                dataEntry instanceof Date);
        };
        ExportUtilities.hasValue = function (value) {
            return value !== undefined && value !== null;
        };
        ExportUtilities.isNullOrWhitespaces = function (value) {
            return value === undefined || value === null || !value.trim();
        };
        return ExportUtilities;
    }());

    /**
     *@hidden
     */
    var GridBaseAPIService = /** @class */ (function () {
        function GridBaseAPIService() {
            this.destroyMap = new Map();
        }
        GridBaseAPIService.prototype.get_column_by_name = function (name) {
            return this.grid.columnList.find(function (col) { return col.field === name; });
        };
        GridBaseAPIService.prototype.get_summary_data = function () {
            var grid = this.grid;
            var data = grid.filteredData;
            if (!data) {
                if (grid.transactions.enabled) {
                    data = DataUtil.mergeTransactions(cloneArray(grid.data), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
                    var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === exports.TransactionType.DELETE; }).map(function (t) { return t.id; });
                    deletedRows.forEach(function (rowID) {
                        var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
                        var index = tempData.indexOf(rowID);
                        if (index !== -1) {
                            data.splice(index, 1);
                        }
                    });
                }
                else {
                    data = grid.data;
                }
            }
            return data;
        };
        /**
         * @hidden
         * @internal
         */
        GridBaseAPIService.prototype.getRowData = function (rowID) {
            var data = this.get_all_data(this.grid.transactions.enabled);
            var index = this.get_row_index_in_data(rowID);
            return data[index];
        };
        // TODO: Refactor
        GridBaseAPIService.prototype.escape_editMode = function () {
            this.grid.crudService.end();
        };
        // TODO: Refactor
        GridBaseAPIService.prototype.get_cell_inEditMode = function () {
            return this.grid.crudService.cell;
        };
        GridBaseAPIService.prototype.get_row_index_in_data = function (rowID) {
            var grid = this.grid;
            if (!grid) {
                return -1;
            }
            var data = this.get_all_data(grid.transactions.enabled);
            return grid.primaryKey ? data.findIndex(function (record) { return record[grid.primaryKey] === rowID; }) : data.indexOf(rowID);
        };
        GridBaseAPIService.prototype.get_row_by_key = function (rowSelector) {
            var primaryKey = this.grid.primaryKey;
            if (primaryKey !== undefined && primaryKey !== null) {
                return this.grid.dataRowList.find(function (row) { return row.rowData[primaryKey] === rowSelector; });
            }
            else {
                return this.grid.dataRowList.find(function (row) { return row.rowData === rowSelector; });
            }
        };
        GridBaseAPIService.prototype.get_row_by_index = function (rowIndex) {
            return this.grid.rowList.find(function (row) { return row.index === rowIndex; });
        };
        GridBaseAPIService.prototype.get_cell_by_key = function (rowSelector, field) {
            var row = this.get_row_by_key(rowSelector);
            if (row && row.cells) {
                return row.cells.find(function (cell) { return cell.column.field === field; });
            }
        };
        GridBaseAPIService.prototype.get_cell_by_index = function (rowIndex, columnIndex) {
            var row = this.get_row_by_index(rowIndex);
            if (row && row.cells) {
                return row.cells.find(function (cell) { return cell.columnIndex === columnIndex; });
            }
        };
        GridBaseAPIService.prototype.get_cell_by_visible_index = function (rowIndex, columnIndex) {
            var row = this.get_row_by_index(rowIndex);
            if (row && row.cells) {
                return row.cells.find(function (cell) { return cell.visibleColumnIndex === columnIndex; });
            }
        };
        GridBaseAPIService.prototype.submit_value = function () {
            var cell = this.grid.crudService.cell;
            if (cell) {
                var args = this.update_cell(cell, cell.editValue);
                if (args.cancel) {
                    return;
                }
                this.escape_editMode();
            }
        };
        GridBaseAPIService.prototype.update_cell = function (cell, value) {
            var _a;
            var data = this.get_all_data(this.grid.transactions.enabled);
            var index = this.get_row_index_in_data(cell.id.rowID);
            cell.editValue = value;
            var args = cell.createEditEventArgs();
            this.grid.onCellEdit.emit(args);
            if (args.cancel) {
                return args;
            }
            // Cast to number after emit
            // TODO: Clean up this
            args.newValue = cell.castToNumber(args.newValue);
            if (isEqual(args.oldValue, args.newValue)) {
                return args;
            }
            this.grid.summaryService.clearSummaryCache(args);
            this.updateData(this.grid, cell.id.rowID, data[index], cell.rowData, (_a = {}, _a[cell.column.field] = args.newValue, _a));
            if (this.grid.primaryKey === cell.column.field) {
                if (this.grid.selectionService.isRowSelected(cell.id.rowID)) {
                    this.grid.selectionService.deselectRow(cell.id.rowID);
                    this.grid.selectionService.selectRowById(args.newValue);
                }
                if (this.grid.hasSummarizedColumns) {
                    this.grid.summaryService.removeSummaries(cell.id.rowID);
                }
            }
            if (!this.grid.rowEditable || !this.grid.crudService.row ||
                this.grid.crudService.row.id !== cell.id.rowID || !this.grid.transactions.enabled) {
                this.grid.summaryService.clearSummaryCache(args);
                this.grid._pipeTrigger++;
            }
            return args;
        };
        /**
         * Updates related row of provided grid's data source with provided new row value
         * @param grid Grid to update data for
         * @param rowID ID of the row to update
         * @param rowValueInDataSource Initial value of the row as it is in data source
         * @param rowCurrentValue Current value of the row as it is with applied previous transactions
         * @param rowNewValue New value of the row
         */
        GridBaseAPIService.prototype.updateData = function (grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
            if (grid.transactions.enabled) {
                var transaction = {
                    id: rowID,
                    type: exports.TransactionType.UPDATE,
                    newValue: rowNewValue
                };
                grid.transactions.add(transaction, rowCurrentValue);
            }
            else {
                mergeObjects(rowValueInDataSource, rowNewValue);
            }
        };
        GridBaseAPIService.prototype._update_row = function (row, value) {
            var grid = this.grid;
            var rowInEditMode = grid.crudService.row;
            row.newData = value ? value : grid.transactions.getAggregatedValue(row.id, true);
            if (rowInEditMode && row.id === rowInEditMode.id) {
                row.data = __assign(__assign({}, row.data), rowInEditMode.transactionState);
                // TODO: Workaround for updating a row in edit mode through the API
            }
            else if (this.grid.transactions.enabled) {
                var state = grid.transactions.getState(row.id);
                row.data = state ? Object.assign({}, row.data, state.value) : row.data;
            }
        };
        GridBaseAPIService.prototype.update_row = function (row, value) {
            var grid = this.grid;
            var selected = grid.selectionService.isRowSelected(row.id);
            var rowInEditMode = grid.crudService.row;
            var data = this.get_all_data(grid.transactions.enabled);
            var index = this.get_row_index_in_data(row.id);
            var hasSummarized = grid.hasSummarizedColumns;
            this._update_row(row, value);
            var args = row.createEditEventArgs();
            // If no valid row is found
            if (index === -1) {
                return args;
            }
            grid.onRowEdit.emit(args);
            if (args.cancel) {
                return args;
            }
            if (rowInEditMode) {
                var hasChanges = grid.transactions.getState(args.rowID, true);
                grid.transactions.endPending(false);
                if (!hasChanges) {
                    return args;
                }
            }
            if (!args.newValue) {
                return args;
            }
            if (hasSummarized) {
                grid.summaryService.removeSummaries(args.rowID);
            }
            this.updateData(grid, row.id, data[index], args.oldValue, args.newValue);
            var newId = grid.primaryKey ? args.newValue[grid.primaryKey] : args.newValue;
            if (selected) {
                grid.selectionService.deselectRow(row.id);
                grid.selectionService.selectRowById(newId);
            }
            if (hasSummarized) {
                grid.summaryService.removeSummaries(newId);
            }
            grid._pipeTrigger++;
            return args;
        };
        GridBaseAPIService.prototype.update_row_in_array = function (value, rowID, index) {
            var grid = this.grid;
            grid.data[index] = value;
        };
        GridBaseAPIService.prototype.sort = function (expression) {
            if (expression.dir === exports.SortingDirection.None) {
                this.remove_grouping_expression(expression.fieldName);
            }
            var sortingState = cloneArray(this.grid.sortingExpressions);
            this.prepare_sorting_expression([sortingState], expression);
            this.grid.sortingExpressions = sortingState;
        };
        GridBaseAPIService.prototype.sort_multiple = function (expressions) {
            var e_1, _a;
            var sortingState = cloneArray(this.grid.sortingExpressions);
            try {
                for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
                    var each = expressions_1_1.value;
                    if (each.dir === exports.SortingDirection.None) {
                        this.remove_grouping_expression(each.fieldName);
                    }
                    this.prepare_sorting_expression([sortingState], each);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return)) _a.call(expressions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.grid.sortingExpressions = sortingState;
        };
        GridBaseAPIService.prototype.filter = function (fieldName, term, conditionOrExpressionsTree, ignoreCase) {
            var grid = this.grid;
            var filteringTree = grid.filteringExpressionsTree;
            grid.endEdit(false);
            if (grid.paging) {
                grid.page = 0;
            }
            var fieldFilterIndex = filteringTree.findIndex(fieldName);
            if (fieldFilterIndex > -1) {
                filteringTree.filteringOperands.splice(fieldFilterIndex, 1);
            }
            this.prepare_filtering_expression(filteringTree, fieldName, term, conditionOrExpressionsTree, ignoreCase, fieldFilterIndex);
            grid.filteringExpressionsTree = filteringTree;
        };
        GridBaseAPIService.prototype.filter_global = function (term, condition, ignoreCase) {
            var e_2, _a;
            if (!condition) {
                return;
            }
            var grid = this.grid;
            var filteringTree = grid.filteringExpressionsTree;
            grid.endEdit(false);
            if (grid.paging) {
                grid.page = 0;
            }
            filteringTree.filteringOperands = [];
            try {
                for (var _b = __values(grid.columns), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var column = _c.value;
                    this.prepare_filtering_expression(filteringTree, column.field, term, condition, ignoreCase || column.filteringIgnoreCase);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            grid.filteringExpressionsTree = filteringTree;
        };
        GridBaseAPIService.prototype.clear_filter = function (fieldName) {
            var grid = this.grid;
            grid.endEdit(false);
            var filteringState = grid.filteringExpressionsTree;
            var index = filteringState.findIndex(fieldName);
            if (index > -1) {
                filteringState.filteringOperands.splice(index, 1);
            }
            else if (!fieldName) {
                filteringState.filteringOperands = [];
            }
            grid.filteringExpressionsTree = filteringState;
        };
        GridBaseAPIService.prototype.clear_sort = function (fieldName) {
            var sortingState = this.grid.sortingExpressions;
            var index = sortingState.findIndex(function (expr) { return expr.fieldName === fieldName; });
            if (index > -1) {
                sortingState.splice(index, 1);
                this.grid.sortingExpressions = sortingState;
            }
        };
        GridBaseAPIService.prototype.prepare_filtering_expression = function (filteringState, fieldName, searchVal, conditionOrExpressionsTree, ignoreCase, insertAtIndex) {
            if (insertAtIndex === void 0) { insertAtIndex = -1; }
            var newExpressionsTree;
            var oldExpressionsTreeIndex = filteringState.findIndex(fieldName);
            var expressionsTree = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
                conditionOrExpressionsTree : null;
            var condition = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
                null : conditionOrExpressionsTree;
            var newExpression = { fieldName: fieldName, searchVal: searchVal, condition: condition, ignoreCase: ignoreCase };
            if (oldExpressionsTreeIndex === -1) {
                // no expressions tree found for this field
                if (expressionsTree) {
                    if (insertAtIndex > -1) {
                        filteringState.filteringOperands.splice(insertAtIndex, 0, expressionsTree);
                    }
                    else {
                        filteringState.filteringOperands.push(expressionsTree);
                    }
                }
                else if (condition) {
                    // create expressions tree for this field and add the new expression to it
                    newExpressionsTree = new FilteringExpressionsTree(filteringState.operator, fieldName);
                    newExpressionsTree.filteringOperands.push(newExpression);
                    filteringState.filteringOperands.push(newExpressionsTree);
                }
            }
        };
        GridBaseAPIService.prototype.prepare_sorting_expression = function (stateCollections, expression) {
            if (expression.dir === exports.SortingDirection.None) {
                stateCollections.forEach(function (state) {
                    state.splice(state.findIndex(function (expr) { return expr.fieldName === expression.fieldName; }), 1);
                });
                return;
            }
            /**
             * We need to make sure the states in each collection with same fields point to the same object reference.
             * If the different state collections provided have different sizes we need to get the largest one.
             * That way we can get the state reference from the largest one that has the same fieldName as the expression to prepare.
             */
            var maxCollection = stateCollections[0];
            for (var i = 1; i < stateCollections.length; i++) {
                if (maxCollection.length < stateCollections[i].length) {
                    maxCollection = stateCollections[i];
                }
            }
            var maxExpr = maxCollection.find(function (expr) { return expr.fieldName === expression.fieldName; });
            stateCollections.forEach(function (collection) {
                var myExpr = collection.find(function (expr) { return expr.fieldName === expression.fieldName; });
                if (!myExpr && !maxExpr) {
                    // Expression with this fieldName is missing from the current and the max collection.
                    collection.push(expression);
                }
                else if (!myExpr && maxExpr) {
                    // Expression with this fieldName is missing from the current and but the max collection has.
                    collection.push(maxExpr);
                    Object.assign(maxExpr, expression);
                }
                else {
                    // The current collection has the expression so just update it.
                    Object.assign(myExpr, expression);
                }
            });
        };
        GridBaseAPIService.prototype.remove_grouping_expression = function (fieldName) {
        };
        GridBaseAPIService.prototype.clear_groupby = function (name) {
        };
        GridBaseAPIService.prototype.should_apply_number_style = function (column) {
            return column.dataType === exports.DataType.Number;
        };
        GridBaseAPIService.prototype.get_data = function () {
            var grid = this.grid;
            var data = grid.data ? grid.data : [];
            return data;
        };
        GridBaseAPIService.prototype.get_all_data = function (includeTransactions) {
            if (includeTransactions === void 0) { includeTransactions = false; }
            var grid = this.grid;
            var data = grid.data ? grid.data : [];
            data = includeTransactions ? grid.dataWithAddedInTransactionRows : data;
            return data;
        };
        GridBaseAPIService.prototype.get_filtered_data = function () {
            return this.grid.filteredData;
        };
        GridBaseAPIService.prototype.getSortStrategyPerColumn = function (fieldName) {
            return this.get_column_by_name(fieldName) ?
                this.get_column_by_name(fieldName).sortStrategy : undefined;
        };
        GridBaseAPIService.prototype.addRowToData = function (rowData) {
            // Add row goes to transactions and if rowEditable is properly implemented, added rows will go to pending transactions
            // If there is a row in edit - > commit and close
            var grid = this.grid;
            if (grid.transactions.enabled) {
                var transactionId = grid.primaryKey ? rowData[grid.primaryKey] : rowData;
                var transaction = { id: transactionId, type: exports.TransactionType.ADD, newValue: rowData };
                grid.transactions.add(transaction);
            }
            else {
                grid.data.push(rowData);
            }
        };
        GridBaseAPIService.prototype.deleteRowFromData = function (rowID, index) {
            //  if there is a row (index !== 0) delete it
            //  if there is a row in ADD or UPDATE state change it's state to DELETE
            var grid = this.grid;
            if (index !== -1) {
                if (grid.transactions.enabled) {
                    var transaction = { id: rowID, type: exports.TransactionType.DELETE, newValue: null };
                    grid.transactions.add(transaction, grid.data[index]);
                }
                else {
                    grid.data.splice(index, 1);
                }
            }
            else {
                var state = grid.transactions.getState(rowID);
                grid.transactions.add({ id: rowID, type: exports.TransactionType.DELETE, newValue: null }, state && state.recordRef);
            }
        };
        GridBaseAPIService.prototype.deleteRowById = function (rowId) {
            var index;
            var grid = this.grid;
            var data = this.get_all_data();
            if (grid.primaryKey) {
                index = data.map(function (record) { return record[grid.primaryKey]; }).indexOf(rowId);
            }
            else {
                index = data.indexOf(rowId);
            }
            var state = grid.transactions.getState(rowId);
            var hasRowInNonDeletedState = state && state.type !== exports.TransactionType.DELETE;
            //  if there is a row (index !== -1) and the we have cell in edit mode on same row exit edit mode
            //  if there is no row (index === -1), but there is a row in ADD or UPDATE state do as above
            //  Otherwise just exit - there is nothing to delete
            if (index !== -1 || hasRowInNonDeletedState) {
                // Always exit edit when row is deleted
                grid.endEdit(true);
            }
            else {
                return;
            }
            //  TODO: should we emit this when cascadeOnDelete is true for each row?!?!
            grid.onRowDeleted.emit({ data: data[index] });
            this.deleteRowFromData(rowId, index);
            grid.selectionService.isRowSelected(rowId) ? grid.selectionService.deselectRow(rowId) : grid.selectionService.clearHeaderCBState();
            grid._pipeTrigger++;
            grid.notifyChanges();
            // Data needs to be recalculated if transactions are in place
            // If no transactions, `data` will be a reference to the grid getter, otherwise it will be stale
            var dataAfterDelete = grid.transactions.enabled ? grid.dataWithAddedInTransactionRows : data;
            grid.refreshSearch();
            if (dataAfterDelete.length % grid.perPage === 0 && dataAfterDelete.length / grid.perPage - 1 < grid.page && grid.page !== 0) {
                grid.page--;
            }
        };
        GridBaseAPIService.prototype.get_row_id = function (rowData) {
            return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;
        };
        GridBaseAPIService.prototype.row_deleted_transaction = function (rowID) {
            var grid = this.grid;
            if (!grid) {
                return false;
            }
            if (!grid.transactions.enabled) {
                return false;
            }
            var state = grid.transactions.getState(rowID);
            if (state) {
                return state.type === exports.TransactionType.DELETE;
            }
            return false;
        };
        GridBaseAPIService.prototype.atInexistingPage = function () {
            return this.grid.totalPages - 1 > this.grid.page;
        };
        GridBaseAPIService.prototype.get_row_expansion_state = function (record) {
            var grid = this.grid;
            var states = grid.expansionStates;
            var rowID = grid.primaryKey ? record[grid.primaryKey] : record;
            var expanded = states.get(rowID);
            if (expanded !== undefined) {
                return expanded;
            }
            else {
                return grid.getDefaultExpandState(record);
            }
        };
        GridBaseAPIService.prototype.set_row_expansion_state = function (rowID, expanded, event) {
            var _this = this;
            var grid = this.grid;
            var expandedStates = grid.expansionStates;
            if (!this.allow_expansion_state_change(rowID, expanded)) {
                return;
            }
            var args = {
                rowID: rowID,
                expanded: expanded,
                event: event,
                cancel: false
            };
            grid.onRowToggle.emit(args);
            if (args.cancel) {
                return;
            }
            expandedStates.set(rowID, expanded);
            grid.expansionStates = expandedStates;
            if (grid.rowEditable) {
                grid.endEdit(true);
            }
            var eventKey = event && event.key ? event.key.toLowerCase() : null;
            if (eventKey && this.isToggleKey(eventKey)) {
                this.grid.zone.onStable.pipe(operators.debounceTime(30)).pipe(operators.first()).subscribe(function () {
                    _this.focusActiveCell(rowID);
                });
            }
        };
        GridBaseAPIService.prototype.get_rec_by_id = function (rowID) {
            return this.grid.primaryKey ? this.getRowData(rowID) : rowID;
        };
        GridBaseAPIService.prototype.allow_expansion_state_change = function (rowID, expanded) {
            return this.grid.expansionStates.get(rowID) !== expanded;
        };
        GridBaseAPIService.prototype.isToggleKey = function (key) {
            return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
        };
        GridBaseAPIService.prototype.focusActiveCell = function (rowID) {
            // persist focused cell
            var isVirtualized = !this.grid.verticalScrollContainer.dc.instance.notVirtual;
            var el = this.grid.selectionService.activeElement;
            if (isVirtualized && el) {
                var cell = this.get_cell_by_key(rowID, this.grid.visibleColumns[el.column].field);
                if (cell) {
                    cell.nativeElement.focus();
                }
            }
        };
        GridBaseAPIService = __decorate([
            core.Injectable()
        ], GridBaseAPIService);
        return GridBaseAPIService;
    }());

    /** @hidden */
    var TreeGridFilteringStrategy = /** @class */ (function (_super) {
        __extends(TreeGridFilteringStrategy, _super);
        function TreeGridFilteringStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TreeGridFilteringStrategy.prototype.filter = function (data, expressionsTree, advancedExpressionsTree) {
            return this.filterImpl(data, expressionsTree, advancedExpressionsTree, undefined);
        };
        TreeGridFilteringStrategy.prototype.filterImpl = function (data, expressionsTree, advancedExpressionsTree, parent) {
            var i;
            var rec;
            var len = data.length;
            var res = [];
            if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
                return data;
            }
            for (i = 0; i < len; i++) {
                rec = DataUtil.cloneTreeGridRecord(data[i]);
                rec.parent = parent;
                if (rec.children) {
                    var filteredChildren = this.filterImpl(rec.children, expressionsTree, advancedExpressionsTree, rec);
                    rec.children = filteredChildren.length > 0 ? filteredChildren : null;
                }
                if (this.matchRecord(rec, expressionsTree) && this.matchRecord(rec, advancedExpressionsTree)) {
                    res.push(rec);
                }
                else if (rec.children && rec.children.length > 0) {
                    rec.isFilteredOutParent = true;
                    res.push(rec);
                }
            }
            return res;
        };
        TreeGridFilteringStrategy.prototype.getFieldValue = function (rec, fieldName) {
            var hierarchicalRecord = rec;
            return hierarchicalRecord.data[fieldName];
        };
        return TreeGridFilteringStrategy;
    }(BaseFilteringStrategy));
    /** @hidden */
    var IgxTreeGridFilteringPipe = /** @class */ (function () {
        function IgxTreeGridFilteringPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridFilteringPipe.prototype.transform = function (hierarchyData, expressionsTree, filterStrategy, advancedFilteringExpressionsTree, id, pipeTrigger, filteringPipeTrigger) {
            var grid = this.gridAPI.grid;
            var state = {
                expressionsTree: expressionsTree,
                advancedExpressionsTree: advancedFilteringExpressionsTree,
                strategy: new TreeGridFilteringStrategy()
            };
            if (filterStrategy) {
                state.strategy = filterStrategy;
            }
            this.resetFilteredOutProperty(grid.records);
            if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
                grid.filteredData = null;
                return hierarchyData;
            }
            var result = this.filter(hierarchyData, state);
            var filteredData = [];
            this.expandAllRecursive(grid, result, grid.expansionStates, filteredData);
            grid.filteredData = filteredData;
            return result;
        };
        IgxTreeGridFilteringPipe.prototype.resetFilteredOutProperty = function (map) {
            var keys = Array.from(map.keys());
            for (var i = 0; i < keys.length; i++) {
                map.get(keys[i]).isFilteredOutParent = undefined;
            }
        };
        IgxTreeGridFilteringPipe.prototype.expandAllRecursive = function (grid, data, expandedStates, filteredData) {
            for (var i = 0; i < data.length; i++) {
                var rec = data[i];
                filteredData.push(rec.data);
                this.updateNonProcessedRecord(grid, rec);
                if (rec.children && rec.children.length > 0) {
                    expandedStates.set(rec.rowID, true);
                    this.expandAllRecursive(grid, rec.children, expandedStates, filteredData);
                }
            }
        };
        IgxTreeGridFilteringPipe.prototype.updateNonProcessedRecord = function (grid, record) {
            var rec = grid.records.get(record.rowID);
            rec.isFilteredOutParent = record.isFilteredOutParent;
        };
        IgxTreeGridFilteringPipe.prototype.filter = function (data, state) {
            return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
        };
        IgxTreeGridFilteringPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxTreeGridFilteringPipe = __decorate([
            core.Pipe({
                name: 'treeGridFiltering',
                pure: true
            })
        ], IgxTreeGridFilteringPipe);
        return IgxTreeGridFilteringPipe;
    }());

    var IgxBaseExporter = /** @class */ (function () {
        function IgxBaseExporter() {
            this.flatRecords = [];
            this._isTreeGrid = false;
            this._indexOfLastPinnedColumn = -1;
            this._sort = null;
            /**
             * This event is emitted when a row is exported.
             * ```typescript
             * this.exporterService.onRowExport.subscribe((args: IRowExportingEventArgs) => {
             * // put event handler code here
             * });
             * ```
             * @memberof IgxBaseExporter
             */
            this.onRowExport = new core.EventEmitter();
            /**
             * This event is emitted when a column is exported.
             * ```typescript
             * this.exporterService.onColumnExport.subscribe((args: IColumnExportingEventArgs) => {
             * // put event handler code here
             * });
             * ```
             * @memberof IgxBaseExporter
             */
            this.onColumnExport = new core.EventEmitter();
        }
        /**
         * Method for exporting IgxGrid component's data.
         * ```typescript
         * this.exporterService.export(this.igxGridForExport, this.exportOptions);
         * ```
         * @memberof IgxBaseExporter
         */
        IgxBaseExporter.prototype.export = function (grid, options) {
            var _this = this;
            if (options === undefined || options === null) {
                throw Error('No options provided!');
            }
            var columns = grid.columnList.toArray();
            this._columnList = new Array(columns.length);
            var hiddenColumns = [];
            var lastVisbleColumnIndex = -1;
            columns.forEach(function (column) {
                var columnHeader = column.header !== '' ? column.header : column.field;
                var exportColumn = !column.hidden || options.ignoreColumnsVisibility;
                var index = options.ignoreColumnsOrder ? column.index : column.visibleIndex;
                var columnInfo = {
                    header: columnHeader,
                    field: column.field,
                    skip: !exportColumn,
                    formatter: column.formatter,
                    skipFormatter: false
                };
                if (index !== -1) {
                    _this._columnList[index] = columnInfo;
                    lastVisbleColumnIndex = Math.max(lastVisbleColumnIndex, index);
                }
                else {
                    hiddenColumns.push(columnInfo);
                }
                if (column.pinned && exportColumn) {
                    _this._indexOfLastPinnedColumn++;
                }
            });
            // Append the hidden columns to the end of the list
            hiddenColumns.forEach(function (hiddenColumn) {
                _this._columnList[++lastVisbleColumnIndex] = hiddenColumn;
            });
            var data = this.prepareData(grid, options);
            this.exportData(data, options);
        };
        /**
         * Method for exporting any kind of array data.
         * ```typescript
         * this.exporterService.exportData(this.arrayForExport, this.exportOptions);
         * ```
         * @memberof IgxBaseExporter
         */
        IgxBaseExporter.prototype.exportData = function (data, options) {
            var _this = this;
            if (options === undefined || options === null) {
                throw Error('No options provided!');
            }
            if (!this._columnList || this._columnList.length === 0) {
                var keys = ExportUtilities.getKeysFromData(data);
                this._columnList = keys.map(function (k) { return ({ header: k, field: k, skip: false }); });
            }
            var skippedPinnedColumnsCount = 0;
            var columnsWithoutHeaderCount = 1;
            this._columnList.forEach(function (column, index) {
                if (!column.skip) {
                    var columnExportArgs = {
                        header: ExportUtilities.isNullOrWhitespaces(column.header) ?
                            'Column' + columnsWithoutHeaderCount++ : column.header,
                        field: column.field,
                        columnIndex: index,
                        cancel: false,
                        skipFormatter: false
                    };
                    _this.onColumnExport.emit(columnExportArgs);
                    column.header = columnExportArgs.header;
                    column.skip = columnExportArgs.cancel;
                    column.skipFormatter = columnExportArgs.skipFormatter;
                    if (column.skip && index <= _this._indexOfLastPinnedColumn) {
                        skippedPinnedColumnsCount++;
                    }
                    if (_this._sort && _this._sort.fieldName === column.field) {
                        if (column.skip) {
                            _this._sort = null;
                        }
                        else {
                            _this._sort.fieldName = column.header;
                        }
                    }
                }
            });
            this._indexOfLastPinnedColumn -= skippedPinnedColumnsCount;
            var dataToExport = new Array();
            var isSpecialData = ExportUtilities.isSpecialData(data);
            data.forEach(function (row, index) {
                _this.exportRow(dataToExport, row, index, isSpecialData);
            });
            this.exportDataImplementation(dataToExport, options);
            this.resetDefaults();
        };
        IgxBaseExporter.prototype.exportRow = function (data, rowData, index, isSpecialData) {
            var _this = this;
            var row;
            if (!isSpecialData) {
                row = this._columnList.reduce(function (a, e) {
                    if (!e.skip) {
                        var rawValue = _this._isTreeGrid ? rowData.data[e.field] : rowData[e.field];
                        a[e.header] = e.formatter && !e.skipFormatter ? e.formatter(rawValue) : rawValue;
                    }
                    return a;
                }, {});
            }
            else {
                row = this._isTreeGrid ? rowData.data : rowData;
            }
            var rowArgs = {
                rowData: row,
                rowIndex: index,
                cancel: false
            };
            this.onRowExport.emit(rowArgs);
            if (!rowArgs.cancel) {
                data.push({ rowData: rowArgs.rowData, originalRowData: rowData });
            }
        };
        IgxBaseExporter.prototype.prepareData = function (grid, options) {
            this.flatRecords = [];
            var rootRecords = grid.rootRecords;
            this._isTreeGrid = rootRecords !== undefined;
            if (this._isTreeGrid) {
                this.prepareHierarchicalData(rootRecords);
            }
            var data = this._isTreeGrid ? this.flatRecords : grid.data;
            if (((grid.filteringExpressionsTree &&
                grid.filteringExpressionsTree.filteringOperands.length > 0) ||
                (grid.advancedFilteringExpressionsTree &&
                    grid.advancedFilteringExpressionsTree.filteringOperands.length > 0)) &&
                !options.ignoreFiltering) {
                var filteringState = {
                    expressionsTree: grid.filteringExpressionsTree,
                    advancedExpressionsTree: grid.advancedFilteringExpressionsTree,
                    logic: grid.filteringLogic
                };
                if (this._isTreeGrid) {
                    this.flatRecords = [];
                    filteringState.strategy = (grid.filterStrategy) ? grid.filterStrategy : new TreeGridFilteringStrategy();
                    rootRecords = filteringState.strategy.filter(rootRecords, filteringState.expressionsTree, filteringState.advancedExpressionsTree);
                    this.prepareHierarchicalData(rootRecords);
                    data = this.flatRecords;
                }
                else {
                    filteringState.strategy = grid.filterStrategy;
                    data = DataUtil.filter(data, filteringState);
                }
            }
            if (grid.sortingExpressions &&
                grid.sortingExpressions.length > 0 &&
                !options.ignoreSorting) {
                this._sort = cloneValue(grid.sortingExpressions[0]);
                if (this._isTreeGrid) {
                    this.flatRecords = [];
                    rootRecords = DataUtil.treeGridSort(rootRecords, grid.sortingExpressions, grid.sortStrategy);
                    this.prepareHierarchicalData(rootRecords);
                    data = this.flatRecords;
                }
                else {
                    data = DataUtil.sort(data, grid.sortingExpressions, grid.sortStrategy);
                }
            }
            return data;
        };
        IgxBaseExporter.prototype.prepareHierarchicalData = function (records) {
            if (!records) {
                return;
            }
            for (var i = 0; i < records.length; i++) {
                var hierarchicalRecord = records[i];
                this.flatRecords.push(hierarchicalRecord);
                this.prepareHierarchicalData(hierarchicalRecord.children);
            }
        };
        IgxBaseExporter.prototype.resetDefaults = function () {
            this._columnList = [];
            this._indexOfLastPinnedColumn = -1;
            this._sort = null;
            this.flatRecords = [];
        };
        return IgxBaseExporter;
    }());

    /**
     * @hidden
     */
    var CharSeparatedValueData = /** @class */ (function () {
        function CharSeparatedValueData(_data, valueDelimiter) {
            this._data = _data;
            this._headerRecord = '';
            this._dataRecords = '';
            this._eor = '\r\n';
            this._escapeCharacters = ['\r', '\n', '\r\n'];
            this._delimiterLength = 1;
            this._isSpecialData = false;
            this.setDelimiter(valueDelimiter);
        }
        CharSeparatedValueData.prototype.prepareData = function () {
            if (!this._data || this._data.length === 0) {
                return '';
            }
            var keys = ExportUtilities.getKeysFromData(this._data);
            if (keys.length === 0) {
                return '';
            }
            this._isSpecialData = ExportUtilities.isSpecialData(this._data);
            this._escapeCharacters.push(this._delimiter);
            this._headerRecord = this.processHeaderRecord(keys, this._escapeCharacters);
            this._dataRecords = this.processDataRecords(this._data, keys, this._escapeCharacters);
            return this._headerRecord + this._dataRecords;
        };
        CharSeparatedValueData.prototype.processField = function (value, escapeChars) {
            var safeValue = ExportUtilities.hasValue(value) ? String(value) : '';
            if (escapeChars.some(function (v) { return safeValue.includes(v); })) {
                safeValue = "\"" + safeValue + "\"";
            }
            return safeValue + this._delimiter;
        };
        CharSeparatedValueData.prototype.processHeaderRecord = function (keys, escapeChars) {
            var e_1, _a;
            var recordData = '';
            try {
                for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                    var keyName = keys_1_1.value;
                    recordData += this.processField(keyName, this._escapeCharacters);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return recordData.slice(0, -this._delimiterLength) + this._eor;
        };
        CharSeparatedValueData.prototype.processRecord = function (record, keys, escapeChars) {
            var e_2, _a;
            var recordData = '';
            try {
                for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
                    var keyName = keys_2_1.value;
                    var value = (record[keyName] !== undefined) ? record[keyName] : this._isSpecialData ? record : '';
                    recordData += this.processField(value, this._escapeCharacters);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (keys_2_1 && !keys_2_1.done && (_a = keys_2.return)) _a.call(keys_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return recordData.slice(0, -this._delimiterLength) + this._eor;
        };
        CharSeparatedValueData.prototype.processDataRecords = function (currentData, keys, escapeChars) {
            var e_3, _a;
            var dataRecords = '';
            try {
                for (var currentData_1 = __values(currentData), currentData_1_1 = currentData_1.next(); !currentData_1_1.done; currentData_1_1 = currentData_1.next()) {
                    var row = currentData_1_1.value;
                    dataRecords += this.processRecord(row, keys, escapeChars);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (currentData_1_1 && !currentData_1_1.done && (_a = currentData_1.return)) _a.call(currentData_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return dataRecords;
        };
        CharSeparatedValueData.prototype.setDelimiter = function (value) {
            this._delimiter = value;
            this._delimiterLength = value.length;
        };
        return CharSeparatedValueData;
    }());

    var IgxExporterOptionsBase = /** @class */ (function () {
        function IgxExporterOptionsBase(fileName, _fileExtension) {
            this._fileExtension = _fileExtension;
            /**
             * Specifies whether hidden columns should be exported.
             * ```typescript
             * let ignoreColumnsVisibility = this.exportOptions.ignoreColumnsVisibility;
             * this.exportOptions.ignoreColumnsVisibility = true;
             * ```
             * @memberof IgxExporterOptionsBase
             */
            this.ignoreColumnsVisibility = false;
            /**
             * Specifies whether filtered out rows should be exported.
             * ```typescript
             * let ignoreFiltering = this.exportOptions.ignoreFiltering;
             * this.exportOptions.ignoreFiltering = true;
             * ```
             * @memberof IgxExporterOptionsBase
             */
            this.ignoreFiltering = false;
            /**
             * Specifies if the exporter should ignore the current column order in the IgxGrid.
             * ```typescript
             * let ignoreColumnsOrder = this.exportOptions.ignoreColumnsOrder;
             * this.exportOptions.ignoreColumnsOrder = true;
             * ```
             * @memberof IgxExporterOptionsBase
             */
            this.ignoreColumnsOrder = false;
            /**
             * Specifies whether the exported data should be sorted as in the provided IgxGrid.
             * ```typescript
             * let ignoreSorting = this.exportOptions.ignoreSorting;
             * this.exportOptions.ignoreSorting = true;
             * ```
             * @memberof IgxExporterOptionsBase
             */
            this.ignoreSorting = false;
            this.setFileName(fileName);
        }
        IgxExporterOptionsBase.prototype.setFileName = function (fileName) {
            this._fileName = fileName + (fileName.endsWith(this._fileExtension) === false ? this._fileExtension : '');
        };
        Object.defineProperty(IgxExporterOptionsBase.prototype, "fileName", {
            /**
             * Gets the file name which will be used for the exporting operation.
             * ```typescript
             * let fileName = this.exportOptions.fileName;
             * ```
             * @memberof IgxExporterOptionsBase
             */
            get: function () {
                return this._fileName;
            },
            /**
             * Sets the file name which will be used for the exporting operation.
             * ```typescript
             * this.exportOptions.fileName = 'exportedData01';
             * ```
             * @memberof IgxExporterOptionsBase
             */
            set: function (value) {
                this.setFileName(value);
            },
            enumerable: true,
            configurable: true
        });
        return IgxExporterOptionsBase;
    }());

    /**
     * Objects of this class are used to configure the CSV exporting process.
     */
    var IgxCsvExporterOptions = /** @class */ (function (_super) {
        __extends(IgxCsvExporterOptions, _super);
        function IgxCsvExporterOptions(fileName, fileType) {
            var _this = _super.call(this, fileName, IgxCsvExporterOptions.getExtensionFromFileType(fileType)) || this;
            _this.setFileType(fileType);
            _this.setDelimiter();
            return _this;
        }
        IgxCsvExporterOptions.getExtensionFromFileType = function (fType) {
            var extension = '';
            switch (fType) {
                case exports.CsvFileTypes.CSV:
                    extension = '.csv';
                    break;
                case exports.CsvFileTypes.TSV:
                    extension = '.tsv';
                    break;
                case exports.CsvFileTypes.TAB:
                    extension = '.tab';
                    break;
                default:
                    throw Error('Unsupported CSV file type!');
            }
            return extension;
        };
        Object.defineProperty(IgxCsvExporterOptions.prototype, "valueDelimiter", {
            /**
             * Gets the value delimiter which will be used for the exporting operation.
             * ```typescript
             * let delimiter = this.exportOptions.valueDelimiter;
             * ```
             * @memberof IgxCsvExporterOptions
             */
            get: function () {
                return this._valueDelimiter;
            },
            /**
             * Sets a value delimiter which will overwrite the default delimiter of the selected export format.
             * ```typescript
             * this.exportOptions.valueDelimiter = '|';
             * ```
             * @memberof IgxCsvExporterOptions
             */
            set: function (value) {
                this.setDelimiter(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCsvExporterOptions.prototype, "fileType", {
            /**
             * Gets the CSV export format.
             * ```typescript
             * let filetype = this.exportOptions.fileType;
             * ```
             * @memberof IgxCsvExporterOptions
             */
            get: function () {
                return this._fileType;
            },
            /**
             * Sets the CSV export format.
             * ```typescript
             * this.exportOptions.fileType = CsvFileTypes.TAB;
             * ```
             * @memberof IgxCsvExporterOptions
             */
            set: function (value) {
                this.setFileType(value);
            },
            enumerable: true,
            configurable: true
        });
        IgxCsvExporterOptions.prototype.setFileType = function (value) {
            if (value !== undefined && value !== null && value !== this._fileType) {
                this._fileType = value;
                var extension = IgxCsvExporterOptions.getExtensionFromFileType(value);
                if (!this.fileName.endsWith(extension)) {
                    var oldExt = '.' + this.fileName.split('.').pop();
                    var newName = this.fileName.replace(oldExt, extension);
                    this._fileExtension = extension;
                    this.fileName = newName;
                }
            }
        };
        IgxCsvExporterOptions.prototype.setDelimiter = function (value) {
            if (value !== undefined && value !== '' && value !== null) {
                this._valueDelimiter = value;
            }
            else {
                switch (this.fileType) {
                    case exports.CsvFileTypes.CSV:
                        this._valueDelimiter = ',';
                        break;
                    case exports.CsvFileTypes.TSV:
                    case exports.CsvFileTypes.TAB:
                        this._valueDelimiter = '\t';
                        break;
                }
            }
        };
        return IgxCsvExporterOptions;
    }(IgxExporterOptionsBase));
    /**
     * This enumeration is used to configure the default value separator
     * as well as the default file extension used when performing CSV exporting.
     */

    (function (CsvFileTypes) {
        /**
         * Character Separated Values, default separator is "comma", default file extension is .csv
         */
        CsvFileTypes[CsvFileTypes["CSV"] = 0] = "CSV";
        /**
         * Tab Separated Values, default separator is tab, default file extension is .tsv
         */
        CsvFileTypes[CsvFileTypes["TSV"] = 1] = "TSV";
        /**
         * Tab Separated Values, default separator is tab, default file extension is .tab
         */
        CsvFileTypes[CsvFileTypes["TAB"] = 2] = "TAB";
    })(exports.CsvFileTypes || (exports.CsvFileTypes = {}));

    /**
     * **Ignite UI for Angular CSV Exporter Service** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_csv.html)
     *
     * The Ignite UI for Angular CSV Exporter service can export data in a Character Separated Values format from
     * both raw data (array) or from an `IgxGrid`.
     *
     * Example:
     * ```typescript
     * public localData = [
     *   { Name: "Eric Ridley", Age: "26" },
     *   { Name: "Alanis Brook", Age: "22" },
     *   { Name: "Jonathan Morris", Age: "23" }
     * ];
     *
     * constructor(private csvExportService: IgxCsvExporterService) {
     * }
     *
     * const opt: IgxCsvExporterOptions = new IgxCsvExporterOptions("FileName", CsvFileTypes.CSV);
     * this.csvExportService.exportData(this.localData, opt);
     * ```
     */
    var IgxCsvExporterService = /** @class */ (function (_super) {
        __extends(IgxCsvExporterService, _super);
        function IgxCsvExporterService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * This event is emitted when the export process finishes.
             * ```typescript
             * this.exporterService.onExportEnded.subscribe((args: ICsvExportEndedEventArgs) => {
             * // put event handler code here
             * });
             * ```
             * @memberof IgxCsvExporterService
             */
            _this.onExportEnded = new core.EventEmitter();
            return _this;
        }
        IgxCsvExporterService.prototype.exportDataImplementation = function (data, options) {
            data = data.map(function (item) { return item.rowData; });
            var csvData = new CharSeparatedValueData(data, options.valueDelimiter);
            this._stringData = csvData.prepareData();
            this.saveFile(options);
            this.onExportEnded.emit({ csvData: this._stringData });
        };
        IgxCsvExporterService.prototype.saveFile = function (options) {
            switch (options.fileType) {
                case exports.CsvFileTypes.CSV:
                    this.exportFile(this._stringData, options.fileName, 'text/csv;charset=utf-8;');
                    break;
                case exports.CsvFileTypes.TSV:
                case exports.CsvFileTypes.TAB:
                    this.exportFile(this._stringData, options.fileName, 'text/tab-separated-values;charset=utf-8;');
                    break;
            }
        };
        IgxCsvExporterService.prototype.exportFile = function (data, fileName, fileType) {
            var blob = new Blob(['\ufeff', data], { type: fileType });
            ExportUtilities.saveBlobToFile(blob, fileName);
        };
        __decorate([
            core.Output()
        ], IgxCsvExporterService.prototype, "onExportEnded", void 0);
        IgxCsvExporterService = __decorate([
            core.Injectable()
        ], IgxCsvExporterService);
        return IgxCsvExporterService;
    }(IgxBaseExporter));

    /**
     * @hidden
     */
    var ExcelFolderTypes;
    (function (ExcelFolderTypes) {
        ExcelFolderTypes[ExcelFolderTypes["RootExcelFolder"] = 0] = "RootExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["RootRelsExcelFolder"] = 1] = "RootRelsExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["DocPropsExcelFolder"] = 2] = "DocPropsExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["XLExcelFolder"] = 3] = "XLExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["XLRelsExcelFolder"] = 4] = "XLRelsExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["ThemeExcelFolder"] = 5] = "ThemeExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["WorksheetsExcelFolder"] = 6] = "WorksheetsExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["WorksheetsRelsExcelFolder"] = 7] = "WorksheetsRelsExcelFolder";
        ExcelFolderTypes[ExcelFolderTypes["TablesExcelFolder"] = 8] = "TablesExcelFolder";
    })(ExcelFolderTypes || (ExcelFolderTypes = {}));
    /**
     * @hidden
     */
    var ExcelFileTypes;
    (function (ExcelFileTypes) {
        ExcelFileTypes[ExcelFileTypes["RootRelsFile"] = 0] = "RootRelsFile";
        ExcelFileTypes[ExcelFileTypes["AppFile"] = 1] = "AppFile";
        ExcelFileTypes[ExcelFileTypes["CoreFile"] = 2] = "CoreFile";
        ExcelFileTypes[ExcelFileTypes["WorkbookRelsFile"] = 3] = "WorkbookRelsFile";
        ExcelFileTypes[ExcelFileTypes["ThemeFile"] = 4] = "ThemeFile";
        ExcelFileTypes[ExcelFileTypes["WorksheetFile"] = 5] = "WorksheetFile";
        ExcelFileTypes[ExcelFileTypes["StyleFile"] = 6] = "StyleFile";
        ExcelFileTypes[ExcelFileTypes["WorkbookFile"] = 7] = "WorkbookFile";
        ExcelFileTypes[ExcelFileTypes["ContentTypesFile"] = 8] = "ContentTypesFile";
        ExcelFileTypes[ExcelFileTypes["SharedStringsFile"] = 9] = "SharedStringsFile";
        ExcelFileTypes[ExcelFileTypes["WorksheetRelsFile"] = 10] = "WorksheetRelsFile";
        ExcelFileTypes[ExcelFileTypes["TablesFile"] = 11] = "TablesFile";
    })(ExcelFileTypes || (ExcelFileTypes = {}));

    /** @hidden */
    var ExcelStrings = /** @class */ (function () {
        function ExcelStrings() {
        }
        ExcelStrings.getRels = function () {
            return ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';
        };
        ExcelStrings.getApp = function () {
            return ExcelStrings.XML_STRING + '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>';
        };
        ExcelStrings.getCore = function () {
            return ExcelStrings.XML_STRING + '<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator></dc:creator><cp:lastModifiedBy></cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">2015-06-05T18:17:20Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2015-06-05T18:17:26Z</dcterms:modified></cp:coreProperties>';
        };
        ExcelStrings.getTheme = function () {
            return ExcelStrings.XML_STRING + '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="5B9BD5"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="4472C4"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック Light"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线 Light"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>';
        };
        ExcelStrings.getStyles = function (hasNonStringValues) {
            var additionalCellXF = '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>';
            var cellXFCount = hasNonStringValues ? 2 : 1;
            return ExcelStrings.XML_STRING + '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="' + cellXFCount + '"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/>' + additionalCellXF + '</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>';
        };
        ExcelStrings.getWorkbook = function () {
            return ExcelStrings.XML_STRING + '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><fileVersion appName="xl" lastEdited="6" lowestEdited="6" rupBuild="14420"/><workbookPr filterPrivacy="1" defaultThemeVersion="164011"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="22260" windowHeight="12645"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="162913"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>';
        };
        ExcelStrings.getWorksheetRels = function () {
            return ExcelStrings.XML_STRING + "<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/table\" Target=\"../tables/table1.xml\"/></Relationships>";
        };
        ExcelStrings.getWorkbookRels = function (hasSharedStrings) {
            var retVal = ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>';
            if (hasSharedStrings) {
                retVal += ExcelStrings.SHARED_STRING_RELATIONSHIP;
            }
            retVal += '</Relationships>';
            return retVal;
        };
        ExcelStrings.getSheetXML = function (dimension, freezePane, cols, sheetData, hasTable, hasGroupedRows, outlineLevel) {
            if (hasGroupedRows === void 0) { hasGroupedRows = false; }
            if (outlineLevel === void 0) { outlineLevel = 0; }
            var tableParts = hasTable ? '<tableParts count="1"><tablePart r:id="rId1"/></tableParts>' : '';
            var sheetOutlineProp = hasGroupedRows ? '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>' : '';
            var sOutlineLevel = outlineLevel > 0 ? "outlineLevelRow=\"" + outlineLevel + "\"" : '';
            // return ExcelStrings.XML_STRING +
            //     '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><dimension ref="' + dimension + '"/><sheetViews><sheetView tabSelected="1" workbookViewId="0">' + freezePane + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/>' + cols + sheetData + '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>' + tableParts + '</worksheet>';
            return ExcelStrings.XML_STRING + "\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">\n" + sheetOutlineProp + "\n<dimension ref=\"" + dimension + "\"/>\n<sheetViews><sheetView tabSelected=\"1\" workbookViewId=\"0\">" + freezePane + "</sheetView></sheetViews>\n<sheetFormatPr defaultRowHeight=\"15\" " + sOutlineLevel + " x14ac:dyDescent=\"0.25\"/>\n" + cols + "\n" + sheetData + "\n<pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\"/>\n" + tableParts + "</worksheet>";
        };
        ExcelStrings.getSharedStringXML = function (count, uniqueCount, table) {
            return ExcelStrings.XML_STRING + '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count + '" uniqueCount="' + uniqueCount + '">' + table + '</sst>';
        };
        ExcelStrings.getContentTypesXML = function (hasSharedStrings, hasTable) {
            var contentTypes = ExcelStrings.XML_STRING +
                "<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">\n            <Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"/>\n            <Default Extension=\"xml\" ContentType=\"application/xml\"/>\n            <Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\"/>\n            <Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"/>\n            <Override PartName=\"/xl/theme/theme1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.theme+xml\"/>\n            <Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"/>\n            <Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\"/>\n            <Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\"/>";
            contentTypes += hasSharedStrings ?
                "\t<Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\"/>" : '';
            contentTypes += hasTable ?
                "<Override PartName=\"/xl/tables/table1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml\"/>" : '';
            contentTypes += "</Types>";
            return contentTypes;
        };
        ExcelStrings.getTablesXML = function (dimension, tableColumns, sort) {
            return ExcelStrings.XML_STRING + "<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"" + dimension + "\" totalsRowShown=\"0\">\n    <autoFilter ref=\"" + dimension + "\"/>" + sort + tableColumns + "<tableStyleInfo name=\"TableStyleMedium2\" showFirstColumn=\"0\" showLastColumn=\"0\" showRowStripes=\"1\" showColumnStripes=\"0\"/>\n</table>";
        };
        /* tslint:enable max-line-length */
        ExcelStrings.getExcelColumn = function (index) {
            // Returns the excel column name for given 0-based index
            // For example 27 should return "AB"
            var returnString = '';
            while (index >= 0) {
                var char = index % 26;
                returnString = String.fromCharCode(65 + char) + returnString;
                index = Math.floor(index / 26) - 1;
            }
            return returnString;
        };
        /* tslint:disable max-line-length */
        ExcelStrings.XML_STRING = '<?xml version="1.0" encoding="UTF-8"?>\r\n';
        ExcelStrings.SHARED_STRING_RELATIONSHIP = '<Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />';
        return ExcelStrings;
    }());

    /**
     * @hidden
     */
    var RootRelsFile = /** @class */ (function () {
        function RootRelsFile() {
        }
        RootRelsFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('.rels', ExcelStrings.getRels());
        };
        return RootRelsFile;
    }());
    /**
     * @hidden
     */
    var AppFile = /** @class */ (function () {
        function AppFile() {
        }
        AppFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('app.xml', ExcelStrings.getApp());
        };
        return AppFile;
    }());
    /**
     * @hidden
     */
    var CoreFile = /** @class */ (function () {
        function CoreFile() {
        }
        CoreFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('core.xml', ExcelStrings.getCore());
        };
        return CoreFile;
    }());
    /**
     * @hidden
     */
    var WorkbookRelsFile = /** @class */ (function () {
        function WorkbookRelsFile() {
        }
        WorkbookRelsFile.prototype.writeElement = function (folder, worksheetData) {
            var hasSharedStrings = worksheetData.isEmpty === false;
            folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));
        };
        return WorkbookRelsFile;
    }());
    /**
     * @hidden
     */
    var ThemeFile = /** @class */ (function () {
        function ThemeFile() {
        }
        ThemeFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('theme1.xml', ExcelStrings.getTheme());
        };
        return ThemeFile;
    }());
    /**
     * @hidden
     */
    var WorksheetFile = /** @class */ (function () {
        function WorksheetFile() {
        }
        WorksheetFile.prototype.writeElement = function (folder, worksheetData) {
            var sheetData = [];
            var cols = [];
            var dimension;
            var dictionary = worksheetData.dataDictionary;
            var freezePane = '';
            var maxOutlineLevel = 0;
            if (worksheetData.isEmpty) {
                sheetData.push('<sheetData/>');
                dimension = 'A1';
            }
            else {
                sheetData.push('<sheetData>');
                var height = worksheetData.options.rowHeight;
                var rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
                sheetData.push("<row r=\"1\"" + rowHeight + ">");
                for (var i = 0; i < worksheetData.columnCount; i++) {
                    var column = ExcelStrings.getExcelColumn(i) + 1;
                    var value = dictionary.saveValue(worksheetData.keys[i], i, true);
                    sheetData.push("<c r=\"" + column + "\" t=\"s\"><v>" + value + "</v></c>");
                }
                sheetData.push('</row>');
                for (var i = 1; i < worksheetData.rowCount; i++) {
                    if (!worksheetData.isTreeGridData) {
                        sheetData.push("<row r=\"" + (i + 1) + "\"" + rowHeight + ">");
                    }
                    else {
                        var rowData = worksheetData.data[i - 1].originalRowData;
                        var sCollapsed = (!rowData.expanded) ? '' : (rowData.expanded === true) ? '' : " collapsed=\"1\"";
                        var sHidden = (rowData.parent && this.hasCollapsedParent(rowData)) ? " hidden=\"1\"" : '';
                        var rowOutlineLevel = rowData.level ? rowData.level : 0;
                        var sOutlineLevel = rowOutlineLevel > 0 ? " outlineLevel=\"" + rowOutlineLevel + "\"" : '';
                        maxOutlineLevel = maxOutlineLevel < rowOutlineLevel ? rowOutlineLevel : maxOutlineLevel;
                        sheetData.push("<row r=\"" + (i + 1) + "\"" + rowHeight + sOutlineLevel + sCollapsed + sHidden + ">");
                    }
                    for (var j = 0; j < worksheetData.columnCount; j++) {
                        var cellData = WorksheetFile.getCellData(worksheetData, i, j);
                        sheetData.push(cellData);
                    }
                    sheetData.push('</row>');
                }
                sheetData.push('</sheetData>');
                dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + worksheetData.rowCount;
                cols.push('<cols>');
                for (var i = 0; i < worksheetData.columnCount; i++) {
                    var width = dictionary.columnWidths[i];
                    // Use the width provided in the options if it exists
                    var widthInTwips = worksheetData.options.columnWidth ?
                        worksheetData.options.columnWidth :
                        Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                    cols.push("<col min=\"" + (i + 1) + "\" max=\"" + (i + 1) + "\" width=\"" + widthInTwips + "\" customWidth=\"1\"/>");
                }
                cols.push('</cols>');
                if (worksheetData.indexOfLastPinnedColumn !== -1 &&
                    !worksheetData.options.ignorePinning &&
                    !worksheetData.options.ignoreColumnsOrder) {
                    var frozenColumnCount = worksheetData.indexOfLastPinnedColumn + 1;
                    var firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + '1';
                    freezePane = "<pane xSplit=\"" + frozenColumnCount + "\" topLeftCell=\"" + firstCell + "\" activePane=\"topRight\" state=\"frozen\"/>";
                }
            }
            var hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
            folder.file('sheet1.xml', ExcelStrings.getSheetXML(dimension, freezePane, cols.join(''), sheetData.join(''), hasTable, worksheetData.isTreeGridData, maxOutlineLevel));
        };
        WorksheetFile.prototype.hasCollapsedParent = function (rowData) {
            var result = !rowData.parent.expanded;
            while (rowData.parent) {
                result = result || !rowData.parent.expanded;
                rowData = rowData.parent;
            }
            return result;
        };
        /* tslint:disable member-ordering */
        WorksheetFile.getCellData = function (worksheetData, row, column) {
            var dictionary = worksheetData.dataDictionary;
            var columnName = ExcelStrings.getExcelColumn(column) + (row + 1);
            var columnHeader = worksheetData.keys[column];
            var rowData = worksheetData.data[row - 1].rowData;
            var cellValue = worksheetData.isSpecialData ? rowData : rowData[columnHeader];
            if (cellValue === undefined || cellValue === null) {
                return "<c r=\"" + columnName + "\" s=\"1\"/>";
            }
            else {
                var savedValue = dictionary.saveValue(cellValue, column, false);
                var isSavedAsString = savedValue !== -1;
                var value = isSavedAsString ? savedValue : cellValue;
                var type = isSavedAsString ? " t=\"s\"" : '';
                var format = isSavedAsString ? '' : " s=\"1\"";
                return "<c r=\"" + columnName + "\"" + type + format + "><v>" + value + "</v></c>";
            }
        };
        WorksheetFile.MIN_WIDTH = 8.34;
        return WorksheetFile;
    }());
    /**
     * @hidden
     */
    var StyleFile = /** @class */ (function () {
        function StyleFile() {
        }
        StyleFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('styles.xml', ExcelStrings.getStyles(worksheetData.dataDictionary && worksheetData.dataDictionary.hasNonStringValues));
        };
        return StyleFile;
    }());
    /**
     * @hidden
     */
    var WorkbookFile = /** @class */ (function () {
        function WorkbookFile() {
        }
        WorkbookFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('workbook.xml', ExcelStrings.getWorkbook());
        };
        return WorkbookFile;
    }());
    /**
     * @hidden
     */
    var ContentTypesFile = /** @class */ (function () {
        function ContentTypesFile() {
        }
        ContentTypesFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(!worksheetData.isEmpty, worksheetData.options.exportAsTable));
        };
        return ContentTypesFile;
    }());
    /**
     * @hidden
     */
    var SharedStringsFile = /** @class */ (function () {
        function SharedStringsFile() {
        }
        SharedStringsFile.prototype.writeElement = function (folder, worksheetData) {
            var e_1, _a;
            var dict = worksheetData.dataDictionary;
            var sortedValues = dict.getKeys();
            var sharedStrings = new Array(sortedValues.length);
            try {
                for (var sortedValues_1 = __values(sortedValues), sortedValues_1_1 = sortedValues_1.next(); !sortedValues_1_1.done; sortedValues_1_1 = sortedValues_1.next()) {
                    var value = sortedValues_1_1.value;
                    sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (sortedValues_1_1 && !sortedValues_1_1.done && (_a = sortedValues_1.return)) _a.call(sortedValues_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
        };
        return SharedStringsFile;
    }());
    /**
     * @hidden
     */
    var TablesFile = /** @class */ (function () {
        function TablesFile() {
        }
        TablesFile.prototype.writeElement = function (folder, worksheetData) {
            var columnCount = worksheetData.columnCount;
            var lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
            var dimension = 'A1:' + lastColumn;
            var values = worksheetData.keys;
            var sortString = '';
            var tableColumns = '<tableColumns count="' + columnCount + '">';
            for (var i = 0; i < columnCount; i++) {
                var value = values[i];
                tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
            }
            tableColumns += '</tableColumns>';
            if (worksheetData.sort) {
                var sortingExpression = worksheetData.sort;
                var sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
                var dir = sortingExpression.dir - 1;
                sortString = "<sortState ref=\"A2:" + lastColumn + "\"><sortCondition descending=\"" + dir + "\" ref=\"" + sc + "1:" + sc + "15\"/></sortState>";
            }
            folder.file('table1.xml', ExcelStrings.getTablesXML(dimension, tableColumns, sortString));
        };
        return TablesFile;
    }());
    /**
     * @hidden
     */
    var WorksheetRelsFile = /** @class */ (function () {
        function WorksheetRelsFile() {
        }
        WorksheetRelsFile.prototype.writeElement = function (folder, worksheetData) {
            folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());
        };
        return WorksheetRelsFile;
    }());

    /** @hidden */
    var RootExcelFolder = /** @class */ (function () {
        function RootExcelFolder() {
        }
        Object.defineProperty(RootExcelFolder.prototype, "folderName", {
            get: function () {
                return '';
            },
            enumerable: true,
            configurable: true
        });
        RootExcelFolder.prototype.childFiles = function (data) {
            return [ExcelFileTypes.ContentTypesFile];
        };
        RootExcelFolder.prototype.childFolders = function (data) {
            return [
                ExcelFolderTypes.RootRelsExcelFolder,
                ExcelFolderTypes.DocPropsExcelFolder,
                ExcelFolderTypes.XLExcelFolder
            ];
        };
        return RootExcelFolder;
    }());
    /** @hidden */
    var RootRelsExcelFolder = /** @class */ (function () {
        function RootRelsExcelFolder() {
        }
        Object.defineProperty(RootRelsExcelFolder.prototype, "folderName", {
            get: function () {
                return '_rels';
            },
            enumerable: true,
            configurable: true
        });
        RootRelsExcelFolder.prototype.childFiles = function (data) {
            return [ExcelFileTypes.RootRelsFile];
        };
        RootRelsExcelFolder.prototype.childFolders = function (data) {
            return [];
        };
        return RootRelsExcelFolder;
    }());
    /** @hidden */
    var DocPropsExcelFolder = /** @class */ (function () {
        function DocPropsExcelFolder() {
        }
        Object.defineProperty(DocPropsExcelFolder.prototype, "folderName", {
            get: function () {
                return 'docProps';
            },
            enumerable: true,
            configurable: true
        });
        DocPropsExcelFolder.prototype.childFiles = function (data) {
            return [
                ExcelFileTypes.AppFile,
                ExcelFileTypes.CoreFile
            ];
        };
        DocPropsExcelFolder.prototype.childFolders = function (data) {
            return [];
        };
        return DocPropsExcelFolder;
    }());
    /** @hidden */
    var XLExcelFolder = /** @class */ (function () {
        function XLExcelFolder() {
        }
        Object.defineProperty(XLExcelFolder.prototype, "folderName", {
            get: function () {
                return 'xl';
            },
            enumerable: true,
            configurable: true
        });
        XLExcelFolder.prototype.childFiles = function (data) {
            var retVal = [
                ExcelFileTypes.StyleFile,
                ExcelFileTypes.WorkbookFile
            ];
            if (!data.isEmpty) {
                retVal.push(ExcelFileTypes.SharedStringsFile);
            }
            return retVal;
        };
        XLExcelFolder.prototype.childFolders = function (data) {
            var retVal = [
                ExcelFolderTypes.XLRelsExcelFolder,
                ExcelFolderTypes.ThemeExcelFolder,
                ExcelFolderTypes.WorksheetsExcelFolder
            ];
            if (!data.isEmpty && data.options.exportAsTable) {
                retVal.push(ExcelFolderTypes.TablesExcelFolder);
            }
            return retVal;
        };
        return XLExcelFolder;
    }());
    /** @hidden */
    var XLRelsExcelFolder = /** @class */ (function () {
        function XLRelsExcelFolder() {
        }
        Object.defineProperty(XLRelsExcelFolder.prototype, "folderName", {
            get: function () {
                return '_rels';
            },
            enumerable: true,
            configurable: true
        });
        XLRelsExcelFolder.prototype.childFiles = function (data) {
            return [ExcelFileTypes.WorkbookRelsFile];
        };
        XLRelsExcelFolder.prototype.childFolders = function (data) {
            return [];
        };
        return XLRelsExcelFolder;
    }());
    /** @hidden */
    var ThemeExcelFolder = /** @class */ (function () {
        function ThemeExcelFolder() {
        }
        Object.defineProperty(ThemeExcelFolder.prototype, "folderName", {
            get: function () {
                return 'theme';
            },
            enumerable: true,
            configurable: true
        });
        ThemeExcelFolder.prototype.childFiles = function (data) {
            return [ExcelFileTypes.ThemeFile];
        };
        ThemeExcelFolder.prototype.childFolders = function (data) {
            return [];
        };
        return ThemeExcelFolder;
    }());
    /** @hidden */
    var WorksheetsExcelFolder = /** @class */ (function () {
        function WorksheetsExcelFolder() {
        }
        Object.defineProperty(WorksheetsExcelFolder.prototype, "folderName", {
            get: function () {
                return 'worksheets';
            },
            enumerable: true,
            configurable: true
        });
        WorksheetsExcelFolder.prototype.childFiles = function (data) {
            return [ExcelFileTypes.WorksheetFile];
        };
        WorksheetsExcelFolder.prototype.childFolders = function (data) {
            return data.isEmpty || !data.options.exportAsTable ? [] : [ExcelFolderTypes.WorksheetsRelsExcelFolder];
        };
        return WorksheetsExcelFolder;
    }());
    /** @hidden */
    var TablesExcelFolder = /** @class */ (function () {
        function TablesExcelFolder() {
        }
        Object.defineProperty(TablesExcelFolder.prototype, "folderName", {
            get: function () {
                return 'tables';
            },
            enumerable: true,
            configurable: true
        });
        TablesExcelFolder.prototype.childFiles = function (data) {
            return [ExcelFileTypes.TablesFile];
        };
        TablesExcelFolder.prototype.childFolders = function (data) {
            return [];
        };
        return TablesExcelFolder;
    }());
    /** @hidden */
    var WorksheetsRelsExcelFolder = /** @class */ (function () {
        function WorksheetsRelsExcelFolder() {
        }
        Object.defineProperty(WorksheetsRelsExcelFolder.prototype, "folderName", {
            get: function () {
                return '_rels';
            },
            enumerable: true,
            configurable: true
        });
        WorksheetsRelsExcelFolder.prototype.childFiles = function (data) {
            return [ExcelFileTypes.WorksheetRelsFile];
        };
        WorksheetsRelsExcelFolder.prototype.childFolders = function (data) {
            return [];
        };
        return WorksheetsRelsExcelFolder;
    }());

    /** @hidden */
    var ExcelElementsFactory = /** @class */ (function () {
        function ExcelElementsFactory() {
        }
        ExcelElementsFactory.getExcelFolder = function (type) {
            switch (type) {
                case ExcelFolderTypes.RootExcelFolder:
                    return new RootExcelFolder();
                case ExcelFolderTypes.RootRelsExcelFolder:
                    return new RootRelsExcelFolder();
                case ExcelFolderTypes.DocPropsExcelFolder:
                    return new DocPropsExcelFolder();
                case ExcelFolderTypes.XLExcelFolder:
                    return new XLExcelFolder();
                case ExcelFolderTypes.XLRelsExcelFolder:
                    return new XLRelsExcelFolder();
                case ExcelFolderTypes.ThemeExcelFolder:
                    return new ThemeExcelFolder();
                case ExcelFolderTypes.WorksheetsExcelFolder:
                    return new WorksheetsExcelFolder();
                case ExcelFolderTypes.WorksheetsRelsExcelFolder:
                    return new WorksheetsRelsExcelFolder();
                case ExcelFolderTypes.TablesExcelFolder:
                    return new TablesExcelFolder();
                default:
                    throw new Error('Unknown excel folder type!');
            }
        };
        ExcelElementsFactory.getExcelFile = function (type) {
            switch (type) {
                case ExcelFileTypes.RootRelsFile:
                    return new RootRelsFile();
                case ExcelFileTypes.AppFile:
                    return new AppFile();
                case ExcelFileTypes.CoreFile:
                    return new CoreFile();
                case ExcelFileTypes.WorkbookRelsFile:
                    return new WorkbookRelsFile();
                case ExcelFileTypes.ThemeFile:
                    return new ThemeFile();
                case ExcelFileTypes.WorksheetFile:
                    return new WorksheetFile();
                case ExcelFileTypes.StyleFile:
                    return new StyleFile();
                case ExcelFileTypes.WorkbookFile:
                    return new WorkbookFile();
                case ExcelFileTypes.ContentTypesFile:
                    return new ContentTypesFile();
                case ExcelFileTypes.SharedStringsFile:
                    return new SharedStringsFile();
                case ExcelFileTypes.WorksheetRelsFile:
                    return new WorksheetRelsFile();
                case ExcelFileTypes.TablesFile:
                    return new TablesFile();
                default:
                    throw Error('Unknown excel file type!');
            }
        };
        return ExcelElementsFactory;
    }());

    /** @hidden */
    var WorksheetDataDictionary = /** @class */ (function () {
        function WorksheetDataDictionary(columnCount, columnWidth) {
            this.hasNonStringValues = false;
            this._dictionary = {};
            this._widthsDictionary = {};
            this._counter = 0;
            this.dirtyKeyCollections();
            this._calculateColumnWidth = !columnWidth;
            this._columnWidths = new Array(columnCount);
            this._columnTypeInfo = new Array(columnCount);
            if (!this._calculateColumnWidth) {
                this._columnWidths.fill(columnWidth);
            }
            this.stringsCount = 0;
        }
        Object.defineProperty(WorksheetDataDictionary.prototype, "columnWidths", {
            get: function () {
                return this._columnWidths;
            },
            enumerable: true,
            configurable: true
        });
        WorksheetDataDictionary.prototype.saveValue = function (value, column, isHeader) {
            if (this._columnTypeInfo[column] === undefined && isHeader === false) {
                this._columnTypeInfo[column] = typeof value === 'string' ||
                    typeof value === 'boolean' ||
                    value instanceof Date;
            }
            var sanitizedValue = '';
            var isSavedAsString = this._columnTypeInfo[column] || isHeader;
            if (isSavedAsString) {
                sanitizedValue = this.sanitizeValue(value);
                if (this._dictionary[sanitizedValue] === undefined) {
                    this._dictionary[sanitizedValue] = this._counter++;
                    this.dirtyKeyCollections();
                }
                this.stringsCount++;
            }
            else {
                this.hasNonStringValues = true;
            }
            if (this._calculateColumnWidth) {
                var width = this.getTextWidth(value);
                var maxWidth = Math.max(this._columnWidths[column] || 0, width);
                this._columnWidths[column] = maxWidth;
            }
            return isSavedAsString ? this.getSanitizedValue(sanitizedValue) : -1;
        };
        WorksheetDataDictionary.prototype.getValue = function (value) {
            return this.getSanitizedValue(this.sanitizeValue(value));
        };
        WorksheetDataDictionary.prototype.getSanitizedValue = function (sanitizedValue) {
            return this._dictionary[sanitizedValue];
        };
        WorksheetDataDictionary.prototype.getKeys = function () {
            if (!this._keysAreValid) {
                this._keys = Object.keys(this._dictionary);
                this._keysAreValid = true;
            }
            return this._keys;
        };
        WorksheetDataDictionary.prototype.getTextWidth = function (value) {
            if (this._widthsDictionary[value] === undefined) {
                var context = this.getContext();
                var metrics = context.measureText(value);
                this._widthsDictionary[value] = metrics.width + WorksheetDataDictionary.TEXT_PADDING;
            }
            return this._widthsDictionary[value];
        };
        WorksheetDataDictionary.prototype.getContext = function () {
            if (!this._context) {
                var canvas = document.createElement('canvas');
                this._context = canvas.getContext('2d');
                this._context.font = WorksheetDataDictionary.DEFAULT_FONT;
            }
            return this._context;
        };
        WorksheetDataDictionary.prototype.sanitizeValue = function (value) {
            if (ExportUtilities.hasValue(value) === false) {
                return '';
            }
            else {
                var stringValue = String(value);
                return stringValue.replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }
        };
        WorksheetDataDictionary.prototype.dirtyKeyCollections = function () {
            this._keysAreValid = false;
        };
        WorksheetDataDictionary.DEFAULT_FONT = '11pt Calibri';
        WorksheetDataDictionary.TEXT_PADDING = 5;
        return WorksheetDataDictionary;
    }());

    /** @hidden */
    var WorksheetData = /** @class */ (function () {
        function WorksheetData(_data, options, indexOfLastPinnedColumn, sort, isTreeGridData) {
            if (isTreeGridData === void 0) { isTreeGridData = false; }
            this._data = _data;
            this.options = options;
            this.indexOfLastPinnedColumn = indexOfLastPinnedColumn;
            this.sort = sort;
            this.isTreeGridData = isTreeGridData;
            this.initializeData();
        }
        Object.defineProperty(WorksheetData.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "columnCount", {
            get: function () {
                return this._columnCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "rowCount", {
            get: function () {
                return this._rowCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "isEmpty", {
            get: function () {
                return !this.rowCount || !this._columnCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "keys", {
            get: function () {
                return this._keys;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "isSpecialData", {
            get: function () {
                return this._isSpecialData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WorksheetData.prototype, "dataDictionary", {
            get: function () {
                return this._dataDictionary;
            },
            enumerable: true,
            configurable: true
        });
        WorksheetData.prototype.initializeData = function () {
            if (!this._data || this._data.length === 0) {
                return;
            }
            var actualData = this._data.map(function (item) { return item.rowData; });
            this._keys = ExportUtilities.getKeysFromData(actualData);
            if (this._keys.length === 0) {
                return;
            }
            this._isSpecialData = ExportUtilities.isSpecialData(actualData);
            this._columnCount = this._keys.length;
            this._rowCount = this._data.length + 1;
            this._dataDictionary = new WorksheetDataDictionary(this._columnCount, this.options.columnWidth);
        };
        return WorksheetData;
    }());

    /**
     * **Ignite UI for Angular Excel Exporter Service** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_excel.html)
     *
     * The Ignite UI for Angular Excel Exporter service can export data in Microsoft® Excel® format from both raw data
     * (array) or from an `IgxGrid`.
     *
     * Example:
     * ```typescript
     * public localData = [
     *   { Name: "Eric Ridley", Age: "26" },
     *   { Name: "Alanis Brook", Age: "22" },
     *   { Name: "Jonathan Morris", Age: "23" }
     * ];
     *
     * constructor(private excelExportService: IgxExcelExporterService) {
     * }
     *
     * this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions("FileName"));
     * ```
     */
    var IgxExcelExporterService = /** @class */ (function (_super) {
        __extends(IgxExcelExporterService, _super);
        function IgxExcelExporterService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * This event is emitted when the export process finishes.
             * ```typescript
             * this.exporterService.onExportEnded.subscribe((args: IExcelExportEndedEventArgs) => {
             * // put event handler code here
             * });
             * ```
             * @memberof IgxExcelExporterService
             */
            _this.onExportEnded = new core.EventEmitter();
            return _this;
        }
        IgxExcelExporterService_1 = IgxExcelExporterService;
        IgxExcelExporterService.populateFolder = function (folder, zip, worksheetData) {
            var e_1, _a, e_2, _b;
            try {
                for (var _c = __values(folder.childFolders(worksheetData)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var childFolder = _d.value;
                    var folderIntance = ExcelElementsFactory.getExcelFolder(childFolder);
                    var zipFolder = zip.folder(folderIntance.folderName);
                    IgxExcelExporterService_1.populateFolder(folderIntance, zipFolder, worksheetData);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            try {
                for (var _e = __values(folder.childFiles(worksheetData)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var childFile = _f.value;
                    var fileInstance = ExcelElementsFactory.getExcelFile(childFile);
                    fileInstance.writeElement(zip, worksheetData);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        IgxExcelExporterService.prototype.exportDataImplementation = function (data, options) {
            var _this = this;
            if (this._isTreeGrid) {
                var maxLevel_1 = 0;
                data.forEach(function (r) {
                    maxLevel_1 = Math.max(maxLevel_1, r.originalRowData.level);
                });
                if (maxLevel_1 > 7) {
                    throw Error('Can create an outline of up to eight levels!');
                }
            }
            var worksheetData = new WorksheetData(data, options, this._indexOfLastPinnedColumn, this._sort, this._isTreeGrid);
            this._xlsx = new JSZip();
            var rootFolder = ExcelElementsFactory.getExcelFolder(ExcelFolderTypes.RootExcelFolder);
            IgxExcelExporterService_1.populateFolder(rootFolder, this._xlsx, worksheetData);
            this._xlsx.generateAsync(IgxExcelExporterService_1.ZIP_OPTIONS).then(function (result) {
                _this.saveFile(result, options.fileName);
                _this.onExportEnded.emit({ xlsx: _this._xlsx });
            });
        };
        IgxExcelExporterService.prototype.saveFile = function (data, fileName) {
            var blob = new Blob([ExportUtilities.stringToArrayBuffer(atob(data))], {
                type: ''
            });
            ExportUtilities.saveBlobToFile(blob, fileName);
        };
        var IgxExcelExporterService_1;
        IgxExcelExporterService.ZIP_OPTIONS = { compression: 'DEFLATE', type: 'base64' };
        __decorate([
            core.Output()
        ], IgxExcelExporterService.prototype, "onExportEnded", void 0);
        IgxExcelExporterService = IgxExcelExporterService_1 = __decorate([
            core.Injectable()
        ], IgxExcelExporterService);
        return IgxExcelExporterService;
    }(IgxBaseExporter));

    /**
     * Objects of this class are used to configure the Excel exporting process.
     */
    var IgxExcelExporterOptions = /** @class */ (function (_super) {
        __extends(IgxExcelExporterOptions, _super);
        function IgxExcelExporterOptions(fileName) {
            var _this = _super.call(this, fileName, '.xlsx') || this;
            /**
             * Specifies if column pinning should be ignored. If ignoreColumnsOrder is set to true,
             * this option will always be considered as set to true.
             * ```typescript
             * let ignorePinning = this.exportOptions.ignorePinning;
             * this.exportOptions.ignorePinning = true;
             * ```
             * @memberof IgxExcelExporterOptions
             */
            _this.ignorePinning = false;
            /**
             * Specifies whether the exported data should be formatted as Excel table. (True by default)
             * ```typescript
             * let exportAsTable = this.exportOptions.exportAsTable;
             * this.exportOptions.exportAsTable = false;
             * ```
             * @memberof IgxExcelExporterOptions
             */
            _this.exportAsTable = true;
            return _this;
        }
        Object.defineProperty(IgxExcelExporterOptions.prototype, "columnWidth", {
            /**
             * Gets the width of the columns in the exported excel file.
             * ```typescript
             * let width = this.exportOptions.columnWidth;
             * ```
             * @memberof IgxExcelExporterOptions
             */
            get: function () {
                return this._columnWidth;
            },
            /**
             * Sets the width of the columns in the exported excel file. If left unspecified or 0,
             * the width of the largest string in the column will be used.
             * ```typescript
             * this.exportOptions.columnWidth = 55;
             * ```
             * @memberof IgxExcelExporterOptions
             */
            set: function (value) {
                if (value < 0) {
                    throw Error('Invalid value for column width!');
                }
                this._columnWidth = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelExporterOptions.prototype, "rowHeight", {
            /**
             * Gets the height of the rows in the exported excel file.
             * ```typescript
             * let height = this.exportOptions.rowHeight;
             * ```
             * @memberof IgxExcelExporterOptions
             */
            get: function () {
                return this._rowHeight;
            },
            /**
             * Sets the height of the rows in the exported excel file. If left unspecified or 0,
             * the default height of the excel rows will be used.
             * ```typescript
             * this.exportOptions.rowHeight = 25;
             * ```
             * @memberof IgxExcelExporterOptions
             */
            set: function (value) {
                if (value < 0) {
                    throw Error('Invalid value for row height!');
                }
                this._rowHeight = value;
            },
            enumerable: true,
            configurable: true
        });
        return IgxExcelExporterOptions;
    }(IgxExporterOptionsBase));


    (function (HorizontalAlignment) {
        HorizontalAlignment[HorizontalAlignment["Left"] = -1] = "Left";
        HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
        HorizontalAlignment[HorizontalAlignment["Right"] = 0] = "Right";
    })(exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));

    (function (VerticalAlignment) {
        VerticalAlignment[VerticalAlignment["Top"] = -1] = "Top";
        VerticalAlignment[VerticalAlignment["Middle"] = -0.5] = "Middle";
        VerticalAlignment[VerticalAlignment["Bottom"] = 0] = "Bottom";
    })(exports.VerticalAlignment || (exports.VerticalAlignment = {}));
    var Point = /** @class */ (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        return Point;
    }());
    /** @hidden */
    var Util = /** @class */ (function () {
        function Util() {
        }
        /**
         * @hidden
         * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0,0,0 rectangle
         * if no target is provided
         * @param settings Overlay settings for which to calculate target rectangle
         */
        Util.getTargetRect = function (settings) {
            var targetRect = {
                bottom: 0,
                height: 0,
                left: 0,
                right: 0,
                top: 0,
                width: 0
            };
            if (settings.target instanceof HTMLElement) {
                targetRect = settings.target.getBoundingClientRect();
            }
            else if (settings.target instanceof Point) {
                var targetPoint = settings.target;
                targetRect = {
                    bottom: targetPoint.y,
                    height: 0,
                    left: targetPoint.x,
                    right: targetPoint.x,
                    top: targetPoint.y,
                    width: 0
                };
            }
            return targetRect;
        };
        /** @hidden @internal */
        Util.getViewportRect = function (document) {
            var width = document.documentElement.clientWidth;
            var height = document.documentElement.clientHeight;
            var scrollPosition = Util.getViewportScrollPosition(document);
            return {
                top: scrollPosition.y,
                left: scrollPosition.x,
                right: scrollPosition.x + width,
                bottom: scrollPosition.y + height,
                width: width,
                height: height,
            };
        };
        /** @hidden @internal */
        Util.getViewportScrollPosition = function (document) {
            var documentElement = document.documentElement;
            var documentRect = documentElement.getBoundingClientRect();
            var horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
            var verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
            return new Point(horizontalScrollPosition, verticalScrollPosition);
        };
        /** @hidden @internal*/
        Util.cloneInstance = function (object) {
            var clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);
            clonedObj.settings = cloneValue(clonedObj.settings);
            return clonedObj;
        };
        return Util;
    }());

    /**
     * Positions the element based on the directions passed in trough PositionSettings.
     * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
     */
    var GlobalPositionStrategy = /** @class */ (function () {
        function GlobalPositionStrategy(settings) {
            this._defaultSettings = {
                horizontalDirection: exports.HorizontalAlignment.Center,
                verticalDirection: exports.VerticalAlignment.Middle,
                horizontalStartPoint: exports.HorizontalAlignment.Center,
                verticalStartPoint: exports.VerticalAlignment.Middle,
                openAnimation: fadeIn,
                closeAnimation: fadeOut,
                minSize: { width: 0, height: 0 }
            };
            this.settings = Object.assign({}, this._defaultSettings, settings);
        }
        /** @inheritdoc */
        GlobalPositionStrategy.prototype.position = function (contentElement, size, document, initialCall) {
            contentElement.classList.add('igx-overlay__content--relative');
            contentElement.parentElement.classList.add('igx-overlay__wrapper--flex');
            this.setPosition(contentElement, this.settings);
        };
        GlobalPositionStrategy.prototype.setPosition = function (contentElement, settings) {
            switch (this.settings.horizontalDirection) {
                case exports.HorizontalAlignment.Left:
                    contentElement.parentElement.style.justifyContent = 'flex-start';
                    break;
                case exports.HorizontalAlignment.Center:
                    contentElement.parentElement.style.justifyContent = 'center';
                    break;
                case exports.HorizontalAlignment.Right:
                    contentElement.parentElement.style.justifyContent = 'flex-end';
                    break;
                default:
                    break;
            }
            switch (this.settings.verticalDirection) {
                case exports.VerticalAlignment.Top:
                    contentElement.parentElement.style.alignItems = 'flex-start';
                    break;
                case exports.VerticalAlignment.Middle:
                    contentElement.parentElement.style.alignItems = 'center';
                    break;
                case exports.VerticalAlignment.Bottom:
                    contentElement.parentElement.style.alignItems = 'flex-end';
                    break;
                default:
                    break;
            }
        };
        /** @inheritdoc */
        GlobalPositionStrategy.prototype.clone = function () {
            return Util.cloneInstance(this);
        };
        return GlobalPositionStrategy;
    }());

    var ScrollStrategy = /** @class */ (function () {
        function ScrollStrategy(scrollContainer) {
        }
        return ScrollStrategy;
    }());

    /**
     * Empty scroll strategy. Does nothing.
     */
    var NoOpScrollStrategy = /** @class */ (function (_super) {
        __extends(NoOpScrollStrategy, _super);
        function NoOpScrollStrategy(scrollContainer) {
            return _super.call(this, scrollContainer) || this;
        }
        /** @inheritdoc */
        NoOpScrollStrategy.prototype.initialize = function (document, overlayService, id) { };
        /** @inheritdoc */
        NoOpScrollStrategy.prototype.attach = function () { };
        /** @inheritdoc */
        NoOpScrollStrategy.prototype.detach = function () { };
        return NoOpScrollStrategy;
    }(ScrollStrategy));

    /**
     * @hidden
     */
    function DeprecateMethod(message) {
        var isMessageShown = false;
        return function (target, key, descriptor) {
            if (descriptor && descriptor.value) {
                var originalMethod_1 = descriptor.value;
                descriptor.value = function () {
                    var targetName = typeof target === 'function' ? target.name : target.constructor.name;
                    isMessageShown = showMessage(targetName + "." + key + ": " + message, isMessageShown);
                    return originalMethod_1.call(this, arguments);
                };
                return descriptor;
            }
        };
    }
    /**
     * @hidden
     */
    function DeprecateProperty(message) {
        return function (target, key) {
            var isMessageShown = false;
            var messageToDisplay = target.constructor.name + "." + key + ": " + message;
            // if the target already has the property defined
            var originalDescriptor = Object.getOwnPropertyDescriptor(target, key);
            if (originalDescriptor) {
                var getter_1, setter_1;
                getter_1 = originalDescriptor.get;
                setter_1 = originalDescriptor.set;
                if (getter_1) {
                    originalDescriptor.get = function () {
                        isMessageShown = showMessage(messageToDisplay, isMessageShown);
                        return getter_1.call(this);
                    };
                }
                if (setter_1) {
                    originalDescriptor.set = function (value) {
                        isMessageShown = showMessage(messageToDisplay, isMessageShown);
                        setter_1.call(this, value);
                    };
                }
                return originalDescriptor;
            }
            // the target doesn't contain a descriptor for that property, so create one
            // use backing field to set/get the value of the property to ensure there won't be infinite recursive calls
            var newKey = generateUniqueKey(target, key);
            Object.defineProperty(target, key, {
                configurable: true,
                enumerable: true,
                set: function (value) {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    this[newKey] = value;
                },
                get: function () {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    return this[newKey];
                }
            });
        };
    }
    /**
     * @hidden
     */
    function generateUniqueKey(target, key) {
        var newKey = '_' + key;
        while (target.hasOwnProperty(newKey)) {
            newKey = '_' + newKey;
        }
        return newKey;
    }
    /**
     * @hidden
     */
    function showMessage(message, isMessageShown) {
        if (!isMessageShown && core.isDevMode()) {
            console.warn(message);
        }
        return true;
    }

    var warningShown = false;
    /**
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/overlay_main.html)
     * The overlay service allows users to show components on overlay div above all other elements in the page.
     */
    var IgxOverlayService = /** @class */ (function () {
        function IgxOverlayService(_factoryResolver, _appRef, _injector, builder, document, _zone) {
            var _this = this;
            this._factoryResolver = _factoryResolver;
            this._appRef = _appRef;
            this._injector = _injector;
            this.builder = builder;
            this.document = document;
            this._zone = _zone;
            this._componentId = 0;
            this._overlayInfos = [];
            this.destroy$ = new rxjs.Subject();
            this._defaultSettings = {
                positionStrategy: new GlobalPositionStrategy(),
                scrollStrategy: new NoOpScrollStrategy(),
                modal: true,
                closeOnOutsideClick: true
            };
            /**
             * Emitted before the component is opened.
             * ```typescript
             * onOpening(event: OverlayCancelableEventArgs){
             *     const onOpening = event;
             * }
             * ```
             */
            this.onOpening = new core.EventEmitter();
            /**
             * Emitted after the component is appended to the overlay, and before animations are started.
             * ```typescript
             * onAppended(event: OverlayEventArgs){
             *     const onAppended = event;
             * }
             * ```
             */
            this.onAppended = new core.EventEmitter();
            /**
             * Emitted after the component is opened and all animations are finished.
             * ```typescript
             * onOpened(event: OverlayEventArgs){
             *     const onOpened = event;
             * }
             * ```
             */
            this.onOpened = new core.EventEmitter();
            /**
             * Emitted before the component is closed.
             * ```typescript
             * onClosing(event: OverlayCancelableEventArgs){
             *     const onClosing = event;
             * }
             * ```
             */
            this.onClosing = new core.EventEmitter();
            /**
             * Emitted after the component is closed and all animations are finished.
             * ```typescript
             * onClosed(event: OverlayEventArgs){
             *     const onClosed = event;
             * }
             * ```
             */
            this.onClosed = new core.EventEmitter();
            /**
             * Emitted before animation is started
             * ```typescript
             * onAnimation(event: OverlayAnimationEventArgs){
             *     const onAnimation = event;
             * }
             * ```
             */
            this.onAnimation = new core.EventEmitter();
            this.documentClicked = function (ev) {
                //  if we get to modal overlay just return - we should not close anything under it
                //  if we get to non-modal overlay do the next:
                //   1. Check it has close on outside click. If not go on to next overlay;
                //   2. If true check if click is on the element. If it is on the element we have closed
                //  already all previous non-modal with close on outside click elements, so we return. If
                //  not close the overlay and check next
                for (var i = _this._overlayInfos.length; i--;) {
                    var info = _this._overlayInfos[i];
                    if (info.settings.modal) {
                        return;
                    }
                    if (info.settings.closeOnOutsideClick) {
                        var target = ev.target;
                        //  if the click is on the element do not close this overlay
                        if (!info.elementRef.nativeElement.contains(target)) {
                            // if we should exclude position target check if the click is over it. If so do not close overlay
                            var positionTarget = info.settings.positionStrategy.settings.target;
                            var clickOnPositionTarget = false;
                            if (positionTarget) {
                                clickOnPositionTarget = positionTarget.contains(target);
                            }
                            if (!(info.settings.excludePositionTarget && clickOnPositionTarget)) {
                                //  if the click is outside click, but close animation has started do nothing
                                if (!(info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted())) {
                                    _this._hide(info.id, ev);
                                }
                            }
                        }
                        else {
                            //  TODO: should we return here, or continue with next overlays
                            return;
                        }
                    }
                }
            };
            /** @hidden */
            this.repositionAll = function () {
                for (var i = _this._overlayInfos.length; i--;) {
                    _this.reposition(_this._overlayInfos[i].id);
                }
            };
            this._document = this.document;
        }
        IgxOverlayService.prototype.attach = function (component, settings, moduleRef) {
            var info;
            info = this.getOverlayInfo(component, moduleRef);
            //  if there is no info most probably wrong type component was provided and we just go out
            if (!info) {
                return null;
            }
            info.id = (this._componentId++).toString();
            settings = Object.assign({}, this._defaultSettings, settings);
            info.settings = settings;
            this._overlayInfos.push(info);
            return info.id;
        };
        IgxOverlayService.prototype.show = function (compOrId, settings) {
            var info;
            var id;
            if (typeof compOrId === 'string') {
                id = compOrId;
                info = this.getOverlayById(compOrId);
                if (!info) {
                    console.warn('igxOverlay.show was called with wrong id: ' + compOrId);
                    return null;
                }
            }
            else {
                warningShown = showMessage('`show(component, settings?)` overload is deprecated. Use `attach(component)` to obtain an Id.' +
                    'Then `show(id, settings?)` with provided Id.', warningShown);
                id = (this._componentId++).toString();
                info = this.getOverlayInfo(compOrId);
                //  if there is no info most probably wrong type component was provided and we just go out
                if (!info) {
                    return;
                }
                info.id = id;
            }
            settings = Object.assign({}, this._defaultSettings, info.settings, settings);
            info.settings = settings;
            this._show(info);
            return id;
        };
        /**
         * Hides the component with the ID provided as a parameter.
         * ```typescript
         * this.overlay.hide(id);
         * ```
         */
        IgxOverlayService.prototype.hide = function (id) {
            this._hide(id);
        };
        /**
         * Hides all the components and the overlay.
         * ```typescript
         * this.overlay.hideAll();
         * ```
         */
        IgxOverlayService.prototype.hideAll = function () {
            // since overlays are removed on animation done, que all hides
            for (var i = this._overlayInfos.length; i--;) {
                this.hide(this._overlayInfos[i].id);
            }
        };
        /**
         * Repositions the component with ID provided as a parameter.
         * ```typescript
         * this.overlay.reposition(id);
         * ```
         */
        IgxOverlayService.prototype.reposition = function (id) {
            var overlayInfo = this.getOverlayById(id);
            if (!overlayInfo || !overlayInfo.settings) {
                console.error('Wrong id provided in overlay.reposition method. Id: ' + id);
                return;
            }
            var contentElement = overlayInfo.elementRef.nativeElement.parentElement;
            var contentElementRect = contentElement.getBoundingClientRect();
            overlayInfo.settings.positionStrategy.position(contentElement, {
                width: contentElementRect.width,
                height: contentElementRect.height
            }, this._document, false);
        };
        /**
         * Offsets the content along the corresponding axis by the provided amount
         * ```typescript
         * this.overlay.setOffset(id, deltaX, deltaY);
         * ```
         */
        IgxOverlayService.prototype.setOffset = function (id, deltaX, deltaY) {
            var info = this.getOverlayById(id);
            if (!info) {
                return;
            }
            info.transformX += deltaX;
            info.transformY += deltaY;
            var transformX = info.transformX;
            var transformY = info.transformY;
            var translate = "translate(" + transformX + "px, " + transformY + "px)";
            info.elementRef.nativeElement.parentElement.style.transform = translate;
        };
        IgxOverlayService.prototype._show = function (info) {
            var eventArgs = { id: info.id, componentRef: info.componentRef, cancel: false };
            this.onOpening.emit(eventArgs);
            if (eventArgs.cancel) {
                if (info.componentRef) {
                    this._appRef.detachView(info.componentRef.hostView);
                    info.componentRef.destroy();
                }
                return;
            }
            //  if there is no close animation player, or there is one but it is not started yet we are in clear
            //  opening. Otherwise, if there is close animation player playing animation now we should not setup
            //  overlay this is already done
            if (!info.closeAnimationPlayer || (info.closeAnimationPlayer && !info.closeAnimationPlayer.hasStarted())) {
                var elementRect = info.elementRef.nativeElement.getBoundingClientRect();
                info.initialSize = { width: elementRect.width, height: elementRect.height };
                info.hook = this.placeElementHook(info.elementRef.nativeElement);
                this.moveElementToOverlay(info);
                if (info.componentRef) {
                    info.componentRef.changeDetectorRef.detectChanges();
                }
                this.onAppended.emit({ id: info.id, componentRef: info.componentRef });
                this.updateSize(info);
                if (this._overlayInfos.indexOf(info) === -1) {
                    this._overlayInfos.push(info);
                }
                info.settings.positionStrategy.position(info.elementRef.nativeElement.parentElement, { width: info.initialSize.width, height: info.initialSize.height }, document, true);
                info.settings.scrollStrategy.initialize(this._document, this, info.id);
                info.settings.scrollStrategy.attach();
            }
            this.addOutsideClickListener(info);
            this.addResizeHandler(info.id);
            if (info.settings.modal) {
                this.setupModalWrapper(info);
            }
            if (info.settings.positionStrategy.settings.openAnimation) {
                this.playOpenAnimation(info);
            }
            else {
                //  to eliminate flickering show the element just before onOpened fire
                info.elementRef.nativeElement.parentElement.style.visibility = '';
                this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
            }
        };
        IgxOverlayService.prototype._hide = function (id, event) {
            var info = this.getOverlayById(id);
            if (!info) {
                console.warn('igxOverlay.hide was called with wrong id: ' + id);
                return;
            }
            var eventArgs = { id: id, componentRef: info.componentRef, cancel: false, event: event };
            this.onClosing.emit(eventArgs);
            if (eventArgs.cancel) {
                return;
            }
            //  TODO: synchronize where these are added/attached and where removed/detached
            info.settings.scrollStrategy.detach();
            this.removeOutsideClickListener(info);
            this.removeResizeHandler(info.id);
            var child = info.elementRef.nativeElement;
            if (info.settings.modal) {
                var parent_1 = child.parentNode.parentNode;
                this.applyAnimationParams(parent_1, info.settings.positionStrategy.settings.closeAnimation);
                parent_1.classList.remove('igx-overlay__wrapper--modal');
                parent_1.classList.add('igx-overlay__wrapper');
            }
            if (info.settings.positionStrategy.settings.closeAnimation) {
                this.playCloseAnimation(info);
            }
            else {
                this.onCloseDone(info);
            }
        };
        IgxOverlayService.prototype.getOverlayInfo = function (component, moduleRef) {
            var info = { ngZone: this._zone, transformX: 0, transformY: 0 };
            if (component instanceof core.ElementRef) {
                info.elementRef = component;
            }
            else {
                var dynamicFactory = void 0;
                var factoryResolver = moduleRef ? moduleRef.componentFactoryResolver : this._factoryResolver;
                try {
                    dynamicFactory = factoryResolver.resolveComponentFactory(component);
                }
                catch (error) {
                    console.error(error);
                    return null;
                }
                var injector = moduleRef ? moduleRef.injector : this._injector;
                var dynamicComponent = dynamicFactory.create(injector);
                this._appRef.attachView(dynamicComponent.hostView);
                // If the element is newly created from a Component, it is wrapped in 'ng-component' tag - we do not want that.
                var element = dynamicComponent.location.nativeElement;
                info.elementRef = { nativeElement: element };
                info.componentRef = dynamicComponent;
            }
            return info;
        };
        IgxOverlayService.prototype.placeElementHook = function (element) {
            if (!element.parentElement) {
                return null;
            }
            var hook = this._document.createElement('div');
            element.parentElement.insertBefore(hook, element);
            return hook;
        };
        IgxOverlayService.prototype.moveElementToOverlay = function (info) {
            var wrapperElement = this.getWrapperElement();
            var contentElement = this.getContentElement(wrapperElement, info.settings.modal);
            this.getOverlayElement(info).appendChild(wrapperElement);
            contentElement.appendChild(info.elementRef.nativeElement);
        };
        IgxOverlayService.prototype.getWrapperElement = function () {
            var wrapper = this._document.createElement('div');
            wrapper.classList.add('igx-overlay__wrapper');
            return wrapper;
        };
        IgxOverlayService.prototype.getContentElement = function (wrapperElement, modal) {
            var content = this._document.createElement('div');
            if (modal) {
                content.classList.add('igx-overlay__content--modal');
                content.addEventListener('click', function (ev) {
                    ev.stopPropagation();
                });
            }
            else {
                content.classList.add('igx-overlay__content');
            }
            content.addEventListener('scroll', function (ev) {
                ev.stopPropagation();
            });
            //  hide element to eliminate flickering. Show the element exactly before animation starts
            content.style.visibility = 'hidden';
            wrapperElement.appendChild(content);
            return content;
        };
        IgxOverlayService.prototype.getOverlayElement = function (info) {
            if (info.settings.outlet) {
                return info.settings.outlet.nativeElement;
            }
            if (!this._overlayElement) {
                this._overlayElement = this._document.createElement('div');
                this._overlayElement.classList.add('igx-overlay');
                this._document.body.appendChild(this._overlayElement);
            }
            return this._overlayElement;
        };
        IgxOverlayService.prototype.updateSize = function (info) {
            if (info.componentRef) {
                //  if we are positioning component this is first time it gets visible
                //  and we can finally get its size
                info.initialSize = info.elementRef.nativeElement.getBoundingClientRect();
            }
            // set content div width only if element to show has width
            if (info.initialSize.width !== 0) {
                info.elementRef.nativeElement.parentElement.style.width = info.initialSize.width + 'px';
            }
        };
        IgxOverlayService.prototype.setupModalWrapper = function (info) {
            var _this = this;
            var wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;
            rxjs.fromEvent(wrapperElement, 'keydown').pipe(operators.filter(function (ev) { return ev.key === 'Escape' || ev.key === 'Esc'; }), operators.takeUntil(this.destroy$)).subscribe(function () { return _this.hide(info.id); });
            wrapperElement.classList.remove('igx-overlay__wrapper');
            this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.openAnimation);
            wrapperElement.classList.add('igx-overlay__wrapper--modal');
        };
        IgxOverlayService.prototype.onCloseDone = function (info) {
            this.cleanUp(info);
            this.onClosed.emit({ id: info.id, componentRef: info.componentRef });
        };
        IgxOverlayService.prototype.cleanUp = function (info) {
            var child = info.elementRef.nativeElement;
            var outlet = this.getOverlayElement(info);
            if (!outlet.contains(child)) {
                console.warn('Component with id:' + info.id + ' is already removed!');
                return;
            }
            outlet.removeChild(child.parentNode.parentNode);
            if (info.componentRef) {
                this._appRef.detachView(info.componentRef.hostView);
                info.componentRef.destroy();
            }
            if (info.hook) {
                info.hook.parentElement.insertBefore(info.elementRef.nativeElement, info.hook);
                info.hook.parentElement.removeChild(info.hook);
            }
            var index = this._overlayInfos.indexOf(info);
            this._overlayInfos.splice(index, 1);
            // this._overlayElement.parentElement check just for tests that manually delete the element
            if (this._overlayInfos.length === 0 && this._overlayElement && this._overlayElement.parentElement) {
                this._overlayElement.parentElement.removeChild(this._overlayElement);
                this._overlayElement = null;
            }
        };
        IgxOverlayService.prototype.playOpenAnimation = function (info) {
            var _this = this;
            if (!info.openAnimationPlayer) {
                var animationBuilder = this.builder.build(info.settings.positionStrategy.settings.openAnimation);
                info.openAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
                //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
                //  and then getting the positions from it.
                //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
                //  As soon as this is resolved we can remove this hack
                var innerRenderer = info.openAnimationPlayer._renderer;
                info.openAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
                info.openAnimationPlayer.onDone(function () {
                    _this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
                    if (info.openAnimationPlayer) {
                        info.openAnimationPlayer.reset();
                        info.openAnimationPlayer = null;
                    }
                    if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                        info.closeAnimationPlayer.reset();
                    }
                });
            }
            //  if there is opening animation already started do nothing
            if (info.openAnimationPlayer.hasStarted()) {
                return;
            }
            //  if there is closing animation already started start open animation from where close one has reached
            //  and remove close animation
            if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
                //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
                //  the previous has finished we need the amount up to 1, therefore we are subtracting what
                //  getPosition() returns from one
                var position = 1 - info.closeAnimationInnerPlayer.getPosition();
                info.closeAnimationPlayer.reset();
                info.closeAnimationPlayer = null;
                info.openAnimationPlayer.init();
                info.openAnimationPlayer.setPosition(position);
            }
            this.onAnimation.emit({ id: info.id, animationPlayer: info.openAnimationPlayer, animationType: 'open' });
            //  to eliminate flickering show the element just before animation start
            info.elementRef.nativeElement.parentElement.style.visibility = '';
            info.openAnimationPlayer.play();
        };
        IgxOverlayService.prototype.playCloseAnimation = function (info) {
            var _this = this;
            if (!info.closeAnimationPlayer) {
                var animationBuilder = this.builder.build(info.settings.positionStrategy.settings.closeAnimation);
                info.closeAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
                //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
                //  and then getting the positions from it.
                //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
                //  As soon as this is resolved we can remove this hack
                var innerRenderer = info.closeAnimationPlayer._renderer;
                info.closeAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
                info.closeAnimationPlayer.onDone(function () {
                    if (info.closeAnimationPlayer) {
                        info.closeAnimationPlayer.reset();
                        info.closeAnimationPlayer = null;
                    }
                    if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                        info.openAnimationPlayer.reset();
                    }
                    _this.onCloseDone(info);
                });
            }
            //  if there is closing animation already started do nothing
            if (info.closeAnimationPlayer.hasStarted()) {
                return;
            }
            //  if there is opening animation already started start close animation from where open one has reached
            //  and remove open animation
            if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
                //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
                //  the previous has finished we need the amount up to 1, therefore we are subtracting what
                //  getPosition() returns from one
                var position = 1 - info.openAnimationInnerPlayer.getPosition();
                info.openAnimationPlayer.reset();
                info.openAnimationPlayer = null;
                info.closeAnimationPlayer.init();
                info.closeAnimationPlayer.setPosition(position);
            }
            this.onAnimation.emit({ id: info.id, animationPlayer: info.closeAnimationPlayer, animationType: 'close' });
            info.closeAnimationPlayer.play();
        };
        //  TODO: check if applyAnimationParams will work with complex animations
        IgxOverlayService.prototype.applyAnimationParams = function (wrapperElement, animationOptions) {
            if (!animationOptions) {
                wrapperElement.style.transitionDuration = '0ms';
                return;
            }
            if (animationOptions.type === 10 /* AnimateRef */) {
                animationOptions = animationOptions.animation;
            }
            if (!animationOptions.options || !animationOptions.options.params) {
                return;
            }
            var params = animationOptions.options.params;
            if (params.duration) {
                wrapperElement.style.transitionDuration = params.duration;
            }
            if (params.easing) {
                wrapperElement.style.transitionTimingFunction = params.easing;
            }
        };
        /** @hidden @internal */
        IgxOverlayService.prototype.getOverlayById = function (id) {
            if (!id) {
                return null;
            }
            var info = this._overlayInfos.find(function (e) { return e.id === id; });
            return info;
        };
        IgxOverlayService.prototype.addOutsideClickListener = function (info) {
            var _this = this;
            if (info.settings.closeOnOutsideClick) {
                if (info.settings.modal) {
                    rxjs.fromEvent(info.elementRef.nativeElement.parentElement.parentElement, 'click')
                        .pipe(operators.takeUntil(this.destroy$))
                        .subscribe(function (e) { return _this._hide(info.id, e); });
                }
                else if (
                //  if all overlays minus closing overlays equals one add the handler
                this._overlayInfos.filter(function (x) { return x.settings.closeOnOutsideClick && !x.settings.modal; }).length -
                    this._overlayInfos.filter(function (x) { return x.settings.closeOnOutsideClick && !x.settings.modal &&
                        x.closeAnimationPlayer &&
                        x.closeAnimationPlayer.hasStarted(); }).length === 1) {
                    this._document.addEventListener('click', this.documentClicked, true);
                }
            }
        };
        IgxOverlayService.prototype.removeOutsideClickListener = function (info) {
            if (info.settings.modal === false) {
                var shouldRemoveClickEventListener_1 = true;
                this._overlayInfos.forEach(function (o) {
                    if (o.settings.modal === false && o.id !== info.id) {
                        shouldRemoveClickEventListener_1 = false;
                    }
                });
                if (shouldRemoveClickEventListener_1) {
                    this._document.removeEventListener('click', this.documentClicked, true);
                }
            }
        };
        IgxOverlayService.prototype.addResizeHandler = function (id) {
            var closingOverlaysCount = this._overlayInfos
                .filter(function (o) { return o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted(); })
                .length;
            if (this._overlayInfos.length - closingOverlaysCount === 1) {
                this._document.defaultView.addEventListener('resize', this.repositionAll);
            }
        };
        IgxOverlayService.prototype.removeResizeHandler = function (id) {
            var closingOverlaysCount = this._overlayInfos
                .filter(function (o) { return o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted(); })
                .length;
            if (this._overlayInfos.length - closingOverlaysCount === 1) {
                this._document.defaultView.removeEventListener('resize', this.repositionAll);
            }
        };
        /**
         *@hidden
         */
        IgxOverlayService.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        IgxOverlayService.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver },
            { type: core.ApplicationRef },
            { type: core.Injector },
            { type: animations.AnimationBuilder },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.NgZone }
        ]; };
        IgxOverlayService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function IgxOverlayService_Factory() { return new IgxOverlayService(core["ɵɵinject"](core.ComponentFactoryResolver), core["ɵɵinject"](core.ApplicationRef), core["ɵɵinject"](core.INJECTOR), core["ɵɵinject"](animations.AnimationBuilder), core["ɵɵinject"](common.DOCUMENT), core["ɵɵinject"](core.NgZone)); }, token: IgxOverlayService, providedIn: "root" });
        IgxOverlayService = __decorate([
            core.Injectable({ providedIn: 'root' }),
            __param(4, core.Inject(common.DOCUMENT))
        ], IgxOverlayService);
        return IgxOverlayService;
    }());

    /**
     * Positions the element inside the containing outlet based on the directions passed in trough PositionSettings.
     * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
     */
    var ContainerPositionStrategy = /** @class */ (function (_super) {
        __extends(ContainerPositionStrategy, _super);
        function ContainerPositionStrategy(settings) {
            return _super.call(this, settings) || this;
        }
        /** @inheritdoc */
        ContainerPositionStrategy.prototype.position = function (contentElement, size, document, initialCall) {
            contentElement.classList.add('igx-overlay__content--relative');
            contentElement.parentElement.classList.add('igx-overlay__wrapper--flex-container');
            this.setPosition(contentElement, this.settings);
        };
        return ContainerPositionStrategy;
    }(GlobalPositionStrategy));

    /**
     * Positions the element based on the directions and start point passed in trough PositionSettings.
     * It is possible to either pass a start point or an HTMLElement as a positioning base.
     */
    var ConnectedPositioningStrategy = /** @class */ (function () {
        function ConnectedPositioningStrategy(settings) {
            this._defaultSettings = {
                // default Point(0, 0) in getPointFromPositionsSettings
                target: null,
                horizontalDirection: exports.HorizontalAlignment.Right,
                verticalDirection: exports.VerticalAlignment.Bottom,
                horizontalStartPoint: exports.HorizontalAlignment.Left,
                verticalStartPoint: exports.VerticalAlignment.Bottom,
                openAnimation: scaleInVerTop,
                closeAnimation: scaleOutVerTop,
                minSize: { width: 0, height: 0 }
            };
            this.settings = Object.assign({}, this._defaultSettings, settings);
        }
        /**
         * Obtains the ClientRect objects for the required elements - target and element to position
         * @returns target and element ClientRect objects
         */
        ConnectedPositioningStrategy.prototype.calculateElementRectangles = function (contentElement) {
            return {
                targetRect: Util.getTargetRect(this.settings),
                elementRect: contentElement.getBoundingClientRect()
            };
        };
        /** @inheritdoc */
        ConnectedPositioningStrategy.prototype.position = function (contentElement, size, document, initialCall) {
            var rects = this.calculateElementRectangles(contentElement);
            this.setStyle(contentElement, rects.targetRect, rects.elementRect, {});
        };
        /**
         * @inheritdoc
         * Creates clone of this position strategy
         * @returns clone of this position strategy
         */
        ConnectedPositioningStrategy.prototype.clone = function () {
            return Util.cloneInstance(this);
        };
        /**
         * Sets element's style which effectively positions provided element according
         * to provided position settings
         * @param element Element to position
         * @param targetRect Bounding rectangle of strategy target
         * @param elementRect Bounding rectangle of the element
         */
        ConnectedPositioningStrategy.prototype.setStyle = function (element, targetRect, elementRect, connectedFit) {
            var horizontalOffset = connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0;
            var verticalOffset = connectedFit.verticalOffset ? connectedFit.verticalOffset : 0;
            var startPoint = {
                x: targetRect.right + targetRect.width * this.settings.horizontalStartPoint + horizontalOffset,
                y: targetRect.bottom + targetRect.height * this.settings.verticalStartPoint + verticalOffset
            };
            var wrapperRect = element.parentElement.getBoundingClientRect();
            //  clean up styles - if auto position strategy is chosen we may pass here several times
            element.style.right = '';
            element.style.left = '';
            element.style.bottom = '';
            element.style.top = '';
            switch (this.settings.horizontalDirection) {
                case exports.HorizontalAlignment.Left:
                    element.style.right = Math.round(wrapperRect.right - startPoint.x) + "px";
                    break;
                case exports.HorizontalAlignment.Center:
                    element.style.left = Math.round(startPoint.x - wrapperRect.left - elementRect.width / 2) + "px";
                    break;
                case exports.HorizontalAlignment.Right:
                    element.style.left = Math.round(startPoint.x - wrapperRect.left) + "px";
                    break;
            }
            switch (this.settings.verticalDirection) {
                case exports.VerticalAlignment.Top:
                    element.style.bottom = Math.round(wrapperRect.bottom - startPoint.y) + "px";
                    break;
                case exports.VerticalAlignment.Middle:
                    element.style.top = Math.round(startPoint.y - wrapperRect.top - elementRect.height / 2) + "px";
                    break;
                case exports.VerticalAlignment.Bottom:
                    element.style.top = Math.round(startPoint.y - wrapperRect.top) + "px";
                    break;
            }
        };
        return ConnectedPositioningStrategy;
    }());

    var BaseFitPositionStrategy = /** @class */ (function (_super) {
        __extends(BaseFitPositionStrategy, _super);
        function BaseFitPositionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** @inheritdoc */
        BaseFitPositionStrategy.prototype.position = function (contentElement, size, document, initialCall) {
            var rects = _super.prototype.calculateElementRectangles.call(this, contentElement);
            var connectedFit = {};
            if (initialCall) {
                connectedFit.targetRect = rects.targetRect;
                connectedFit.contentElementRect = rects.elementRect;
                this._initialSettings = this._initialSettings || Object.assign({}, this.settings);
                this.settings = Object.assign({}, this._initialSettings);
                connectedFit.viewPortRect = Util.getViewportRect(document);
                this.updateViewPortFit(connectedFit);
                if (this.shouldFitInViewPort(connectedFit)) {
                    this.fitInViewport(contentElement, connectedFit);
                }
            }
            this.setStyle(contentElement, rects.targetRect, rects.elementRect, connectedFit);
        };
        /**
         * Checks if element can fit in viewport and updates provided connectedFit
         * with the result
         * @param connectedFit connectedFit to update
         */
        BaseFitPositionStrategy.prototype.updateViewPortFit = function (connectedFit) {
            connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection, connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0);
            connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;
            connectedFit.fitHorizontal = {
                back: Math.round(connectedFit.left),
                forward: Math.round(connectedFit.viewPortRect.width - connectedFit.right)
            };
            connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection, connectedFit.verticalOffset ? connectedFit.verticalOffset : 0);
            connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;
            connectedFit.fitVertical = {
                back: Math.round(connectedFit.top),
                forward: Math.round(connectedFit.viewPortRect.height - connectedFit.bottom)
            };
        };
        /**
         * Calculates the position of the left border of the element if it gets positioned
         * with provided start point and direction
         * @param targetRect Rectangle of the target where element is attached
         * @param elementRect Rectangle of the element
         * @param startPoint Start point of the target
         * @param direction Direction in which to show the element
         */
        BaseFitPositionStrategy.prototype.calculateLeft = function (targetRect, elementRect, startPoint, direction, offset) {
            return targetRect.right + targetRect.width * startPoint + elementRect.width * direction + offset;
        };
        /**
         * Calculates the position of the top border of the element if it gets positioned
         * with provided position settings related to the target
         * @param targetRect Rectangle of the target where element is attached
         * @param elementRect Rectangle of the element
         * @param startPoint Start point of the target
         * @param direction Direction in which to show the element
         */
        BaseFitPositionStrategy.prototype.calculateTop = function (targetRect, elementRect, startPoint, direction, offset) {
            return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction + offset;
        };
        /**
         * Returns whether the element should fit in viewport
         * @param connectedFit connectedFit object containing all necessary parameters
         */
        BaseFitPositionStrategy.prototype.shouldFitInViewPort = function (connectedFit) {
            return connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0 ||
                connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0;
        };
        return BaseFitPositionStrategy;
    }(ConnectedPositioningStrategy));

    /**
     * Positions the element as in **Connected** positioning strategy and re-positions the element in
     * the view port (calculating a different start point) in case the element is partially getting out of view
     */
    var AutoPositionStrategy = /** @class */ (function (_super) {
        __extends(AutoPositionStrategy, _super);
        function AutoPositionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** @inheritdoc */
        AutoPositionStrategy.prototype.fitInViewport = function (element, connectedFit) {
            var transformString = [];
            if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
                if (this.canFlipHorizontal(connectedFit)) {
                    this.flipHorizontal();
                }
                else {
                    var horizontalPush = this.horizontalPush(connectedFit);
                    transformString.push("translateX(" + horizontalPush + "px)");
                }
            }
            if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
                if (this.canFlipVertical(connectedFit)) {
                    this.flipVertical();
                }
                else {
                    var verticalPush = this.verticalPush(connectedFit);
                    transformString.push("translateY(" + verticalPush + "px)");
                }
            }
            element.style.transform = transformString.join(' ').trim();
        };
        /**
         * Checks if element can be flipped without get off the viewport
         * @param connectedFit connectedFit object containing all necessary parameters
         * @returns true if element can be flipped and stain in viewport
         */
        AutoPositionStrategy.prototype.canFlipHorizontal = function (connectedFit) {
            //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
            //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
            //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
            //  this way:
            //  (-1) * (Left + 1) = 0 = Right
            //  (-1) * (Center + 1) = -0.5 = Center
            //  (-1) * (Right + 1) = -1 = Left
            var flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
            var flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
            var leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
            var rightBorder = leftBorder + connectedFit.contentElementRect.width;
            return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
        };
        /**
         * Checks if element can be flipped without get off the viewport
         * @param connectedFit connectedFit object containing all necessary parameters
         * @returns true if element can be flipped and stain in viewport
         */
        AutoPositionStrategy.prototype.canFlipVertical = function (connectedFit) {
            var flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
            var flippedDirection = (-1) * (this.settings.verticalDirection + 1);
            var topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
            var bottomBorder = topBorder + connectedFit.contentElementRect.height;
            return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
        };
        /**
         * Flips direction and start point of the position settings
         */
        AutoPositionStrategy.prototype.flipHorizontal = function () {
            switch (this.settings.horizontalDirection) {
                case exports.HorizontalAlignment.Left:
                    this.settings.horizontalDirection = exports.HorizontalAlignment.Right;
                    break;
                case exports.HorizontalAlignment.Right:
                    this.settings.horizontalDirection = exports.HorizontalAlignment.Left;
                    break;
            }
            switch (this.settings.horizontalStartPoint) {
                case exports.HorizontalAlignment.Left:
                    this.settings.horizontalStartPoint = exports.HorizontalAlignment.Right;
                    break;
                case exports.HorizontalAlignment.Right:
                    this.settings.horizontalStartPoint = exports.HorizontalAlignment.Left;
                    break;
            }
        };
        /**
         * Flips direction and start point of the position settings
         */
        AutoPositionStrategy.prototype.flipVertical = function () {
            switch (this.settings.verticalDirection) {
                case exports.VerticalAlignment.Top:
                    this.settings.verticalDirection = exports.VerticalAlignment.Bottom;
                    break;
                case exports.VerticalAlignment.Bottom:
                    this.settings.verticalDirection = exports.VerticalAlignment.Top;
                    break;
            }
            switch (this.settings.verticalStartPoint) {
                case exports.VerticalAlignment.Top:
                    this.settings.verticalStartPoint = exports.VerticalAlignment.Bottom;
                    break;
                case exports.VerticalAlignment.Bottom:
                    this.settings.verticalStartPoint = exports.VerticalAlignment.Top;
                    break;
            }
        };
        /**
         * Calculates necessary horizontal push according to provided connectedFit
         * @param connectedFit connectedFit object containing all necessary parameters
         * @returns amount of necessary translation which will push the element into viewport
         */
        AutoPositionStrategy.prototype.horizontalPush = function (connectedFit) {
            var leftExtend = connectedFit.left;
            var rightExtend = connectedFit.right - connectedFit.viewPortRect.right;
            //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
            //  as much as it is beyond the screen.
            //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
            //  extend but with amount not bigger than what left between left border of screen and left border of
            //  overlay, e.g. leftExtend
            if (leftExtend < 0) {
                return Math.abs(leftExtend);
            }
            else if (rightExtend > 0) {
                return -Math.min(rightExtend, leftExtend);
            }
            else {
                return 0;
            }
        };
        /**
         * Calculates necessary vertical push according to provided connectedFit
         * @param connectedFit connectedFit object containing all necessary parameters
         * @returns amount of necessary translation which will push the element into viewport
         */
        AutoPositionStrategy.prototype.verticalPush = function (connectedFit) {
            var topExtend = connectedFit.top;
            var bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.bottom;
            if (topExtend < 0) {
                return Math.abs(topExtend);
            }
            else if (bottomExtend > 0) {
                return -Math.min(bottomExtend, topExtend);
            }
            else {
                return 0;
            }
        };
        return AutoPositionStrategy;
    }(BaseFitPositionStrategy));

    /**
     * Positions the element as in **Connected** positioning strategy and resize the element
     * to fit in the view port in case the element is partially getting out of view
     */
    var ElasticPositionStrategy = /** @class */ (function (_super) {
        __extends(ElasticPositionStrategy, _super);
        function ElasticPositionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** @inheritdoc */
        ElasticPositionStrategy.prototype.fitInViewport = function (element, connectedFit) {
            element.classList.add('igx-overlay__content--elastic');
            var transformString = [];
            if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
                var maxReduction = Math.max(0, connectedFit.contentElementRect.width - this.settings.minSize.width);
                var leftExtend = Math.max(0, -connectedFit.fitHorizontal.back);
                var rightExtend = Math.max(0, -connectedFit.fitHorizontal.forward);
                var reduction = Math.min(maxReduction, leftExtend + rightExtend);
                element.style.width = connectedFit.contentElementRect.width - reduction + "px";
                //  if direction is center and element goes off the screen in left direction we should push the
                //  element to the right. Prevents left still going out of view when normally positioned
                if (this.settings.horizontalDirection === exports.HorizontalAlignment.Center) {
                    //  the amount of translation depends on whether element goes off the screen to the left,
                    //  to the right or in both directions, as well as how much it goes of the screen and finally
                    //  on the minSize. The translation should be proportional between left and right extend
                    //  taken from the reduction
                    var translation = leftExtend * reduction / (leftExtend + rightExtend);
                    if (translation > 0) {
                        transformString.push("translateX(" + translation + "px)");
                    }
                }
            }
            if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
                var maxReduction = Math.max(0, connectedFit.contentElementRect.height - this.settings.minSize.height);
                var topExtend = Math.max(0, -connectedFit.fitVertical.back);
                var bottomExtend = Math.max(0, -connectedFit.fitVertical.forward);
                var reduction = Math.min(maxReduction, topExtend + bottomExtend);
                element.style.height = connectedFit.contentElementRect.height - reduction + "px";
                //  if direction is middle and element goes off the screen in top direction we should push the
                //  element to the bottom. Prevents top still going out of view when normally positioned
                if (this.settings.verticalDirection === exports.VerticalAlignment.Middle) {
                    //  the amount of translation depends on whether element goes off the screen to the top,
                    //  to the bottom or in both directions, as well as how much it goes of the screen and finally
                    //  on the minSize. The translation should be proportional between top and bottom extend
                    //  taken from the reduction
                    var translation = topExtend * reduction / (topExtend + bottomExtend);
                    if (translation > 0) {
                        transformString.push("translateY(" + translation + "px)");
                    }
                }
            }
            element.style.transform = transformString.join(' ').trim();
        };
        return ElasticPositionStrategy;
    }(BaseFitPositionStrategy));

    /**
     * On scroll reposition the overlay content.
     */
    var AbsoluteScrollStrategy = /** @class */ (function (_super) {
        __extends(AbsoluteScrollStrategy, _super);
        function AbsoluteScrollStrategy(scrollContainer) {
            var _this = _super.call(this, scrollContainer) || this;
            _this._initialized = false;
            _this.onScroll = function (e) {
                var overlayInfo = _this._overlayService.getOverlayById(_this._id);
                if (!overlayInfo) {
                    return;
                }
                if (!overlayInfo.elementRef.nativeElement.contains(e.target)) {
                    _this._overlayService.reposition(_this._id);
                }
            };
            _this._scrollContainer = scrollContainer;
            return _this;
        }
        /** @inheritdoc */
        AbsoluteScrollStrategy.prototype.initialize = function (document, overlayService, id) {
            if (this._initialized) {
                return;
            }
            this._overlayService = overlayService;
            this._id = id;
            this._document = document;
            this._zone = overlayService.getOverlayById(id).ngZone;
            this._initialized = true;
        };
        /** @inheritdoc */
        AbsoluteScrollStrategy.prototype.attach = function () {
            var _this = this;
            if (this._zone) {
                this._zone.runOutsideAngular(function () {
                    _this.addScrollEventListener();
                });
            }
            else {
                this.addScrollEventListener();
            }
        };
        /** @inheritdoc */
        AbsoluteScrollStrategy.prototype.detach = function () {
            if (this._scrollContainer) {
                this._scrollContainer.removeEventListener('scroll', this.onScroll, true);
            }
            else {
                this._document.removeEventListener('scroll', this.onScroll, true);
            }
            this._initialized = false;
        };
        AbsoluteScrollStrategy.prototype.addScrollEventListener = function () {
            if (this._scrollContainer) {
                this._scrollContainer.addEventListener('scroll', this.onScroll, true);
            }
            else {
                this._document.addEventListener('scroll', this.onScroll, true);
            }
        };
        return AbsoluteScrollStrategy;
    }(ScrollStrategy));

    /**
     * Prevents scrolling while the overlay content is shown.
     */
    var BlockScrollStrategy = /** @class */ (function (_super) {
        __extends(BlockScrollStrategy, _super);
        function BlockScrollStrategy(scrollContainer) {
            var _this = _super.call(this, scrollContainer) || this;
            _this._initialized = false;
            _this.onScroll = function (ev) {
                ev.preventDefault();
                if (!_this._sourceElement || _this._sourceElement !== ev.target) {
                    _this._sourceElement = ev.target;
                    _this._initialScrollTop = _this._sourceElement.scrollTop;
                    _this._initialScrollLeft = _this._sourceElement.scrollLeft;
                }
                _this._sourceElement.scrollTop = _this._initialScrollTop;
                _this._sourceElement.scrollLeft = _this._initialScrollLeft;
            };
            return _this;
        }
        /** @inheritdoc */
        BlockScrollStrategy.prototype.initialize = function (document, overlayService, id) {
            if (this._initialized) {
                return;
            }
            this._document = document;
            this._initialized = true;
        };
        /** @inheritdoc */
        BlockScrollStrategy.prototype.attach = function () {
            this._document.addEventListener('scroll', this.onScroll, true);
        };
        /** @inheritdoc */
        BlockScrollStrategy.prototype.detach = function () {
            this._document.removeEventListener('scroll', this.onScroll, true);
            this._sourceElement = null;
            this._initialScrollTop = 0;
            this._initialScrollLeft = 0;
            this._initialized = false;
        };
        return BlockScrollStrategy;
    }(ScrollStrategy));

    /**
     * Uses a tolerance and closes the shown component upon scrolling if the tolerance is exceeded
     */
    var CloseScrollStrategy = /** @class */ (function (_super) {
        __extends(CloseScrollStrategy, _super);
        function CloseScrollStrategy(scrollContainer) {
            var _this = _super.call(this, scrollContainer) || this;
            _this._initialized = false;
            _this.onScroll = function (ev) {
                if (!_this._sourceElement) {
                    return;
                }
                _this.cumulativeScrollTop += _this._sourceElement.scrollTop;
                _this.cumulativeScrollLeft += _this._sourceElement.scrollLeft;
                if (Math.abs(_this.cumulativeScrollTop - _this.initialScrollTop) > _this._threshold ||
                    Math.abs(_this.cumulativeScrollLeft - _this.initialScrollLeft) > _this._threshold) {
                    _this._document.removeEventListener('scroll', _this.onScroll, true);
                    _this._overlayService.hide(_this._id);
                }
            };
            _this._scrollContainer = scrollContainer;
            _this._threshold = 10;
            _this.cumulativeScrollTop = 0;
            _this.cumulativeScrollLeft = 0;
            return _this;
        }
        /** @inheritdoc */
        CloseScrollStrategy.prototype.initialize = function (document, overlayService, id) {
            if (this._initialized) {
                return;
            }
            this._overlayService = overlayService;
            this._id = id;
            this._document = document;
            this._initialized = true;
        };
        /** @inheritdoc */
        CloseScrollStrategy.prototype.attach = function () {
            if (this._scrollContainer) {
                this._scrollContainer.addEventListener('scroll', this.onScroll);
                this._sourceElement = this._scrollContainer;
            }
            else {
                this._document.addEventListener('scroll', this.onScroll);
                if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
                    this._sourceElement = document.documentElement;
                }
                else if (document.body.scrollHeight > document.body.clientHeight) {
                    this._sourceElement = document.body;
                }
            }
            if (!this._sourceElement) {
                return;
            }
            this.cumulativeScrollTop = 0;
            this.cumulativeScrollLeft = 0;
            this.initialScrollTop = this._sourceElement.scrollTop;
            this.initialScrollLeft = this._sourceElement.scrollLeft;
        };
        /** @inheritdoc */
        CloseScrollStrategy.prototype.detach = function () {
            // TODO: check why event listener removes only on first call and remains on each next!!!
            if (this._scrollContainer) {
                this._scrollContainer.removeEventListener('scroll', this.onScroll);
            }
            else {
                this._document.removeEventListener('scroll', this.onScroll);
            }
            this._sourceElement = null;
            this.cumulativeScrollTop = 0;
            this.cumulativeScrollLeft = 0;
            this.initialScrollTop = 0;
            this.initialScrollLeft = 0;
            this._initialized = false;
        };
        return CloseScrollStrategy;
    }(ScrollStrategy));

    // Export scroll strategies

    var IgxBaseTransactionService = /** @class */ (function () {
        function IgxBaseTransactionService() {
            this._isPending = false;
            this._pendingTransactions = [];
            this._pendingStates = new Map();
            /**
             * @inheritdoc
             */
            this.onStateUpdate = new core.EventEmitter();
        }
        Object.defineProperty(IgxBaseTransactionService.prototype, "canRedo", {
            /**
             * @inheritdoc
             */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxBaseTransactionService.prototype, "canUndo", {
            /**
             * @inheritdoc
             */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxBaseTransactionService.prototype, "enabled", {
            /**
             * @inheritdoc
             */
            get: function () {
                return this._isPending;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.add = function (transaction, recordRef) {
            if (this._isPending) {
                this.updateState(this._pendingStates, transaction, recordRef);
                this._pendingTransactions.push(transaction);
            }
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.getTransactionLog = function (id) { return []; };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.undo = function () { };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.redo = function () { };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.getAggregatedChanges = function (mergeChanges) {
            var _this = this;
            var result = [];
            this._pendingStates.forEach(function (state, key) {
                var value = mergeChanges ? _this.getAggregatedValue(key, mergeChanges) : state.value;
                result.push({ id: key, newValue: value, type: state.type });
            });
            return result;
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.getState = function (id) {
            return this._pendingStates.get(id);
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.getAggregatedValue = function (id, mergeChanges) {
            var state = this._pendingStates.get(id);
            if (!state) {
                return null;
            }
            if (mergeChanges) {
                return this.updateValue(state);
            }
            return state.value;
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.commit = function (data, id) { };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.clear = function (id) {
            this._pendingStates.clear();
            this._pendingTransactions = [];
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.startPending = function () {
            this._isPending = true;
        };
        /**
         * @inheritdoc
         */
        IgxBaseTransactionService.prototype.endPending = function (commit) {
            this._isPending = false;
            this._pendingStates.clear();
            this._pendingTransactions = [];
        };
        /**
         * Updates the provided states collection according to passed transaction and recordRef
         * @param states States collection to apply the update to
         * @param transaction Transaction to apply to the current state
         * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
         */
        IgxBaseTransactionService.prototype.updateState = function (states, transaction, recordRef) {
            var state = states.get(transaction.id);
            if (state) {
                if (isObject(state.value)) {
                    mergeObjects(state.value, transaction.newValue);
                }
                else {
                    state.value = transaction.newValue;
                }
            }
            else {
                state = { value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type };
                states.set(transaction.id, state);
            }
        };
        /**
         * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
         * @param state State to update value for
         * @returns updated value including all the changes in provided state
         */
        IgxBaseTransactionService.prototype.updateValue = function (state) {
            return this.mergeValues(state.recordRef, state.value);
        };
        /**
         * Merges second values in first value and the result in empty object. If values are primitive type
         * returns second value if exists, or first value.
         * @param first Value to merge into
         * @param second Value to merge
         */
        IgxBaseTransactionService.prototype.mergeValues = function (first, second) {
            var result;
            if (isObject(first) || isObject(second)) {
                result = mergeObjects(mergeObjects({}, first), second);
            }
            else {
                result = second ? second : first;
            }
            return result;
        };
        IgxBaseTransactionService = __decorate([
            core.Injectable()
        ], IgxBaseTransactionService);
        return IgxBaseTransactionService;
    }());

    var IgxTransactionService = /** @class */ (function (_super) {
        __extends(IgxTransactionService, _super);
        function IgxTransactionService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._transactions = [];
            _this._redoStack = [];
            _this._undoStack = [];
            _this._states = new Map();
            /**
             * @inheritdoc
             */
            _this.onStateUpdate = new core.EventEmitter();
            return _this;
        }
        Object.defineProperty(IgxTransactionService.prototype, "canUndo", {
            /**
             * @inheritdoc
             */
            get: function () {
                return this._undoStack.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTransactionService.prototype, "canRedo", {
            /**
             * @inheritdoc
             */
            get: function () {
                return this._redoStack.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.add = function (transaction, recordRef) {
            var states = this._isPending ? this._pendingStates : this._states;
            this.verifyAddedTransaction(states, transaction, recordRef);
            this.addTransaction(transaction, states, recordRef);
        };
        IgxTransactionService.prototype.addTransaction = function (transaction, states, recordRef) {
            this.updateState(states, transaction, recordRef);
            var transactions = this._isPending ? this._pendingTransactions : this._transactions;
            transactions.push(transaction);
            if (!this._isPending) {
                this._undoStack.push([{ transaction: transaction, recordRef: recordRef }]);
                this._redoStack = [];
                this.onStateUpdate.emit();
            }
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.getTransactionLog = function (id) {
            if (id !== undefined) {
                return this._transactions.filter(function (t) { return t.id === id; });
            }
            return __spread(this._transactions);
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.getAggregatedChanges = function (mergeChanges) {
            var _this = this;
            var result = [];
            this._states.forEach(function (state, key) {
                var value = mergeChanges ? _this.mergeValues(state.recordRef, state.value) : state.value;
                result.push({ id: key, newValue: value, type: state.type });
            });
            return result;
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.getState = function (id, pending) {
            if (pending === void 0) { pending = false; }
            return pending ? this._pendingStates.get(id) : this._states.get(id);
        };
        Object.defineProperty(IgxTransactionService.prototype, "enabled", {
            /**
             * @inheritdoc
             */
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.getAggregatedValue = function (id, mergeChanges) {
            var state = this._states.get(id);
            var pendingState = _super.prototype.getState.call(this, id);
            //  if there is no state and there is no pending state return null
            if (!state && !pendingState) {
                return null;
            }
            var pendingChange = _super.prototype.getAggregatedValue.call(this, id, false);
            var change = state && state.value;
            var aggregatedValue = this.mergeValues(change, pendingChange);
            if (mergeChanges) {
                var originalValue = state ? state.recordRef : pendingState.recordRef;
                aggregatedValue = this.mergeValues(originalValue, aggregatedValue);
            }
            return aggregatedValue;
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.endPending = function (commit) {
            var e_1, _a;
            this._isPending = false;
            if (commit) {
                var actions = [];
                try {
                    // don't use addTransaction due to custom undo handling
                    for (var _b = __values(this._pendingTransactions), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var transaction = _c.value;
                        var pendingState = this._pendingStates.get(transaction.id);
                        this._transactions.push(transaction);
                        this.updateState(this._states, transaction, pendingState.recordRef);
                        actions.push({ transaction: transaction, recordRef: pendingState.recordRef });
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                this._undoStack.push(actions);
                this._redoStack = [];
                this.onStateUpdate.emit();
            }
            _super.prototype.endPending.call(this, commit);
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.commit = function (data, id) {
            var _this = this;
            if (id !== undefined) {
                var state = this.getState(id);
                if (state) {
                    this.updateRecord(data, state);
                }
            }
            else {
                this._states.forEach(function (s) {
                    _this.updateRecord(data, s);
                });
            }
            this.clear(id);
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.clear = function (id) {
            if (id !== undefined) {
                this._transactions = this._transactions.filter(function (t) { return t.id !== id; });
                this._states.delete(id);
                //  Undo stack is an array of actions. Each action is array of transaction like objects
                //  We are going trough all the actions. For each action we are filtering out transactions
                //  with provided id. Finally if any action ends up as empty array we are removing it from
                //  undo stack
                this._undoStack = this._undoStack.map(function (a) { return a.filter(function (t) { return t.transaction.id !== id; }); }).filter(function (a) { return a.length > 0; });
            }
            else {
                this._transactions = [];
                this._states.clear();
                this._undoStack = [];
            }
            this._redoStack = [];
            this.onStateUpdate.emit();
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.undo = function () {
            var e_2, _a, e_3, _b;
            if (this._undoStack.length <= 0) {
                return;
            }
            var lastActions = this._undoStack.pop();
            this._transactions.splice(this._transactions.length - lastActions.length);
            this._redoStack.push(lastActions);
            this._states.clear();
            try {
                for (var _c = __values(this._undoStack), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var currentActions = _d.value;
                    try {
                        for (var currentActions_1 = (e_3 = void 0, __values(currentActions)), currentActions_1_1 = currentActions_1.next(); !currentActions_1_1.done; currentActions_1_1 = currentActions_1.next()) {
                            var transaction = currentActions_1_1.value;
                            this.updateState(this._states, transaction.transaction, transaction.recordRef);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (currentActions_1_1 && !currentActions_1_1.done && (_b = currentActions_1.return)) _b.call(currentActions_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.onStateUpdate.emit();
        };
        /**
         * @inheritdoc
         */
        IgxTransactionService.prototype.redo = function () {
            var e_4, _a;
            if (this._redoStack.length > 0) {
                var actions = void 0;
                actions = this._redoStack.pop();
                try {
                    for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                        var action = actions_1_1.value;
                        this.updateState(this._states, action.transaction, action.recordRef);
                        this._transactions.push(action.transaction);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                this._undoStack.push(actions);
                this.onStateUpdate.emit();
            }
        };
        /**
         * Verifies if the passed transaction is correct. If not throws an exception.
         * @param transaction Transaction to be verified
         */
        IgxTransactionService.prototype.verifyAddedTransaction = function (states, transaction, recordRef) {
            var state = states.get(transaction.id);
            switch (transaction.type) {
                case exports.TransactionType.ADD:
                    if (state) {
                        //  cannot add same item twice
                        throw new Error("Cannot add this transaction. Transaction with id: " + transaction.id + " has been already added.");
                    }
                    break;
                case exports.TransactionType.DELETE:
                case exports.TransactionType.UPDATE:
                    if (state && state.type === exports.TransactionType.DELETE) {
                        //  cannot delete or update deleted items
                        throw new Error("Cannot add this transaction. Transaction with id: " + transaction.id + " has been already deleted.");
                    }
                    if (!state && !recordRef && !this._isPending) {
                        //  cannot initially add transaction or delete item with no recordRef
                        throw new Error("Cannot add this transaction. This is first transaction of type " + transaction.type + " " +
                            ("for id " + transaction.id + ". For first transaction of this type recordRef is mandatory."));
                    }
                    break;
            }
        };
        /**
         * Updates the provided states collection according to passed transaction and recordRef
         * @param states States collection to apply the update to
         * @param transaction Transaction to apply to the current state
         * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
         */
        IgxTransactionService.prototype.updateState = function (states, transaction, recordRef) {
            var state = states.get(transaction.id);
            //  if TransactionType is ADD simply add transaction to states;
            //  if TransactionType is DELETE:
            //    - if there is state with this id of type ADD remove it from the states;
            //    - if there is state with this id of type UPDATE change its type to DELETE;
            //    - if there is no state with this id add transaction to states;
            //  if TransactionType is UPDATE:
            //    - if there is state with this id of type ADD merge new value and state recordRef into state new value
            //    - if there is state with this id of type UPDATE merge new value into state new value
            //    - if there is state with this id and state type is DELETE change its type to UPDATE
            //    - if there is no state with this id add transaction to states;
            if (state) {
                switch (transaction.type) {
                    case exports.TransactionType.DELETE:
                        if (state.type === exports.TransactionType.ADD) {
                            states.delete(transaction.id);
                        }
                        else if (state.type === exports.TransactionType.UPDATE) {
                            state.value = transaction.newValue;
                            state.type = exports.TransactionType.DELETE;
                        }
                        break;
                    case exports.TransactionType.UPDATE:
                        if (isObject(state.value)) {
                            if (state.type === exports.TransactionType.ADD) {
                                state.value = this.mergeValues(state.value, transaction.newValue);
                            }
                            if (state.type === exports.TransactionType.UPDATE) {
                                mergeObjects(state.value, transaction.newValue);
                            }
                        }
                        else {
                            state.value = transaction.newValue;
                        }
                }
            }
            else {
                state = { value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type };
                states.set(transaction.id, state);
            }
            //  should not clean pending state. This will happen automatically on endPending call
            if (!this._isPending) {
                this.cleanState(transaction.id, states);
            }
        };
        /**
         * Compares the state with recordRef and clears all duplicated values. If any state ends as
         * empty object removes it from states.
         * @param state State to clean
         */
        IgxTransactionService.prototype.cleanState = function (id, states) {
            var e_5, _a;
            var state = states.get(id);
            //  do nothing if
            //  there is no state, or
            //  there is no state value (e.g. DELETED transaction), or
            //  there is no recordRef (e.g. ADDED transaction)
            if (state && state.value && state.recordRef) {
                //  if state's value is object compare each key with the ones in recordRef
                //  if values in any key are the same delete it from state's value
                //  if state's value is not object, simply compare with recordRef and remove
                //  the state if they are equal
                if (isObject(state.recordRef)) {
                    try {
                        for (var _b = __values(Object.keys(state.value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var key = _c.value;
                            if (JSON.stringify(state.recordRef[key]) === JSON.stringify(state.value[key])) {
                                delete state.value[key];
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    //  if state's value is empty remove the state from the states, only if state is not DELETE type
                    if (state.type !== exports.TransactionType.DELETE && Object.keys(state.value).length === 0) {
                        states.delete(id);
                    }
                }
                else {
                    if (state.recordRef === state.value) {
                        states.delete(id);
                    }
                }
            }
        };
        /**
         * Updates state related record in the provided data
         * @param data Data source to update
         * @param state State to update data from
         */
        IgxTransactionService.prototype.updateRecord = function (data, state) {
            var index = data.findIndex(function (i) { return JSON.stringify(i) === JSON.stringify(state.recordRef || {}); });
            switch (state.type) {
                case exports.TransactionType.ADD:
                    data.push(state.value);
                    break;
                case exports.TransactionType.DELETE:
                    if (0 <= index && index < data.length) {
                        data.splice(index, 1);
                    }
                    break;
                case exports.TransactionType.UPDATE:
                    if (0 <= index && index < data.length) {
                        data[index] = this.updateValue(state);
                    }
                    break;
            }
        };
        IgxTransactionService = __decorate([
            core.Injectable()
        ], IgxTransactionService);
        return IgxTransactionService;
    }(IgxBaseTransactionService));

    /** @experimental @hidden */
    var IgxHierarchicalTransactionService = /** @class */ (function (_super) {
        __extends(IgxHierarchicalTransactionService, _super);
        function IgxHierarchicalTransactionService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxHierarchicalTransactionService.prototype.getAggregatedChanges = function (mergeChanges) {
            var _this = this;
            var result = [];
            this._states.forEach(function (state, key) {
                var value = mergeChanges ? _this.mergeValues(state.recordRef, state.value) : cloneValue(state.value);
                _this.clearArraysFromObject(value);
                result.push({ id: key, path: state.path, newValue: value, type: state.type });
            });
            return result;
        };
        IgxHierarchicalTransactionService.prototype.updateState = function (states, transaction, recordRef) {
            _super.prototype.updateState.call(this, states, transaction, recordRef);
            //  if transaction has no path, e.g. flat data source, get out
            if (!transaction.path) {
                return;
            }
            var currentState = states.get(transaction.id);
            if (currentState) {
                currentState.path = transaction.path;
            }
            //  if transaction has path, Hierarchical data source, and it is DELETE
            //  type transaction for all child rows remove ADD states and update
            //  transaction type and value of UPDATE states
            if (transaction.type === exports.TransactionType.DELETE) {
                states.forEach(function (v, k) {
                    if (v.path && v.path.indexOf(transaction.id) !== -1) {
                        switch (v.type) {
                            case exports.TransactionType.ADD:
                                states.delete(k);
                                break;
                            case exports.TransactionType.UPDATE:
                                states.get(k).type = exports.TransactionType.DELETE;
                                states.get(k).value = null;
                        }
                    }
                });
            }
        };
        /**
         * Applies all transactions over the provided data
         * @param data Data source to update
         * @param primaryKey Primary key of the hierarchical data
         * @param childDataKey Kye of child data collection
         * @param id Optional record id to commit transactions for
         */
        IgxHierarchicalTransactionService.prototype.commit = function (data, primaryKey, childDataKey, id) {
            if (childDataKey !== undefined) {
                var transactions = this.getAggregatedChanges(true);
                if (id !== undefined) {
                    transactions = transactions.filter(function (t) { return t.id === id; });
                }
                DataUtil.mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, true);
            }
            else {
                _super.prototype.commit.call(this, data, id);
            }
            this.clear(id);
        };
        //  TODO: remove this method. Force cloning to strip child arrays when needed instead
        IgxHierarchicalTransactionService.prototype.clearArraysFromObject = function (obj) {
            var e_1, _a;
            if (obj) {
                try {
                    for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var prop = _c.value;
                        if (Array.isArray(obj[prop])) {
                            delete obj[prop];
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        };
        IgxHierarchicalTransactionService = __decorate([
            core.Injectable()
        ], IgxHierarchicalTransactionService);
        return IgxHierarchicalTransactionService;
    }(IgxTransactionService));

    // Export services

    var IgxToggleDirective = /** @class */ (function () {
        /**
         * @hidden
         */
        function IgxToggleDirective(elementRef, cdr, overlayService, navigationService) {
            var _this = this;
            this.elementRef = elementRef;
            this.cdr = cdr;
            this.overlayService = overlayService;
            this.navigationService = navigationService;
            this.destroy$ = new rxjs.Subject();
            this._overlaySubFilter = [
                operators.filter(function (x) { return x.id === _this._overlayId; }),
                operators.takeUntil(this.destroy$)
            ];
            /**
             * Emits an event after the toggle container is opened.
             *
             * ```typescript
             * onToggleOpened(event) {
             *    alert("Toggle opened!");
             * }
             * ```
             *
             * ```html
             * <div
             *   igxToggle
             *   (onOpened)='onToggleOpened($event)'>
             * </div>
             * ```
             */
            this.onOpened = new core.EventEmitter();
            /**
             * Emits an event before the toggle container is opened.
             *
             * ```typescript
             * onToggleOpening(event) {
             *  alert("Toggle opening!");
             * }
             * ```
             *
             * ```html
             * <div
             *   igxToggle
             *   (onOpening)='onToggleOpening($event)'>
             * </div>
             * ```
             */
            this.onOpening = new core.EventEmitter();
            /**
             * Emits an event after the toggle container is closed.
             *
             * ```typescript
             * onToggleClosed(event) {
             *  alert("Toggle closed!");
             * }
             * ```
             *
             * ```html
             * <div
             *   igxToggle
             *   (onClosed)='onToggleClosed($event)'>
             * </div>
             * ```
             */
            this.onClosed = new core.EventEmitter();
            /**
             * Emits an event before the toggle container is closed.
             *
             * ```typescript
             * onToggleClosing(event) {
             *  alert("Toggle closing!");
             * }
             * ```
             *
             * ```html
             * <div
             *  igxToggle
             *  (onClosing)='onToggleClosing($event)'>
             * </div>
             * ```
             */
            this.onClosing = new core.EventEmitter();
            this._collapsed = true;
            /**
             * Emits an event after the toggle element is appended to the overlay container.
             *
             * ```typescript
             * onAppended() {
             *  alert("Content appended!");
             * }
             * ```
             *
             * ```html
             * <div
             *   igxToggle
             *   (onAppended)='onToggleAppended()'>
             * </div>
             * ```
             */
            this.onAppended = new core.EventEmitter();
            this.overlayClosed = function () {
                _this._collapsed = true;
                _this.cdr.detectChanges();
                delete _this._overlayId;
                _this.unsubscribe();
                _this.onClosed.emit();
            };
        }
        Object.defineProperty(IgxToggleDirective.prototype, "collapsed", {
            /**
             * @hidden
             */
            get: function () {
                return this._collapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxToggleDirective.prototype, "element", {
            /**
             * @hidden
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxToggleDirective.prototype, "hiddenClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxToggleDirective.prototype, "defaultClass", {
            /**
             * @hidden
             */
            get: function () {
                return !this.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Opens the toggle.
         *
         * ```typescript
         * this.myToggle.open();
         * ```
         */
        IgxToggleDirective.prototype.open = function (overlaySettings) {
            var _a, _b, _c, _d;
            var _this = this;
            //  if there is open animation do nothing
            //  if toggle is not collapsed and there is no close animation do nothing
            var info = this.overlayService.getOverlayById(this._overlayId);
            var hasOpenAnimation = info ? info.openAnimationPlayer : false;
            var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
            if (hasOpenAnimation || !(this._collapsed || hasCloseAnimation)) {
                return;
            }
            if (!info) {
                this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
            }
            this._collapsed = false;
            this.cdr.detectChanges();
            var openEventArgs = { cancel: false };
            this.onOpening.emit(openEventArgs);
            if (openEventArgs.cancel) {
                this._collapsed = true;
                this.cdr.detectChanges();
                return;
            }
            this.unsubscribe();
            this._overlayAppendedSub = (_a = this.overlayService.onAppended).pipe.apply(_a, __spread(this._overlaySubFilter)).subscribe(function () {
                _this.onAppended.emit();
            });
            this._overlayOpenedSub = (_b = this.overlayService.onOpened).pipe.apply(_b, __spread(this._overlaySubFilter)).subscribe(function () {
                _this.onOpened.emit();
            });
            this._overlayClosingSub = (_c = this.overlayService
                .onClosing).pipe.apply(_c, __spread(this._overlaySubFilter)).subscribe(function (e) {
                var eventArgs = { cancel: false, event: e.event };
                _this.onClosing.emit(eventArgs);
                e.cancel = eventArgs.cancel;
                //  in case event is not canceled this will close the toggle and we need to unsubscribe.
                //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
                //  onClosed was fired we will end with calling onClosing more than once
                if (!e.cancel) {
                    _this.clearSubscription(_this._overlayClosingSub);
                }
            });
            this._overlayClosedSub = (_d = this.overlayService.onClosed).pipe.apply(_d, __spread(this._overlaySubFilter)).subscribe(this.overlayClosed);
            this.overlayService.show(this._overlayId, overlaySettings);
        };
        /**
         * Closes the toggle.
         *
         * ```typescript
         * this.myToggle.close();
         * ```
         */
        IgxToggleDirective.prototype.close = function () {
            //  if toggle is collapsed do nothing
            //  if there is close animation do nothing, toggle will close anyway
            var info = this.overlayService.getOverlayById(this._overlayId);
            var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
            if (this._collapsed || hasCloseAnimation) {
                return;
            }
            this.overlayService.hide(this._overlayId);
        };
        /**
         * Opens or closes the toggle, depending on its current state.
         *
         * ```typescript
         * this.myToggle.toggle();
         * ```
         */
        IgxToggleDirective.prototype.toggle = function (overlaySettings) {
            //  if toggle is collapsed call open
            //  if there is close animation call open
            if (this.collapsed || this.isClosing) {
                this.open(overlaySettings);
            }
            else {
                this.close();
            }
        };
        Object.defineProperty(IgxToggleDirective.prototype, "isClosing", {
            /** @hidden @internal */
            get: function () {
                var info = this.overlayService.getOverlayById(this._overlayId);
                return info ? info.closeAnimationPlayer : false;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Repositions the toggle.
         * ```typescript
         * this.myToggle.reposition();
         * ```
         */
        IgxToggleDirective.prototype.reposition = function () {
            this.overlayService.reposition(this._overlayId);
        };
        /**
         * Offsets the content along the corresponding axis by the provided amount
         */
        IgxToggleDirective.prototype.setOffset = function (deltaX, deltaY) {
            this.overlayService.setOffset(this._overlayId, deltaX, deltaY);
        };
        /**
         * @hidden
         */
        IgxToggleDirective.prototype.ngOnInit = function () {
            if (this.navigationService && this.id) {
                this.navigationService.add(this.id, this);
            }
        };
        /**
         * @hidden
         */
        IgxToggleDirective.prototype.ngOnDestroy = function () {
            if (this.navigationService && this.id) {
                this.navigationService.remove(this.id);
            }
            if (!this.collapsed && this._overlayId) {
                this.overlayService.hide(this._overlayId);
            }
            this.unsubscribe();
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        IgxToggleDirective.prototype.unsubscribe = function () {
            this.clearSubscription(this._overlayOpenedSub);
            this.clearSubscription(this._overlayClosingSub);
            this.clearSubscription(this._overlayClosedSub);
            this.clearSubscription(this._overlayAppendedSub);
        };
        IgxToggleDirective.prototype.clearSubscription = function (subscription) {
            if (subscription && !subscription.closed) {
                subscription.unsubscribe();
            }
        };
        IgxToggleDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: IgxOverlayService, decorators: [{ type: core.Inject, args: [IgxOverlayService,] }] },
            { type: IgxNavigationService, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Output()
        ], IgxToggleDirective.prototype, "onOpened", void 0);
        __decorate([
            core.Output()
        ], IgxToggleDirective.prototype, "onOpening", void 0);
        __decorate([
            core.Output()
        ], IgxToggleDirective.prototype, "onClosed", void 0);
        __decorate([
            core.Output()
        ], IgxToggleDirective.prototype, "onClosing", void 0);
        __decorate([
            core.Input()
        ], IgxToggleDirective.prototype, "id", void 0);
        __decorate([
            core.HostBinding('class.igx-toggle--hidden'),
            core.HostBinding('attr.aria-hidden')
        ], IgxToggleDirective.prototype, "hiddenClass", null);
        __decorate([
            core.HostBinding('class.igx-toggle')
        ], IgxToggleDirective.prototype, "defaultClass", null);
        __decorate([
            core.Output()
        ], IgxToggleDirective.prototype, "onAppended", void 0);
        IgxToggleDirective = __decorate([
            core.Directive({
                exportAs: 'toggle',
                selector: '[igxToggle]'
            }),
            __param(2, core.Inject(IgxOverlayService)),
            __param(3, core.Optional())
        ], IgxToggleDirective);
        return IgxToggleDirective;
    }());
    var IgxToggleActionDirective = /** @class */ (function () {
        function IgxToggleActionDirective(element, navigationService) {
            this.element = element;
            this.navigationService = navigationService;
        }
        Object.defineProperty(IgxToggleActionDirective.prototype, "target", {
            /**
             * @hidden
             */
            get: function () {
                if (typeof this._target === 'string') {
                    return this.navigationService.get(this._target);
                }
                return this._target;
            },
            /**
             * @hidden
             */
            set: function (target) {
                if (target !== null && target !== '') {
                    this._target = target;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxToggleActionDirective.prototype.ngOnInit = function () {
            this._overlayDefaults = {
                positionStrategy: new ConnectedPositioningStrategy({ target: this.element.nativeElement }),
                scrollStrategy: new AbsoluteScrollStrategy(),
                closeOnOutsideClick: true,
                modal: false,
                excludePositionTarget: true
            };
        };
        /**
         * @hidden
         */
        IgxToggleActionDirective.prototype.onClick = function () {
            if (this.outlet) {
                this._overlayDefaults.outlet = this.outlet;
            }
            var clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
            this.updateOverlaySettings(clonedSettings);
            this.target.toggle(clonedSettings);
        };
        /**
         * Updates provided overlay settings
         * @param settings settings to update
         * @returns returns updated copy of provided overlay settings
         */
        IgxToggleActionDirective.prototype.updateOverlaySettings = function (settings) {
            if (settings && settings.positionStrategy) {
                var positionStrategyClone = settings.positionStrategy.clone();
                positionStrategyClone.settings.target = this.element.nativeElement;
                settings.positionStrategy = positionStrategyClone;
            }
            return settings;
        };
        IgxToggleActionDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: IgxNavigationService, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input()
        ], IgxToggleActionDirective.prototype, "overlaySettings", void 0);
        __decorate([
            core.Input('igxToggleOutlet')
        ], IgxToggleActionDirective.prototype, "outlet", void 0);
        __decorate([
            core.Input('igxToggleAction')
        ], IgxToggleActionDirective.prototype, "target", null);
        __decorate([
            core.HostListener('click')
        ], IgxToggleActionDirective.prototype, "onClick", null);
        IgxToggleActionDirective = __decorate([
            core.Directive({
                exportAs: 'toggle-action',
                selector: '[igxToggleAction]'
            }),
            __param(1, core.Optional())
        ], IgxToggleActionDirective);
        return IgxToggleActionDirective;
    }());
    /**
     * Mark an element as an igxOverlay outlet container.
     * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
     * ```html
     * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
     * ```
     */
    var IgxOverlayOutletDirective = /** @class */ (function () {
        function IgxOverlayOutletDirective(element) {
            this.element = element;
        }
        Object.defineProperty(IgxOverlayOutletDirective.prototype, "nativeElement", {
            /** @hidden */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        IgxOverlayOutletDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        IgxOverlayOutletDirective = __decorate([
            core.Directive({
                exportAs: 'overlay-outlet',
                selector: '[igxOverlayOutlet]'
            })
        ], IgxOverlayOutletDirective);
        return IgxOverlayOutletDirective;
    }());
    /**
     * @hidden
     */
    var IgxToggleModule = /** @class */ (function () {
        function IgxToggleModule() {
        }
        IgxToggleModule = __decorate([
            core.NgModule({
                declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                providers: [IgxNavigationService]
            })
        ], IgxToggleModule);
        return IgxToggleModule;
    }());

    /** @hidden */
    var Navigate;
    (function (Navigate) {
        Navigate[Navigate["Up"] = -1] = "Up";
        Navigate[Navigate["Down"] = 1] = "Down";
    })(Navigate || (Navigate = {}));
    /** Key actions that have designated handlers in IgxDropDownComponent */
    var DropDownActionKey;
    (function (DropDownActionKey) {
        DropDownActionKey["ESCAPE"] = "escape";
        DropDownActionKey["ENTER"] = "enter";
        DropDownActionKey["SPACE"] = "space";
    })(DropDownActionKey || (DropDownActionKey = {}));
    var IGX_DROPDOWN_BASE = new core.InjectionToken('IgxDropDownBaseToken');

    /** @hidden */
    var IgxSelectionAPIService = /** @class */ (function () {
        function IgxSelectionAPIService() {
            /**
             * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
             * If the primaryKey is omitted, then selection is based on the item data
             */
            this.selection = new Map();
        }
        /**
         * Get current component selection.
         * @param componentID ID of the component.
         */
        IgxSelectionAPIService.prototype.get = function (componentID) {
            return this.selection.get(componentID);
        };
        /**
         * Set new component selection.
         * @param componentID ID of the component.
         * @param newSelection The new component selection to be set.
         */
        IgxSelectionAPIService.prototype.set = function (componentID, newSelection) {
            if (!componentID) {
                throw Error('Invalid value for component id!');
            }
            this.selection.set(componentID, newSelection);
        };
        /**
         * Clears selection for component.
         * @param componentID ID of the component.
         */
        IgxSelectionAPIService.prototype.clear = function (componentID) {
            this.selection.set(componentID, this.get_empty());
        };
        /**
         * Get current component selection length.
         * @param componentID ID of the component.
         */
        IgxSelectionAPIService.prototype.size = function (componentID) {
            var sel = this.get(componentID);
            return sel ? sel.size : 0;
        };
        /**
         * Creates new selection that consist of the new item added to the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the select_item() one.
         * @param componentID ID of the component, which we add new item to.
         * @param itemID ID of the item to add to component selection.
         * @param sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
         *
         * @returns Selection after the new item is added.
         */
        IgxSelectionAPIService.prototype.add_item = function (componentID, itemID, sel) {
            if (!sel) {
                sel = new Set(this.get(componentID));
            }
            if (sel === undefined) {
                sel = this.get_empty();
            }
            if (!itemID && itemID !== 0) {
                throw Error('Invalid value for item id!');
            }
            sel.add(itemID);
            return sel;
        };
        /**
         * Creates new selection that consist of the new items added to the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the select_items() one.
         * @param componentID ID of the component, which we add new items to.
         * @param itemIDs Array of IDs of the items to add to component selection.
         * @param clearSelection If true it will clear previous selection.
         *
         * @returns Selection after the new items are added.
         */
        IgxSelectionAPIService.prototype.add_items = function (componentID, itemIDs, clearSelection) {
            var _this = this;
            var selection;
            if (clearSelection) {
                selection = this.get_empty();
            }
            else if (itemIDs && itemIDs.length === 0) {
                selection = new Set(this.get(componentID));
            }
            itemIDs.forEach(function (item) { return selection = _this.add_item(componentID, item, selection); });
            return selection;
        };
        /**
         * Add item to the current component selection.
         * @param componentID ID of the component, which we add new item to.
         * @param itemID ID of the item to add to component selection.
         * @param sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
         */
        IgxSelectionAPIService.prototype.select_item = function (componentID, itemID, sel) {
            this.set(componentID, this.add_item(componentID, itemID, sel));
        };
        /**
         * Add items to the current component selection.
         * @param componentID ID of the component, which we add new items to.
         * @param itemIDs Array of IDs of the items to add to component selection.
         * @param clearSelection If true it will clear previous selection.
         */
        IgxSelectionAPIService.prototype.select_items = function (componentID, itemID, clearSelection) {
            this.set(componentID, this.add_items(componentID, itemID, clearSelection));
        };
        /**
         * Creates new selection that consist of the new items excluded from the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the deselect_item() one.
         * @param componentID ID of the component, which we remove items from.
         * @param itemID ID of the item to remove from component selection.
         * @param sel Used internally only by the selection (delete_items method) to accumulate deselected items.
         *
         * @returns Selection after the item is removed.
         */
        IgxSelectionAPIService.prototype.delete_item = function (componentID, itemID, sel) {
            if (!sel) {
                sel = new Set(this.get(componentID));
            }
            if (sel === undefined) {
                return;
            }
            sel.delete(itemID);
            return sel;
        };
        /**
         * Creates new selection that consist of the new items removed to the current component selection.
         * The returned collection is new Set,
         * therefore if you want to update component selection you need to call in addition the set_selection() method
         * or instead use the deselect_items() one.
         * @param componentID ID of the component, which we remove items from.
         * @param itemID ID of the items to remove from component selection.
         *
         * @returns Selection after the items are removed.
         */
        IgxSelectionAPIService.prototype.delete_items = function (componentID, itemIDs) {
            var _this = this;
            var selection;
            itemIDs.forEach(function (deselectedItem) { return selection = _this.delete_item(componentID, deselectedItem, selection); });
            return selection;
        };
        /**
         * Remove item from the current component selection.
         * @param componentID ID of the component, which we remove item from.
         * @param itemID ID of the item to remove from component selection.
         * @param sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
         */
        IgxSelectionAPIService.prototype.deselect_item = function (componentID, itemID, sel) {
            this.set(componentID, this.delete_item(componentID, itemID, sel));
        };
        /**
         * Remove items to the current component selection.
         * @param componentID ID of the component, which we add new items to.
         * @param itemIDs Array of IDs of the items to add to component selection.
         */
        IgxSelectionAPIService.prototype.deselect_items = function (componentID, itemID, clearSelection) {
            this.set(componentID, this.delete_items(componentID, itemID));
        };
        /**
         * Check if the item is selected in the component selection.
         * @param componentID ID of the component.
         * @param itemID ID of the item to search.
         *
         * @returns If item is selected.
         */
        IgxSelectionAPIService.prototype.is_item_selected = function (componentID, itemID) {
            var sel = this.get(componentID);
            if (!sel) {
                return false;
            }
            return sel.has(itemID);
        };
        /**
         * Get first element in the selection.
         * This is correct when we have only one item in the collection (for single selection purposes)
         * and the method returns that item.
         * @param componentID ID of the component.
         *
         * @returns First element in the set.
         */
        IgxSelectionAPIService.prototype.first_item = function (componentID) {
            var sel = this.get(componentID);
            if (sel && sel.size > 0) {
                return sel.values().next().value;
            }
        };
        /**
         * Returns whether all items are selected.
         * @param componentID ID of the component.
         * @param dataCount: number Number of items in the data.
         *
         * @returns If all items are selected.
         */
        IgxSelectionAPIService.prototype.are_all_selected = function (componentID, dataCount) {
            return dataCount > 0 && dataCount === this.size(componentID);
        };
        /**
         * Returns whether any of the items is selected.
         * @param componentID ID of the component.
         * @param data Entire data array.
         *
         * @returns If there is any item selected.
         */
        IgxSelectionAPIService.prototype.are_none_selected = function (componentID) {
            return this.size(componentID) === 0;
        };
        /**
         * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
         * @param data Entire data array.
         * @param primaryKey Data primary key.
         *
         * @returns Array of identifiers, either primary key values or the entire data array.
         */
        IgxSelectionAPIService.prototype.get_all_ids = function (data, primaryKey) {
            // If primaryKey is 0, this should still map to the property
            return primaryKey !== undefined && primaryKey !== null ? data.map(function (x) { return x[primaryKey]; }) : data;
        };
        /**
         * Returns empty selection collection.
         * @returns empty set.
        */
        IgxSelectionAPIService.prototype.get_empty = function () {
            return new Set();
        };
        IgxSelectionAPIService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function IgxSelectionAPIService_Factory() { return new IgxSelectionAPIService(); }, token: IgxSelectionAPIService, providedIn: "root" });
        IgxSelectionAPIService = __decorate([
            core.Injectable({
                providedIn: 'root',
            })
        ], IgxSelectionAPIService);
        return IgxSelectionAPIService;
    }());

    var NEXT_ID = 0;
    /**
     * The `<igx-drop-down-item>` is a container intended for row items in
     * a `<igx-drop-down>` container.
     */
    var IgxDropDownGroupComponent = /** @class */ (function () {
        function IgxDropDownGroupComponent() {
            this._id = NEXT_ID++;
            /**
             * @hidden @internal
             */
            this.role = 'group';
            /** @hidden @internal */
            this.groupClass = true;
            /**
             * Sets/gets if the item group is disabled
             *
             * ```typescript
             * const myDropDownGroup: IgxDropDownGroupComponent = this.dropdownGroup;
             * // get
             * ...
             * const groupState: boolean = myDropDownGroup.disabled;
             * ...
             * //set
             * ...
             * myDropDownGroup,disabled = false;
             * ...
             * ```
             *
             * ```html
             * <igx-drop-down-item-group [label]="'My Items'" [disabled]="true">
             *     <igx-drop-down-item *ngFor="let item of items[index]" [value]="item.value">
             *         {{ item.text }}
             *     </igx-drop-down-item>
             * </igx-drop-down-item-group>
             * ```
             *
             * **NOTE:** All items inside of a disabled drop down group will be treated as disabled
             */
            this.disabled = false;
        }
        Object.defineProperty(IgxDropDownGroupComponent.prototype, "labelId", {
            /**
             * @hidden @internal
             */
            get: function () {
                return "igx-item-group-label-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownGroupComponent.prototype, "labelledBy", {
            get: function () {
                return this.labelId;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.HostBinding("attr.aria-labelledby")
        ], IgxDropDownGroupComponent.prototype, "labelledBy", null);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxDropDownGroupComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('class.igx-drop-down__group')
        ], IgxDropDownGroupComponent.prototype, "groupClass", void 0);
        __decorate([
            core.Input(),
            core.HostBinding("attr.aria-disabled"),
            core.HostBinding('class.igx-drop-down__group--disabled')
        ], IgxDropDownGroupComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input()
        ], IgxDropDownGroupComponent.prototype, "label", void 0);
        IgxDropDownGroupComponent = __decorate([
            core.Component({
                selector: 'igx-drop-down-item-group',
                template: "\n        <label id=\"{{labelId}}\">{{ label }}</label>\n        <ng-content select=\"igx-drop-down-item\"></ng-content>\n    "
            })
        ], IgxDropDownGroupComponent);
        return IgxDropDownGroupComponent;
    }());

    var NEXT_ID$1 = 0;
    var warningShown$1 = false;
    /**
     * An abstract class defining a drop-down item:
     * With properties / styles for selection, highlight, height
     * Bindable property for passing data (`value: any`)
     * Parent component (has to be used under a parent with type `IDropDownBase`)
     * Method for handling click on Host()
     */
    var IgxDropDownItemBaseDirective = /** @class */ (function () {
        function IgxDropDownItemBaseDirective(dropDown, elementRef, group, selection) {
            this.dropDown = dropDown;
            this.elementRef = elementRef;
            this.group = group;
            this.selection = selection;
            /**
             * @hidden
             */
            this._focused = false;
            this._selected = false;
            this._index = null;
            this._disabled = false;
            /**
             * Sets/gets the `id` of the item.
             * ```html
             * <igx-drop-down-item [id] = 'igx-drop-down-item-0'></igx-drop-down-item>
             * ```
             * ```typescript
             * let itemId =  this.item.id;
             * ```
             * @memberof IgxSelectItemComponent
             */
            this.id = "igx-drop-down-item-" + NEXT_ID$1++;
            /**
             *@hidden
             */
            this.selectedChange = new core.EventEmitter();
            /**
             * Gets/sets the `role` attribute of the item. Default is 'option'.
             *
             * ```html
             *  <igx-drop-down-item [role]="customRole"></igx-drop-down-item>
             * ```
             */
            this.role = 'option';
        }
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "hasIndex", {
            get: function () {
                return this._index !== null && this._index !== undefined;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "itemID", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "index", {
            /**
             * The data index of the dropdown item.
             *
             * ```typescript
             * // get the data index of the selected dropdown item
             * let selectedItemIndex = this.dropdown.selectedItem.index
             * ```
             */
            get: function () {
                if (this._index === null) {
                    warningShown$1 = showMessage('IgxDropDownItemBaseDirective: Automatic index is deprecated.' +
                        'Bind in the template instead using `<igx-drop-down-item [index]="i"` instead.`', warningShown$1);
                    return this.itemIndex;
                }
                return this._index;
            },
            set: function (value) {
                this._index = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "itemStyle", {
            /**
             * @hidden @internal
             */
            get: function () {
                return !this.isHeader;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "itemStyleCosy", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.dropDown.displayDensity === 'cosy' && !this.isHeader;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "itemStyleCompact", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.dropDown.displayDensity === 'compact' && !this.isHeader;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "selected", {
            /**
             * Sets/Gets if the item is the currently selected one in the dropdown
             *
             * ```typescript
             *  let mySelectedItem = this.dropdown.selectedItem;
             *  let isMyItemSelected = mySelectedItem.selected; // true
             * ```
             *
             * Two-way data binding
             * ```html
             * <igx-drop-down-item [(selected)]='model.isSelected'></igx-drop-down-item>
             * ```
             */
            get: function () {
                return this._selected;
            },
            set: function (value) {
                if (this.isHeader) {
                    return;
                }
                this._selected = value;
                this.selectedChange.emit(this._selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "isSelected", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.selected;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                this.selected = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "focused", {
            /**
             * Sets/gets if the given item is focused
             * ```typescript
             *  let mySelectedItem = this.dropdown.selectedItem;
             *  let isMyItemFocused = mySelectedItem.focused;
             * ```
             */
            get: function () {
                return this.isSelectable && this._focused;
            },
            /**
             * ```html
             *  <igx-drop-down-item *ngFor="let item of items" focused={{!item.focused}}>
             *      <div>
             *          {{item.field}}
             *      </div>
             *  </igx-drop-down-item>
             * ```
             */
            set: function (value) {
                this._focused = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "isFocused", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.focused;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                this.focused = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "headerClassCosy", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.isHeader && this.dropDown.displayDensity === 'cosy';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "headerClassCompact", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.isHeader && this.dropDown.displayDensity === 'compact';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "disabled", {
            /**
             * Sets/gets if the given item is disabled
             *
             * ```typescript
             *  // get
             *  let mySelectedItem = this.dropdown.selectedItem;
             *  let myItemIsDisabled = mySelectedItem.disabled;
             * ```
             *
             * ```html
             *  <igx-drop-down-item *ngFor="let item of items" disabled={{!item.disabled}}>
             *      <div>
             *          {{item.field}}
             *      </div>
             *  </igx-drop-down-item>
             * ```
             * **NOTE:** Drop-down items inside of a disabled `IgxDropDownGroup` will always count as disabled
             */
            get: function () {
                return this.group ? this.group.disabled || this._disabled : this._disabled;
            },
            set: function (value) {
                this._disabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "itemIndex", {
            /**
             * Gets item index
             * @hidden @internal
             */
            get: function () {
                return this.dropDown.items.indexOf(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "elementHeight", {
            /**
             * Gets item element height
             * @hidden @internal
             */
            get: function () {
                return this.elementRef.nativeElement.clientHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "element", {
            /**
             * Get item html element
             * @hidden @internal
             */
            get: function () {
                return this.elementRef;
            },
            enumerable: true,
            configurable: true
        });
        IgxDropDownItemBaseDirective.prototype.ngDoCheck = function () {
            if (this._selected) {
                var dropDownSelectedItem = this.dropDown.selectedItem;
                if (!dropDownSelectedItem) {
                    this.dropDown.selectItem(this);
                }
                else if (this.hasIndex
                    ? this._index !== dropDownSelectedItem.index || this.value !== dropDownSelectedItem.value :
                    this !== dropDownSelectedItem) {
                    this.dropDown.selectItem(this);
                }
            }
        };
        Object.defineProperty(IgxDropDownItemBaseDirective.prototype, "isSelectable", {
            /** Returns true if the items is not a header or disabled  */
            get: function () {
                return !(this.disabled || this.isHeader);
            },
            enumerable: true,
            configurable: true
        });
        /** If `allowItemsFocus` is enabled, keep the browser focus on the active item */
        IgxDropDownItemBaseDirective.prototype.ensureItemFocus = function () {
            if (this.dropDown.allowItemsFocus) {
                var focusedItem = this.dropDown.items.find(function (item) { return item.focused; });
                if (!focusedItem) {
                    return;
                }
                focusedItem.element.nativeElement.focus({ preventScroll: true });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxDropDownItemBaseDirective.prototype.clicked = function (event) {
        };
        IgxDropDownItemBaseDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_DROPDOWN_BASE,] }] },
            { type: core.ElementRef },
            { type: IgxDropDownGroupComponent, decorators: [{ type: core.Optional }] },
            { type: IgxSelectionAPIService, decorators: [{ type: core.Optional }, { type: core.Inject, args: [IgxSelectionAPIService,] }] }
        ]; };
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxDropDownItemBaseDirective.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxDropDownItemBaseDirective.prototype, "index", null);
        __decorate([
            core.Input()
        ], IgxDropDownItemBaseDirective.prototype, "value", void 0);
        __decorate([
            core.HostBinding('class.igx-drop-down__item')
        ], IgxDropDownItemBaseDirective.prototype, "itemStyle", null);
        __decorate([
            core.HostBinding('class.igx-drop-down__item--cosy')
        ], IgxDropDownItemBaseDirective.prototype, "itemStyleCosy", null);
        __decorate([
            core.HostBinding('class.igx-drop-down__item--compact')
        ], IgxDropDownItemBaseDirective.prototype, "itemStyleCompact", null);
        __decorate([
            core.Input(),
            core.HostBinding('attr.aria-selected'),
            core.HostBinding('class.igx-drop-down__item--selected')
        ], IgxDropDownItemBaseDirective.prototype, "selected", null);
        __decorate([
            core.Output()
        ], IgxDropDownItemBaseDirective.prototype, "selectedChange", void 0);
        __decorate([
            core.Input(),
            DeprecateProperty("IgxDropDownItemBaseDirective `isSelected` property is deprecated.\n" +
                "Use `selected` instead.")
        ], IgxDropDownItemBaseDirective.prototype, "isSelected", null);
        __decorate([
            core.HostBinding('class.igx-drop-down__item--focused')
        ], IgxDropDownItemBaseDirective.prototype, "focused", null);
        __decorate([
            DeprecateProperty("IgxDropDownItemBaseDirective `isFocused` property is depracated.\n" +
                "Use `focused` instead.")
        ], IgxDropDownItemBaseDirective.prototype, "isFocused", null);
        __decorate([
            core.Input(),
            core.HostBinding('class.igx-drop-down__header')
        ], IgxDropDownItemBaseDirective.prototype, "isHeader", void 0);
        __decorate([
            core.HostBinding('class.igx-drop-down__header--cosy')
        ], IgxDropDownItemBaseDirective.prototype, "headerClassCosy", null);
        __decorate([
            core.HostBinding('class.igx-drop-down__header--compact')
        ], IgxDropDownItemBaseDirective.prototype, "headerClassCompact", null);
        __decorate([
            core.Input(),
            core.HostBinding('attr.aria-disabled'),
            core.HostBinding('class.igx-drop-down__item--disabled')
        ], IgxDropDownItemBaseDirective.prototype, "disabled", null);
        __decorate([
            core.Input(),
            core.HostBinding('attr.role')
        ], IgxDropDownItemBaseDirective.prototype, "role", void 0);
        __decorate([
            core.HostListener('click', ['$event'])
        ], IgxDropDownItemBaseDirective.prototype, "clicked", null);
        IgxDropDownItemBaseDirective = __decorate([
            core.Directive({
                selector: '[igxDropDownItemBase]'
            }),
            __param(0, core.Inject(IGX_DROPDOWN_BASE)),
            __param(2, core.Optional()),
            __param(3, core.Optional()), __param(3, core.Inject(IgxSelectionAPIService))
        ], IgxDropDownItemBaseDirective);
        return IgxDropDownItemBaseDirective;
    }());

    /**
     * The `<igx-drop-down-item>` is a container intended for row items in
     * a `<igx-drop-down>` container.
     */
    var IgxDropDownItemComponent = /** @class */ (function (_super) {
        __extends(IgxDropDownItemComponent, _super);
        function IgxDropDownItemComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxDropDownItemComponent.prototype, "focused", {
            /**
             * @inheritdoc
             */
            get: function () {
                var focusedState = this._focused;
                if (this.hasIndex) {
                    var focusedItem = this.selection.first_item(this.dropDown.id + "-active");
                    var focusedIndex = focusedItem ? focusedItem.index : -1;
                    focusedState = this._index === focusedIndex;
                }
                return this.isSelectable && focusedState;
            },
            /**
             * @inheritdoc
             */
            set: function (value) {
                this._focused = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemComponent.prototype, "selected", {
            /**
             * @inheritdoc
             */
            get: function () {
                if (this.hasIndex) {
                    var item = this.selection.first_item("" + this.dropDown.id);
                    return item ? item.index === this._index && item.value === this.value : false;
                }
                return this._selected;
            },
            /**
             * @inheritdoc
             */
            set: function (value) {
                if (this.isHeader) {
                    return;
                }
                this._selected = value;
                this.selectedChange.emit(this._selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownItemComponent.prototype, "setTabIndex", {
            /**
             * @hidden @internal
             */
            get: function () {
                var shouldSetTabIndex = this.dropDown.allowItemsFocus && this.isSelectable;
                if (shouldSetTabIndex) {
                    return 0;
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritdoc
         */
        IgxDropDownItemComponent.prototype.clicked = function (event) {
            if (!this.isSelectable) {
                this.ensureItemFocus();
                return;
            }
            if (this.selection) {
                this.dropDown.selectItem(this, event);
            }
        };
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxDropDownItemComponent.prototype, "setTabIndex", null);
        IgxDropDownItemComponent = __decorate([
            core.Component({
                selector: 'igx-drop-down-item',
                template: "<ng-content></ng-content>"
            })
        ], IgxDropDownItemComponent);
        return IgxDropDownItemComponent;
    }(IgxDropDownItemBaseDirective));

    /**
     * Defines the posible values of the components' display density.
     */

    (function (DisplayDensity) {
        DisplayDensity["comfortable"] = "comfortable";
        DisplayDensity["cosy"] = "cosy";
        DisplayDensity["compact"] = "compact";
    })(exports.DisplayDensity || (exports.DisplayDensity = {}));
    /**
     * Defines the DisplayDensity DI token.
     */
    var DisplayDensityToken = new core.InjectionToken('DisplayDensity');
    /**
     * Base class containing all logic required for implementing DisplayDensity.
     */
    var DisplayDensityBase = /** @class */ (function () {
        function DisplayDensityBase(displayDensityOptions) {
            this.displayDensityOptions = displayDensityOptions;
            this.onDensityChanged = new core.EventEmitter();
            this.oldDisplayDensityOptions = { displayDensity: exports.DisplayDensity.comfortable };
            Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
        }
        Object.defineProperty(DisplayDensityBase.prototype, "displayDensity", {
            /**
             * Returns the theme of the component.
             * The default theme is `comfortable`.
             * Available options are `comfortable`, `cosy`, `compact`.
             * ```typescript
             * let componentTheme = this.component.displayDensity;
             * ```
             */
            get: function () {
                return this._displayDensity ||
                    ((this.displayDensityOptions && this.displayDensityOptions.displayDensity) || exports.DisplayDensity.comfortable);
            },
            /**
             * Sets the theme of the component.
             */
            set: function (val) {
                var currentDisplayDensity = this._displayDensity;
                this._displayDensity = val;
                if (currentDisplayDensity !== this._displayDensity) {
                    var densityChangedArgs = {
                        oldDensity: currentDisplayDensity,
                        newDensity: this._displayDensity
                    };
                    this.onDensityChanged.emit(densityChangedArgs);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        DisplayDensityBase.prototype.ngOnInit = function () {
            this.initialDensity = this._displayDensity;
        };
        DisplayDensityBase.prototype.ngDoCheck = function () {
            if (!this._displayDensity && this.displayDensityOptions &&
                this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {
                var densityChangedArgs = {
                    oldDensity: this.oldDisplayDensityOptions.displayDensity,
                    newDensity: this.displayDensityOptions.displayDensity
                };
                this.onDensityChanged.emit(densityChangedArgs);
                this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
            }
        };
        /**
         * Given a style class of a component/element returns the modified version of it based
         * on the current display density.
         */
        DisplayDensityBase.prototype.getComponentDensityClass = function (baseStyleClass) {
            switch (this.displayDensity) {
                case exports.DisplayDensity.cosy:
                    return baseStyleClass + "--" + exports.DisplayDensity.cosy;
                case exports.DisplayDensity.compact:
                    return baseStyleClass + "--" + exports.DisplayDensity.compact;
                default:
                    return baseStyleClass;
            }
        };
        DisplayDensityBase.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.Input()
        ], DisplayDensityBase.prototype, "displayDensity", null);
        __decorate([
            core.Output()
        ], DisplayDensityBase.prototype, "onDensityChanged", void 0);
        DisplayDensityBase = __decorate([
            core.Directive({
                selector: '[igxDisplayDensityBase]'
            })
            // tslint:disable-next-line: directive-class-suffix
            ,
            __param(0, core.Optional()), __param(0, core.Inject(DisplayDensityToken))
        ], DisplayDensityBase);
        return DisplayDensityBase;
    }());
    var IgxDisplayDensityModule = /** @class */ (function () {
        function IgxDisplayDensityModule() {
        }
        IgxDisplayDensityModule = __decorate([
            core.NgModule({
                declarations: [
                    DisplayDensityBase
                ],
                exports: [
                    DisplayDensityBase
                ]
            })
        ], IgxDisplayDensityModule);
        return IgxDisplayDensityModule;
    }());

    var NEXT_ID$2 = 0;
    /**
     * An abstract class, defining a drop-down component, with:
     * Properties for display styles and classes
     * A collection items of type `IgxDropDownItemBaseDirective`
     * Properties and methods for navigating (highlighting/focusing) items from the collection
     * Properties and methods for selecting items from the collection
     */
    var IgxDropDownBaseDirective = /** @class */ (function (_super) {
        __extends(IgxDropDownBaseDirective, _super);
        function IgxDropDownBaseDirective(elementRef, cdr, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this._displayDensityOptions = _displayDensityOptions;
            _this._focusedItem = null;
            _this._id = "igx-drop-down-" + NEXT_ID$2++;
            /**
             * Emitted when item selection is changing, before the selection completes
             *
             * ```html
             * <igx-drop-down (onSelection)='handleSelection()'></igx-drop-down>
             * ```
             */
            _this.onSelection = new core.EventEmitter();
            /**
             * Gets/Sets the drop down's container max height.
             *
             * ```typescript
             * // get
             * let maxHeight = this.dropdown.maxHeight;
             * ```
             * ```html
             * <!--set-->
             * <igx-drop-down [maxHeight]='200px'></igx-drop-down>
             * ```
             */
            _this.maxHeight = null;
            /**
             * @hidden @internal
             */
            _this.cssClass = true;
            return _this;
        }
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "scrollContainer", {
            /**
             * @hidden @internal
             * Get dropdown's html element of its scroll container
             */
            get: function () {
                return this.element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "items", {
            /**
             * Get all non-header items
             *
             * ```typescript
             * let myDropDownItems = this.dropdown.items;
             * ```
             */
            get: function () {
                var e_1, _a;
                var items = [];
                if (this.children !== undefined) {
                    try {
                        for (var _b = __values(this.children.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var child = _c.value;
                            if (!child.isHeader) {
                                items.push(child);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                return items;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "headers", {
            /**
             * Get all header items
             *
             * ```typescript
             * let myDropDownHeaderItems = this.dropdown.headers;
             * ```
             */
            get: function () {
                var e_2, _a;
                var headers = [];
                if (this.children !== undefined) {
                    try {
                        for (var _b = __values(this.children.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var child = _c.value;
                            if (child.isHeader) {
                                headers.push(child);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                return headers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "element", {
            /**
             * Get dropdown html element
             *
             * ```typescript
             * let myDropDownElement = this.dropdown.element;
             * ```
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        /** Keydown Handler */
        IgxDropDownBaseDirective.prototype.onItemActionKey = function (key, event) {
            switch (key) {
                case DropDownActionKey.ENTER:
                case DropDownActionKey.SPACE:
                    this.selectItem(this.focusedItem, event);
                    break;
                case DropDownActionKey.ESCAPE:
            }
        };
        /**
         * Emits onSelection with the target item & event
         * @hidden @internal
         * @param newSelection the item selected
         * @param event the event that triggered the call
         */
        IgxDropDownBaseDirective.prototype.selectItem = function (newSelection, event) {
            this.onSelection.emit({
                newSelection: newSelection,
                oldSelection: null,
                cancel: false
            });
        };
        Object.defineProperty(IgxDropDownBaseDirective.prototype, "focusedItem", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._focusedItem;
            },
            /**
             * @hidden @internal
             */
            set: function (item) {
                this._focusedItem = item;
            },
            enumerable: true,
            configurable: true
        });
        IgxDropDownBaseDirective.prototype.navigate = function (direction, currentIndex) {
            var index = -1;
            if (this._focusedItem) {
                index = currentIndex ? currentIndex : this.focusedItem.itemIndex;
            }
            var newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
            this.navigateItem(newIndex);
        };
        IgxDropDownBaseDirective.prototype.getNearestSiblingFocusableItemIndex = function (startIndex, direction) {
            var index = startIndex;
            var items = this.items;
            while (items[index + direction] && items[index + direction].disabled) {
                index += direction;
            }
            index += direction;
            if (index >= 0 && index < items.length) {
                return index;
            }
            else {
                return -1;
            }
        };
        /**
         * Navigates to the item on the specified index
         * @param newIndex number - the index of the item in the `items` collection
         */
        IgxDropDownBaseDirective.prototype.navigateItem = function (newIndex) {
            if (newIndex !== -1) {
                var oldItem = this._focusedItem;
                var newItem = this.items[newIndex];
                if (oldItem) {
                    oldItem.focused = false;
                }
                this.focusedItem = newItem;
                this.scrollToHiddenItem(newItem);
                this.focusedItem.focused = true;
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownBaseDirective.prototype.navigateFirst = function () {
            this.navigate(Navigate.Down, -1);
        };
        /**
         * @hidden @internal
         */
        IgxDropDownBaseDirective.prototype.navigateLast = function () {
            this.navigate(Navigate.Up, this.items.length);
        };
        /**
         * @hidden @internal
         */
        IgxDropDownBaseDirective.prototype.navigateNext = function () {
            this.navigate(Navigate.Down);
        };
        /**
         * @hidden @internal
         */
        IgxDropDownBaseDirective.prototype.navigatePrev = function () {
            this.navigate(Navigate.Up);
        };
        IgxDropDownBaseDirective.prototype.scrollToHiddenItem = function (newItem) {
            var elementRect = newItem.element.nativeElement.getBoundingClientRect();
            var parentRect = this.scrollContainer.getBoundingClientRect();
            if (parentRect.top > elementRect.top) {
                this.scrollContainer.scrollTop -= (parentRect.top - elementRect.top);
            }
            if (parentRect.bottom < elementRect.bottom) {
                this.scrollContainer.scrollTop += (elementRect.bottom - parentRect.bottom);
            }
        };
        IgxDropDownBaseDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.Output()
        ], IgxDropDownBaseDirective.prototype, "onSelection", void 0);
        __decorate([
            core.Input()
        ], IgxDropDownBaseDirective.prototype, "width", void 0);
        __decorate([
            core.Input()
        ], IgxDropDownBaseDirective.prototype, "height", void 0);
        __decorate([
            core.Input()
        ], IgxDropDownBaseDirective.prototype, "id", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('style.maxHeight')
        ], IgxDropDownBaseDirective.prototype, "maxHeight", void 0);
        __decorate([
            core.HostBinding('class.igx-drop-down')
        ], IgxDropDownBaseDirective.prototype, "cssClass", void 0);
        IgxDropDownBaseDirective = __decorate([
            core.Directive({
                selector: '[igxDropDownBase]'
            }),
            __param(2, core.Optional()), __param(2, core.Inject(DisplayDensityToken))
        ], IgxDropDownBaseDirective);
        return IgxDropDownBaseDirective;
    }(DisplayDensityBase));

    var DisplayContainerComponent = /** @class */ (function () {
        function DisplayContainerComponent(cdr, _viewContainer) {
            this.cdr = cdr;
            this._viewContainer = _viewContainer;
            this.cssClass = 'igx-display-container';
            this.notVirtual = true;
        }
        DisplayContainerComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ViewContainerRef }
        ]; };
        __decorate([
            core.ViewChild('display_container', { read: core.ViewContainerRef, static: true })
        ], DisplayContainerComponent.prototype, "_vcr", void 0);
        __decorate([
            core.HostBinding('class')
        ], DisplayContainerComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('class.igx-display-container--inactive')
        ], DisplayContainerComponent.prototype, "notVirtual", void 0);
        DisplayContainerComponent = __decorate([
            core.Component({
                selector: 'igx-display-container',
                template: "\n        <ng-template\n            #display_container\n            igxScrollInertia\n            [IgxScrollInertiaScrollContainer]=\"scrollContainer\"\n            [IgxScrollInertiaDirection]=\"scrollDirection\">\n        </ng-template>\n    "
            })
        ], DisplayContainerComponent);
        return DisplayContainerComponent;
    }());

    var VirtualHelperBaseDirective = /** @class */ (function () {
        function VirtualHelperBaseDirective(elementRef, cdr) {
            this.elementRef = elementRef;
            this.cdr = cdr;
            this.scrollAmount = 0;
            this._size = 0;
            this._afterViewInit = false;
        }
        VirtualHelperBaseDirective.prototype.ngAfterViewInit = function () {
            this._afterViewInit = true;
        };
        VirtualHelperBaseDirective.prototype.onScroll = function (event) {
            this.scrollAmount = event.target.scrollTop || event.target.scrollLeft;
        };
        Object.defineProperty(VirtualHelperBaseDirective.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        VirtualHelperBaseDirective.prototype.ngOnDestroy = function () {
            this.destroyed = true;
        };
        Object.defineProperty(VirtualHelperBaseDirective.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (value) {
                if (this.destroyed) {
                    return;
                }
                this._size = value;
                if (this._afterViewInit) {
                    this.cdr.detectChanges();
                }
            },
            enumerable: true,
            configurable: true
        });
        VirtualHelperBaseDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.HostListener('scroll', ['$event'])
        ], VirtualHelperBaseDirective.prototype, "onScroll", null);
        VirtualHelperBaseDirective = __decorate([
            core.Directive({
                selector: '[igxVirtualHelperBase]'
            })
        ], VirtualHelperBaseDirective);
        return VirtualHelperBaseDirective;
    }());

    /**
     * @hidden
     */
    var HVirtualHelperComponent = /** @class */ (function (_super) {
        __extends(HVirtualHelperComponent, _super);
        function HVirtualHelperComponent(elementRef, cdr) {
            var _this = _super.call(this, elementRef, cdr) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.cssClasses = 'igx-vhelper--horizontal';
            return _this;
        }
        HVirtualHelperComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.ViewChild('horizontal_container', { read: core.ViewContainerRef, static: true })
        ], HVirtualHelperComponent.prototype, "_vcr", void 0);
        __decorate([
            core.Input()
        ], HVirtualHelperComponent.prototype, "width", void 0);
        __decorate([
            core.HostBinding('class')
        ], HVirtualHelperComponent.prototype, "cssClasses", void 0);
        HVirtualHelperComponent = __decorate([
            core.Component({
                selector: 'igx-horizontal-virtual-helper',
                template: '<div #horizontal_container class="igx-vhelper__placeholder-content" [style.width.px]="size"></div>'
            })
        ], HVirtualHelperComponent);
        return HVirtualHelperComponent;
    }(VirtualHelperBaseDirective));

    var VirtualHelperComponent = /** @class */ (function (_super) {
        __extends(VirtualHelperComponent, _super);
        function VirtualHelperComponent(elementRef, cdr) {
            var _this = _super.call(this, elementRef, cdr) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.cssClasses = 'igx-vhelper--vertical';
            return _this;
        }
        VirtualHelperComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.HostBinding('scrollTop')
        ], VirtualHelperComponent.prototype, "scrollTop", void 0);
        __decorate([
            core.ViewChild('container', { read: core.ViewContainerRef, static: true })
        ], VirtualHelperComponent.prototype, "_vcr", void 0);
        __decorate([
            core.Input()
        ], VirtualHelperComponent.prototype, "itemsLength", void 0);
        __decorate([
            core.HostBinding('class')
        ], VirtualHelperComponent.prototype, "cssClasses", void 0);
        VirtualHelperComponent = __decorate([
            core.Component({
                selector: 'igx-virtual-helper',
                template: '<div #container class="igx-vhelper__placeholder-content" [style.height.px]="size"></div>'
            })
        ], VirtualHelperComponent);
        return VirtualHelperComponent;
    }(VirtualHelperBaseDirective));

    /**
     * @hidden
     */
    var IgxScrollInertiaDirective = /** @class */ (function () {
        function IgxScrollInertiaDirective(element, _zone) {
            this.element = element;
            this._zone = _zone;
            this.wheelStep = 50;
            this.inertiaStep = 1.5;
            this.swipeToleranceX = 20;
            this.inertiaDeltaY = 3;
            this.inertiaDeltaX = 2;
            this.inertiaDuration = 0.5;
            this._savedSpeedsX = [];
            this.setPointerCaptureFName = typeof Element.prototype['msSetPointerCapture'] === 'function' ?
                'msSetPointerCapture' :
                'setPointerCapture';
            this.releasePointerCaptureFName = typeof Element.prototype['msReleasePointerCapture'] === 'function' ?
                'msReleasePointerCapture' :
                'releasePointerCapture';
        }
        IgxScrollInertiaDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._zone.runOutsideAngular(function () {
                _this.parentElement = _this.element.nativeElement.parentElement || _this.element.nativeElement.parentNode;
                var targetElem = _this.parentElement;
                targetElem.addEventListener('wheel', function (evt) { _this.onWheel(evt); });
                targetElem.addEventListener('touchstart', function (evt) { _this.onTouchStart(evt); });
                targetElem.addEventListener('touchmove', function (evt) { _this.onTouchMove(evt); });
                targetElem.addEventListener('touchend', function (evt) { _this.onTouchEnd(evt); });
                targetElem.addEventListener('pointerdown', function (evt) { _this.onPointerDown(evt); });
                targetElem.addEventListener('pointerup', function (evt) { _this.onPointerUp(evt); });
                targetElem.addEventListener('MSGestureStart', function (evt) { _this.onMSGestureStart(evt); });
                targetElem.addEventListener('MSGestureChange', function (evt) { _this.onMSGestureChange(evt); });
            });
        };
        /**
        * @hidden
        * Function that is called when scrolling with the mouse wheel or using touchpad
        */
        IgxScrollInertiaDirective.prototype.onWheel = function (evt) {
            // if no scrollbar return
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            var scrollDeltaX;
            var scrollDeltaY;
            var scrollStep = this.wheelStep;
            var minWheelStep = 1 / this.wheelStep;
            this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
            this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
            if (evt.wheelDeltaX) {
                /* Option supported on Chrome, Safari, Opera.
                /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
                scrollDeltaX = -evt.wheelDeltaX / 120;
                if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
                    scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
                }
            }
            else if (evt.deltaX) {
                /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
                scrollDeltaX = this.calcAxisCoords(evt.deltaX, -1, 1);
            }
            /** Get delta for the Y axis*/
            if (evt.wheelDeltaY) {
                /* Option supported on Chrome, Safari, Opera.
                /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
                scrollDeltaY = -evt.wheelDeltaY / 120;
                if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
                    scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
                }
            }
            else if (evt.deltaY) {
                /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
                scrollDeltaY = this.calcAxisCoords(evt.deltaY, -1, 1);
            }
            if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
                this._scrollToX(this._startX + scrollDeltaX * scrollStep);
                var curScrollLeft = this.IgxScrollInertiaScrollContainer.scrollLeft;
                var maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);
                if (0 < curScrollLeft && curScrollLeft < maxScrollLeft) {
                    // Prevent navigating through pages when scrolling on Mac
                    evt.preventDefault();
                }
            }
            else if (scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
                this._scrollToY(this._startY + scrollDeltaY * scrollStep);
                this.preventParentScroll(evt, true);
            }
        };
        /**
         * @hidden
         * When there is still room to scroll up/down prevent the parent elements from scrolling too.
         */
        IgxScrollInertiaDirective.prototype.preventParentScroll = function (evt, preventDefault) {
            var curScrollTop = this.IgxScrollInertiaScrollContainer.scrollTop;
            var maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight -
                this.IgxScrollInertiaScrollContainer.offsetHeight;
            if (0 < curScrollTop && curScrollTop < maxScrollTop) {
                if (preventDefault) {
                    evt.preventDefault();
                }
                if (evt.stopPropagation) {
                    evt.stopPropagation();
                }
            }
        };
        /**
         * @hidden
         * Function that is called the first moment we start interacting with the content on a touch device
         */
        IgxScrollInertiaDirective.prototype.onTouchStart = function (event) {
            if (typeof MSGesture === 'function' || !this.IgxScrollInertiaScrollContainer) {
                return false;
            }
            // stops any current ongoing inertia
            cancelAnimationFrame(this._touchInertiaAnimID);
            var touch = event.touches[0];
            this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
            this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
            this._touchStartX = touch.pageX;
            this._touchStartY = touch.pageY;
            this._lastTouchEnd = new Date().getTime();
            this._lastTouchX = touch.pageX;
            this._lastTouchY = touch.pageY;
            this._savedSpeedsX = [];
            this._savedSpeedsY = [];
            // Vars regarding swipe offset
            this._totalMovedX = 0;
            this._offsetRecorded = false;
            this._offsetDirection = 0;
            this._touchPrevented = false;
            if (this.IgxScrollInertiaDirection === 'vertical') {
                this.preventParentScroll(event, false);
            }
        };
        /**
         * @hidden
         * Function that is called when we need to scroll the content based on touch interactions
         */
        IgxScrollInertiaDirective.prototype.onTouchMove = function (event) {
            if (typeof MSGesture === 'function') {
                this._touchPrevented = false;
                return false;
            }
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            var touch = event.touches[0];
            var destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
            var destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
            /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */
            /* **********************************************************/
            var timeFromLastTouch = (new Date().getTime()) - this._lastTouchEnd;
            if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
                var speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
                var speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch;
                // Save the last 5 speeds between two touchmoves on X axis
                if (this._savedSpeedsX.length < 5) {
                    this._savedSpeedsX.push(speedX);
                }
                else {
                    this._savedSpeedsX.shift();
                    this._savedSpeedsX.push(speedX);
                }
                // Save the last 5 speeds between two touchmoves on Y axis
                if (this._savedSpeedsY.length < 5) {
                    this._savedSpeedsY.push(speedY);
                }
                else {
                    this._savedSpeedsY.shift();
                    this._savedSpeedsY.push(speedY);
                }
            }
            this._lastTouchEnd = new Date().getTime();
            this._lastMovedX = this._lastTouchX - touch.pageX;
            this._lastMovedY = this._lastTouchY - touch.pageY;
            this._lastTouchX = touch.pageX;
            this._lastTouchY = touch.pageY;
            this._totalMovedX += this._lastMovedX;
            var scrolledXY; // Object: {x, y}
            /*	Do not scroll using touch untill out of the swipeToleranceX bounds */
            if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
                scrolledXY = this._scrollTo(this._startX, destY);
            }
            else {
                /*	Record the direction the first time we are out of the swipeToleranceX bounds.
                *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
                if (!this._offsetRecorded) {
                    this._offsetDirection = Math.sign(destX - this._startX);
                    this._offsetRecorded = true;
                }
                /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
                don't change it after that ever until touchend and again touchstart */
                scrolledXY = this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
            }
            if (scrolledXY.x === 0 && scrolledXY.y === 0) {
                this._touchPrevented = true;
            }
            // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow
            if (this.IgxScrollInertiaDirection === 'vertical') {
                this.preventParentScroll(event, true);
            }
        };
        IgxScrollInertiaDirective.prototype.onTouchEnd = function (event) {
            if (typeof MSGesture === 'function') {
                return;
            }
            var speedX = 0;
            var speedY = 0;
            // savedSpeedsX and savedSpeedsY have same length
            for (var i = 0; i < this._savedSpeedsX.length; i++) {
                speedX += this._savedSpeedsX[i];
                speedY += this._savedSpeedsY[i];
            }
            speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
            speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0;
            // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia
            if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) &&
                (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
                this._inertiaInit(speedX, speedY);
            }
            if (this.IgxScrollInertiaDirection === 'vertical') {
                this.preventParentScroll(event, false);
            }
        };
        /**
         * @hidden
         * Function that is called when we need to detect touch starting on a touch device on IE/Edge
         */
        IgxScrollInertiaDirective.prototype.onPointerDown = function (event) {
            if (!event || (event.pointerType !== 2 && event.pointerType !== 'touch') ||
                typeof MSGesture !== 'function') {
                return true;
            }
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            // setPointerCaptureFName is the name of the function that is supported
            event.target[this.setPointerCaptureFName](this._pointer = event.pointerId);
            // create gestureObject only one time to prevent overlapping during intertia
            if (!this._gestureObject) {
                this._gestureObject = new MSGesture();
                this._gestureObject.target = this.parentElement;
            }
            this._gestureObject.addPointer(this._pointer);
        };
        /**
         * @hidden
         * Function that is called when we need to detect touch ending on a touch device on IE/Edge
         */
        IgxScrollInertiaDirective.prototype.onPointerUp = function (event) {
            if (!this._pointer) {
                return true;
            }
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            /* releasePointerCaptureFName is the name of the function that is supported */
            event.target[this.releasePointerCaptureFName](this._pointer);
            delete this._pointer;
        };
        /**
         * @hidden
         *  Function that is called when a gesture begins on IE/Edge
         */
        IgxScrollInertiaDirective.prototype.onMSGestureStart = function (event) {
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
            this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
            this._touchStartX = event.screenX;
            this._touchStartY = event.screenY;
            // Vars regarding swipe offset
            this._totalMovedX = 0;
            this._offsetRecorded = false;
            this._offsetDirection = 0;
            return false;
        };
        /**
         * @hidden
         * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
         */
        IgxScrollInertiaDirective.prototype.onMSGestureChange = function (event) {
            if (!this.IgxScrollInertiaScrollContainer) {
                return;
            }
            var touchPos = event, destX = this._startX + this._touchStartX - touchPos.screenX, destY = this._startY + this._touchStartY - touchPos.screenY;
            /* Logic regarding x tolerance to prevent accidental horizontal scrolling when scrolling vertically */
            this._totalMovedX = this._touchStartX - touchPos.screenX;
            if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
                /* Do not scroll horizontally yet while in the tolerance range */
                this._scrollToY(destY);
            }
            else {
                if (!this._offsetRecorded) {
                    this._offsetDirection = Math.sign(destX - this._startX);
                    this._offsetRecorded = true;
                }
                /* Once the tolerance is exceeded it can be scrolled horizontally */
                this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
            }
            return false;
        };
        IgxScrollInertiaDirective.prototype.calcAxisCoords = function (target, min, max) {
            if (target === undefined || target < min) {
                target = min;
            }
            else if (target > max) {
                target = max;
            }
            return target;
        };
        IgxScrollInertiaDirective.prototype._scrollTo = function (destX, destY) {
            var curPosX = this.IgxScrollInertiaScrollContainer.scrollLeft;
            var curPosY = this.IgxScrollInertiaScrollContainer.scrollTop;
            // TODO Trigger scrolling event?
            var scrolledX = this._scrollToX(destX);
            var scrolledY = this._scrollToY(destY);
            return { x: scrolledX, y: scrolledY };
        };
        IgxScrollInertiaDirective.prototype._scrollToX = function (dest) {
            this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
        };
        IgxScrollInertiaDirective.prototype._scrollToY = function (dest) {
            this.IgxScrollInertiaScrollContainer.scrollTop = dest;
        };
        IgxScrollInertiaDirective.prototype._inertiaInit = function (speedX, speedY) {
            var _this = this;
            var stepModifer = this.inertiaStep, inertiaDuration = this.inertiaDuration;
            var x = 0;
            this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
            this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
            // Sets timeout until executing next movement iteration of the inertia
            var inertiaStep = function () {
                if (x > 6) {
                    cancelAnimationFrame(_this._touchInertiaAnimID);
                    return;
                }
                if (Math.abs(speedX) > Math.abs(speedY)) {
                    x += 0.05 / (1 * inertiaDuration);
                }
                else {
                    x += 0.05 / (1 * inertiaDuration);
                }
                if (x <= 1) {
                    // We use constant quation to determine the offset without speed falloff befor x reaches 1
                    if (Math.abs(speedY) <= Math.abs(speedX) * _this.inertiaDeltaY) {
                        _this._nextX += 1 * speedX * 15 * stepModifer;
                    }
                    if (Math.abs(speedY) >= Math.abs(speedX) * _this.inertiaDeltaX) {
                        _this._nextY += 1 * speedY * 15 * stepModifer;
                    }
                }
                else {
                    // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
                    if (Math.abs(speedY) <= Math.abs(speedX) * _this.inertiaDeltaY) {
                        _this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
                    }
                    if (Math.abs(speedY) >= Math.abs(speedX) * _this.inertiaDeltaX) {
                        _this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
                    }
                }
                // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse
                _this._scrollTo(_this._nextX, _this._nextY);
                _this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
            };
            // Start inertia and continue it recursively
            this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        };
        IgxScrollInertiaDirective.prototype.ngOnDestroy = function () {
            var _this = this;
            this._zone.runOutsideAngular(function () {
                var targetElem = _this.parentElement;
                targetElem.removeEventListener('wheel', function (evt) { _this.onWheel(evt); });
                targetElem.removeEventListener('touchstart', function (evt) { _this.onTouchStart(evt); });
                targetElem.removeEventListener('touchmove', function (evt) { _this.onTouchMove(evt); });
                targetElem.removeEventListener('touchend', function (evt) { _this.onTouchEnd(evt); });
                targetElem.removeEventListener('pointerdown', function (evt) { _this.onPointerDown(evt); });
                targetElem.removeEventListener('pointerup', function (evt) { _this.onPointerUp(evt); });
                targetElem.removeEventListener('MSGestureStart', function (evt) { _this.onMSGestureStart(evt); });
                targetElem.removeEventListener('MSGestureChange', function (evt) { _this.onMSGestureChange(evt); });
            });
        };
        IgxScrollInertiaDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.Input()
        ], IgxScrollInertiaDirective.prototype, "IgxScrollInertiaDirection", void 0);
        __decorate([
            core.Input()
        ], IgxScrollInertiaDirective.prototype, "IgxScrollInertiaScrollContainer", void 0);
        __decorate([
            core.Input()
        ], IgxScrollInertiaDirective.prototype, "wheelStep", void 0);
        __decorate([
            core.Input()
        ], IgxScrollInertiaDirective.prototype, "inertiaStep", void 0);
        __decorate([
            core.Input()
        ], IgxScrollInertiaDirective.prototype, "swipeToleranceX", void 0);
        __decorate([
            core.Input()
        ], IgxScrollInertiaDirective.prototype, "inertiaDeltaY", void 0);
        __decorate([
            core.Input()
        ], IgxScrollInertiaDirective.prototype, "inertiaDeltaX", void 0);
        __decorate([
            core.Input()
        ], IgxScrollInertiaDirective.prototype, "inertiaDuration", void 0);
        IgxScrollInertiaDirective = __decorate([
            core.Directive({ selector: '[igxScrollInertia]' })
        ], IgxScrollInertiaDirective);
        return IgxScrollInertiaDirective;
    }());
    /**
     * @hidden
     */
    var IgxScrollInertiaModule = /** @class */ (function () {
        function IgxScrollInertiaModule() {
        }
        IgxScrollInertiaModule = __decorate([
            core.NgModule({
                declarations: [IgxScrollInertiaDirective],
                exports: [IgxScrollInertiaDirective],
                imports: [common.CommonModule]
            })
        ], IgxScrollInertiaModule);
        return IgxScrollInertiaModule;
    }());

    var IgxForOfSyncService = /** @class */ (function () {
        function IgxForOfSyncService() {
            this._master = new Map();
        }
        /**
         * @hidden
         */
        IgxForOfSyncService.prototype.isMaster = function (directive) {
            return this._master.get(directive.igxForScrollOrientation) === directive;
        };
        /**
         * @hidden
         */
        IgxForOfSyncService.prototype.setMaster = function (directive, forced) {
            if (forced === void 0) { forced = false; }
            var orientation = directive.igxForScrollOrientation;
            if (orientation && (forced || !this._master.has(orientation))) {
                this._master.set(orientation, directive);
            }
        };
        /**
         * @hidden
         */
        IgxForOfSyncService.prototype.resetMaster = function () {
            this._master.clear();
        };
        /**
         * @hidden
         */
        IgxForOfSyncService.prototype.sizesCache = function (dir) {
            return this._master.get(dir).sizesCache;
        };
        /**
         * @hidden
         */
        IgxForOfSyncService.prototype.chunkSize = function (dir) {
            return this._master.get(dir).state.chunkSize;
        };
        IgxForOfSyncService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function IgxForOfSyncService_Factory() { return new IgxForOfSyncService(); }, token: IgxForOfSyncService, providedIn: "root" });
        IgxForOfSyncService = __decorate([
            core.Injectable({
                providedIn: 'root',
            })
        ], IgxForOfSyncService);
        return IgxForOfSyncService;
    }());
    var IgxForOfScrollSyncService = /** @class */ (function () {
        function IgxForOfScrollSyncService() {
            this._masterScroll = new Map();
        }
        IgxForOfScrollSyncService.prototype.setScrollMaster = function (dir, scroll) {
            this._masterScroll.set(dir, scroll);
        };
        IgxForOfScrollSyncService.prototype.getScrollMaster = function (dir) {
            return this._masterScroll.get(dir);
        };
        IgxForOfScrollSyncService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function IgxForOfScrollSyncService_Factory() { return new IgxForOfScrollSyncService(); }, token: IgxForOfScrollSyncService, providedIn: "root" });
        IgxForOfScrollSyncService = __decorate([
            core.Injectable({
                providedIn: 'root',
            })
        ], IgxForOfScrollSyncService);
        return IgxForOfScrollSyncService;
    }());

    /**
     *  @publicApi
     */
    var IgxForOfContext = /** @class */ (function () {
        function IgxForOfContext($implicit, index, count) {
            this.$implicit = $implicit;
            this.index = index;
            this.count = count;
        }
        Object.defineProperty(IgxForOfContext.prototype, "first", {
            /**
             * A function that returns whether the element is the first or not
             */
            get: function () { return this.index === 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxForOfContext.prototype, "last", {
            /**
             * A function that returns whether the element is the last or not
             */
            get: function () { return this.index === this.count - 1; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxForOfContext.prototype, "even", {
            /**
             * A function that returns whether the element is even or not
             */
            get: function () { return this.index % 2 === 0; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxForOfContext.prototype, "odd", {
            /**
             * A function that returns whether the element is odd or not
             */
            get: function () { return !this.even; },
            enumerable: true,
            configurable: true
        });
        return IgxForOfContext;
    }());
    var IgxForOfDirective = /** @class */ (function () {
        function IgxForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService) {
            this._viewContainer = _viewContainer;
            this._template = _template;
            this._differs = _differs;
            this.resolver = resolver;
            this.cdr = cdr;
            this._zone = _zone;
            this.syncScrollService = syncScrollService;
            /**
             * An @Input property that specifies the scroll orientation.
             * Scroll orientation can be "vertical" or "horizontal".
             * ```html
             * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
             * ```
             */
            this.igxForScrollOrientation = 'vertical';
            /**
             * The current state of the directive. It contains `startIndex` and `chunkSize`.
             * state.startIndex - The index of the item at which the current visible chunk begins.
             * state.chunkSize - The number of items the current visible chunk holds.
             * These options can be used when implementing remote virtualization as they provide the necessary state information.
             * ```typescript
             * const gridState = this.parentVirtDir.state;
             * ```
             */
            this.state = {
                startIndex: 0,
                chunkSize: 0
            };
            /**
             * The total count of the virtual data items, when using remote service.
             * ```typescript
             * this.parentVirtDir.totalItemCount = data.Count;
             * ```
             */
            this.totalItemCount = null;
            /**
             * An event that is emitted after a new chunk has been loaded.
             * ```html
             * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
             * ```
             * ```typescript
             * chunkLoad(e){
             * alert("chunk loaded!");
             * }
             * ```
             */
            this.onChunkLoad = new core.EventEmitter();
            /**
             * @hidden @internal
             * An event that is emitted when scrollbar visibility has changed.
             */
            this.onScrollbarVisibilityChanged = new core.EventEmitter();
            /**
             * An event that is emitted after the rendered content size of the igxForOf has been changed.
            */
            this.onContentSizeChange = new core.EventEmitter();
            /**
             * An event that is emitted after data has been changed.
             * ```html
             * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
             * ```
             * ```typescript
             * dataChanged(e){
             * alert("data changed!");
             * }
             * ```
             */
            this.onDataChanged = new core.EventEmitter();
            this.onBeforeViewDestroyed = new core.EventEmitter();
            /**
             * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
             * Can be used for implementing remote load on demand for the igxFor data.
             * ```html
             * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
             * ```
             * ```typescript
             * chunkPreload(e){
             * alert("chunk is loading!");
             * }
             * ```
             */
            this.onChunkPreload = new core.EventEmitter();
            this._sizesCache = [];
            this._differ = null;
            this.heightCache = [];
            this.MAX_PERF_SCROLL_DIFF = 4;
            /** Height that is being virtualized. */
            this._virtHeight = 0;
            /**
             * Ratio for height that's being virtualizaed and the one visible
             * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
             */
            this._virtHeightRatio = 1;
            /** Internal track for scroll top that is being virtualized */
            this._virtScrollTop = 0;
            /** If the next onScroll event is triggered due to internal setting of scrollTop */
            this._bScrollInternal = false;
            // End properties related to virtual height handling
            this._embeddedViews = [];
            this.contentResizeNotify = new rxjs.Subject();
            /**
             * @hidden
             */
            this.destroy$ = new rxjs.Subject();
        }
        Object.defineProperty(IgxForOfDirective.prototype, "igxForTotalItemCount", {
            /**
             * The total count of the virtual data items, when using remote service.
             * Similar to the property totalItemCount, but this will allow setting the data count into the template.
             * ```html
             * <ng-template igxFor let-item [igxForOf]="data | async" [igxForTotalItemCount]="count | async"
             *  [igxForContainerSize]="'500px'" [igxForItemSize]="'50px'"></ng-template>
             * ```
             */
            get: function () {
                return this.totalItemCount;
            },
            set: function (value) {
                this.totalItemCount = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "displayContainer", {
            get: function () {
                return this.dc.instance._viewContainer.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "virtualHelper", {
            get: function () {
                return this.scrollComponent.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "sizesCache", {
            get: function () {
                return this._sizesCache;
            },
            set: function (value) {
                this._sizesCache = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "_isScrolledToBottom", {
            get: function () {
                if (!this.getScroll()) {
                    return true;
                }
                var scrollHeight = this.getScroll().scrollHeight;
                // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
                // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
                return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "_isAtBottomIndex", {
            get: function () {
                return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "isRemote", {
            /**
             * @hidden
             */
            get: function () {
                return this.totalItemCount !== null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxForOfDirective.prototype, "scrollPosition", {
            /**
             *
             * Gets/Sets the scroll position.
             * ```typescript
             * const position = directive.scrollPosition;
             * directive.scrollPosition = value;
             * ```
             */
            get: function () {
                return this.scrollComponent.scrollAmount;
            },
            set: function (val) {
                if (val === this.scrollComponent.scrollAmount) {
                    return;
                }
                if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
                    this.scrollComponent.nativeElement.scrollLeft = val;
                }
                else if (this.scrollComponent) {
                    this.scrollComponent.nativeElement.scrollTop = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.removeScrollEventListeners = function () {
            var _this = this;
            if (this.igxForScrollOrientation === 'horizontal') {
                this._zone.runOutsideAngular(function () {
                    return _this.scrollComponent.nativeElement.removeEventListener('scroll', _this.func);
                });
            }
            else {
                this._zone.runOutsideAngular(function () {
                    return _this.scrollComponent.nativeElement.removeEventListener('scroll', _this.verticalScrollHandler);
                });
            }
        };
        IgxForOfDirective.prototype.verticalScrollHandler = function (event) {
            this.onScroll(event);
        };
        IgxForOfDirective.prototype.isScrollable = function () {
            return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.ngOnInit = function () {
            var _this = this;
            var totalSize = 0;
            var vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
            this.igxForSizePropName = this.igxForSizePropName || 'width';
            var dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
            this.dc = this._viewContainer.createComponent(dcFactory, 0);
            this.dc.instance.scrollDirection = this.igxForScrollOrientation;
            if (typeof MSGesture === 'function') {
                // On Edge and IE when scrolling on touch the page scroll instead of the grid.
                this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
            }
            if (this.igxForOf && this.igxForOf.length) {
                totalSize = this.initSizesCache(this.igxForOf);
                this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
                this.state.chunkSize = this._calculateChunkSize();
                this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
                if (this.scrollComponent) {
                    this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache, 0), this.igxForOf.length - this.state.chunkSize);
                }
                for (var i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize &&
                    this.igxForOf[i] !== undefined; i++) {
                    var input = this.igxForOf[i];
                    var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
                    this._embeddedViews.push(embeddedView);
                }
            }
            if (this.igxForScrollOrientation === 'vertical') {
                this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
                var factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
                this.scrollComponent = vc.createComponent(factory).instance;
                this._maxHeight = this._calcMaxBrowserHeight();
                this.scrollComponent.size = this.igxForOf ? this._calcHeight() : 0;
                this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                this._zone.runOutsideAngular(function () {
                    _this.verticalScrollHandler = _this.verticalScrollHandler.bind(_this);
                    _this.scrollComponent.nativeElement.addEventListener('scroll', _this.verticalScrollHandler);
                    _this.dc.instance.scrollContainer = _this.scrollComponent.nativeElement;
                });
                var destructor = operators.takeUntil(this.destroy$);
                this.contentResizeNotify.pipe(destructor, operators.filter(function () { return _this.igxForContainerSize && _this.igxForOf && _this.igxForOf.length > 0; }), operators.throttleTime(40, undefined, { leading: true, trailing: true }))
                    .subscribe(function () {
                    _this._zone.runTask(function () {
                        _this.updateSizes();
                    });
                });
            }
            if (this.igxForScrollOrientation === 'horizontal') {
                this.func = function (evt) { _this.onHScroll(evt); };
                this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
                if (!this.scrollComponent) {
                    var hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
                    this.scrollComponent = vc.createComponent(hvFactory).instance;
                    this.scrollComponent.size = totalSize;
                    this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                    this._zone.runOutsideAngular(function () {
                        _this.scrollComponent.nativeElement.addEventListener('scroll', _this.func);
                        _this.dc.instance.scrollContainer = _this.scrollComponent.nativeElement;
                    });
                }
                else {
                    this._zone.runOutsideAngular(function () {
                        _this.scrollComponent.nativeElement.addEventListener('scroll', _this.func);
                        _this.dc.instance.scrollContainer = _this.scrollComponent.nativeElement;
                    });
                }
                this._updateHScrollOffset();
            }
        };
        IgxForOfDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.igxForScrollOrientation === 'vertical') {
                this._zone.runOutsideAngular(function () {
                    _this.contentObserver = new ResizeObserver(function () { return _this.contentResizeNotify.next(); });
                    _this.contentObserver.observe(_this.dc.instance._viewContainer.element.nativeElement);
                });
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.ngOnDestroy = function () {
            this.removeScrollEventListeners();
            this.destroy$.next(true);
            this.destroy$.complete();
            if (this.contentObserver) {
                this.contentObserver.disconnect();
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.ngOnChanges = function (changes) {
            var forOf = 'igxForOf';
            if (forOf in changes) {
                var value = changes[forOf].currentValue;
                if (!this._differ && value) {
                    try {
                        this._differ = this._differs.find(value).create(this.igxForTrackBy);
                    }
                    catch (e) {
                        throw new Error("Cannot find a differ supporting object \"" + value + "\" of type \"" + getTypeNameForDebugging(value) + "\".\n                     NgFor only supports binding to Iterables such as Arrays.");
                    }
                }
            }
            var defaultItemSize = 'igxForItemSize';
            if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
                this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
                // handle default item size changed.
                this.initSizesCache(this.igxForOf);
                this._applyChanges();
            }
            var containerSize = 'igxForContainerSize';
            if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
                this._recalcOnContainerChange(changes);
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.ngDoCheck = function () {
            var _this = this;
            if (this._differ) {
                var changes = this._differ.diff(this.igxForOf);
                if (changes) {
                    //  re-init cache.
                    if (!this.igxForOf) {
                        this.igxForOf = [];
                    }
                    this._updateSizeCache();
                    this._zone.run(function () {
                        _this._applyChanges();
                        _this.cdr.markForCheck();
                        _this._updateScrollOffset();
                        _this.onDataChanged.emit();
                    });
                }
            }
        };
        /**
         * Shifts the scroll thumb position.
         * ```typescript
         * this.parentVirtDir.addScrollTop(5);
         * ```
         * @param addTop negative value to scroll up and positive to scroll down;
         */
        IgxForOfDirective.prototype.addScrollTop = function (addTop) {
            if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
                return false;
            }
            var originalVirtScrollTop = this._virtScrollTop;
            var containerSize = parseInt(this.igxForContainerSize, 10);
            var maxVirtScrollTop = this._virtHeight - containerSize;
            this._bScrollInternal = true;
            this._virtScrollTop += addTop;
            this._virtScrollTop = this._virtScrollTop > 0 ?
                (this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop) :
                0;
            this.scrollPosition += addTop / this._virtHeightRatio;
            if (Math.abs(addTop / this._virtHeightRatio) < 1) {
                // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
                var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
                // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
                this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
            }
            var maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;
            if ((this._virtScrollTop > 0 && this.scrollPosition === 0) ||
                (this._virtScrollTop < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop)) {
                // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
                // Recalculate actual scroll position based on the virtual scroll.
                this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
            }
            else if (this._virtScrollTop === 0 && this.scrollPosition > 0) {
                // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
                this.scrollPosition = 0;
            }
            else if (this._virtScrollTop === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
                // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
                this.scrollPosition = maxRealScrollTop;
            }
            return this._virtScrollTop !== originalVirtScrollTop;
        };
        /**
         * Scrolls to the specified index.
         * ```typescript
         * this.parentVirtDir.scrollTo(5);
         * ```
         * @param index
         */
        IgxForOfDirective.prototype.scrollTo = function (index) {
            if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
                return;
            }
            var containerSize = parseInt(this.igxForContainerSize, 10);
            var isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
            var nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
            if (nextScroll < 0) {
                return;
            }
            if (this.igxForScrollOrientation === 'horizontal') {
                this.scrollPosition = nextScroll;
            }
            else {
                var maxVirtScrollTop = this._virtHeight - containerSize;
                if (nextScroll > maxVirtScrollTop) {
                    nextScroll = maxVirtScrollTop;
                }
                this._bScrollInternal = true;
                this._virtScrollTop = nextScroll;
                this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
                this._adjustToIndex = !isPrevItem ? index : null;
            }
        };
        /**
         * Scrolls by one item into the appropriate next direction.
         * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
         * ```typescript
         * this.parentVirtDir.scrollNext();
         * ```
         */
        IgxForOfDirective.prototype.scrollNext = function () {
            var scr = Math.ceil(this.scrollPosition);
            var endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
            this.scrollTo(endIndex);
        };
        /**
         * Scrolls by one item into the appropriate previous direction.
         * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
         * ```typescript
         * this.parentVirtDir.scrollPrev();
         * ```
         */
        IgxForOfDirective.prototype.scrollPrev = function () {
            this.scrollTo(this.state.startIndex - 1);
        };
        /**
         * Scrolls by one page into the appropriate next direction.
         * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
         * ```typescript
         * this.parentVirtDir.scrollNextPage();
         * ```
         */
        IgxForOfDirective.prototype.scrollNextPage = function () {
            if (this.igxForScrollOrientation === 'horizontal') {
                this.scrollPosition += parseInt(this.igxForContainerSize, 10);
            }
            else {
                this.addScrollTop(parseInt(this.igxForContainerSize, 10));
            }
        };
        /**
         * Scrolls by one page into the appropriate previous direction.
         * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
         * ```typescript
         * this.parentVirtDir.scrollPrevPage();
         * ```
         */
        IgxForOfDirective.prototype.scrollPrevPage = function () {
            if (this.igxForScrollOrientation === 'horizontal') {
                this.scrollPosition -= parseInt(this.igxForContainerSize, 10);
            }
            else {
                var containerSize = (parseInt(this.igxForContainerSize, 10));
                this.addScrollTop(-containerSize);
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.getColumnScrollLeft = function (colIndex) {
            return this.sizesCache[colIndex];
        };
        /**
         * Returns the total number of items that are fully visible.
         * ```typescript
         * this.parentVirtDir.getItemCountInView();
         * ```
         */
        IgxForOfDirective.prototype.getItemCountInView = function () {
            var startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
            if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
                // fisrt item is not fully in view
                startIndex++;
            }
            var endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
            return endIndex - startIndex;
        };
        /**
         * Returns a reference to the scrollbar DOM element.
         * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
         * ```typescript
         * dir.getScroll();
         * ```
         */
        IgxForOfDirective.prototype.getScroll = function () {
            return this.scrollComponent.nativeElement;
        };
        /**
         * Returns the size of the element at the specified index.
         * ```typescript
         * this.parentVirtDir.getSizeAt(1);
         * ```
         */
        IgxForOfDirective.prototype.getSizeAt = function (index) {
            return this.sizesCache[index + 1] - this.sizesCache[index];
        };
        /**
         * Returns the scroll offset of the element at the specified index.
         * ```typescript
         * this.parentVirtDir.getScrollForIndex(1);
         * ```
         */
        IgxForOfDirective.prototype.getScrollForIndex = function (index, bottom) {
            var containerSize = parseInt(this.igxForContainerSize, 10);
            var scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
            return scroll;
        };
        /**
         * @hidden
         * Function that is called when scrolling vertically
         */
        IgxForOfDirective.prototype.onScroll = function (event) {
            /* in certain situations this may be called when no scrollbar is visible */
            if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
                return;
            }
            var containerSize = parseInt(this.igxForContainerSize, 10);
            var maxRealScrollTop = event.target.children[0].scrollHeight - containerSize;
            var realPercentScrolled = maxRealScrollTop !== 0 ? event.target.scrollTop / maxRealScrollTop : 0;
            if (!this._bScrollInternal) {
                var maxVirtScrollTop = this._virtHeight - containerSize;
                this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
            }
            else {
                this._bScrollInternal = false;
            }
            var prevStartIndex = this.state.startIndex;
            var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
            this.dc.changeDetectorRef.detectChanges();
            if (prevStartIndex !== this.state.startIndex) {
                this.onChunkLoad.emit(this.state);
            }
        };
        IgxForOfDirective.prototype.updateSizes = function () {
            this.recalcUpdateSizes();
            this._applyChanges();
            this._updateScrollOffset();
            this.onContentSizeChange.emit();
        };
        /**
         * @hidden
         * Function that recaculates and updates cache sizes.
         */
        IgxForOfDirective.prototype.recalcUpdateSizes = function () {
            var dimension = this.igxForScrollOrientation === 'horizontal' ?
                this.igxForSizePropName : 'height';
            var diffs = [];
            var totalDiff = 0;
            var l = this._embeddedViews.length;
            var rNodes = this._embeddedViews.map(function (view) {
                return view.rootNodes.find(function (node) { return node.nodeType === Node.ELEMENT_NODE; }) || view.rootNodes[0].nextElementSibling;
            });
            for (var i = 0; i < l; i++) {
                var rNode = rNodes[i];
                if (rNode) {
                    var h = rNode.offsetHeight || parseInt(this.igxForItemSize, 10);
                    var index = this.state.startIndex + i;
                    if (!this.isRemote && !this.igxForOf[index]) {
                        continue;
                    }
                    var oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
                    var newVal = dimension === 'height' ? h : rNode.clientWidth;
                    if (dimension === 'height') {
                        this.heightCache[index] = newVal;
                    }
                    else {
                        this.igxForOf[index][dimension] = newVal;
                    }
                    var currDiff = newVal - oldVal;
                    diffs.push(currDiff);
                    totalDiff += currDiff;
                    this.sizesCache[index + 1] += totalDiff;
                }
            }
            // update cache
            if (Math.abs(totalDiff) > 0) {
                for (var j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                    this.sizesCache[j] += totalDiff;
                }
                // update scrBar heights/widths
                if (this.igxForScrollOrientation === 'horizontal') {
                    var totalWidth = parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10) + totalDiff;
                    this.scrollComponent.nativeElement.children[0].style.width = totalWidth + 'px';
                }
                var reducer = function (acc, val) { return acc + val; };
                if (this.igxForScrollOrientation === 'vertical') {
                    var scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
                    var hSum = this.heightCache.reduce(reducer);
                    if (hSum > this._maxHeight) {
                        this._virtHeightRatio = hSum / this._maxHeight;
                    }
                    this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxHeight);
                    this._virtHeight = hSum;
                    if (!this.scrollComponent.destroyed) {
                        this.scrollComponent.cdr.detectChanges();
                    }
                    if (scrToBottom && !this._isAtBottomIndex) {
                        var containerSize = parseInt(this.igxForContainerSize, 10);
                        var maxVirtScrollTop = this._virtHeight - containerSize;
                        this._bScrollInternal = true;
                        this._virtScrollTop = maxVirtScrollTop;
                        this.scrollPosition = maxVirtScrollTop;
                        return;
                    }
                    if (this._adjustToIndex) {
                        // in case scrolled to specific index where after scroll heights are changed
                        // need to adjust the offsets so that item is last in view.
                        var updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                        var sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                        var currOffset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                        this.dc.instance._viewContainer.element.nativeElement.style.top = (currOffset - sumDiffs) + 'px';
                        this._adjustToIndex = null;
                    }
                }
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.fixedUpdateAllElements = function (inScrollTop) {
            var count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
            var newStart = this.getIndexAt(inScrollTop, this.sizesCache, 0);
            if (newStart + this.state.chunkSize > count) {
                newStart = count - this.state.chunkSize;
            }
            var prevStart = this.state.startIndex;
            var diff = newStart - this.state.startIndex;
            this.state.startIndex = newStart;
            if (diff) {
                this.onChunkPreload.emit(this.state);
                if (!this.isRemote) {
                    /*recalculate and apply page size.*/
                    if (diff > 0 && diff <= this.MAX_PERF_SCROLL_DIFF) {
                        this.moveApplyScrollNext(prevStart);
                    }
                    else if (diff < 0 && Math.abs(diff) <= this.MAX_PERF_SCROLL_DIFF) {
                        this.moveApplyScrollPrev(prevStart);
                    }
                    else {
                        this.fixedApplyScroll();
                    }
                }
            }
            return inScrollTop - this.sizesCache[this.state.startIndex];
        };
        /**
         * @hidden
         * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
         */
        IgxForOfDirective.prototype.moveApplyScrollNext = function (prevIndex) {
            var start = prevIndex + this.state.chunkSize;
            for (var i = start; i < start + this.state.startIndex - prevIndex && this.igxForOf[i] !== undefined; i++) {
                var input = this.igxForOf[i];
                var embView = this._embeddedViews.shift();
                var cntx = embView.context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
                cntx.count = this.igxForOf.length;
                var view = this.dc.instance._vcr.detach(0);
                this.dc.instance._vcr.insert(view);
                this._embeddedViews.push(embView);
            }
        };
        /**
         * @hidden
         * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
         */
        IgxForOfDirective.prototype.moveApplyScrollPrev = function (prevIndex) {
            for (var i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
                var input = this.igxForOf[i];
                var embView = this._embeddedViews.pop();
                var cntx = embView.context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
                var view = this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
                this.dc.instance._vcr.insert(view, 0);
                this._embeddedViews.unshift(embView);
            }
        };
        /**
         * @hidden
        */
        IgxForOfDirective.prototype.getContextIndex = function (input) {
            return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
        };
        /**
         * @hidden
         * The function applies an optimized state change through context change for each view
         */
        IgxForOfDirective.prototype.fixedApplyScroll = function () {
            var j = 0;
            var endIndex = this.state.startIndex + this.state.chunkSize;
            for (var i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                var input = this.igxForOf[i];
                var embView = this._embeddedViews[j++];
                var cntx = embView.context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
                cntx.count = this.igxForOf.length;
            }
        };
        /**
         * @hidden
         * Function that is called when scrolling horizontally
         */
        IgxForOfDirective.prototype.onHScroll = function (event) {
            /* in certain situations this may be called when no scrollbar is visible */
            if (!parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
                return;
            }
            var prevStartIndex = this.state.startIndex;
            // Updating horizontal chunks
            var scrollOffset = this.fixedUpdateAllElements(event.target.scrollLeft);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
            this.dc.changeDetectorRef.detectChanges();
            if (prevStartIndex !== this.state.startIndex) {
                this.onChunkLoad.emit(this.state);
            }
        };
        Object.defineProperty(IgxForOfDirective.prototype, "igxForTrackBy", {
            /**
             * Gets the function used to track changes in the items collection.
             * By default the object references are compared. However this can be optimized if you have unique identifier
             * value that can be used for the comparison instead of the object ref or if you have some other property values
             * in the item object that should be tracked for changes.
             * This option is similar to ngForTrackBy.
             * ```typescript
             * const trackFunc = this.parentVirtDir.igxForTrackBy;
             * ```
             */
            get: function () { return this._trackByFn; },
            /**
             * Sets the function used to track changes in the items collection.
             * This function can be set in scenarios where you want to optimize or
             * customize the tracking of changes for the items in the collection.
             * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
             * ```typescript
             * this.parentVirtDir.igxForTrackBy = (index, item) => {
             *      return item.id + item.width;
             * };
             * ```
             */
            set: function (fn) { this._trackByFn = fn; },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxForOfDirective.prototype._applyChanges = function () {
            var prevChunkSize = this.state.chunkSize;
            this.applyChunkSizeChange();
            this._recalcScrollBarSize();
            if (this.igxForOf && this.igxForOf.length && this.dc) {
                var embeddedViewCopy = Object.assign([], this._embeddedViews);
                var startIndex = this.state.startIndex;
                var endIndex = this.state.chunkSize + this.state.startIndex;
                if (this.isRemote) {
                    startIndex = 0;
                    endIndex = this.igxForOf.length;
                }
                for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                    var input = this.igxForOf[i];
                    var embView = embeddedViewCopy.shift();
                    var cntx = embView.context;
                    cntx.$implicit = input;
                    cntx.index = this.getContextIndex(input);
                    cntx.count = this.igxForOf.length;
                }
                if (prevChunkSize !== this.state.chunkSize) {
                    this.onChunkLoad.emit(this.state);
                }
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype._calcMaxBrowserHeight = function () {
            var div = document.createElement('div');
            var style = div.style;
            style.position = 'absolute';
            style.top = '9999999999999999px';
            document.body.appendChild(div);
            var size = Math.abs(div.getBoundingClientRect()['top']);
            document.body.removeChild(div);
            return size;
        };
        /**
         * @hidden
         * Recalculates the chunkSize based on current startIndex and returns the new size.
         * This should be called after this.state.startIndex is updated, not before.
         */
        IgxForOfDirective.prototype._calculateChunkSize = function () {
            var chunkSize = 0;
            if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
                if (!this.sizesCache) {
                    this.initSizesCache(this.igxForOf);
                }
                chunkSize = this._calcMaxChunkSize();
                if (this.igxForOf && chunkSize > this.igxForOf.length) {
                    chunkSize = this.igxForOf.length;
                }
            }
            else {
                if (this.igxForOf) {
                    chunkSize = this.igxForOf.length;
                }
            }
            return chunkSize;
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.getElement = function (viewref, nodeName) {
            var elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
            return elem.length > 0 ? elem[0] : null;
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.initSizesCache = function (items) {
            var totalSize = 0;
            var size = 0;
            var dimension = this.igxForScrollOrientation === 'horizontal' ?
                this.igxForSizePropName : 'height';
            var i = 0;
            this.sizesCache = [];
            this.heightCache = [];
            this.sizesCache.push(0);
            var count = this.isRemote ? this.totalItemCount : items.length;
            for (i; i < count; i++) {
                if (dimension === 'height') {
                    // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
                    size = parseInt(this.igxForItemSize, 10) || 0;
                    this.heightCache.push(size);
                }
                else {
                    size = this._getItemSize(items[i], dimension);
                }
                totalSize += size;
                this.sizesCache.push(totalSize);
            }
            return totalSize;
        };
        IgxForOfDirective.prototype._updateSizeCache = function () {
            if (this.igxForScrollOrientation === 'horizontal') {
                this.initSizesCache(this.igxForOf);
                return;
            }
            var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) { return acc + val; }) : 0;
            var newHeight = this.initSizesCache(this.igxForOf);
            var diff = oldHeight - newHeight;
            // if data has been changed while container is scrolled
            // should update scroll top/left according to change so that same startIndex is in view
            if (Math.abs(diff) > 0 && this.scrollPosition > 0) {
                this.recalcUpdateSizes();
                var offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
            }
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype._calcMaxChunkSize = function () {
            var _this = this;
            var i = 0;
            var length = 0;
            var maxLength = 0;
            var arr = [];
            var sum = 0;
            var availableSize = parseInt(this.igxForContainerSize, 10);
            if (!availableSize) {
                return 0;
            }
            var dimension = this.igxForScrollOrientation === 'horizontal' ?
                this.igxForSizePropName : 'height';
            var reducer = function (accumulator, currentItem) { return accumulator + _this._getItemSize(currentItem, dimension); };
            for (i; i < this.igxForOf.length; i++) {
                var item = this.igxForOf[i];
                if (dimension === 'height') {
                    item = { value: this.igxForOf[i], height: this.heightCache[i] };
                }
                var size = dimension === 'height' ?
                    this.heightCache[i] :
                    this._getItemSize(item, dimension);
                sum = arr.reduce(reducer, size);
                if (sum < availableSize) {
                    arr.push(item);
                    length = arr.length;
                    if (i === this.igxForOf.length - 1) {
                        // reached end without exceeding
                        // include prev items until size is filled or first item is reached.
                        var curItem = dimension === 'height' ? arr[0].value : arr[0];
                        var prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        while (prevIndex >= 0 && sum <= availableSize) {
                            curItem = dimension === 'height' ? arr[0].value : arr[0];
                            prevIndex = this.igxForOf.indexOf(curItem) - 1;
                            var prevItem = this.igxForOf[prevIndex];
                            var prevSize = dimension === 'height' ?
                                this.heightCache[prevIndex] :
                                parseInt(prevItem[dimension], 10);
                            sum = arr.reduce(reducer, prevSize);
                            arr.unshift(prevItem);
                            length = arr.length;
                        }
                    }
                }
                else {
                    arr.push(item);
                    length = arr.length + 1;
                    arr.shift();
                }
                if (length > maxLength) {
                    maxLength = length;
                }
            }
            return maxLength;
        };
        /**
         * @hidden
         */
        IgxForOfDirective.prototype.getIndexAt = function (left, set, index) {
            var start = 0;
            var end = set.length - 1;
            if (left === 0) {
                return 0;
            }
            while (start <= end) {
                var midIdx = Math.floor((start + end) / 2);
                var midLeft = set[midIdx];
                var cmp = left - midLeft;
                if (cmp > 0) {
                    start = midIdx + 1;
                }
                else if (cmp < 0) {
                    end = midIdx - 1;
                }
                else {
                    return midIdx;
                }
            }
            return end;
        };
        IgxForOfDirective.prototype._recalcScrollBarSize = function () {
            var count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
            var scrollable = this.isScrollable();
            if (this.igxForScrollOrientation === 'horizontal') {
                var totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
                this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
                this.scrollComponent.size = totalWidth;
                if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
                    this.scrollPosition = 0;
                    // Need to reset the scrollAmount value here, because horizontalScrollBar is hidden, therefore
                    // onScroll event handler for VirtualHelperBaseDirective will not be called
                    this.scrollComponent.scrollAmount = 0;
                }
            }
            if (this.igxForScrollOrientation === 'vertical') {
                this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
                this.scrollComponent.size = this._calcHeight();
                if (this.scrollComponent.size <= parseInt(this.igxForContainerSize, 10)) {
                    this.scrollPosition = 0;
                    // Need to reset the scrollAmount value here, because verticalScrollBar is hidden, therefore
                    // onScroll event handler for VirtualHelperBaseDirective will not be called
                    this.scrollComponent.scrollAmount = 0;
                }
            }
            if (scrollable !== this.isScrollable()) {
                // scrollbar visibility has changed
                this.onScrollbarVisibilityChanged.emit();
            }
        };
        IgxForOfDirective.prototype._calcHeight = function () {
            var height;
            if (this.heightCache) {
                height = this.heightCache.reduce(function (acc, val) { return acc + val; }, 0);
            }
            else {
                height = this.initSizesCache(this.igxForOf);
            }
            this._virtHeight = height;
            if (height > this._maxHeight) {
                this._virtHeightRatio = height / this._maxHeight;
                height = this._maxHeight;
            }
            return height;
        };
        IgxForOfDirective.prototype._recalcOnContainerChange = function (changes) {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
            var prevChunkSize = this.state.chunkSize;
            this.applyChunkSizeChange();
            this._recalcScrollBarSize();
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
            if (this.sizesCache && this.igxForScrollOrientation === 'horizontal') {
                // Updating horizontal chunks and offsets based on the new scrollLeft
                var scrollOffset = this.fixedUpdateAllElements(this.scrollPosition);
                this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
            }
        };
        /**
         * @hidden
         * Removes an elemenet from the embedded views and updates chunkSize.
         */
        IgxForOfDirective.prototype.removeLastElem = function () {
            var oldElem = this._embeddedViews.pop();
            this.onBeforeViewDestroyed.emit(oldElem);
            // also detach from ViewContainerRef to make absolutely sure this is removed from the view container.
            this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
            oldElem.destroy();
            this.state.chunkSize--;
        };
        /**
         * @hidden
         * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
         */
        IgxForOfDirective.prototype.addLastElem = function () {
            var _this = this;
            var elemIndex = this.state.startIndex + this.state.chunkSize;
            if (!this.isRemote && !this.igxForOf) {
                return;
            }
            if (elemIndex >= this.igxForOf.length) {
                elemIndex = this.igxForOf.length - this.state.chunkSize;
            }
            var input = this.igxForOf[elemIndex];
            var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
            this._embeddedViews.push(embeddedView);
            this.state.chunkSize++;
            this._zone.run(function () {
                _this.cdr.markForCheck();
            });
        };
        /**
         * Recalculates chunkSize and adds/removes elements if need due to the change.
         * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
         */
        IgxForOfDirective.prototype.applyChunkSizeChange = function () {
            var chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
            if (chunkSize > this.state.chunkSize) {
                var diff = chunkSize - this.state.chunkSize;
                for (var i = 0; i < diff; i++) {
                    this.addLastElem();
                }
            }
            else if (chunkSize < this.state.chunkSize) {
                var diff = this.state.chunkSize - chunkSize;
                for (var i = 0; i < diff; i++) {
                    this.removeLastElem();
                }
            }
        };
        IgxForOfDirective.prototype._updateScrollOffset = function () {
            if (this.igxForScrollOrientation === 'horizontal') {
                this._updateHScrollOffset();
            }
            else {
                this._updateVScrollOffset();
            }
        };
        IgxForOfDirective.prototype._updateVScrollOffset = function () {
            var scrollOffset = 0;
            var vScroll = this.scrollComponent.nativeElement;
            scrollOffset = vScroll && this.scrollComponent.size ?
                this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        };
        IgxForOfDirective.prototype._updateHScrollOffset = function () {
            var scrollOffset = 0;
            scrollOffset = this.scrollComponent.nativeElement &&
                this.scrollComponent.size ?
                this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        };
        IgxForOfDirective.prototype._getItemSize = function (item, dimension) {
            var dim = item[dimension];
            return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
        };
        IgxForOfDirective.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.TemplateRef },
            { type: core.IterableDiffers },
            { type: core.ComponentFactoryResolver },
            { type: core.ChangeDetectorRef },
            { type: core.NgZone },
            { type: IgxForOfScrollSyncService }
        ]; };
        __decorate([
            core.Input()
        ], IgxForOfDirective.prototype, "igxForOf", void 0);
        __decorate([
            core.Input()
        ], IgxForOfDirective.prototype, "igxForSizePropName", void 0);
        __decorate([
            core.Input()
        ], IgxForOfDirective.prototype, "igxForScrollOrientation", void 0);
        __decorate([
            core.Input()
        ], IgxForOfDirective.prototype, "igxForScrollContainer", void 0);
        __decorate([
            core.Input()
        ], IgxForOfDirective.prototype, "igxForContainerSize", void 0);
        __decorate([
            core.Input()
        ], IgxForOfDirective.prototype, "igxForItemSize", void 0);
        __decorate([
            core.Input()
        ], IgxForOfDirective.prototype, "igxForTotalItemCount", null);
        __decorate([
            core.Output()
        ], IgxForOfDirective.prototype, "onChunkLoad", void 0);
        __decorate([
            core.Output()
        ], IgxForOfDirective.prototype, "onScrollbarVisibilityChanged", void 0);
        __decorate([
            core.Output()
        ], IgxForOfDirective.prototype, "onContentSizeChange", void 0);
        __decorate([
            core.Output()
        ], IgxForOfDirective.prototype, "onDataChanged", void 0);
        __decorate([
            core.Output()
        ], IgxForOfDirective.prototype, "onBeforeViewDestroyed", void 0);
        __decorate([
            core.Output()
        ], IgxForOfDirective.prototype, "onChunkPreload", void 0);
        __decorate([
            core.Input()
        ], IgxForOfDirective.prototype, "igxForTrackBy", null);
        IgxForOfDirective = __decorate([
            core.Directive({ selector: '[igxFor][igxForOf]' })
        ], IgxForOfDirective);
        return IgxForOfDirective;
    }());
    function getTypeNameForDebugging(type) {
        var name = 'name';
        return type[name] || typeof type;
    }
    var IgxGridForOfDirective = /** @class */ (function (_super) {
        __extends(IgxGridForOfDirective, _super);
        function IgxGridForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, syncService) {
            var _this = _super.call(this, _viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService) || this;
            _this.syncScrollService = syncScrollService;
            _this.syncService = syncService;
            /**
             * @hidden @internal
             * An event that is emitted after data has been changed but before the view is refreshed
             */
            _this.onDataChanging = new core.EventEmitter();
            return _this;
        }
        Object.defineProperty(IgxGridForOfDirective.prototype, "igxGridForOf", {
            get: function () {
                return this.igxForOf;
            },
            set: function (value) {
                this.igxForOf = value;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridForOfDirective.prototype.ngOnInit = function () {
            this.syncService.setMaster(this);
            _super.prototype.ngOnInit.call(this);
            this.removeScrollEventListeners();
        };
        IgxGridForOfDirective.prototype.ngOnChanges = function (changes) {
            var forOf = 'igxGridForOf';
            this.syncService.setMaster(this);
            if (forOf in changes) {
                var value = changes[forOf].currentValue;
                if (!this._differ && value) {
                    try {
                        this._differ = this._differs.find(value).create(this.igxForTrackBy);
                    }
                    catch (e) {
                        throw new Error("Cannot find a differ supporting object \"" + value + "\" of type \"" + getTypeNameForDebugging(value) + "\".\n                     NgFor only supports binding to Iterables such as Arrays.");
                    }
                }
            }
            var defaultItemSize = 'igxForItemSize';
            if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
                this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
                // handle default item size changed.
                this.initSizesCache(this.igxForOf);
            }
            var containerSize = 'igxForContainerSize';
            if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
                this._recalcOnContainerChange(changes);
            }
        };
        Object.defineProperty(IgxGridForOfDirective.prototype, "sizesCache", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.syncService.isMaster(this)) {
                    return this._sizesCache;
                }
                return this.syncService.sizesCache(this.igxForScrollOrientation);
            },
            /**
             * @hidden
             * @internal
             */
            set: function (value) {
                this._sizesCache = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridForOfDirective.prototype, "itemsDimension", {
            get: function () {
                return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
            },
            enumerable: true,
            configurable: true
        });
        IgxGridForOfDirective.prototype.getItemSize = function (item) {
            var size = 0;
            var dimension = this.igxForScrollOrientation === 'horizontal' ?
                this.igxForSizePropName : 'height';
            if (dimension === 'height') {
                size = parseInt(this.igxForItemSize, 10) || 0;
                if (item && item.summaries) {
                    size = item.max;
                }
                else if (item && item.groups && item.height) {
                    size = item.height;
                }
            }
            else {
                size = parseInt(item[dimension], 10) || 0;
            }
            return size;
        };
        IgxGridForOfDirective.prototype.initSizesCache = function (items) {
            if (!this.syncService.isMaster(this)) {
                var masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
                return masterSizesCache[masterSizesCache.length - 1];
            }
            var totalSize = 0;
            var size = 0;
            var i = 0;
            this.sizesCache = [];
            this.heightCache = [];
            this.sizesCache.push(0);
            var count = this.isRemote ? this.totalItemCount : items.length;
            for (i; i < count; i++) {
                size = this.getItemSize(items[i]);
                if (this.itemsDimension === 'height') {
                    this.heightCache.push(size);
                }
                totalSize += size;
                this.sizesCache.push(totalSize);
            }
            return totalSize;
        };
        IgxGridForOfDirective.prototype._updateSizeCache = function (changes) {
            var _this = this;
            if (changes === void 0) { changes = null; }
            if (this.igxForScrollOrientation === 'horizontal') {
                this.initSizesCache(this.igxForOf);
                return;
            }
            var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) { return acc + val; }) : 0;
            var newHeight = oldHeight;
            if (changes && !this.isRemote) {
                newHeight = this.handleCacheChanges(changes);
            }
            else {
                newHeight = this.initSizesCache(this.igxForOf);
            }
            var diff = oldHeight - newHeight;
            // if data has been changed while container is scrolled
            // should update scroll top/left according to change so that same startIndex is in view
            if (Math.abs(diff) > 0) {
                // TODO: This code can be removed. However tests need to be rewritten in a way that they wait for ResizeObserved to complete.
                // So leaving as is for the moment.
                requestAnimationFrame(function () {
                    _this.recalcUpdateSizes();
                    var offset = parseInt(_this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                    if (_this.scrollPosition !== 0) {
                        _this.scrollPosition = _this.sizesCache[_this.state.startIndex] - offset;
                    }
                    else {
                        _this._updateScrollOffset();
                    }
                });
            }
        };
        IgxGridForOfDirective.prototype.handleCacheChanges = function (changes) {
            var _this = this;
            var identityChanges = [];
            var newHeightCache = [];
            var newSizesCache = [];
            newSizesCache.push(0);
            var newHeight = 0;
            // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
            var numRemovedItems = 0;
            changes.forEachRemovedItem(function () { return numRemovedItems++; });
            // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
            changes.forEachIdentityChange(function (item) {
                if (item.currentIndex !== item.previousIndex) {
                    // Filter out ones that have not changed their index.
                    identityChanges[item.currentIndex] = item;
                }
            });
            // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
            changes.forEachItem(function (item) {
                if (item.previousIndex !== null &&
                    (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
                    // Reuse cache on those who have previousIndex.
                    // When there are more than one removed items currently the changes are not readable so ones with identity change
                    // should be racalculated.
                    newHeightCache[item.currentIndex] = _this.heightCache[item.previousIndex];
                }
                else {
                    // Assign default item size.
                    newHeightCache[item.currentIndex] = _this.getItemSize(item.item);
                }
                newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
                newHeight += newHeightCache[item.currentIndex];
            });
            this.heightCache = newHeightCache;
            this.sizesCache = newSizesCache;
            return newHeight;
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridForOfDirective.prototype.assumeMaster = function () {
            this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            this.syncService.setMaster(this, true);
        };
        IgxGridForOfDirective.prototype.ngDoCheck = function () {
            if (this._differ) {
                var changes = this._differ.diff(this.igxForOf);
                if (changes) {
                    var args = {
                        containerSize: this.igxForContainerSize
                    };
                    this.onDataChanging.emit(args);
                    //  re-init cache.
                    if (!this.igxForOf) {
                        this.igxForOf = [];
                    }
                    /* we need to reset the master dir if all rows are removed
                    (e.g. because of filtering); if all columns are hidden, rows are
                    still rendered empty, so we should not reset master */
                    if (!this.igxForOf.length &&
                        this.igxForScrollOrientation === 'vertical') {
                        this.syncService.resetMaster();
                    }
                    this.syncService.setMaster(this);
                    this.igxForContainerSize = args.containerSize;
                    this._updateSizeCache(changes);
                    this._applyChanges();
                    this._updateScrollOffset();
                    this.onDataChanged.emit();
                }
            }
        };
        IgxGridForOfDirective.prototype.onScroll = function (event) {
            var _this = this;
            if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
                return;
            }
            var containerSize = parseInt(this.igxForContainerSize, 10);
            var maxRealScrollTop = event.target.children[0].scrollHeight - containerSize;
            var realPercentScrolled = maxRealScrollTop !== 0 ? event.target.scrollTop / maxRealScrollTop : 0;
            if (!this._bScrollInternal) {
                var maxVirtScrollTop = this._virtHeight - containerSize;
                this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
            }
            else {
                this._bScrollInternal = false;
            }
            var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
            this._zone.onStable.pipe(operators.first()).subscribe(function () {
                _this.recalcUpdateSizes();
            });
            this.cdr.markForCheck();
        };
        IgxGridForOfDirective.prototype.onHScroll = function (scrollAmount) {
            /* in certain situations this may be called when no scrollbar is visible */
            if (!this.scrollComponent || !parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
                return;
            }
            // Updating horizontal chunks
            var scrollOffset = this.fixedUpdateAllElements(scrollAmount);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        };
        IgxGridForOfDirective.prototype.addLastElem = function () {
            var elemIndex = this.state.startIndex + this.state.chunkSize;
            if (!this.isRemote && !this.igxForOf) {
                return;
            }
            if (elemIndex >= this.igxForOf.length) {
                elemIndex = this.igxForOf.length - this.state.chunkSize;
            }
            var input = this.igxForOf[elemIndex];
            var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
            this._embeddedViews.push(embeddedView);
            this.state.chunkSize++;
        };
        IgxGridForOfDirective.prototype._updateViews = function (prevChunkSize) {
            if (this.igxForOf && this.igxForOf.length && this.dc) {
                var embeddedViewCopy = Object.assign([], this._embeddedViews);
                var startIndex = void 0;
                var endIndex = void 0;
                if (this.isRemote) {
                    startIndex = 0;
                    endIndex = this.igxForOf.length;
                }
                else {
                    startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
                    if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                        startIndex = this.igxForOf.length - this.state.chunkSize;
                    }
                    this.state.startIndex = startIndex;
                    endIndex = this.state.chunkSize + this.state.startIndex;
                }
                for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                    var input = this.igxForOf[i];
                    var embView = embeddedViewCopy.shift();
                    var cntx = embView.context;
                    cntx.$implicit = input;
                    cntx.index = this.getContextIndex(input);
                    cntx.count = this.igxForOf.length;
                }
                if (prevChunkSize !== this.state.chunkSize) {
                    this.onChunkLoad.emit(this.state);
                }
            }
        };
        IgxGridForOfDirective.prototype._applyChanges = function () {
            var prevChunkSize = this.state.chunkSize;
            this.applyChunkSizeChange();
            this._recalcScrollBarSize();
            this._updateViews(prevChunkSize);
        };
        /**
         * @hidden
         */
        IgxGridForOfDirective.prototype._calcMaxChunkSize = function () {
            if (this.syncService.isMaster(this)) {
                return _super.prototype._calcMaxChunkSize.call(this);
            }
            return this.syncService.chunkSize(this.igxForScrollOrientation);
        };
        IgxGridForOfDirective.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.TemplateRef },
            { type: core.IterableDiffers },
            { type: core.ComponentFactoryResolver },
            { type: core.ChangeDetectorRef },
            { type: core.NgZone },
            { type: IgxForOfScrollSyncService },
            { type: IgxForOfSyncService }
        ]; };
        __decorate([
            core.Input()
        ], IgxGridForOfDirective.prototype, "igxGridForOf", null);
        __decorate([
            core.Output()
        ], IgxGridForOfDirective.prototype, "onDataChanging", void 0);
        IgxGridForOfDirective = __decorate([
            core.Directive({
                selector: '[igxGridFor][igxGridForOf]'
            })
        ], IgxGridForOfDirective);
        return IgxGridForOfDirective;
    }(IgxForOfDirective));
    /**
     * @hidden
     */
    var IgxForOfModule = /** @class */ (function () {
        function IgxForOfModule() {
        }
        IgxForOfModule = __decorate([
            core.NgModule({
                declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent,
                    HVirtualHelperComponent, VirtualHelperBaseDirective],
                entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
                exports: [IgxForOfDirective, IgxGridForOfDirective],
                imports: [IgxScrollInertiaModule, common.CommonModule]
            })
        ], IgxForOfModule);
        return IgxForOfModule;
    }());

    /**
     * **Ignite UI for Angular DropDown** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/drop_down.html)
     *
     * The Ignite UI for Angular Drop Down displays a scrollable list of items which may be visually grouped and
     * supports selection of a single item. Clicking or tapping an item selects it and closes the Drop Down
     *
     * Example:
     * ```html
     * <igx-drop-down>
     *   <igx-drop-down-item *ngFor="let item of items" disabled={{item.disabled}} isHeader={{item.header}}>
     *     {{ item.value }}
     *   </igx-drop-down-item>
     * </igx-drop-down>
     * ```
     */
    var IgxDropDownComponent = /** @class */ (function (_super) {
        __extends(IgxDropDownComponent, _super);
        function IgxDropDownComponent(elementRef, cdr, selection, _displayDensityOptions) {
            var _this = _super.call(this, elementRef, cdr, _displayDensityOptions) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.selection = selection;
            _this._displayDensityOptions = _displayDensityOptions;
            _this.destroy$ = new rxjs.Subject();
            /**
             * Emitted before the dropdown is opened
             *
             * ```html
             * <igx-drop-down (onOpening)='handleOpening()'></igx-drop-down>
             * ```
             */
            _this.onOpening = new core.EventEmitter();
            /**
             * Emitted after the dropdown is opened
             *
             * ```html
             * <igx-drop-down (onOpened)='handleOpened()'></igx-drop-down>
             * ```
             */
            _this.onOpened = new core.EventEmitter();
            /**
             * Emitted before the dropdown is closed
             *
             * ```html
             * <igx-drop-down (onClosing)='handleClosing()'></igx-drop-down>
             * ```
             */
            _this.onClosing = new core.EventEmitter();
            /**
             * Emitted after the dropdown is closed
             *
             * ```html
             * <igx-drop-down (onClosed)='handleClosed()'></igx-drop-down>
             * ```
             */
            _this.onClosed = new core.EventEmitter();
            /**
             * Gets/sets whether items take focus. Disabled by default.
             * When enabled, drop down items gain tab index and are focused when active -
             * this includes activating the selected item when opening the drop down and moving with keyboard navigation.
             *
             * Note: Keep that focus shift in mind when using the igxDropDownItemNavigation directive
             * and ensure it's placed either on each focusable item or a common ancestor to allow it to handle keyboard events.
             *
             * ```typescript
             * // get
             * let dropDownAllowsItemFocus = this.dropdown.allowItemsFocus;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-drop-down [allowItemsFocus]='true'></igx-drop-down>
             * ```
             */
            _this.allowItemsFocus = false;
            return _this;
        }
        IgxDropDownComponent_1 = IgxDropDownComponent;
        Object.defineProperty(IgxDropDownComponent.prototype, "focusedItem", {
            /**
             * @hidden @internal
             */
            get: function () {
                var _this = this;
                if (this.virtDir) {
                    return this._focusedItem && this._focusedItem.index !== -1 ?
                        (this.children.find(function (e) { return e.index === _this._focusedItem.index; }) || null) :
                        null;
                }
                return this._focusedItem;
            },
            set: function (value) {
                if (!value) {
                    this.selection.clear(this.id + "-active");
                    this._focusedItem = null;
                    return;
                }
                this._focusedItem = value;
                if (this.virtDir) {
                    this._focusedItem = {
                        value: value.value,
                        index: value.index
                    };
                }
                this.selection.set(this.id + "-active", new Set([this._focusedItem]));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "id", {
            get: function () {
                return this._id;
            },
            set: function (value) {
                this.selection.set(value, this.selection.get(this.id));
                this.selection.clear(this.id);
                this.selection.set(value, this.selection.get(this.id + "-active"));
                this.selection.clear(this.id + "-active");
                this._id = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "listId", {
            /** Id of the internal listbox of the drop down */
            get: function () {
                return this.id + '-list';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "selectedItem", {
            /**
             * Get currently selected item
             *
             * ```typescript
             * let currentItem = this.dropdown.selectedItem;
             * ```
             */
            get: function () {
                var selectedItem = this.selection.first_item(this.id);
                if (selectedItem) {
                    return selectedItem;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "collapsed", {
            /**
             * Gets if the dropdown is collapsed
             *
             * ```typescript
             * let isCollapsed = this.dropdown.collapsed;
             * ```
             */
            get: function () {
                return this.toggleDirective.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "scrollContainer", {
            /** @hidden @internal */
            get: function () {
                return this.scrollContainerRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDropDownComponent.prototype, "collectionLength", {
            get: function () {
                if (this.virtDir) {
                    return this.virtDir.totalItemCount || this.virtDir.igxForOf.length;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Opens the dropdown
         *
         * ```typescript
         * this.dropdown.open();
         * ```
         */
        IgxDropDownComponent.prototype.open = function (overlaySettings) {
            this.toggleDirective.open(overlaySettings);
            this.updateScrollPosition();
        };
        /**
         * Closes the dropdown
         *
         * ```typescript
         * this.dropdown.close();
         * ```
         */
        IgxDropDownComponent.prototype.close = function () {
            this.toggleDirective.close();
        };
        /**
         * Toggles the dropdown
         *
         * ```typescript
         * this.dropdown.toggle();
         * ```
         */
        IgxDropDownComponent.prototype.toggle = function (overlaySettings) {
            if (this.collapsed || this.toggleDirective.isClosing) {
                this.open(overlaySettings);
            }
            else {
                this.close();
            }
        };
        /**
         * Select an item by index
         * @param index of the item to select; If the drop down uses *igxFor, pass the index in data
         */
        IgxDropDownComponent.prototype.setSelectedItem = function (index) {
            if (index < 0 || index >= this.items.length) {
                return;
            }
            var newSelection;
            if (this.virtDir) {
                newSelection = {
                    value: this.virtDir.igxForOf[index],
                    index: index
                };
            }
            else {
                newSelection = this.items[index];
            }
            this.selectItem(newSelection);
        };
        /**
         * Navigates to the item on the specified index
         * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.
         * @param newIndex number
         */
        IgxDropDownComponent.prototype.navigateItem = function (index) {
            var _this = this;
            if (this.virtDir) {
                if (index === -1 || index >= this.collectionLength) {
                    return;
                }
                var direction_1 = index > (this.focusedItem ? this.focusedItem.index : -1) ? Navigate.Down : Navigate.Up;
                var subRequired = this.isIndexOutOfBounds(index, direction_1);
                this.focusedItem = {
                    value: this.virtDir.igxForOf[index],
                    index: index
                };
                if (subRequired) {
                    this.virtDir.scrollTo(index);
                }
                if (subRequired) {
                    this.virtDir.onChunkLoad.pipe(operators.take(1)).subscribe(function () {
                        _this.skipHeader(direction_1);
                    });
                }
                else {
                    this.skipHeader(direction_1);
                }
            }
            else {
                _super.prototype.navigateItem.call(this, index);
            }
            if (this.allowItemsFocus && this.focusedItem) {
                this.focusedItem.element.nativeElement.focus();
                this.cdr.markForCheck();
            }
        };
        IgxDropDownComponent.prototype.isIndexOutOfBounds = function (index, direction) {
            var virtState = this.virtDir.state;
            var currentPosition = this.virtDir.getScroll().scrollTop;
            var itemPosition = this.virtDir.getScrollForIndex(index, direction === Navigate.Down);
            var indexOutOfChunk = index < virtState.startIndex || index > virtState.chunkSize + virtState.startIndex;
            var scrollNeeded = direction === Navigate.Down ? currentPosition < itemPosition : currentPosition > itemPosition;
            var subRequired = indexOutOfChunk || scrollNeeded;
            return subRequired;
        };
        IgxDropDownComponent.prototype.skipHeader = function (direction) {
            if (!this.focusedItem) {
                return;
            }
            if (this.focusedItem.isHeader || this.focusedItem.disabled) {
                if (direction === Navigate.Up) {
                    this.navigatePrev();
                }
                else {
                    this.navigateNext();
                }
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.updateScrollPosition = function () {
            if (!this.virtDir) {
                return;
            }
            if (!this.selectedItem) {
                this.virtDir.scrollTo(0);
                return;
            }
            var targetScroll = this.virtDir.getScrollForIndex(this.selectedItem.index);
            var itemsInView = this.virtDir.igxForContainerSize / this.virtDir.igxForItemSize;
            targetScroll -= (itemsInView / 2 - 1) * this.virtDir.igxForItemSize;
            this.virtDir.getScroll().scrollTop = targetScroll;
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.onToggleOpening = function (e) {
            this.onOpening.emit(e);
            if (e.cancel) {
                return;
            }
            if (this.virtDir) {
                this.virtDir.scrollPosition = this._scrollPosition;
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.onToggleContentAppended = function () {
            if (!this.virtDir && this.selectedItem) {
                this.scrollToItem(this.selectedItem);
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.onToggleOpened = function () {
            if (this.selectedItem) {
                this.focusedItem = this.selectedItem;
                this._focusedItem.focused = true;
            }
            else if (this.allowItemsFocus) {
                this.navigateFirst();
            }
            this.onOpened.emit();
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.onToggleClosing = function (e) {
            this.onClosing.emit(e);
            if (this.virtDir) {
                this._scrollPosition = this.virtDir.scrollPosition;
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.onToggleClosed = function () {
            if (this._focusedItem) {
                this._focusedItem.focused = false;
            }
            this.onClosed.emit();
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
            this.selection.clear(this.id);
            this.selection.clear(this.id + "-active");
        };
        IgxDropDownComponent.prototype.scrollToItem = function (item) {
            var _this = this;
            var itemPosition = this.calculateScrollPosition(item);
            //  in IE11 setting sctrollTop is somehow slow and forces dropdown
            //  to appear on screen before animation start. As a result dropdown
            //  flickers badly. This is why we set scrollTop just a little later
            //  allowing animation to start and prevent dropdown flickering
            if (isIE()) {
                setTimeout(function () {
                    _this.scrollContainer.scrollTop = (itemPosition);
                }, 1);
            }
            else {
                this.scrollContainer.scrollTop = (itemPosition);
            }
        };
        /** @hidden @internal */
        IgxDropDownComponent.prototype.calculateScrollPosition = function (item) {
            if (!item) {
                return 0;
            }
            var elementRect = item.element.nativeElement.getBoundingClientRect();
            var parentRect = this.scrollContainer.getBoundingClientRect();
            var scrollDelta = parentRect.top - elementRect.top;
            var scrollPosition = this.scrollContainer.scrollTop - scrollDelta;
            var dropDownHeight = this.scrollContainer.clientHeight;
            scrollPosition -= dropDownHeight / 2;
            scrollPosition += item.elementHeight / 2;
            return Math.floor(scrollPosition);
        };
        /**
         * @hidden @internal
         */
        // temp workaround until fix --> https://github.com/angular/angular/issues/34992
        IgxDropDownComponent.prototype.ngOnChanges = function (changes) {
            if (changes.id) {
                this.toggleDirective.id = changes.id.currentValue;
            }
        };
        IgxDropDownComponent.prototype.ngAfterViewInit = function () {
            if (this.virtDir) {
                this.virtDir.igxForItemSize = 28;
            }
        };
        /** Keydown Handler */
        IgxDropDownComponent.prototype.onItemActionKey = function (key, event) {
            _super.prototype.onItemActionKey.call(this, key, event);
            this.close();
        };
        /**
         * Virtual scroll implementation
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.navigateFirst = function () {
            if (this.virtDir) {
                this.navigateItem(0);
            }
            else {
                _super.prototype.navigateFirst.call(this);
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.navigateLast = function () {
            if (this.virtDir) {
                this.navigateItem(this.virtDir.totalItemCount ? this.virtDir.totalItemCount - 1 : this.virtDir.igxForOf.length - 1);
            }
            else {
                _super.prototype.navigateLast.call(this);
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.navigateNext = function () {
            if (this.virtDir) {
                this.navigateItem(this._focusedItem ? this._focusedItem.index + 1 : 0);
            }
            else {
                _super.prototype.navigateNext.call(this);
            }
        };
        /**
         * @hidden @internal
         */
        IgxDropDownComponent.prototype.navigatePrev = function () {
            if (this.virtDir) {
                this.navigateItem(this._focusedItem ? this._focusedItem.index - 1 : 0);
            }
            else {
                _super.prototype.navigatePrev.call(this);
            }
        };
        /**
         * Handles the `onSelection` emit and the drop down toggle when selection changes
         * @hidden
         * @internal
         * @param newSelection
         * @param event
         */
        IgxDropDownComponent.prototype.selectItem = function (newSelection, event) {
            var oldSelection = this.selectedItem;
            if (!newSelection) {
                newSelection = this.focusedItem;
            }
            if (newSelection === null) {
                return;
            }
            if (newSelection instanceof IgxDropDownItemBaseDirective && newSelection.isHeader) {
                return;
            }
            if (this.virtDir) {
                newSelection = {
                    value: newSelection.value,
                    index: newSelection.index
                };
            }
            var args = { oldSelection: oldSelection, newSelection: newSelection, cancel: false };
            this.onSelection.emit(args);
            if (!args.cancel) {
                if (this.isSelectionValid(args.newSelection)) {
                    this.selection.set(this.id, new Set([args.newSelection]));
                    if (!this.virtDir) {
                        if (oldSelection) {
                            oldSelection.selected = false;
                        }
                        if (args.newSelection) {
                            args.newSelection.selected = true;
                        }
                    }
                    if (event) {
                        this.toggleDirective.close();
                    }
                }
                else {
                    throw new Error('Please provide a valid drop-down item for the selection!');
                }
            }
        };
        /**
         * Clears the selection of the dropdown
         * ```typescript
         * this.dropdown.clearSelection();
         * ```
         */
        IgxDropDownComponent.prototype.clearSelection = function () {
            var oldSelection = this.selectedItem;
            var newSelection = null;
            var args = { oldSelection: oldSelection, newSelection: newSelection, cancel: false };
            this.onSelection.emit(args);
            if (this.selectedItem && !args.cancel) {
                this.selectedItem.selected = false;
                this.selection.clear(this.id);
            }
        };
        /**
         * Checks whether the selection is valid
         * `null` - the selection should be emptied
         * Virtual? - the selection should at least have and `index` and `value` property
         * Non-virtual? - the selection should be a valid drop-down item and **not** be a header
         */
        IgxDropDownComponent.prototype.isSelectionValid = function (selection) {
            return selection === null
                || (this.virtDir && selection.hasOwnProperty('value') && selection.hasOwnProperty('index'))
                || (selection instanceof IgxDropDownItemComponent && !selection.isHeader);
        };
        var IgxDropDownComponent_1;
        IgxDropDownComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: IgxSelectionAPIService },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.ContentChild(IgxForOfDirective, { read: IgxForOfDirective })
        ], IgxDropDownComponent.prototype, "virtDir", void 0);
        __decorate([
            core.ViewChild(IgxToggleDirective, { static: true })
        ], IgxDropDownComponent.prototype, "toggleDirective", void 0);
        __decorate([
            core.ViewChild('scrollContainer', { static: true })
        ], IgxDropDownComponent.prototype, "scrollContainerRef", void 0);
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return IgxDropDownItemComponent; }), { descendants: true })
        ], IgxDropDownComponent.prototype, "children", void 0);
        __decorate([
            core.Output()
        ], IgxDropDownComponent.prototype, "onOpening", void 0);
        __decorate([
            core.Output()
        ], IgxDropDownComponent.prototype, "onOpened", void 0);
        __decorate([
            core.Output()
        ], IgxDropDownComponent.prototype, "onClosing", void 0);
        __decorate([
            core.Output()
        ], IgxDropDownComponent.prototype, "onClosed", void 0);
        __decorate([
            core.Input()
        ], IgxDropDownComponent.prototype, "allowItemsFocus", void 0);
        __decorate([
            core.Input()
        ], IgxDropDownComponent.prototype, "id", null);
        IgxDropDownComponent = IgxDropDownComponent_1 = __decorate([
            core.Component({
                selector: 'igx-drop-down',
                template: "<div class=\"igx-drop-down__list\" igxToggle [style.width]=\"width\"\n(onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\" (onAppended)=\"onToggleContentAppended()\"\n(onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <div class=\"igx-drop-down__list-scroll\" #scrollContainer [attr.id]=\"this.listId\" role=\"listbox\"\n    [style.height]=\"height\"\n    [style.maxHeight]=\"maxHeight\">\n        <ng-container *ngIf=\"!collapsed\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</div>\n",
                providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxDropDownComponent_1 }]
            }),
            __param(3, core.Optional()), __param(3, core.Inject(DisplayDensityToken))
        ], IgxDropDownComponent);
        return IgxDropDownComponent;
    }(IgxDropDownBaseDirective));

    /**
     * Navigation Directive that handles keyboard events on its host and controls a targeted IgxDropDownBaseDirective component
     */
    var IgxDropDownItemNavigationDirective = /** @class */ (function () {
        function IgxDropDownItemNavigationDirective(dropdown) {
            this.dropdown = dropdown;
            this._target = null;
        }
        Object.defineProperty(IgxDropDownItemNavigationDirective.prototype, "target", {
            /**
             * Gets the target of the navigation directive;
             *
             * ```typescript
             * // Get
             * export class MyComponent {
             *  ...
             *  @ContentChild(IgxDropDownNavigationDirective)
             *  navDirective: IgxDropDownNavigationDirective = null
             *  ...
             *  const navTarget: IgxDropDownBaseDirective = navDirective.navTarget
             * }
             * ```
             */
            get: function () {
                return this._target;
            },
            /**
             * Sets the target of the navigation directive;
             * If no valid target is passed, it falls back to the drop down context
             *
             * ```html
             * <!-- Set -->
             * <input [igxDropDownItemNavigation]="dropdown" />
             * ...
             * <igx-drop-down #dropdown>
             * ...
             * </igx-drop-down>
             * ```
             */
            set: function (target) {
                this._target = target ? target : this.dropdown;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Captures keydown events and calls the appropriate handlers on the target component
         */
        IgxDropDownItemNavigationDirective.prototype.handleKeyDown = function (event) {
            if (event) {
                var key = event.key.toLowerCase();
                if (!this.target.collapsed) { // If dropdown is opened
                    var navKeys = ['esc', 'escape', 'enter', 'space', 'spacebar', ' ',
                        'arrowup', 'up', 'arrowdown', 'down', 'home', 'end'];
                    if (navKeys.indexOf(key) === -1) { // If key has appropriate function in DD
                        return;
                    }
                    event.preventDefault();
                    event.stopPropagation();
                }
                else { // If dropdown is closed, do nothing
                    return;
                }
                switch (key) {
                    case 'esc':
                    case 'escape':
                        this.target.onItemActionKey(DropDownActionKey.ESCAPE, event);
                        break;
                    case 'enter':
                        this.target.onItemActionKey(DropDownActionKey.ENTER, event);
                        break;
                    case 'space':
                    case 'spacebar':
                    case ' ':
                        this.target.onItemActionKey(DropDownActionKey.SPACE, event);
                        break;
                    case 'arrowup':
                    case 'up':
                        this.onArrowUpKeyDown();
                        break;
                    case 'arrowdown':
                    case 'down':
                        this.onArrowDownKeyDown();
                        break;
                    case 'home':
                        this.onHomeKeyDown();
                        break;
                    case 'end':
                        this.onEndKeyDown();
                        break;
                    default:
                        return;
                }
            }
        };
        /**
         * Navigates to previous item
         */
        IgxDropDownItemNavigationDirective.prototype.onArrowDownKeyDown = function () {
            this.target.navigateNext();
        };
        /**
         * Navigates to previous item
         */
        IgxDropDownItemNavigationDirective.prototype.onArrowUpKeyDown = function () {
            this.target.navigatePrev();
        };
        /**
         * Navigates to target's last item
         */
        IgxDropDownItemNavigationDirective.prototype.onEndKeyDown = function () {
            this.target.navigateLast();
        };
        /**
         * Navigates to target's first item
         */
        IgxDropDownItemNavigationDirective.prototype.onHomeKeyDown = function () {
            this.target.navigateFirst();
        };
        IgxDropDownItemNavigationDirective.ctorParameters = function () { return [
            { type: IgxDropDownBaseDirective, decorators: [{ type: core.Self }, { type: core.Optional }, { type: core.Inject, args: [IGX_DROPDOWN_BASE,] }] }
        ]; };
        __decorate([
            core.Input('igxDropDownItemNavigation')
        ], IgxDropDownItemNavigationDirective.prototype, "target", null);
        __decorate([
            core.HostListener('keydown', ['$event'])
        ], IgxDropDownItemNavigationDirective.prototype, "handleKeyDown", null);
        IgxDropDownItemNavigationDirective = __decorate([
            core.Directive({
                selector: '[igxDropDownItemNavigation]'
            }),
            __param(0, core.Self()), __param(0, core.Optional()), __param(0, core.Inject(IGX_DROPDOWN_BASE))
        ], IgxDropDownItemNavigationDirective);
        return IgxDropDownItemNavigationDirective;
    }());

    /**
     * @hidden
     */
    var IgxDropDownModule = /** @class */ (function () {
        function IgxDropDownModule() {
        }
        IgxDropDownModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxDropDownBaseDirective,
                    IgxDropDownComponent,
                    IgxDropDownItemBaseDirective,
                    IgxDropDownItemComponent,
                    IgxDropDownGroupComponent,
                    IgxDropDownItemNavigationDirective
                ],
                exports: [
                    IgxDropDownComponent,
                    IgxDropDownItemComponent,
                    IgxDropDownGroupComponent,
                    IgxDropDownItemNavigationDirective
                ],
                imports: [
                    common.CommonModule,
                    IgxToggleModule
                ]
            })
        ], IgxDropDownModule);
        return IgxDropDownModule;
    }());

    var IgxHintPosition;
    (function (IgxHintPosition) {
        IgxHintPosition[IgxHintPosition["START"] = 0] = "START";
        IgxHintPosition[IgxHintPosition["END"] = 1] = "END";
    })(IgxHintPosition || (IgxHintPosition = {}));
    var IgxHintDirective = /** @class */ (function () {
        function IgxHintDirective(_element) {
            this._element = _element;
            this._position = IgxHintPosition.START;
            /**
             * Sets/gets whether the hint position is at the start.
             * Default value is `false`.
             * ```typescript
             * @ViewChild('hint', {read: IgxHintDirective})
             * public igxHint: IgxHintDirective;
             * this.igxHint.isPositionStart = true;
             * ```
             * ```typescript
             * let isHintPositionStart = this.igxHint.isPositionStart;
             * ```
             * @memberof IgxHintDirective
             */
            this.isPositionStart = false;
            /**
             * Sets/gets whether the hint position is at the end.
             * Default value is `false`.
             * ```typescript
             * @ViewChild('hint', {read: IgxHintDirective})
             * public igxHint: IgxHintDirective;
             * this.igxHint.isPositionEnd = true;
             * ```
             * ```typescript
             * let isHintPositionEnd = this.igxHint.isPositionEnd;
             * ```
             * @memberof IgxHintDirective
             */
            this.isPositionEnd = false;
        }
        Object.defineProperty(IgxHintDirective.prototype, "position", {
            /**
             * Gets the position of the hint.
             * ```typescript
             * @ViewChild('hint', {read: IgxHintDirective})
             * public igxHint: IgxHintDirective;
             * let hintPosition =  this.igxHint.position;
             * ```
             * @memberof IgxHintDirective
             */
            get: function () {
                return this._position.toString();
            },
            /**
             * Sets the position of the hint.
             * ```html
             * <igx-input-group>
             *  <input igxInput type="text"/>
             *  <igx-hint #hint [position]="'start'">IgxHint displayed at the start</igx-hint>
             * </igx-input-group>
             * ```
             * @memberof IgxHintDirective
             */
            set: function (value) {
                var position = IgxHintPosition[value.toUpperCase()];
                if (position !== undefined) {
                    this._position = position;
                    this._applyPosition(this._position);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxHintDirective.prototype.ngOnInit = function () {
            this._applyPosition(this._position);
        };
        IgxHintDirective.prototype._applyPosition = function (position) {
            this.isPositionStart = this.isPositionEnd = false;
            switch (position) {
                case IgxHintPosition.START:
                    this.isPositionStart = true;
                    break;
                case IgxHintPosition.END:
                    this.isPositionEnd = true;
                    break;
                default: break;
            }
        };
        IgxHintDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.HostBinding('class.igx-input-group__hint-item--start')
        ], IgxHintDirective.prototype, "isPositionStart", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group__hint-item--end')
        ], IgxHintDirective.prototype, "isPositionEnd", void 0);
        __decorate([
            core.Input('position')
        ], IgxHintDirective.prototype, "position", null);
        IgxHintDirective = __decorate([
            core.Directive({
                selector: 'igx-hint,[igxHint]'
            })
        ], IgxHintDirective);
        return IgxHintDirective;
    }());

    /** @hidden */
    var IgxInputGroupBase = /** @class */ (function () {
        function IgxInputGroupBase() {
        }
        return IgxInputGroupBase;
    }());

    var nativeValidationAttributes = ['required', 'pattern', 'minlength', 'maxlength', 'min', 'max', 'step'];

    (function (IgxInputState) {
        IgxInputState[IgxInputState["INITIAL"] = 0] = "INITIAL";
        IgxInputState[IgxInputState["VALID"] = 1] = "VALID";
        IgxInputState[IgxInputState["INVALID"] = 2] = "INVALID";
    })(exports.IgxInputState || (exports.IgxInputState = {}));
    /**
     * The `igxInput` directive creates single- or multiline text elements, covering common scenarios when dealing with form inputs.
     *
     * @igxModule IgxInputGroupModule
     *
     * @igxParent Data Entry & Display
     *
     * @igxTheme igx-input-group-theme
     *
     * @igxKeywords input, input group, form, field, validation
     *
     * @igxGroup presentation
     *
     * @example
     * ```html
     * <input-group>
     *  <label for="address">Adress</label>
     *  <input igxInput name="address" type="text" [(ngModel)]="customer.address">
     * </input-group>
     * ```
     */
    var IgxInputDirective = /** @class */ (function () {
        function IgxInputDirective(inputGroup, ngModel, formControl, element, cdr) {
            this.inputGroup = inputGroup;
            this.ngModel = ngModel;
            this.formControl = formControl;
            this.element = element;
            this.cdr = cdr;
            this._valid = exports.IgxInputState.INITIAL;
            /**
             * Sets/gets whether the `"igx-input-group__input"` class is added to the host element.
             * Default value is `false`.
             *
             * @example
             * ```typescript
             * this.igxInput.isInput = true;
             * ```
             *
             * @example
             * ```typescript
             * let isCLassAdded = this.igxInput.isInput;
             * ```
             */
            this.isInput = false;
            /**
             * Sets/gets whether the `"class.igx-input-group__textarea"` class is added to the host element.
             * Default value is `false`.
             *
             * @example
             * ```typescript
             * this.igxInput.isTextArea = true;
             * ```
             *
             * @example
             * ```typescript
             * let isCLassAdded = this.igxInput.isTextArea;
             * ```
             */
            this.isTextArea = false;
        }
        Object.defineProperty(IgxInputDirective.prototype, "ngControl", {
            get: function () {
                return this.ngModel ? this.ngModel : this.formControl;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "value", {
            /**
             * Gets the `value` propery.
             *
             * @example
             * ```typescript
             * @ViewChild('igxInput', {read: IgxInputDirective})
             *  public igxInput: IgxInputDirective;
             * let inputValue = this.igxInput.value;
             * ```
             */
            get: function () {
                return this.nativeElement.value;
            },
            /**
             * Sets the `value` property.
             *
             * @example
             * ```html
             * <input-group>
             *  <input igxInput #igxInput [value]="'IgxInput Value'">
             * </input-group>
             * ```
             */
            set: function (value) {
                this.nativeElement.value = value;
                this.checkValidity();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "disabled", {
            /**
             * Gets the `disabled` property
             *
             * @example
             * ```typescript
             * @ViewChild('igxInput', {read: IgxInputDirective})
             *  public igxInput: IgxInputDirective;
             * let isDisabled = this.igxInput.disabled;
             * ```
             */
            get: function () {
                return this.nativeElement.hasAttribute('disabled');
            },
            /**
             * Sets the `disabled` property.
             *
             * @example
             * ```html
             * <input-group>
             *  <input igxInput #igxInput [disabled]="true">
             * </input-group>
             * ```
             */
            set: function (value) {
                this.nativeElement.disabled = value;
                this.inputGroup.disabled = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "required", {
            /**
             * Gets whether the igxInput is required.
             *
             * @example
             * ```typescript
             * let isRequired = this.igxInput.required;
             * ```
             */
            get: function () {
                return this.nativeElement.hasAttribute('required');
            },
            /**
             * Sets the `required` property.
             *
             * @example
             * ```html
             * <input-group>
             *  <input igxInput #igxInput [required]="true">
             * </input-group>
             * ```
             */
            set: function (value) {
                if (typeof value === 'boolean') {
                    this.nativeElement.required = this.inputGroup.isRequired = value;
                    if (value && !this.nativeElement.checkValidity()) {
                        this._valid = exports.IgxInputState.INVALID;
                    }
                    else {
                        this._valid = exports.IgxInputState.INITIAL;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.onFocus = function (event) {
            this.inputGroup.isFocused = true;
        };
        /**
         * @param event The event to invoke the handler
         *
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.onBlur = function (event) {
            this.inputGroup.isFocused = false;
            this._valid = exports.IgxInputState.INITIAL;
            if (this.ngControl) {
                if (!this.ngControl.valid) {
                    this._valid = exports.IgxInputState.INVALID;
                }
            }
            else if (this._hasValidators() && !this.nativeElement.checkValidity()) {
                this._valid = exports.IgxInputState.INVALID;
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.onInput = function () {
            this.checkValidity();
        };
        /**
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.ngAfterViewInit = function () {
            this.inputGroup.hasPlaceholder = this.nativeElement.hasAttribute('placeholder');
            this.inputGroup.disabled = this.inputGroup.disabled || this.nativeElement.hasAttribute('disabled');
            this.inputGroup.isRequired = this.nativeElement.hasAttribute('required');
            // Make sure we do not invalidate the input on init
            if (!this.ngControl) {
                this._valid = exports.IgxInputState.INITIAL;
            }
            // Also check the control's validators for required
            if (!this.inputGroup.isRequired && this.ngControl && this.ngControl.control.validator) {
                var validation = this.ngControl.control.validator({});
                this.inputGroup.isRequired = validation && validation.required;
            }
            var elTag = this.nativeElement.tagName.toLowerCase();
            if (elTag === 'textarea') {
                this.isTextArea = true;
            }
            else {
                this.isInput = true;
            }
            if (this.ngControl) {
                this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            }
            this.cdr.detectChanges();
        };
        /**
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.ngOnDestroy = function () {
            if (this._statusChanges$) {
                this._statusChanges$.unsubscribe();
            }
        };
        /**
         * Sets a focus on the igxInput.
         *
         * @example
         * ```typescript
         * this.igxInput.focus();
         * ```
         */
        IgxInputDirective.prototype.focus = function () {
            this.nativeElement.focus();
        };
        Object.defineProperty(IgxInputDirective.prototype, "nativeElement", {
            /**
             * Gets the `nativeElement` of the igxInput.
             *
             * @example
             * ```typescript
             * let igxInputNativeElement = this.igxInput.nativeElement;
             * ```
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.onStatusChanged = function () {
            if (this.ngControl.control.validator || this.ngControl.control.asyncValidator) {
                if (this.ngControl.control.touched || this.ngControl.control.dirty) {
                    //  TODO: check the logic when control is touched or dirty
                    if (this.inputGroup.isFocused) {
                        // the user is still typing in the control
                        this._valid = this.ngControl.valid ? exports.IgxInputState.VALID : exports.IgxInputState.INVALID;
                    }
                    else {
                        // the user had touched the control previously but now the value is changing due to changes in the form
                        this._valid = this.ngControl.valid ? exports.IgxInputState.INITIAL : exports.IgxInputState.INVALID;
                    }
                }
                else {
                    //  if control is untouched and pristine its state is initial. This is when user did not interact
                    //  with the input or when form/control is reset
                    this._valid = exports.IgxInputState.INITIAL;
                }
            }
        };
        Object.defineProperty(IgxInputDirective.prototype, "hasPlaceholder", {
            /**
             * Gets whether the igxInput has a placeholder.
             *
             * @example
             * ```typescript
             * let hasPlaceholder = this.igxInput.hasPlaceholder;
             * ```
             */
            get: function () {
                return this.nativeElement.hasAttribute('placeholder');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "placeholder", {
            /**
             * Gets the placeholder element of the igxInput.
             *
             * @example
             * ```typescript
             * let igxInputPlaceholder = this.igxInput.placeholder;
             * ```
             */
            get: function () {
                return this.nativeElement.placeholder;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @returns An indicator of whether the input has validator attributes or not
         *
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype._hasValidators = function () {
            var e_1, _a;
            try {
                for (var nativeValidationAttributes_1 = __values(nativeValidationAttributes), nativeValidationAttributes_1_1 = nativeValidationAttributes_1.next(); !nativeValidationAttributes_1_1.done; nativeValidationAttributes_1_1 = nativeValidationAttributes_1.next()) {
                    var nativeValidationAttribute = nativeValidationAttributes_1_1.value;
                    if (this.nativeElement.hasAttribute(nativeValidationAttribute)) {
                        return true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (nativeValidationAttributes_1_1 && !nativeValidationAttributes_1_1.done && (_a = nativeValidationAttributes_1.return)) _a.call(nativeValidationAttributes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return !!this.ngControl && (!!this.ngControl.control.validator || !!this.ngControl.control.asyncValidator);
        };
        Object.defineProperty(IgxInputDirective.prototype, "focused", {
            /**
             * Gets whether the igxInput is focused.
             *
             * @example
             * ```typescript
             * let isFocused = this.igxInput.focused;
             * ```
             */
            get: function () {
                return this.inputGroup.isFocused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "valid", {
            /**
             * Gets the state of the igxInput.
             *
             * @example
             * ```typescript
             * let igxInputState = this.igxInput.valid;
             * ```
             */
            get: function () {
                return this._valid;
            },
            /**
             * Sets the state of the igxInput.
             *
             * @example
             * ```typescript
             * this.igxInput.valid = IgxInputState.INVALID;
             * ```
             */
            set: function (value) {
                this._valid = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputDirective.prototype, "isValid", {
            /**
             * Gets whether the igxInput is valid.
             *
             * @example
             * ```typescript
             * let valid = this.igxInput.isValid;
             * ```
             */
            get: function () {
                return this.valid !== exports.IgxInputState.INVALID;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * A function to assign a validity property of an input.
         *
         * @hidden
         * @internal
         */
        IgxInputDirective.prototype.checkValidity = function () {
            if (!this.ngControl && this._hasValidators()) {
                this._valid = this.nativeElement.checkValidity() ? exports.IgxInputState.VALID : exports.IgxInputState.INVALID;
            }
        };
        IgxInputDirective.ctorParameters = function () { return [
            { type: IgxInputGroupBase },
            { type: forms.NgModel, decorators: [{ type: core.Optional }, { type: core.Self }, { type: core.Inject, args: [forms.NgModel,] }] },
            { type: forms.FormControlName, decorators: [{ type: core.Optional }, { type: core.Self }, { type: core.Inject, args: [forms.FormControlName,] }] },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input('value')
        ], IgxInputDirective.prototype, "value", null);
        __decorate([
            core.Input()
        ], IgxInputDirective.prototype, "disabled", null);
        __decorate([
            core.Input()
        ], IgxInputDirective.prototype, "required", null);
        __decorate([
            core.HostBinding('class.igx-input-group__input')
        ], IgxInputDirective.prototype, "isInput", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group__textarea')
        ], IgxInputDirective.prototype, "isTextArea", void 0);
        __decorate([
            core.HostListener('focus', ['$event'])
        ], IgxInputDirective.prototype, "onFocus", null);
        __decorate([
            core.HostListener('blur', ['$event'])
        ], IgxInputDirective.prototype, "onBlur", null);
        __decorate([
            core.HostListener('input')
        ], IgxInputDirective.prototype, "onInput", null);
        IgxInputDirective = __decorate([
            core.Directive({
                selector: '[igxInput]',
                exportAs: 'igxInput'
            }),
            __param(1, core.Optional()), __param(1, core.Self()), __param(1, core.Inject(forms.NgModel)),
            __param(2, core.Optional()), __param(2, core.Self()), __param(2, core.Inject(forms.FormControlName))
        ], IgxInputDirective);
        return IgxInputDirective;
    }());

    var NEXT_ID$3 = 0;
    var IgxLabelDirective = /** @class */ (function () {
        function IgxLabelDirective() {
            this.defaultClass = true;
            /**
             * @hidden
             */
            this.id = "igx-label-" + NEXT_ID$3++;
        }
        __decorate([
            core.HostBinding('class.igx-input-group__label')
        ], IgxLabelDirective.prototype, "defaultClass", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxLabelDirective.prototype, "id", void 0);
        IgxLabelDirective = __decorate([
            core.Directive({
                selector: '[igxLabel]'
            })
        ], IgxLabelDirective);
        return IgxLabelDirective;
    }());

    /**
     * @hidden
     */
    var IgxPrefixDirective = /** @class */ (function () {
        function IgxPrefixDirective() {
        }
        IgxPrefixDirective = __decorate([
            core.Directive({
                selector: 'igx-prefix,[igxPrefix]'
            })
        ], IgxPrefixDirective);
        return IgxPrefixDirective;
    }());
    /**
     * @hidden
     */
    var IgxPrefixModule = /** @class */ (function () {
        function IgxPrefixModule() {
        }
        IgxPrefixModule = __decorate([
            core.NgModule({
                declarations: [IgxPrefixDirective],
                exports: [IgxPrefixDirective]
            })
        ], IgxPrefixModule);
        return IgxPrefixModule;
    }());

    /**
     * @hidden
     */
    var IgxSuffixDirective = /** @class */ (function () {
        function IgxSuffixDirective() {
        }
        IgxSuffixDirective = __decorate([
            core.Directive({
                selector: 'igx-suffix,[igxSuffix]'
            })
        ], IgxSuffixDirective);
        return IgxSuffixDirective;
    }());
    /**
     * @hidden
     */
    var IgxSuffixModule = /** @class */ (function () {
        function IgxSuffixModule() {
        }
        IgxSuffixModule = __decorate([
            core.NgModule({
                declarations: [IgxSuffixDirective],
                exports: [IgxSuffixDirective]
            })
        ], IgxSuffixModule);
        return IgxSuffixModule;
    }());

    var NEXT_ID$4 = 0;
    var IgxInputGroupType;
    (function (IgxInputGroupType) {
        IgxInputGroupType[IgxInputGroupType["LINE"] = 0] = "LINE";
        IgxInputGroupType[IgxInputGroupType["BOX"] = 1] = "BOX";
        IgxInputGroupType[IgxInputGroupType["BORDER"] = 2] = "BORDER";
        IgxInputGroupType[IgxInputGroupType["FLUENT"] = 3] = "FLUENT";
        IgxInputGroupType[IgxInputGroupType["BOOTSTRAP"] = 4] = "BOOTSTRAP";
        IgxInputGroupType[IgxInputGroupType["SEARCH"] = 5] = "SEARCH";
        IgxInputGroupType[IgxInputGroupType["FLUENT_SEARCH"] = 6] = "FLUENT_SEARCH";
    })(IgxInputGroupType || (IgxInputGroupType = {}));
    var IgxInputGroupComponent = /** @class */ (function (_super) {
        __extends(IgxInputGroupComponent, _super);
        function IgxInputGroupComponent(_element, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this._element = _element;
            _this._displayDensityOptions = _displayDensityOptions;
            _this._type = IgxInputGroupType.LINE;
            _this._filled = false;
            _this._supressInputAutofocus = false;
            /**
             * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
             * ```html
             * <igx-input-group [id]="'igx-input-group-55'"></igx-input-group>
             * ```
             */
            _this.id = "igx-input-group-" + NEXT_ID$4++;
            /**
             * Property that enables/disables the autogenerated class of the `IgxInputGroupComponent`.
             * By default applied the class is applied.
             *```typescript
             *@ViewChild("MyInputGroup")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *this.inputGroup.defaultClass = false;
             *```
             *}
             */
            _this.defaultClass = true;
            /**
             * @hidden
             */
            _this.hasPlaceholder = false;
            /**
             * @hidden
             */
            _this.isRequired = false;
            /**
             * @hidden
             */
            _this.isFocused = false;
            /**
             * @hidden
             */
            _this.isBox = false;
            /**
             * @hidden
             */
            _this.isBorder = false;
            /**
             * @hidden
             */
            _this.isSearch = false;
            /**
             * @hidden
             */
            _this.isFluentSearch = false;
            /**
             * @hidden
             */
            _this.isFluent = false;
            /**
             * @hidden
             */
            _this.isBootstrap = false;
            /**
             * An @Input property that disables the `IgxInputGroupComponent`.
             * ```html
             * <igx-input-group [disabled]="'true'"></igx-input-group>
             * ```
             */
            _this.disabled = false;
            /**
             * @hidden
             */
            _this.hasWarning = false;
            _this.element = _element;
            return _this;
        }
        IgxInputGroupComponent_1 = IgxInputGroupComponent;
        Object.defineProperty(IgxInputGroupComponent.prototype, "validClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.input.valid === exports.IgxInputState.VALID;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "invalidClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.input.valid === exports.IgxInputState.INVALID;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxInputGroupComponent.prototype.onClick = function (event) {
            if (!this._supressInputAutofocus) {
                this.input.focus();
            }
        };
        Object.defineProperty(IgxInputGroupComponent.prototype, "type", {
            /**
             * Returns the type of the `IgxInputGroupComponent`. How the input is styled.
             * Values are `line` - 0, `box` - 1, `border` - 2,  `fluent` - 3 `fluentSearch` - 4 and `search` - 5. The default is `line`.
             * ```typescript
             *@ViewChild("MyInputGroup")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *    let inputType = this.inputGroup.type;
             *}
             * ```
             */
            get: function () {
                return this._type.toString();
            },
            /**
             * An @Input property that sets how the input will be styled.
             * The allowed values are `line`, `box`, `border`, `fluent`, `search` and `fluentSearch`. The default is `line`.
             * ```html
             *<igx-input-group [type]="'search'">
             * ```
             */
            set: function (value) {
                var type = IgxInputGroupType[value.toUpperCase()];
                if (type !== undefined) {
                    this.isBox = this.isBootstrap = this.isFluent = this.isFluentSearch = this.isBorder = this.isSearch = false;
                    switch (type) {
                        case IgxInputGroupType.BOX:
                            this.isBox = true;
                            break;
                        case IgxInputGroupType.BORDER:
                            this.isBorder = true;
                            break;
                        case IgxInputGroupType.FLUENT:
                            this.isFluent = true;
                            break;
                        case IgxInputGroupType.FLUENT_SEARCH:
                            this.isFluentSearch = true;
                            break;
                        case IgxInputGroupType.SEARCH:
                            this.isSearch = true;
                            break;
                        case IgxInputGroupType.BOOTSTRAP:
                            this.isBootstrap = true;
                            break;
                        default: break;
                    }
                    this._type = type;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "supressInputAutofocus", {
            /**
             * Returns whether the input element of the input group will be automatically focused on click.
             * ```typescript
             * let supressInputAutofocus = this.inputGroup.supressInputAutofocus;
             * ```
             */
            get: function () {
                return this._supressInputAutofocus;
            },
            /**
             * Sets whether the input element of the input group will be automatically focused on click.
             * ```html
             * <igx-input-group [supressInputAutofocus]="true"></igx-input-group>
             * ```
             */
            set: function (value) {
                this._supressInputAutofocus = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isFilled", {
            /**
             *@hidden
             */
            get: function () {
                return this._filled || (this.input && this.input.value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isDisplayDensityCosy", {
            /**
             *@hidden
             */
            get: function () {
                return this.displayDensity === exports.DisplayDensity.cosy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isDisplayDensityComfortable", {
            /**
             *@hidden
             */
            get: function () {
                return this.displayDensity === exports.DisplayDensity.comfortable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isDisplayDensityCompact", {
            /**
             *@hidden
             */
            get: function () {
                return this.displayDensity === exports.DisplayDensity.compact;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "hasHints", {
            /**
             * Returns whether the `IgxInputGroupComponent` has hints.
             * ```typescript
             *@ViewChild("MyInputGroup")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *    let inputHints = this.inputGroup.hasHints;
             *}
             * ```
             */
            get: function () {
                return this.hints.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "hasBorder", {
            /**
             * Returns whether the `IgxInputGroupComponent` has border.
             * ```typescript
             *@ViewChild("MyInputGroup")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *    let inputBroder = this.inputGroup.hasBorder;
             *}
             * ```
             */
            get: function () {
                return this._type === IgxInputGroupType.LINE ||
                    this._type === IgxInputGroupType.BOX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeLine", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is line.
             * ```typescript
             *@ViewChild("MyInputGroup1")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *    let isTypeLine = this.inputGroup.isTypeLine;
             *}
             * ```
             */
            get: function () {
                return this._type === IgxInputGroupType.LINE;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeBox", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is box.
             * ```typescript
             *@ViewChild("MyInputGroup1")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *    let isTypeBox = this.inputGroup.isTypeBox;
             *}
             *```
             */
            get: function () {
                return this._type === IgxInputGroupType.BOX;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeBorder", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is border.
             * ```typescript
             *@ViewChild("MyInputGroup1")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *    let isTypeBorder = this.inputGroup.isTypeBorder;
             *}
             * ```
             */
            get: function () {
                return this._type === IgxInputGroupType.BORDER;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeFluent", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is Fluent.
             * ```typescript
             *@ViewChild("MyInputGroup1")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *    let isTypeFluent = this.inputGroup.isTypeFluent;
             *}
             * ```
             */
            get: function () {
                return this._type === IgxInputGroupType.FLUENT;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeBootstrap", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is Bootstrap.
             * ```typescript
             *@ViewChild("MyInputGroup1")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *    let isTypeBootstrap = this.inputGroup.isTypeBootstrap;
             *}
             * ```
             */
            get: function () {
                return this._type === IgxInputGroupType.BOOTSTRAP;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isNotMaterial", {
            get: function () {
                return this._type === IgxInputGroupType.FLUENT || this._type === IgxInputGroupType.BOOTSTRAP;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeSearch", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is search.
             * ```typescript
             *@ViewChild("MyInputGroup1")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *    let isTypeSearch = this.inputGroup.isTypeSearch;
             *}
             * ```
             */
            get: function () {
                return this._type === IgxInputGroupType.SEARCH;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeFluentSearch", {
            /**
             * Returns whether the `IgxInputGroupComponent` type is fluentSearch.
             * ```typescript
             *@ViewChild("MyInputGroup1")
             *public inputGroup: IgxInputGroupComponent;
             *ngAfterViewInit(){
             *    let isTypeFluentSearch = this.inputGroup.isTypeFluentSearch;
             *}
             * ```
             */
            get: function () {
                return this._type === IgxInputGroupType.FLUENT_SEARCH;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxInputGroupComponent.prototype, "filled", {
            get: function () {
                return this._filled;
            },
            set: function (val) {
                this._filled = val;
            },
            enumerable: true,
            configurable: true
        });
        var IgxInputGroupComponent_1;
        IgxInputGroupComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxInputGroupComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group')
        ], IgxInputGroupComponent.prototype, "defaultClass", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--placeholder')
        ], IgxInputGroupComponent.prototype, "hasPlaceholder", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--required')
        ], IgxInputGroupComponent.prototype, "isRequired", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--focused')
        ], IgxInputGroupComponent.prototype, "isFocused", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--box')
        ], IgxInputGroupComponent.prototype, "isBox", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--border')
        ], IgxInputGroupComponent.prototype, "isBorder", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--search')
        ], IgxInputGroupComponent.prototype, "isSearch", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--fluent-search')
        ], IgxInputGroupComponent.prototype, "isFluentSearch", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--fluent')
        ], IgxInputGroupComponent.prototype, "isFluent", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--bootstrap')
        ], IgxInputGroupComponent.prototype, "isBootstrap", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--disabled'),
            core.Input()
        ], IgxInputGroupComponent.prototype, "disabled", void 0);
        __decorate([
            core.HostBinding('class.igx-input-group--valid')
        ], IgxInputGroupComponent.prototype, "validClass", null);
        __decorate([
            core.HostBinding('class.igx-input-group--invalid')
        ], IgxInputGroupComponent.prototype, "invalidClass", null);
        __decorate([
            core.HostBinding('class.igx-input-group--warning')
        ], IgxInputGroupComponent.prototype, "hasWarning", void 0);
        __decorate([
            core.ContentChildren(IgxHintDirective, { read: IgxHintDirective })
        ], IgxInputGroupComponent.prototype, "hints", void 0);
        __decorate([
            core.ContentChild(IgxInputDirective, { read: IgxInputDirective, static: true })
        ], IgxInputGroupComponent.prototype, "input", void 0);
        __decorate([
            core.HostListener('click', ['$event'])
        ], IgxInputGroupComponent.prototype, "onClick", null);
        __decorate([
            core.Input('type')
        ], IgxInputGroupComponent.prototype, "type", null);
        __decorate([
            core.Input()
        ], IgxInputGroupComponent.prototype, "supressInputAutofocus", null);
        __decorate([
            core.HostBinding('class.igx-input-group--filled')
        ], IgxInputGroupComponent.prototype, "isFilled", null);
        __decorate([
            core.HostBinding('class.igx-input-group--cosy')
        ], IgxInputGroupComponent.prototype, "isDisplayDensityCosy", null);
        __decorate([
            core.HostBinding('class.igx-input-group--comfortable')
        ], IgxInputGroupComponent.prototype, "isDisplayDensityComfortable", null);
        __decorate([
            core.HostBinding('class.igx-input-group--compact')
        ], IgxInputGroupComponent.prototype, "isDisplayDensityCompact", null);
        IgxInputGroupComponent = IgxInputGroupComponent_1 = __decorate([
            core.Component({
                selector: 'igx-input-group',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__hint\">\n    <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #inputBundle>\n    <ng-container *ngIf=\"!isNotMaterial\">\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n    </ng-container>\n\n    <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container *ngIf=\"isNotMaterial\">\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n    </ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n        <div *ngIf=\"!isTypeBootstrap; else inputBundle\" class=\"igx-input-group__bundle-main\">\n\n            <ng-container *ngIf=\"!isNotMaterial\">\n                <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            </ng-container>\n\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        </div>\n\n        <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </div>\n    <div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n</ng-template>\n",
                providers: [{ provide: IgxInputGroupBase, useExisting: IgxInputGroupComponent_1 }]
            }),
            __param(1, core.Optional()), __param(1, core.Inject(DisplayDensityToken))
        ], IgxInputGroupComponent);
        return IgxInputGroupComponent;
    }(DisplayDensityBase));
    /**
     * @hidden
     */
    var IgxInputGroupModule = /** @class */ (function () {
        function IgxInputGroupModule() {
        }
        IgxInputGroupModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxInputGroupComponent,
                    IgxHintDirective,
                    IgxInputDirective,
                    IgxLabelDirective
                ],
                exports: [
                    IgxInputGroupComponent,
                    IgxHintDirective,
                    IgxInputDirective,
                    IgxLabelDirective,
                    IgxPrefixModule,
                    IgxSuffixModule
                ],
                imports: [
                    common.CommonModule,
                    IgxPrefixModule,
                    IgxSuffixModule
                ]
            })
        ], IgxInputGroupModule);
        return IgxInputGroupModule;
    }());

    /**
     * **Ignite UI for Angular Autocomplete** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/autocomplete.html)
     *
     * The igxAutocomplete directive provides a way to enhance a text input
     * by showing a drop down of suggested options, provided by the developer.
     *
     * Example:
     * ```html
     * <input type="text" [igxAutocomplete]="townsPanel" />
     * <igx-drop-down #townsPanel>
     *     <igx-drop-down-item *ngFor="let town of towns | startsWith:townSelected" [value]="town">
     *         {{town}}
     *     </igx-drop-down-item>
     * </igx-drop-down>
     * ```
     */
    var IgxAutocompleteDirective = /** @class */ (function (_super) {
        __extends(IgxAutocompleteDirective, _super);
        function IgxAutocompleteDirective(ngModel, formControl, group, elementRef, cdr) {
            var _this = _super.call(this, null) || this;
            _this.ngModel = ngModel;
            _this.formControl = formControl;
            _this.group = group;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.defaultSettings = {
                modal: false,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new AutoPositionStrategy({ target: _this.parentElement }),
                excludePositionTarget: true
            };
            _this.dropDownOpened$ = new rxjs.Subject();
            /**
             * Enables/disables autocomplete component
             *
             * ```typescript
             * // get
             * let disabled = this.autocomplete.disabled;
             * ```
             * ```html
             * <!--set-->
             * <input type="text" [igxAutocomplete]="townsPanel" [igxAutocompleteDisabled]="disabled"/>
             * ```
             * ```typescript
             * // set
             * public disabled = true;
             * ```
             */
            _this.disabled = false;
            /**
             * Emitted after item from the drop down is selected
             *
             * ```html
             * <input igxInput [igxAutocomplete]="townsPanel" (onItemSelected)='itemSelected($event)' />
             * ```
             */
            _this.onItemSelected = new core.EventEmitter();
            /** @hidden @internal */
            _this.autofill = 'off';
            /** @hidden  @internal */
            _this.role = 'combobox';
            _this.select = function (value) {
                if (!value.newSelection) {
                    return;
                }
                value.cancel = true; // Disable selection in the drop down, because in autocomplete we do not save selection.
                var newValue = value.newSelection.value;
                var args = { value: newValue, cancel: false };
                _this.onItemSelected.emit(args);
                if (args.cancel) {
                    return;
                }
                _this.close();
                _this.nativeElement.focus();
                // Update model after the input is re-focused, in order to have proper valid styling.
                // Otherwise when item is selected using mouse (and input is blurred), then valid style will be removed.
                _this.model ? _this.model.control.setValue(newValue) : _this.nativeElement.value = newValue;
            };
            _this.highlightFirstItem = function () {
                if (_this.target.focusedItem) {
                    _this.target.focusedItem.focused = false;
                    _this.target.focusedItem = null;
                }
                _this.target.navigateFirst();
                _this.cdr.detectChanges();
            };
            return _this;
        }
        Object.defineProperty(IgxAutocompleteDirective.prototype, "model", {
            get: function () {
                return this.ngModel || this.formControl;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "nativeElement", {
            /** @hidden @internal */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "parentElement", {
            /** @hidden @internal */
            get: function () {
                return this.group ? this.group.element.nativeElement : this.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "settings", {
            get: function () {
                var settings = Object.assign({}, this.defaultSettings, this.autocompleteSettings);
                if (!settings.positionStrategy.settings.target) {
                    var positionStrategyClone = settings.positionStrategy.clone();
                    positionStrategyClone.settings.target = this.parentElement;
                    settings.positionStrategy = positionStrategyClone;
                }
                return settings;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaExpanded", {
            /** @hidden  @internal */
            get: function () {
                return !this.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "hasPopUp", {
            /** @hidden  @internal */
            get: function () {
                return 'listbox';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaOwns", {
            /** @hidden  @internal */
            get: function () {
                return this.target.listId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaActiveDescendant", {
            /** @hidden  @internal */
            get: function () {
                return !this.target.collapsed && this.target.focusedItem ? this.target.focusedItem.id : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaAutocomplete", {
            /** @hidden  @internal */
            get: function () {
                return 'list';
            },
            enumerable: true,
            configurable: true
        });
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onInput = function () {
            this.open();
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onArrowDown = function (event) {
            event.preventDefault();
            this.open();
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onTab = function () {
            this.close();
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.handleKeyDown = function (event) {
            if (!this.collapsed) {
                switch (event.key.toLowerCase()) {
                    case 'space':
                    case 'spacebar':
                    case ' ':
                    case 'home':
                    case 'end':
                        return;
                    default:
                        _super.prototype.handleKeyDown.call(this, event);
                }
            }
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onArrowDownKeyDown = function () {
            _super.prototype.onArrowDownKeyDown.call(this);
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onArrowUpKeyDown = function () {
            _super.prototype.onArrowUpKeyDown.call(this);
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onEndKeyDown = function () {
            _super.prototype.onEndKeyDown.call(this);
        };
        /** @hidden  @internal */
        IgxAutocompleteDirective.prototype.onHomeKeyDown = function () {
            _super.prototype.onHomeKeyDown.call(this);
        };
        /**
         * Closes autocomplete drop down
         */
        IgxAutocompleteDirective.prototype.close = function () {
            if (this.collapsed) {
                return;
            }
            this.target.close();
            this.dropDownOpened$.next();
        };
        /**
         * Opens autocomplete drop down
         */
        IgxAutocompleteDirective.prototype.open = function () {
            if (this.disabled || !this.collapsed) {
                return;
            }
            // If no drop-down width is set, the drop-down will be as wide as the autocomplete input;
            this.target.width = this.target.width || (this.parentElement.clientWidth + 'px');
            this.target.open(this.settings);
            this.target.onSelection.pipe(operators.takeUntil(this.dropDownOpened$)).subscribe(this.select);
            this.target.onOpened.pipe(operators.first()).subscribe(this.highlightFirstItem);
            this.target.children.changes.pipe(operators.takeUntil(this.dropDownOpened$)).subscribe(this.highlightFirstItem);
        };
        Object.defineProperty(IgxAutocompleteDirective.prototype, "collapsed", {
            get: function () {
                return this.target ? this.target.collapsed : true;
            },
            enumerable: true,
            configurable: true
        });
        /** @hidden */
        IgxAutocompleteDirective.prototype.ngOnDestroy = function () {
            this.dropDownOpened$.complete();
        };
        IgxAutocompleteDirective.ctorParameters = function () { return [
            { type: forms.NgModel, decorators: [{ type: core.Self }, { type: core.Optional }, { type: core.Inject, args: [forms.NgModel,] }] },
            { type: forms.FormControlName, decorators: [{ type: core.Self }, { type: core.Optional }, { type: core.Inject, args: [forms.FormControlName,] }] },
            { type: IgxInputGroupComponent, decorators: [{ type: core.Optional }] },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input('igxAutocomplete')
        ], IgxAutocompleteDirective.prototype, "target", void 0);
        __decorate([
            core.Input('igxAutocompleteDisabled')
        ], IgxAutocompleteDirective.prototype, "disabled", void 0);
        __decorate([
            core.Input('igxAutocompleteSettings')
        ], IgxAutocompleteDirective.prototype, "autocompleteSettings", void 0);
        __decorate([
            core.Output()
        ], IgxAutocompleteDirective.prototype, "onItemSelected", void 0);
        __decorate([
            core.HostBinding('attr.autocomplete')
        ], IgxAutocompleteDirective.prototype, "autofill", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxAutocompleteDirective.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.aria-expanded')
        ], IgxAutocompleteDirective.prototype, "ariaExpanded", null);
        __decorate([
            core.HostBinding('attr.aria-haspopup')
        ], IgxAutocompleteDirective.prototype, "hasPopUp", null);
        __decorate([
            core.HostBinding('attr.aria-owns')
        ], IgxAutocompleteDirective.prototype, "ariaOwns", null);
        __decorate([
            core.HostBinding('attr.aria-activedescendant')
        ], IgxAutocompleteDirective.prototype, "ariaActiveDescendant", null);
        __decorate([
            core.HostBinding('attr.aria-autocomplete')
        ], IgxAutocompleteDirective.prototype, "ariaAutocomplete", null);
        __decorate([
            core.HostListener('input')
        ], IgxAutocompleteDirective.prototype, "onInput", null);
        __decorate([
            core.HostListener('keydown.ArrowDown', ['$event']),
            core.HostListener('keydown.Alt.ArrowDown', ['$event']),
            core.HostListener('keydown.ArrowUp', ['$event']),
            core.HostListener('keydown.Alt.ArrowUp', ['$event'])
        ], IgxAutocompleteDirective.prototype, "onArrowDown", null);
        __decorate([
            core.HostListener('keydown.Tab'),
            core.HostListener('keydown.Shift.Tab')
        ], IgxAutocompleteDirective.prototype, "onTab", null);
        IgxAutocompleteDirective = __decorate([
            core.Directive({
                selector: '[igxAutocomplete]'
            }),
            __param(0, core.Self()), __param(0, core.Optional()), __param(0, core.Inject(forms.NgModel)),
            __param(1, core.Self()), __param(1, core.Optional()), __param(1, core.Inject(forms.FormControlName)),
            __param(2, core.Optional())
        ], IgxAutocompleteDirective);
        return IgxAutocompleteDirective;
    }(IgxDropDownItemNavigationDirective));
    /** @hidden */
    var IgxAutocompleteModule = /** @class */ (function () {
        function IgxAutocompleteModule() {
        }
        IgxAutocompleteModule = __decorate([
            core.NgModule({
                imports: [IgxDropDownModule, common.CommonModule],
                declarations: [IgxAutocompleteDirective],
                exports: [IgxAutocompleteDirective]
            })
        ], IgxAutocompleteModule);
        return IgxAutocompleteModule;
    }());

    /**
     * The Button directive provides the Ignite UI Button functionality to every component that's intended to be used as a button.
     *
     * @igxModule IgxButtonModule
     *
     * @igxParent Data Entry & Display
     *
     * @igxTheme igx-button-theme
     *
     * @igxKeywords button, span, div, click
     *
     * @remarks
     * The Ignite UI Button directive is intended to be used by any button, span or div and turn it into a fully functional button.
     *
     * @example
     * ```html
     * <button igxButton="outlined">A Button</button>
     * ```
     */
    var IgxButtonDirective = /** @class */ (function (_super) {
        __extends(IgxButtonDirective, _super);
        function IgxButtonDirective(element, _renderer, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.element = element;
            _this._renderer = _renderer;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * @hidden
             * @internal
             */
            _this._defaultType = 'flat';
            /**
             * @hidden
             * @internal
             */
            _this._cssClassPrefix = 'igx-button';
            /**
             * Called when the button is clicked.
             */
            _this.buttonClick = new core.EventEmitter();
            /**
             * Sets/gets the `role` attribute.
             *
             * @example
             * ```typescript
             * this.button.role = 'navbutton';
             * let buttonRole = this.button.role;
             * ```
             */
            _this.role = 'button';
            /**
             * Gets or sets whether the button is selected.
             * Mainly used in the IgxButtonGroup component and it will have no effect if set separately.
             *
             * @example
             * ```html
             * <button igxButton="flat" [selected]="button.selected"></button>
             * ```
             */
            _this.selected = false;
            return _this;
        }
        Object.defineProperty(IgxButtonDirective.prototype, "nativeElement", {
            /**
             * Returns the underlying DOM element.
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "type", {
            /**
             * Sets the type of the button.
             *
             * @example
             * ```html
             * <button igxButton="icon"></button>
             * ```
             */
            set: function (value) {
                var newValue = value ? value : this._defaultType;
                if (this._type !== newValue) {
                    this._renderer.removeClass(this.nativeElement, this._cssClassPrefix + "--" + this._type);
                    this._type = newValue;
                    this._renderer.addClass(this.nativeElement, this._cssClassPrefix + "--" + this._type);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "color", {
            /**
             * Sets the button text color.
             *
             * @example
             * ```html
             * <button igxButton="gradient" igxButtonColor="blue"></button>
             * ```
             */
            set: function (value) {
                this._color = value || this.nativeElement.style.color;
                this._renderer.setStyle(this.nativeElement, 'color', this._color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "background", {
            /**
             * Sets the background color of the button.
             *
             * @example
             *  ```html
             * <button igxButton="raised" igxButtonBackground="red"></button>
             * ```
             */
            set: function (value) {
                this._backgroundColor = value || this._backgroundColor;
                this._renderer.setStyle(this.nativeElement, 'background', this._backgroundColor);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "label", {
            /**
             * Sets the `aria-label` attribute.
             *
             * @example
             *  ```html
             * <button igxButton= "flat" igxLabel="Label"></button>
             * ```
             */
            set: function (value) {
                this._label = value || this._label;
                this._renderer.setAttribute(this.nativeElement, "aria-label", this._label);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "disabled", {
            /**
             * Enables/disables the button.
             *
             * @example
             * ```html
             * <button igxButton= "fab" [disabled]="true"></button>
             * ```
             */
            set: function (val) {
                val = !!val;
                this._disabled = val;
                if (val) {
                    this._renderer.addClass(this.nativeElement, this._cssClassPrefix + "--disabled");
                }
                else {
                    this._renderer.removeClass(this.nativeElement, this._cssClassPrefix + "--disabled");
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "cssClassCosy", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') &&
                    this.displayDensity === exports.DisplayDensity.cosy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "cssClassCompact", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') &&
                    this.displayDensity === exports.DisplayDensity.compact;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "cssClassCosyFab", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._type === 'fab' && this.displayDensity === exports.DisplayDensity.cosy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "cssClassCompactFab", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._type === 'fab' && this.displayDensity === exports.DisplayDensity.compact;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonDirective.prototype, "disabledAttribute", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._disabled ? this._disabled : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxButtonDirective.prototype.onClick = function (ev) {
            this.buttonClick.emit(ev);
        };
        IgxButtonDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.Output()
        ], IgxButtonDirective.prototype, "buttonClick", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxButtonDirective.prototype, "role", void 0);
        __decorate([
            core.Input('igxButton')
        ], IgxButtonDirective.prototype, "type", null);
        __decorate([
            core.Input('igxButtonColor')
        ], IgxButtonDirective.prototype, "color", null);
        __decorate([
            core.Input('igxButtonBackground')
        ], IgxButtonDirective.prototype, "background", null);
        __decorate([
            core.Input('igxLabel')
        ], IgxButtonDirective.prototype, "label", null);
        __decorate([
            core.Input()
        ], IgxButtonDirective.prototype, "disabled", null);
        __decorate([
            core.HostBinding('class.igx-button--cosy')
        ], IgxButtonDirective.prototype, "cssClassCosy", null);
        __decorate([
            core.HostBinding('class.igx-button--compact')
        ], IgxButtonDirective.prototype, "cssClassCompact", null);
        __decorate([
            core.HostBinding('class.igx-button--fab-cosy')
        ], IgxButtonDirective.prototype, "cssClassCosyFab", null);
        __decorate([
            core.HostBinding('class.igx-button--fab-compact')
        ], IgxButtonDirective.prototype, "cssClassCompactFab", null);
        __decorate([
            core.HostBinding('attr.disabled')
        ], IgxButtonDirective.prototype, "disabledAttribute", null);
        __decorate([
            core.Input()
        ], IgxButtonDirective.prototype, "selected", void 0);
        __decorate([
            core.HostListener('click', ['$event'])
        ], IgxButtonDirective.prototype, "onClick", null);
        IgxButtonDirective = __decorate([
            core.Directive({
                selector: '[igxButton]'
            }),
            __param(2, core.Optional()), __param(2, core.Inject(DisplayDensityToken))
        ], IgxButtonDirective);
        return IgxButtonDirective;
    }(DisplayDensityBase));
    /**
     * @hidden
     */
    var IgxButtonModule = /** @class */ (function () {
        function IgxButtonModule() {
        }
        IgxButtonModule = __decorate([
            core.NgModule({
                declarations: [IgxButtonDirective],
                exports: [IgxButtonDirective]
            })
        ], IgxButtonModule);
        return IgxButtonModule;
    }());


    (function (IgxDividerType) {
        IgxDividerType["SOLID"] = "solid";
        IgxDividerType["DASHED"] = "dashed";
    })(exports.IgxDividerType || (exports.IgxDividerType = {}));
    var NEXT_ID$5 = 0;
    var IgxDividerDirective = /** @class */ (function () {
        function IgxDividerDirective() {
            /**
             * Sets/gets the `id` of the divider.
             * If not set, `id` will have value `"igx-divider-0"`;
             * ```html
             * <igx-divider id="my-divider"></igx-divider>
             * ```
             * ```typescript
             * let dividerId =  this.divider.id;
             * ```
             */
            this.id = "igx-divider-" + NEXT_ID$5++;
            /**
             * An @Input property that sets the value of the `inset` attribute.
             * If not provided it will be set to `'0'`.
             * ```html
             * <igx-divider inset="16px"></igx-divider>
             * ```
             */
            this._inset = '0';
            /**
             * An @Input property that sets the value of `role` attribute.
             * If not the default value of `separator` will be used.
             */
            this.role = 'separator';
            /**
             * Sets the type of the divider. The default value
             * is `default`. The divider can also be `dashed`;
             * ```html
             * <igx-divider type="dashed"></igx-divider>
             * ```
             */
            this.type = exports.IgxDividerType.SOLID;
            /**
             * An @Input that sets the `middle` attribute of the divider.
             * If set to `true` and an `inset` value has been provided,
             * the divider will start shrinking from both ends.
             * ```html
             * <igx-divider [middle]="true"></igx-divider>
             * ```
             */
            this.middle = false;
            /**
             * An @Input that sets the vertical attribute of the divider.
             * ```html
             * <igx-divider [vertical]="true"></igx-divider>
             * ```
             */
            this.vertical = false;
        }
        Object.defineProperty(IgxDividerDirective.prototype, "isDashed", {
            get: function () {
                return this.type === exports.IgxDividerType.DASHED;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDividerDirective.prototype, "isSolid", {
            /**
             * A getter that returns `true` if the type of the divider is `default`;
             * ```typescript
             * const isDefault = this.divider.isDefault;
             * ```
             */
            get: function () {
                return this.type === exports.IgxDividerType.SOLID;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDividerDirective.prototype, "inset", {
            /**
             * Gets the current divider inset in terms of
             * margin representation as applied to the divider.
             * ```typescript
             * const inset = this.divider.inset;
             * ```
             */
            get: function () {
                var baseMargin = '0';
                if (this.middle) {
                    if (this.vertical) {
                        return this._inset + " " + baseMargin;
                    }
                    return baseMargin + " " + this._inset;
                }
                else {
                    if (this.vertical) {
                        return this._inset + " " + baseMargin + " 0 " + baseMargin;
                    }
                    return baseMargin + " 0 " + baseMargin + " " + this._inset;
                }
            },
            /**
             * Sets the inset of the divider from the side(s).
             * If the divider attribute `middle` is set to `true`,
             * it will inset the divider on both sides.
             * ```typescript
             * this.divider.inset = '32px';
             * ```
             */
            set: function (value) {
                this._inset = value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxDividerDirective.prototype, "id", void 0);
        __decorate([
            core.Input('inset')
        ], IgxDividerDirective.prototype, "_inset", void 0);
        __decorate([
            core.HostBinding('attr.role'),
            core.Input()
        ], IgxDividerDirective.prototype, "role", void 0);
        __decorate([
            core.HostBinding('class.igx-divider'),
            core.Input()
        ], IgxDividerDirective.prototype, "type", void 0);
        __decorate([
            core.HostBinding('class.igx-divider--dashed')
        ], IgxDividerDirective.prototype, "isDashed", null);
        __decorate([
            core.HostBinding('class.igx-divider--inset'),
            core.Input()
        ], IgxDividerDirective.prototype, "middle", void 0);
        __decorate([
            core.HostBinding('class.igx-divider--vertical'),
            core.Input()
        ], IgxDividerDirective.prototype, "vertical", void 0);
        __decorate([
            core.HostBinding('style.margin')
        ], IgxDividerDirective.prototype, "inset", null);
        IgxDividerDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: 'igx-divider'
            })
        ], IgxDividerDirective);
        return IgxDividerDirective;
    }());
    var IgxDividerModule = /** @class */ (function () {
        function IgxDividerModule() {
        }
        IgxDividerModule = __decorate([
            core.NgModule({
                declarations: [IgxDividerDirective],
                exports: [IgxDividerDirective]
            })
        ], IgxDividerModule);
        return IgxDividerModule;
    }());

    // @dynamic
    var IgxDefaultDropStrategy = /** @class */ (function () {
        function IgxDefaultDropStrategy() {
        }
        IgxDefaultDropStrategy.prototype.dropAction = function (drag, drop, atIndex) { };
        return IgxDefaultDropStrategy;
    }());
    // @dynamic
    var IgxAppendDropStrategy = /** @class */ (function () {
        function IgxAppendDropStrategy(_renderer) {
            this._renderer = _renderer;
        }
        IgxAppendDropStrategy.prototype.dropAction = function (drag, drop, atIndex) {
            var dragElement = drag.element.nativeElement;
            var dropAreaElement = drop.element.nativeElement;
            this._renderer.removeChild(dragElement.parentNode, dragElement);
            this._renderer.appendChild(dropAreaElement, dragElement);
        };
        return IgxAppendDropStrategy;
    }());
    // @dynamic
    var IgxPrependDropStrategy = /** @class */ (function () {
        function IgxPrependDropStrategy(_renderer) {
            this._renderer = _renderer;
        }
        IgxPrependDropStrategy.prototype.dropAction = function (drag, drop, atIndex) {
            var dragElement = drag.element.nativeElement;
            var dropAreaElement = drop.element.nativeElement;
            this._renderer.removeChild(dragElement.parentNode, dragElement);
            if (dropAreaElement.children.length) {
                this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[0]);
            }
            else {
                this._renderer.appendChild(dropAreaElement, dragElement);
            }
        };
        return IgxPrependDropStrategy;
    }());
    // @dynamic
    var IgxInsertDropStrategy = /** @class */ (function () {
        function IgxInsertDropStrategy(_renderer) {
            this._renderer = _renderer;
        }
        IgxInsertDropStrategy.prototype.dropAction = function (drag, drop, atIndex) {
            if (drag.element.nativeElement.parentElement === drop.element.nativeElement && atIndex === -1) {
                return;
            }
            var dragElement = drag.element.nativeElement;
            var dropAreaElement = drop.element.nativeElement;
            this._renderer.removeChild(dragElement.parentNode, dragElement);
            if (atIndex !== -1 && dropAreaElement.children.length > atIndex) {
                this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[atIndex]);
            }
            else {
                this._renderer.appendChild(dropAreaElement, dragElement);
            }
        };
        return IgxInsertDropStrategy;
    }());

    var IgxDragHandleDirective = /** @class */ (function () {
        function IgxDragHandleDirective(element) {
            this.element = element;
            this.baseClass = true;
        }
        IgxDragHandleDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.HostBinding('class.igx-drag__handle')
        ], IgxDragHandleDirective.prototype, "baseClass", void 0);
        IgxDragHandleDirective = __decorate([
            core.Directive({
                selector: '[igxDragHandle]'
            })
        ], IgxDragHandleDirective);
        return IgxDragHandleDirective;
    }());


    (function (RestrictDrag) {
        RestrictDrag[RestrictDrag["VERTICALLY"] = 0] = "VERTICALLY";
        RestrictDrag[RestrictDrag["HORIZONTALLY"] = 1] = "HORIZONTALLY";
        RestrictDrag[RestrictDrag["NONE"] = 2] = "NONE";
    })(exports.RestrictDrag || (exports.RestrictDrag = {}));
    var IgxDragLocation = /** @class */ (function () {
        function IgxDragLocation(_pageX, _pageY) {
            this._pageX = _pageX;
            this._pageY = _pageY;
            this.pageX = parseFloat(_pageX);
            this.pageY = parseFloat(_pageY);
        }
        return IgxDragLocation;
    }());
    var IgxDragDirective = /** @class */ (function () {
        function IgxDragDirective(cdr, element, viewContainer, zone, renderer) {
            this.cdr = cdr;
            this.element = element;
            this.viewContainer = viewContainer;
            this.zone = zone;
            this.renderer = renderer;
            this.ghostContext = null;
            /**
             * An @Input property that indicates when the drag should start.
             * By default the drag starts after the draggable element is moved by 5px.
             * ```html
             * <div igxDrag [dragTolerance]="100">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * @memberof IgxDragDirective
             */
            this.dragTolerance = 5;
            /**
             * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
             * By default it is set to `true`.
             * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
             * ```html
             * <div igxDrag [ghost]="false">
             *      <span>Drag Me!</span>
             * </div>
             * ```
             * @memberof IgxDragDirective
             */
            this.ghost = true;
            /**
             * Sets a custom class that will be added to the `ghostElement` element.
             * ```html
             * <div igxDrag [ghostClass]="'ghostElement'">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * @memberof IgxDragDirective
             */
            this.ghostClass = '';
            /**
             * @deprecated Please use custom base styling instead.
             * An @Input property that hides the draggable element.
             * By default it's set to false.
             * ```html
             * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * @memberof IgxDragDirective
             */
            this.hideBaseOnDrag = false;
            /**
             * @deprecated Please use provided transition functions in future.
             * An @Input property that enables/disables the draggable element animation
             * when the element is released.
             * By default it's set to false.
             * ```html
             * <div igxDrag [animateOnRelease]="'true'">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * @memberof IgxDragDirective
             */
            this.animateOnRelease = false;
            /**
             * Event triggered when the draggable element drag starts.
             * ```html
             * <div igxDrag (dragStart)="onDragStart()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public onDragStart(){
             *      alert("The drag has stared!");
             * }
             * ```
             * @memberof IgxDragDirective
             */
            this.dragStart = new core.EventEmitter();
            /**
             * Event triggered when the draggable element has been moved.
             * ```html
             * <div igxDrag  (dragMove)="onDragMove()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public onDragMove(){
             *      alert("The element has moved!");
             * }
             * ```
             * @memberof IgxDragDirective
             */
            this.dragMove = new core.EventEmitter();
            /**
             * Event triggered when the draggable element is released.
             * ```html
             * <div igxDrag (dragEnd)="onDragEnd()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public onDragEnd(){
             *      alert("The drag has ended!");
             * }
             * ```
             * @memberof IgxDragDirective
             */
            this.dragEnd = new core.EventEmitter();
            /**
             * Event triggered when the draggable element is clicked.
             * ```html
             * <div igxDrag (dragClick)="onDragClick()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public onDragClick(){
             *      alert("The element has been clicked!");
             * }
             * ```
             * @memberof IgxDragDirective
             */
            this.dragClick = new core.EventEmitter();
            /**
             * Event triggered when the drag ghost element is created.
             * ```html
             * <div igxDrag (ghostCreate)="ghostCreated()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public ghostCreated(){
             *      alert("The ghost has been created!");
             * }
             * ```
             * @memberof IgxDragDirective
             */
            this.ghostCreate = new core.EventEmitter();
            /**
             * Event triggered when the drag ghost element is created.
             * ```html
             * <div igxDrag (ghostDestroy)="ghostDestroyed()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public ghostDestroyed(){
             *      alert("The ghost has been destroyed!");
             * }
             * ```
             * @memberof IgxDragDirective
             */
            this.ghostDestroy = new core.EventEmitter();
            /**
             * Event triggered after the draggable element is released and after its animation has finished.
             * ```html
             * <div igxDrag (transitioned)="onMoveEnd()">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * ```typescript
             * public onMoveEnd(){
             *      alert("The move has ended!");
             * }
             * ```
             * @memberof IgxDragDirective
             */
            this.transitioned = new core.EventEmitter();
            /**
             * @hidden
             */
            this._visibility = 'visible';
            /**
             * @hidden
             */
            this.baseClass = true;
            /**
             * @hidden
             */
            this.selectDisabled = false;
            /**
             * @hidden
             */
            this.defaultReturnDuration = '0.5s';
            /**
             * @hidden
             */
            this.animInProgress = false;
            this._startX = 0;
            this._startY = 0;
            this._lastX = 0;
            this._lastY = 0;
            this._dragStarted = false;
            this._ghostHostX = 0;
            this._ghostHostY = 0;
            this._pointerDownId = null;
            this._clicked = false;
            this._lastDropArea = null;
            this._destroy = new rxjs.Subject();
            this._removeOnDestroy = true;
        }
        Object.defineProperty(IgxDragDirective.prototype, "ghostOffsetX", {
            get: function () {
                return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
            },
            /**
             * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
             * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
             * ```html
             * <div #hostDiv></div>
             * <div igxDrag [ghostOffsetX]="0">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * @memberof IgxDragDirective
             */
            set: function (value) {
                this._offsetX = parseInt(value, 10);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "ghostOffsetY", {
            get: function () {
                return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
            },
            /**
             * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
             * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
             * ```html
             * <div #hostDiv></div>
             * <div igxDrag [ghostOffsetY]="0">
             *         <span>Drag Me!</span>
             * </div>
             * ```
             * @memberof IgxDragDirective
             */
            set: function (value) {
                this._offsetY = parseInt(value, 10);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "visible", {
            /**
             * Returns the visibility state of the draggable element.
             * ```typescript
             * @ViewChild("myDrag" ,{read: IgxDragDirective})
             * public myDrag: IgxDragDirective;
             * ngAfterViewInit(){
             *     let dragVisibility = this.myDrag.visible;
             * }
             * ```
             */
            get: function () {
                return this._visibility === 'visible';
            },
            /**
             * @deprecated Please use native angular ways of hiding it using custom to the base element styling for future versions.
             * Sets the visibility of the draggable element.
             * ```typescript
             * @ViewChild("myDrag" ,{read: IgxDragDirective})
             * public myDrag: IgxDragDirective;
             * ngAfterViewInit(){
             *     this.myDrag.visible = false;
             * }
             * ```
             */
            set: function (bVisible) {
                this._visibility = bVisible ? 'visible' : 'hidden';
                this.cdr.detectChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "location", {
            /**
             * Gets the current location of the element relative to the page.
             */
            get: function () {
                return new IgxDragLocation(this.pageX, this.pageY);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "originLocation", {
            /**
             * Gets the original location of the element before dragging started.
             */
            get: function () {
                return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "pointerEventsEnabled", {
            /**
             * @hidden
             */
            get: function () {
                return typeof PointerEvent !== 'undefined';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "touchEventsEnabled", {
            /**
             * @hidden
             */
            get: function () {
                return 'ontouchstart' in window;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "pageX", {
            /**
             * @hidden
             */
            get: function () {
                if (this.ghost && this.ghostElement) {
                    return this.ghostLeft;
                }
                return this.baseLeft;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "pageY", {
            /**
             * @hidden
             */
            get: function () {
                if (this.ghost && this.ghostElement) {
                    return this.ghostTop;
                }
                return this.baseTop;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "baseLeft", {
            get: function () {
                return this.element.nativeElement.getBoundingClientRect().left;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "baseTop", {
            get: function () {
                return this.element.nativeElement.getBoundingClientRect().top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "baseOriginLeft", {
            get: function () {
                return this.baseLeft - this.getTransformX(this.element.nativeElement);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "baseOriginTop", {
            get: function () {
                return this.baseTop - this.getTransformY(this.element.nativeElement);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "ghostLeft", {
            get: function () {
                return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
            },
            set: function (pageX) {
                if (this.ghostElement) {
                    // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.
                    var ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
                    // If ghost host is defined it needs to be taken into account.
                    this.ghostElement.style.left = (pageX - ghostMarginLeft - this._ghostHostX) + 'px';
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDragDirective.prototype, "ghostTop", {
            get: function () {
                return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
            },
            set: function (pageY) {
                if (this.ghostElement) {
                    // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.
                    var ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
                    // If ghost host is defined it needs to be taken into account.
                    this.ghostElement.style.top = (pageY - ghostMarginTop - this._ghostHostY) + 'px';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxDragDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (!this.dragHandles || !this.dragHandles.length) {
                // Set user select none to the whole draggable element if no drag handles are defined.
                this.selectDisabled = true;
            }
            // Bind events
            this.zone.runOutsideAngular(function () {
                var targetElements = _this.dragHandles && _this.dragHandles.length ?
                    _this.dragHandles.map(function (item) { return item.element.nativeElement; }) : [_this.element.nativeElement];
                targetElements.forEach(function (element) {
                    if (_this.pointerEventsEnabled) {
                        rxjs.fromEvent(element, 'pointerdown').pipe(operators.takeUntil(_this._destroy))
                            .subscribe(function (res) { return _this.onPointerDown(res); });
                        rxjs.fromEvent(element, 'pointermove').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                        rxjs.fromEvent(element, 'pointerup').pipe(operators.takeUntil(_this._destroy))
                            .subscribe(function (res) { return _this.onPointerUp(res); });
                        if (!_this.ghost) {
                            // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                            rxjs.fromEvent(element, 'lostpointercapture').pipe(operators.takeUntil(_this._destroy))
                                .subscribe(function (res) { return _this.onPointerLost(res); });
                        }
                    }
                    else if (_this.touchEventsEnabled) {
                        rxjs.fromEvent(element, 'touchstart').pipe(operators.takeUntil(_this._destroy))
                            .subscribe(function (res) { return _this.onPointerDown(res); });
                    }
                    else {
                        // We don't have pointer events and touch events. Use then mouse events.
                        rxjs.fromEvent(element, 'mousedown').pipe(operators.takeUntil(_this._destroy))
                            .subscribe(function (res) { return _this.onPointerDown(res); });
                    }
                });
                // We should bind to document events only once when there are no pointer events.
                if (!_this.pointerEventsEnabled && _this.touchEventsEnabled) {
                    rxjs.fromEvent(document.defaultView, 'touchmove').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                    rxjs.fromEvent(document.defaultView, 'touchend').pipe(operators.takeUntil(_this._destroy))
                        .subscribe(function (res) { return _this.onPointerUp(res); });
                }
                else if (!_this.pointerEventsEnabled) {
                    rxjs.fromEvent(document.defaultView, 'mousemove').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                    rxjs.fromEvent(document.defaultView, 'mouseup').pipe(operators.takeUntil(_this._destroy))
                        .subscribe(function (res) { return _this.onPointerUp(res); });
                }
                _this.element.nativeElement.addEventListener('transitionend', function (args) {
                    _this.onTransitionEnd(args);
                });
            });
            // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.
            this.element.nativeElement.style.transitionDuration = '0.0s';
        };
        /**
         * @hidden
         */
        IgxDragDirective.prototype.ngOnDestroy = function () {
            this._destroy.next(true);
            this._destroy.complete();
            if (this.ghost && this.ghostElement && this._removeOnDestroy) {
                this.ghostElement.parentNode.removeChild(this.ghostElement);
                this.ghostElement = null;
            }
        };
        /**
         * Sets desired location of the base element or ghost element if rended relative to the document.
         * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
         */
        IgxDragDirective.prototype.setLocation = function (newLocation) {
            // We do not subtract marginLeft and marginTop here because here we calculate deltas.
            if (this.ghost && this.ghostElement) {
                var offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
                var offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
                this.ghostLeft = newLocation.pageX - offsetHostX + this.getWindowScrollLeft();
                this.ghostTop = newLocation.pageY - offsetHostY + this.getWindowScrollTop();
            }
            else if (!this.ghost) {
                var deltaX = newLocation.pageX - this.pageX;
                var deltaY = newLocation.pageY - this.pageY;
                var transformX = this.getTransformX(this.element.nativeElement);
                var transformY = this.getTransformY(this.element.nativeElement);
                this.setTransformXY(transformX + deltaX, transformY + deltaY);
            }
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
        };
        /**
         * Animates the base or ghost element depending on the `ghost` input to its initial location.
         * If `ghost` is true but there is not ghost rendered, it will be created and animated.
         * If the base element has changed its DOM position its initial location will be changed accordingly.
         * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
         * @param startLocation Start location from where the transition should start.
         */
        IgxDragDirective.prototype.transitionToOrigin = function (customAnimArgs, startLocation) {
            var _this = this;
            if ((!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft) ||
                (!startLocation && this.ghost && !this.ghostElement)) {
                return;
            }
            if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
                if (this.ghost && !this.ghostElement) {
                    this._startX = startLocation.pageX;
                    this._startY = startLocation.pageY;
                    this._ghostStartX = this._startX;
                    this._ghostStartY = this._startY;
                    this.createGhost(this._startX, this._startY);
                }
                this.setLocation(startLocation);
            }
            this.animInProgress = true;
            // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
            setTimeout(function () {
                if (_this.ghost) {
                    _this.ghostElement.style.transitionProperty = 'top, left';
                    _this.ghostElement.style.transitionDuration =
                        customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this.defaultReturnDuration;
                    _this.ghostElement.style.transitionTimingFunction =
                        customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                    _this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                    _this.setLocation(new IgxDragLocation(_this.baseLeft, _this.baseTop));
                }
                else if (!_this.ghost) {
                    _this.element.nativeElement.style.transitionProperty = 'transform';
                    _this.element.nativeElement.style.transitionDuration =
                        customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this.defaultReturnDuration;
                    _this.element.nativeElement.style.transitionTimingFunction =
                        customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                    _this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                    _this._startX = _this.baseLeft;
                    _this._startY = _this.baseTop;
                    _this.setTransformXY(0, 0);
                }
            }, 0);
        };
        /**
         * Animates the base or ghost element to a specific target location or other element using transition.
         * If `ghost` is true but there is not ghost rendered, it will be created and animated.
         * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
         * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
         * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
         * @param startLocation Start location from where the transition should start.
         */
        IgxDragDirective.prototype.transitionTo = function (target, customAnimArgs, startLocation) {
            var _this = this;
            if (!!startLocation && this.ghost && !this.ghostElement) {
                this._startX = startLocation.pageX;
                this._startY = startLocation.pageY;
                this._ghostStartX = this._startX;
                this._ghostStartY = this._startY;
            }
            else if (!!startLocation && (!this.ghost || this.ghostElement)) {
                this.setLocation(startLocation);
            }
            else if (this.ghost && !this.ghostElement) {
                this._startX = this.baseLeft;
                this._startY = this.baseTop;
                this._ghostStartX = this._startX + this.getWindowScrollLeft();
                this._ghostStartY = this._startY + this.getWindowScrollTop();
            }
            if (this.ghost && !this.ghostElement) {
                this.createGhost(this._startX, this._startY);
            }
            this.animInProgress = true;
            // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
            setTimeout(function () {
                var movedElem = _this.ghost ? _this.ghostElement : _this.element.nativeElement;
                movedElem.style.transitionProperty = _this.ghost && _this.ghostElement ? 'left, top' : 'transform';
                movedElem.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this.defaultReturnDuration;
                movedElem.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                if (target instanceof IgxDragLocation) {
                    _this.setLocation(new IgxDragLocation(target.pageX, target.pageY));
                }
                else {
                    var targetRects = target.nativeElement.getBoundingClientRect();
                    _this.setLocation(new IgxDragLocation(targetRects.left - _this.getWindowScrollLeft(), targetRects.top - _this.getWindowScrollTop()));
                }
            }, 0);
        };
        /**
         * @hidden
         * Method bound to the PointerDown event of the base element igxDrag is initialized.
         * @param event PointerDown event captured
         */
        IgxDragDirective.prototype.onPointerDown = function (event) {
            this._clicked = true;
            this._pointerDownId = event.pointerId;
            // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.
            var handleFound = this.dragHandles.find(function (handle) { return handle.element.nativeElement === event.currentTarget; });
            var targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;
            if (this.pointerEventsEnabled) {
                targetElement.setPointerCapture(this._pointerDownId);
            }
            else {
                targetElement.focus();
                event.preventDefault();
            }
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                this._startX = event.pageX;
                this._startY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                this._startX = event.touches[0].pageX;
                this._startY = event.touches[0].pageY;
            }
            this._defaultOffsetX = this.baseLeft - this._startX + this.getWindowScrollLeft();
            this._defaultOffsetY = this.baseTop - this._startY + this.getWindowScrollTop();
            this._ghostStartX = this._startX + this.ghostOffsetX;
            this._ghostStartY = this._startY + this.ghostOffsetY;
            this._lastX = this._startX;
            this._lastY = this._startY;
        };
        /**
         * @hidden
         * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
         * This method is bound at first at the base element.
         * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
         * @param event PointerMove event captured
         */
        IgxDragDirective.prototype.onPointerMove = function (event) {
            var _this = this;
            if (this._clicked) {
                var pageX = void 0, pageY = void 0;
                if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                    // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                    pageX = event.pageX;
                    pageY = event.pageY;
                }
                else if (this.touchEventsEnabled) {
                    pageX = event.touches[0].pageX;
                    pageY = event.touches[0].pageY;
                    // Prevent scrolling on touch while dragging
                    event.preventDefault();
                }
                var totalMovedX = pageX - this._startX;
                var totalMovedY = pageY - this._startY;
                if (!this._dragStarted &&
                    (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                    var dragStartArgs_1 = {
                        originalEvent: event,
                        owner: this,
                        startX: pageX - totalMovedX,
                        startY: pageY - totalMovedY,
                        pageX: pageX,
                        pageY: pageY,
                        cancel: false
                    };
                    this.zone.run(function () {
                        _this.dragStart.emit(dragStartArgs_1);
                    });
                    if (!dragStartArgs_1.cancel) {
                        this._dragStarted = true;
                        if (this.ghost) {
                            // We moved enough so ghostElement can be rendered and actual dragging to start.
                            // When creating it will take into account any offset set by the user by default.
                            this.createGhost(pageX, pageY);
                        }
                        else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                            // There is no need for ghost, but we will need to position initially the base element to reflect any offset.
                            var transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) +
                                this.getTransformX(this.element.nativeElement);
                            var transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) +
                                this.getTransformY(this.element.nativeElement);
                            this.setTransformXY(transformX, transformY);
                        }
                    }
                    else {
                        return;
                    }
                }
                else if (!this._dragStarted) {
                    return;
                }
                var moveArgs = {
                    originalEvent: event,
                    owner: this,
                    startX: this._startX,
                    startY: this._startY,
                    pageX: this._lastX,
                    pageY: this._lastY,
                    nextPageX: pageX,
                    nextPageY: pageY,
                    cancel: false
                };
                this.dragMove.emit(moveArgs);
                var setPageX = moveArgs.nextPageX;
                var setPageY = moveArgs.nextPageY;
                var updatedMovedX = setPageX - this._startX;
                var updatedMovedY = setPageY - this._startY;
                if (!moveArgs.cancel) {
                    if (this.ghost) {
                        this.ghostLeft = this._ghostStartX + updatedMovedX;
                        this.ghostTop = this._ghostStartY + updatedMovedY;
                    }
                    else {
                        var lastMovedX = setPageX - this._lastX;
                        var lastMovedY = setPageY - this._lastY;
                        var translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                        var translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                        this.setTransformXY(translateX, translateY);
                    }
                    this.dispatchDragEvents(pageX, pageY, event);
                }
                this._lastX = setPageX;
                this._lastY = setPageY;
            }
        };
        /**
         * @hidden
         * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
         * This method is bound at first at the base element.
         * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
         * @param event PointerUp event captured
         */
        IgxDragDirective.prototype.onPointerUp = function (event) {
            var _this = this;
            if (!this._clicked) {
                return;
            }
            var pageX, pageY;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            var eventArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: pageX,
                pageY: pageY
            };
            this._pointerDownId = null;
            this._clicked = false;
            if (this._dragStarted) {
                if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                    this.dispatchDropEvent(event.pageX, event.pageY, event);
                }
                else if (this.animateOnRelease) {
                    this.transitionToOrigin();
                }
                this.zone.run(function () {
                    _this.dragEnd.emit(eventArgs);
                });
                if (!this.animInProgress) {
                    this.onTransitionEnd(null);
                }
            }
            else {
                // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
                this.zone.run(function () {
                    _this.dragClick.emit(eventArgs);
                });
            }
        };
        /**
         * @hidden
         * Execute this method whe the pointer capture has been lost.
         * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
         * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
         * @param event Event captured
         */
        IgxDragDirective.prototype.onPointerLost = function (event) {
            var _this = this;
            if (!this._clicked) {
                return;
            }
            var eventArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: event.pageX,
                pageY: event.pageY
            };
            this._pointerDownId = null;
            this._clicked = false;
            if (this._dragStarted) {
                this.zone.run(function () {
                    _this.dragEnd.emit(eventArgs);
                });
                if (this.animateOnRelease) {
                    this.transitionToOrigin();
                }
                else if (!this.animInProgress) {
                    this.onTransitionEnd(null);
                }
            }
        };
        /**
         * @hidden
         * Create ghost element - if a Node object is provided it creates a clone of that node,
         * otherwise it clones the host element.
         * Bind all needed events.
         * @param pageX Latest pointer position on the X axis relative to the page.
         * @param pageY Latest pointer position on the Y axis relative to the page.
         * @param node The Node object to be cloned.
         */
        IgxDragDirective.prototype.createGhost = function (pageX, pageY, node) {
            var _this = this;
            if (node === void 0) { node = null; }
            if (!this.ghost) {
                return;
            }
            var dynamicGhostRef;
            if (this.ghostTemplate) {
                dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);
                this.ghostElement = dynamicGhostRef.rootNodes[0];
            }
            else {
                this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
            }
            var totalMovedX = pageX - this._startX;
            var totalMovedY = pageY - this._startY;
            this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
            this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
            this.ghostElement.style.transitionDuration = '0.0s';
            this.ghostElement.style.position = 'absolute';
            if (this.ghostClass) {
                this.renderer.addClass(this.ghostElement, this.ghostClass);
            }
            var createEventArgs = {
                owner: this,
                ghostElement: this.ghostElement,
                cancel: false
            };
            this.ghostCreate.emit(createEventArgs);
            if (createEventArgs.cancel) {
                this.ghostElement = null;
                if (this.ghostTemplate && dynamicGhostRef) {
                    dynamicGhostRef.destroy();
                }
                return;
            }
            if (this.ghostHost) {
                this.ghostHost.appendChild(this.ghostElement);
            }
            else {
                document.body.appendChild(this.ghostElement);
            }
            var ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
            var ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
            this.ghostElement.style.left = (this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX) + 'px';
            this.ghostElement.style.top = (this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX) + 'px';
            if (this.pointerEventsEnabled) {
                // The ghostElement takes control for moving and dragging after it has been rendered.
                if (this._pointerDownId !== null) {
                    this.ghostElement.setPointerCapture(this._pointerDownId);
                }
                this.ghostElement.addEventListener('pointermove', function (args) {
                    _this.onPointerMove(args);
                });
                this.ghostElement.addEventListener('pointerup', function (args) {
                    _this.onPointerUp(args);
                });
                this.ghostElement.addEventListener('lostpointercapture', function (args) {
                    _this.onPointerLost(args);
                });
            }
            // Transition animation when the ghostElement is released and it returns to it's original position.
            this.ghostElement.addEventListener('transitionend', function (args) {
                _this.onTransitionEnd(args);
            });
            // Hide the base after the ghostElement is created, because otherwise the ghostElement will be not visible.
            if (this.hideBaseOnDrag) {
                this.visible = false;
            }
            this.cdr.detectChanges();
        };
        /**
         * @hidden
         * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
         */
        IgxDragDirective.prototype.dispatchDragEvents = function (pageX, pageY, originalEvent) {
            var topDropArea;
            var customEventArgs = {
                startX: this._startX,
                startY: this._startY,
                pageX: pageX,
                pageY: pageY,
                owner: this,
                originalEvent: originalEvent
            };
            var elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
            for (var i = 0; i < elementsFromPoint.length; i++) {
                if (elementsFromPoint[i].getAttribute('droppable') === 'true' &&
                    elementsFromPoint[i] !== this.ghostElement && elementsFromPoint[i] !== this.element.nativeElement) {
                    topDropArea = elementsFromPoint[i];
                    break;
                }
            }
            if (topDropArea &&
                (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
                if (this._lastDropArea) {
                    this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
                }
                this._lastDropArea = topDropArea;
                this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
            }
            else if (!topDropArea && this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
                this._lastDropArea = null;
                return;
            }
            if (topDropArea) {
                this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
            }
        };
        /**
         * @hidden
         * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
         * Last recorder drop area is updated in @dispatchDragEvents method.
         */
        IgxDragDirective.prototype.dispatchDropEvent = function (pageX, pageY, originalEvent) {
            var eventArgs = {
                startX: this._startX,
                startY: this._startY,
                pageX: pageX,
                pageY: pageY,
                owner: this,
                originalEvent: originalEvent
            };
            this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
            this._lastDropArea = null;
        };
        /**
         * @hidden
         */
        IgxDragDirective.prototype.onTransitionEnd = function (event) {
            var _this = this;
            if ((!this._dragStarted && !this.animInProgress) || this._clicked) {
                // Return if no dragging started and there is no animation in progress.
                return;
            }
            if (this.ghost && this.ghostElement) {
                this._ghostStartX = this.baseLeft + this.getWindowScrollLeft();
                this._ghostStartY = this.baseTop + this.getWindowScrollTop();
                var ghostDestroyArgs = {
                    owner: this,
                    ghostElement: this.ghostElement,
                    cancel: false
                };
                this.ghostDestroy.emit(ghostDestroyArgs);
                if (ghostDestroyArgs.cancel) {
                    return;
                }
                if (this.hideBaseOnDrag) {
                    this.visible = true;
                }
                this.ghostElement.parentNode.removeChild(this.ghostElement);
                this.ghostElement = null;
            }
            else if (!this.ghost) {
                this.element.nativeElement.style.transitionProperty = '';
                this.element.nativeElement.style.transitionDuration = '0.0s';
                this.element.nativeElement.style.transitionTimingFunction = '';
                this.element.nativeElement.style.transitionDelay = '';
            }
            this.animInProgress = false;
            this._dragStarted = false;
            // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.
            this.zone.run(function () {
                _this.transitioned.emit({
                    originalEvent: event,
                    owner: _this,
                    startX: _this._startX,
                    startY: _this._startY,
                    pageX: _this._startX,
                    pageY: _this._startY
                });
            });
        };
        /**
         * @hidden
         */
        IgxDragDirective.prototype.getElementsAtPoint = function (pageX, pageY) {
            // correct the coordinates with the current scroll position, because
            // document.elementsFromPoint consider position within the current viewport
            // window.pageXOffset == window.scrollX; // always true
            // using window.pageXOffset for IE9 compatibility
            var viewPortX = pageX - window.pageXOffset;
            var viewPortY = pageY - window.pageYOffset;
            if (document['msElementsFromPoint']) {
                // Edge and IE special snowflakes
                var elements = document['msElementsFromPoint'](viewPortX, viewPortY);
                return elements === null ? [] : elements;
            }
            else {
                // Other browsers like Chrome, Firefox, Opera
                return document.elementsFromPoint(viewPortX, viewPortY);
            }
        };
        /**
         * @hidden
         */
        IgxDragDirective.prototype.dispatchEvent = function (target, eventName, eventArgs) {
            // This way is IE11 compatible.
            var dragLeaveEvent = document.createEvent('CustomEvent');
            dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
            target.dispatchEvent(dragLeaveEvent);
            // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
        };
        IgxDragDirective.prototype.getTransformX = function (elem) {
            var posX = 0;
            if (elem.style.transform) {
                var matrix = elem.style.transform;
                var values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
                posX = values ? Number(values[1]) : 0;
            }
            return posX;
        };
        IgxDragDirective.prototype.getTransformY = function (elem) {
            var posY = 0;
            if (elem.style.transform) {
                var matrix = elem.style.transform;
                var values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
                posY = values ? Number(values[2]) : 0;
            }
            return posY;
        };
        /** Method setting transformation to the base draggable element. */
        IgxDragDirective.prototype.setTransformXY = function (x, y) {
            this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
        };
        IgxDragDirective.prototype.getWindowScrollTop = function () {
            return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
        };
        IgxDragDirective.prototype.getWindowScrollLeft = function () {
            return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
        };
        IgxDragDirective.prototype.ghostHostOffsetLeft = function (ghostHost) {
            var ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
            if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
                return 0;
            }
            else if (ghostPosition === 'static' && ghostHost.offsetParent) {
                return ghostHost.offsetParent.getBoundingClientRect().left - this.getWindowScrollLeft();
            }
            return ghostHost.getBoundingClientRect().left - this.getWindowScrollLeft();
        };
        IgxDragDirective.prototype.ghostHostOffsetTop = function (ghostHost) {
            var ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
            if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
                return 0;
            }
            else if (ghostPosition === 'static' && ghostHost.offsetParent) {
                return ghostHost.offsetParent.getBoundingClientRect().top - this.getWindowScrollTop();
            }
            return ghostHost.getBoundingClientRect().top - this.getWindowScrollTop();
        };
        IgxDragDirective.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.ViewContainerRef },
            { type: core.NgZone },
            { type: core.Renderer2 }
        ]; };
        __decorate([
            core.Input('igxDrag')
        ], IgxDragDirective.prototype, "data", void 0);
        __decorate([
            core.Input()
        ], IgxDragDirective.prototype, "dragTolerance", void 0);
        __decorate([
            core.Input()
        ], IgxDragDirective.prototype, "dragChannel", void 0);
        __decorate([
            core.Input()
        ], IgxDragDirective.prototype, "ghost", void 0);
        __decorate([
            core.Input()
        ], IgxDragDirective.prototype, "ghostClass", void 0);
        __decorate([
            DeprecateProperty("'hideBaseOnDrag' @Input property is deprecated and will be removed in future major versions.\n        Alternatives to it are using the new no ghost dragging and custom base styling."),
            core.Input()
        ], IgxDragDirective.prototype, "hideBaseOnDrag", void 0);
        __decorate([
            DeprecateProperty("'animateOnRelease' @Input property is deprecated and will be removed in future major versions.\n        Please use 'transitionToOrigin' or 'transitionTo' methods instead."),
            core.Input()
        ], IgxDragDirective.prototype, "animateOnRelease", void 0);
        __decorate([
            core.Input()
        ], IgxDragDirective.prototype, "ghostTemplate", void 0);
        __decorate([
            core.Input()
        ], IgxDragDirective.prototype, "ghostHost", void 0);
        __decorate([
            core.Input()
        ], IgxDragDirective.prototype, "ghostOffsetX", null);
        __decorate([
            core.Input()
        ], IgxDragDirective.prototype, "ghostOffsetY", null);
        __decorate([
            core.Output()
        ], IgxDragDirective.prototype, "dragStart", void 0);
        __decorate([
            core.Output()
        ], IgxDragDirective.prototype, "dragMove", void 0);
        __decorate([
            core.Output()
        ], IgxDragDirective.prototype, "dragEnd", void 0);
        __decorate([
            core.Output()
        ], IgxDragDirective.prototype, "dragClick", void 0);
        __decorate([
            core.Output()
        ], IgxDragDirective.prototype, "ghostCreate", void 0);
        __decorate([
            core.Output()
        ], IgxDragDirective.prototype, "ghostDestroy", void 0);
        __decorate([
            core.Output()
        ], IgxDragDirective.prototype, "transitioned", void 0);
        __decorate([
            core.ContentChildren(IgxDragHandleDirective)
        ], IgxDragDirective.prototype, "dragHandles", void 0);
        __decorate([
            core.HostBinding('style.visibility')
        ], IgxDragDirective.prototype, "_visibility", void 0);
        __decorate([
            core.HostBinding('class.igx-drag')
        ], IgxDragDirective.prototype, "baseClass", void 0);
        __decorate([
            core.HostBinding('class.igx-drag--select-disabled')
        ], IgxDragDirective.prototype, "selectDisabled", void 0);
        __decorate([
            DeprecateProperty("'visible' @Input property is deprecated and will be removed in future major versions.\n        Please use native angular ways of hiding the base element using styling.")
        ], IgxDragDirective.prototype, "visible", null);
        IgxDragDirective = __decorate([
            core.Directive({
                exportAs: 'drag',
                selector: '[igxDrag]'
            })
        ], IgxDragDirective);
        return IgxDragDirective;
    }());
    var IgxDropDirective = /** @class */ (function () {
        function IgxDropDirective(element, _renderer, _zone) {
            this.element = element;
            this._renderer = _renderer;
            this._zone = _zone;
            /** Event triggered when dragged element enters the area of the element.
             * ```html
             * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
             * </div>
             * ```
             * ```typescript
             * public dragEnter(){
             *     alert("A draggable element has entered the chip area!");
             * }
             * ```
             * @memberof IgxDropDirective
             */
            this.enter = new core.EventEmitter();
            /** Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
            this.over = new core.EventEmitter();
            /** Event triggered when dragged element leaves the area of the element.
             * ```html
             * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
             * </div>
             * ```
             * ```typescript
             * public dragLeave(){
             *     alert("A draggable element has left the chip area!");
             * }
             * ```
             * @memberof IgxDropDirective
             */
            this.leave = new core.EventEmitter();
            /** Event triggered when dragged element is dropped in the area of the element.
             * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
             * To cancel the default logic the `cancel` property of the event needs to be set to true.
             * ```html
             * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
             * </div>
             * ```
             * ```typescript
             * public dragDrop(){
             *     alert("A draggable element has been dropped in the chip area!");
             * }
             * ```
             * @memberof IgxDropDirective
             */
            this.dropped = new core.EventEmitter();
            /**
             * @hidden
             */
            this.droppable = true;
            /**
             * @hidden
             */
            this.dragover = false;
            /**
             * @hidden
             */
            this._destroy = new rxjs.Subject();
            this._dropStrategy = new IgxDefaultDropStrategy();
        }
        Object.defineProperty(IgxDropDirective.prototype, "dropStrategy", {
            get: function () {
                return this._dropStrategy;
            },
            /**
             * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
             *  the current drop area. The provided strategies are:
             *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
             *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
             *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
             *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
             *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
             * ```html
             * <div igxDrag>
             *      <span>DragMe</span>
             * </div>
             * <div igxDrop [dropStrategy]="myDropStrategy">
             *         <span>Numbers drop area!</span>
             * </div>
             * ```
             * ```typescript
             * import { IgxAppendDropStrategy } from 'igniteui-angular';
             *
             * export class App {
             *      public myDropStrategy = IgxAppendDropStrategy;
             * }
             * ```
             * @memberof IgxDropDirective
             */
            set: function (classRef) {
                this._dropStrategy = new classRef(this._renderer);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxDropDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._zone.runOutsideAngular(function () {
                rxjs.fromEvent(_this.element.nativeElement, 'igxDragEnter').pipe(operators.takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onDragEnter(res); });
                rxjs.fromEvent(_this.element.nativeElement, 'igxDragLeave').pipe(operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragLeave(res); });
                rxjs.fromEvent(_this.element.nativeElement, 'igxDragOver').pipe(operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragOver(res); });
            });
        };
        /**
         * @hidden
         */
        IgxDropDirective.prototype.ngOnDestroy = function () {
            this._destroy.next(true);
            this._destroy.complete();
        };
        /**
         * @hidden
         */
        IgxDropDirective.prototype.onDragOver = function (event) {
            var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
            var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
            var offsetX = event.detail.pageX - elementPosX;
            var offsetY = event.detail.pageY - elementPosY;
            var eventArgs = {
                originalEvent: event.detail.originalEvent,
                owner: this,
                drag: event.detail.owner,
                dragData: event.detail.owner.data,
                startX: event.detail.startX,
                startY: event.detail.startY,
                pageX: event.detail.pageX,
                pageY: event.detail.pageY,
                offsetX: offsetX,
                offsetY: offsetY
            };
            this.over.emit(eventArgs);
        };
        /**
         * @hidden
         */
        IgxDropDirective.prototype.onDragEnter = function (event) {
            var _this = this;
            if (!this.isDragLinked(event.detail.owner)) {
                return;
            }
            this.dragover = true;
            var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
            var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
            var offsetX = event.detail.pageX - elementPosX;
            var offsetY = event.detail.pageY - elementPosY;
            var eventArgs = {
                originalEvent: event.detail.originalEvent,
                owner: this,
                drag: event.detail.owner,
                dragData: event.detail.owner.data,
                startX: event.detail.startX,
                startY: event.detail.startY,
                pageX: event.detail.pageX,
                pageY: event.detail.pageY,
                offsetX: offsetX,
                offsetY: offsetY
            };
            this._zone.run(function () {
                _this.enter.emit(eventArgs);
            });
        };
        /**
         * @hidden
         */
        IgxDropDirective.prototype.onDragLeave = function (event) {
            var _this = this;
            if (!this.isDragLinked(event.detail.owner)) {
                return;
            }
            this.dragover = false;
            var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
            var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
            var offsetX = event.detail.pageX - elementPosX;
            var offsetY = event.detail.pageY - elementPosY;
            var eventArgs = {
                originalEvent: event.detail.originalEvent,
                owner: this,
                drag: event.detail.owner,
                dragData: event.detail.owner.data,
                startX: event.detail.startX,
                startY: event.detail.startY,
                pageX: event.detail.pageX,
                pageY: event.detail.pageY,
                offsetX: offsetX,
                offsetY: offsetY
            };
            this._zone.run(function () {
                _this.leave.emit(eventArgs);
            });
        };
        /**
         * @hidden
         */
        IgxDropDirective.prototype.onDragDrop = function (event) {
            var _this = this;
            if (!this.isDragLinked(event.detail.owner)) {
                return;
            }
            var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
            var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
            var offsetX = event.detail.pageX - elementPosX;
            var offsetY = event.detail.pageY - elementPosY;
            var args = {
                owner: this,
                originalEvent: event.detail.originalEvent,
                drag: event.detail.owner,
                dragData: event.detail.owner.data,
                startX: event.detail.startX,
                startY: event.detail.startY,
                pageX: event.detail.pageX,
                pageY: event.detail.pageY,
                offsetX: offsetX,
                offsetY: offsetY,
                cancel: false
            };
            this._zone.run(function () {
                _this.dropped.emit(args);
            });
            if (this._dropStrategy && !args.cancel) {
                var elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
                var insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);
                this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
            }
        };
        IgxDropDirective.prototype.getWindowScrollTop = function () {
            return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
        };
        IgxDropDirective.prototype.getWindowScrollLeft = function () {
            return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
        };
        IgxDropDirective.prototype.isDragLinked = function (drag) {
            var dragLinkArray = drag.dragChannel instanceof Array;
            var dropLinkArray = this.dropChannel instanceof Array;
            if (!dragLinkArray && !dropLinkArray) {
                return this.dropChannel === drag.dragChannel;
            }
            else if (!dragLinkArray && dropLinkArray) {
                var dropLinks = this.dropChannel;
                for (var i = 0; i < dropLinks.length; i++) {
                    if (dropLinks[i] === drag.dragChannel) {
                        return true;
                    }
                }
            }
            else if (dragLinkArray && !dropLinkArray) {
                var dragLinks = drag.dragChannel;
                for (var i = 0; i < dragLinks.length; i++) {
                    if (dragLinks[i] === this.dropChannel) {
                        return true;
                    }
                }
            }
            else {
                var dragLinks = drag.dragChannel;
                var dropLinks = this.dropChannel;
                for (var i = 0; i < dragLinks.length; i++) {
                    for (var j = 0; j < dropLinks.length; j++) {
                        if (dragLinks[i] === dropLinks[j]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        IgxDropDirective.prototype.getInsertIndexAt = function (draggedDir, elementsAtPoint) {
            var insertIndex = -1;
            var dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);
            if (!dropChildren.length) {
                return insertIndex;
            }
            var i = 0;
            var childUnder = null;
            while (!childUnder && i < elementsAtPoint.length) {
                if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
                    childUnder = elementsAtPoint[i];
                }
                i++;
            }
            var draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
            insertIndex = dropChildren.indexOf(childUnder);
            if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
                insertIndex++;
            }
            return insertIndex;
        };
        IgxDropDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.Input('igxDrop')
        ], IgxDropDirective.prototype, "data", void 0);
        __decorate([
            core.Input()
        ], IgxDropDirective.prototype, "dropChannel", void 0);
        __decorate([
            core.Input()
        ], IgxDropDirective.prototype, "dropStrategy", null);
        __decorate([
            core.Output()
        ], IgxDropDirective.prototype, "enter", void 0);
        __decorate([
            core.Output()
        ], IgxDropDirective.prototype, "over", void 0);
        __decorate([
            core.Output()
        ], IgxDropDirective.prototype, "leave", void 0);
        __decorate([
            core.Output()
        ], IgxDropDirective.prototype, "dropped", void 0);
        __decorate([
            core.HostBinding('attr.droppable')
        ], IgxDropDirective.prototype, "droppable", void 0);
        __decorate([
            core.HostBinding('class.dragOver')
        ], IgxDropDirective.prototype, "dragover", void 0);
        __decorate([
            core.HostListener('igxDrop', ['$event'])
        ], IgxDropDirective.prototype, "onDragDrop", null);
        IgxDropDirective = __decorate([
            core.Directive({
                exportAs: 'drop',
                selector: '[igxDrop]'
            })
        ], IgxDropDirective);
        return IgxDropDirective;
    }());
    /**
     * @hidden
     */
    var IgxDragDropModule = /** @class */ (function () {
        function IgxDragDropModule() {
        }
        IgxDragDropModule = __decorate([
            core.NgModule({
                declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective],
                exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective]
            })
        ], IgxDragDropModule);
        return IgxDragDropModule;
    }());

    var IgxFilterOptions = /** @class */ (function () {
        function IgxFilterOptions() {
            // Input text value that will be used as a filtering pattern (matching condition is based on it)
            this.inputValue = '';
        }
        // Function - get value to be tested from the item
        // item - single item of the list to be filtered
        // key - property name of item, which value should be tested
        // Default behavior - returns "key"- named property value of item if key si provided,
        // otherwise textContent of the item's html element
        IgxFilterOptions.prototype.get_value = function (item, key) {
            var result = '';
            if (key && item[key]) {
                result = item[key].toString();
            }
            else if (item.element) {
                if (item.element.nativeElement) {
                    result = item.element.nativeElement.textContent.trim();
                    // Check if element doesn't return the DOM element directly
                }
                else if (item.element.textContent) {
                    result = item.element.textContent.trim();
                }
            }
            return result;
        };
        // Function - formats the original text before matching process
        // Default behavior - returns text to lower case
        IgxFilterOptions.prototype.formatter = function (valueToTest) {
            return valueToTest.toLowerCase();
        };
        // Function - determines whether the item met the condition
        // valueToTest - text value that should be tested
        // inputValue - text value from input that condition is based on
        // Default behavior - "contains"
        IgxFilterOptions.prototype.matchFn = function (valueToTest, inputValue) {
            return valueToTest.indexOf(inputValue && inputValue.toLowerCase() || '') > -1;
        };
        // Function - executed after matching test for every matched item
        // Default behavior - shows the item
        IgxFilterOptions.prototype.metConditionFn = function (item) {
            if (item.hasOwnProperty('hidden')) {
                item.hidden = false;
            }
        };
        // Function - executed for every NOT matched item after matching test
        // Default behavior - hides the item
        IgxFilterOptions.prototype.overdueConditionFn = function (item) {
            if (item.hasOwnProperty('hidden')) {
                item.hidden = true;
            }
        };
        return IgxFilterOptions;
    }());
    var IgxFilterDirective = /** @class */ (function () {
        function IgxFilterDirective(element, renderer) {
            this.element = element;
            this.filtering = new core.EventEmitter(false); // synchronous event emitter
            this.filtered = new core.EventEmitter();
        }
        IgxFilterDirective.prototype.ngOnChanges = function (changes) {
            // Detect only changes of input value
            if (changes.filterOptions &&
                changes.filterOptions.currentValue &&
                changes.filterOptions.currentValue.inputValue !== undefined &&
                changes.filterOptions.previousValue &&
                changes.filterOptions.currentValue.inputValue !== changes.filterOptions.previousValue.inputValue) {
                this.filter();
            }
        };
        IgxFilterDirective.prototype.filter = function () {
            if (!this.filterOptions.items) {
                return;
            }
            var args = { cancel: false, items: this.filterOptions.items };
            this.filtering.emit(args);
            if (args.cancel) {
                return;
            }
            var pipe = new IgxFilterPipe();
            var filtered = pipe.transform(this.filterOptions.items, this.filterOptions);
            this.filtered.emit({ filteredItems: filtered });
        };
        IgxFilterDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 }
        ]; };
        __decorate([
            core.Output()
        ], IgxFilterDirective.prototype, "filtering", void 0);
        __decorate([
            core.Output()
        ], IgxFilterDirective.prototype, "filtered", void 0);
        __decorate([
            core.Input('igxFilter')
        ], IgxFilterDirective.prototype, "filterOptions", void 0);
        IgxFilterDirective = __decorate([
            core.Directive({
                selector: '[igxFilter]'
            })
        ], IgxFilterDirective);
        return IgxFilterDirective;
    }());
    var IgxFilterPipe = /** @class */ (function () {
        function IgxFilterPipe() {
        }
        IgxFilterPipe.prototype.transform = function (items, 
        // options - initial settings of filter functionality
        options) {
            var result = [];
            if (!items || !items.length || !options) {
                return;
            }
            if (options.items) {
                items = options.items;
            }
            result = items.filter(function (item) {
                var match = options.matchFn(options.formatter(options.get_value(item, options.key)), options.inputValue);
                if (match) {
                    if (options.metConditionFn) {
                        options.metConditionFn(item);
                    }
                }
                else {
                    if (options.overdueConditionFn) {
                        options.overdueConditionFn(item);
                    }
                }
                return match;
            });
            return result;
        };
        IgxFilterPipe = __decorate([
            core.Pipe({
                name: 'igxFilter',
                pure: false
            })
        ], IgxFilterPipe);
        return IgxFilterPipe;
    }());
    /**
     * @hidden
     */
    var IgxFilterModule = /** @class */ (function () {
        function IgxFilterModule() {
        }
        IgxFilterModule = __decorate([
            core.NgModule({
                declarations: [IgxFilterDirective, IgxFilterPipe],
                exports: [IgxFilterDirective, IgxFilterPipe],
                imports: [common.CommonModule]
            })
        ], IgxFilterModule);
        return IgxFilterModule;
    }());

    var IgxFocusDirective = /** @class */ (function () {
        function IgxFocusDirective(element, comp) {
            this.element = element;
            this.comp = comp;
            this.focusState = true;
        }
        Object.defineProperty(IgxFocusDirective.prototype, "focused", {
            /**
             * Returns the state of the igxFocus.
             * ```typescript
             * @ViewChild('focusContainer', {read: IgxFocusDirective})
             * public igxFocus: IgxFocusDirective;
             * let isFocusOn = this.igxFocus.focused;
             * ```
             * @memberof IgxFocusDirective
             */
            get: function () {
                return this.focusState;
            },
            /**
             * Sets the state of the igxFocus.
             * ```html
             * <igx-input-group >
             *  <input #focusContainer igxInput [igxFocus]="true"/>
             * </igx-input-group>
             * ```
             * @memberof IgxFocusDirective
             */
            set: function (val) {
                this.focusState = val;
                this.trigger();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxFocusDirective.prototype, "nativeElement", {
            /**
             * Gets the native element of the igxFocus.
             * ```typescript
             * @ViewChild('focusContainer', {read: IgxFocusDirective})
             * public igxFocus: IgxFocusDirective;
             * let igxFocusNativeElement = this.igxFocus.nativeElement;
             * ```
             * @memberof IgxFocusDirective
             */
            get: function () {
                if (this.comp && this.comp[0] && this.comp[0].getEditElement) {
                    return this.comp[0].getEditElement();
                }
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Triggers the igxFocus state.
         * ```typescript
         * @ViewChild('focusContainer', {read: IgxFocusDirective})
         * public igxFocus: IgxFocusDirective;
         * this.igxFocus.trigger();
         * ```
         * @memberof IgxFocusDirective
         */
        IgxFocusDirective.prototype.trigger = function () {
            var _this = this;
            if (this.focusState) {
                requestAnimationFrame(function () { return _this.nativeElement.focus(); });
            }
        };
        IgxFocusDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: Array, decorators: [{ type: core.Inject, args: [forms.NG_VALUE_ACCESSOR,] }, { type: core.Self }, { type: core.Optional }] }
        ]; };
        __decorate([
            core.Input('igxFocus')
        ], IgxFocusDirective.prototype, "focused", null);
        IgxFocusDirective = __decorate([
            core.Directive({
                exportAs: 'igxFocus',
                selector: '[igxFocus]'
            }),
            __param(1, core.Inject(forms.NG_VALUE_ACCESSOR)), __param(1, core.Self()), __param(1, core.Optional())
        ], IgxFocusDirective);
        return IgxFocusDirective;
    }());
    /**
     * @hidden
     */
    var IgxFocusModule = /** @class */ (function () {
        function IgxFocusModule() {
        }
        IgxFocusModule = __decorate([
            core.NgModule({
                declarations: [IgxFocusDirective],
                exports: [IgxFocusDirective]
            })
        ], IgxFocusModule);
        return IgxFocusModule;
    }());

    var IgxLayoutDirective = /** @class */ (function () {
        function IgxLayoutDirective() {
            /**
             * Sets the default flow direction of the container's children.
             *
             * Defaults to `rows`.
             *
             * ```html
             *  <div
             *   igxLayout
             *   igxLayoutDir="row">
             *    <div igxFlex>1</div>
             *    <div igxFlex>2</div>
             *    <div igxFlex>3</div>
             *  </div>
             * ```
             */
            this.dir = 'row';
            /**
             * Defines the direction flex children are placed in the flex container.
             *
             * When set to `true`, the `rows` direction goes right to left and `columns` goes bottom to top.
             *
             * ```html
             * <div
             *   igxLayout
             *   igxLayoutReverse="true">
             *    <div igxFlex>1</div>
             *    <div igxFlex>2</div>
             *    <div igxFlex>3</div>
             * </div>
             * ```
             */
            this.reverse = false;
            /**
             * By default the immediate children will all try to fit onto one line.
             *
             * The default value `nowrap` sets this behavior.
             *
             * Other accepted values are `wrap` and `wrap-reverse`.
             *
             * ```html
             * <div
             *   igxLayout
             *   igxLayoutDir="row"
             *   igxLayoutWrap="wrap">
             *    <div igxFlex igxFlexGrow="0">1</div>
             *    <div igxFlex igxFlexGrow="0">2</div>
             *    <div igxFlex igxFlexGrow="0">3</div>
             * </div>
             * ```
             */
            this.wrap = 'nowrap';
            /**
             * Defines the alignment along the main axis.
             *
             * Defaults to `flex-start` which packs the children toward the start line.
             *
             * Other possible values are `flex-end`, `center`, `space-between`, `space-around`.
             *
             * ```html
             * <div
             *   igxLayout
             *   igxLayoutDir="column"
             *   igxLayoutJustify="space-between">
             *    <div>1</div>
             *    <div>2</div>
             *    <div>3</div>
             * </div>
             * ```
             */
            this.justify = 'flex-start';
            /**
             * Defines the default behavior for how children are laid out along the corss axis of the current line.
             *
             * Defaults to `flex-start`.
             *
             * Other possible values are `flex-end`, `center`, `baseline`, and `stretch`.
             *
             * ```html
             * <div
             *   igxLayout
             *   igxLayoutDir="column"
             *   igxLayoutItemAlign="start">
             *    <div igxFlex igxFlexGrow="0">1</div>
             *    <div igxFlex igxFlexGrow="0">2</div>
             *    <div igxFlex igxFlexGrow="0">3</div>
             * </div>
             * ```
             */
            this.itemAlign = 'stretch';
            /**
             * @hidden
             */
            this.display = 'flex';
        }
        Object.defineProperty(IgxLayoutDirective.prototype, "flexwrap", {
            /**
             * @hidden
             */
            get: function () { return this.wrap; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLayoutDirective.prototype, "justifycontent", {
            /**
             * @hidden
             */
            get: function () { return this.justify; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLayoutDirective.prototype, "align", {
            /**
             * @hidden
             */
            get: function () { return this.itemAlign; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLayoutDirective.prototype, "direction", {
            /**
             * @hidden
             */
            get: function () {
                if (this.reverse) {
                    return (this.dir === 'row') ? 'row-reverse' : 'column-reverse';
                }
                return (this.dir === 'row') ? 'row' : 'column';
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input('igxLayoutDir')
        ], IgxLayoutDirective.prototype, "dir", void 0);
        __decorate([
            core.Input('igxLayoutReverse')
        ], IgxLayoutDirective.prototype, "reverse", void 0);
        __decorate([
            core.Input('igxLayoutWrap')
        ], IgxLayoutDirective.prototype, "wrap", void 0);
        __decorate([
            core.Input('igxLayoutJustify')
        ], IgxLayoutDirective.prototype, "justify", void 0);
        __decorate([
            core.Input('igxLayoutItemAlign')
        ], IgxLayoutDirective.prototype, "itemAlign", void 0);
        __decorate([
            core.HostBinding('style.display')
        ], IgxLayoutDirective.prototype, "display", void 0);
        __decorate([
            core.HostBinding('style.flex-wrap')
        ], IgxLayoutDirective.prototype, "flexwrap", null);
        __decorate([
            core.HostBinding('style.justify-content')
        ], IgxLayoutDirective.prototype, "justifycontent", null);
        __decorate([
            core.HostBinding('style.align-items')
        ], IgxLayoutDirective.prototype, "align", null);
        __decorate([
            core.HostBinding('style.flex-direction')
        ], IgxLayoutDirective.prototype, "direction", null);
        IgxLayoutDirective = __decorate([
            core.Directive({
                selector: '[igxLayout]'
            })
        ], IgxLayoutDirective);
        return IgxLayoutDirective;
    }());
    var IgxFlexDirective = /** @class */ (function () {
        function IgxFlexDirective() {
            /**
             * Applies the `grow` attribute to an element that uses the directive.
             *
             * Default value is `1`.
             *
             * ```html
             * <div>
             *    <div igxFlex igxFlexGrow="0">Content1</div>
             *    <div igxFlex igxFlexGrow="1">Content2</div>
             *    <div igxFlex igxFlexGrow="0">Content3</div>
             * </div>
             * ```
             */
            this.grow = 1;
            /**
             * Applies the `shrink` attribute to an element that uses the directive.
             *
             * Default value is `1`.
             *
             * ```html
             * <div>
             *    <div igxFlex igxFlexShrink="1">Content1</div>
             *    <div igxFlex igxFlexShrink="0">Content2</div>
             *    <div igxFlex igxFlexShrink="1">Content3</div>
             * </div>
             * ```
             */
            this.shrink = 1;
            /**
             * Applies the directive to an element.
             *
             * Possible values include `igxFlexGrow`, `igxFlexShrink`, `igxFlexOrder`, `igxFlexBasis`.
             *
             * ```html
             * <div igxFlex>Content</div>
             * ```
             */
            this.flex = '';
            /**
             * Applies the `order` attribute to an element that uses the directive.
             *
             * Default value is `0`.
             *
             * ```html
             * <div>
             *    <div igxFlex igxFlexOrder="1">Content1</div>
             *    <div igxFlex igxFlexOrder="0">Content2</div>
             *    <div igxFlex igxFlexOrder="2">Content3</div>
             * </div>
             * ```
             */
            this.order = 0;
            /**
             * Applies the `flex-basis` attribute to an element that uses the directive.
             *
             * Default value is `auto`.
             *
             * Other possible values include `content`, `max-content`, `min-content`, `fit-content`.
             *
             * ```html
             * <div igxFlex igxFlexBasis="fit-content">Content</div>
             * ```
             */
            this.basis = 'auto';
        }
        Object.defineProperty(IgxFlexDirective.prototype, "style", {
            /**
             * @hidden
             */
            get: function () {
                if (this.flex) {
                    return "" + this.flex;
                }
                return this.grow + " " + this.shrink + " " + this.basis;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxFlexDirective.prototype, "itemorder", {
            /**
             * @hidden
             */
            get: function () {
                return this.order || 0;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input('igxFlexGrow')
        ], IgxFlexDirective.prototype, "grow", void 0);
        __decorate([
            core.Input('igxFlexShrink')
        ], IgxFlexDirective.prototype, "shrink", void 0);
        __decorate([
            core.Input('igxFlex')
        ], IgxFlexDirective.prototype, "flex", void 0);
        __decorate([
            core.Input('igxFlexOrder')
        ], IgxFlexDirective.prototype, "order", void 0);
        __decorate([
            core.Input('igxFlexBasis')
        ], IgxFlexDirective.prototype, "basis", void 0);
        __decorate([
            core.HostBinding('style.flex')
        ], IgxFlexDirective.prototype, "style", null);
        __decorate([
            core.HostBinding('style.order')
        ], IgxFlexDirective.prototype, "itemorder", null);
        IgxFlexDirective = __decorate([
            core.Directive({
                selector: '[igxFlex]'
            })
        ], IgxFlexDirective);
        return IgxFlexDirective;
    }());
    /**
     * @hidden
     */
    var IgxLayoutModule = /** @class */ (function () {
        function IgxLayoutModule() {
        }
        IgxLayoutModule = __decorate([
            core.NgModule({
                declarations: [IgxFlexDirective, IgxLayoutDirective],
                exports: [IgxFlexDirective, IgxLayoutDirective]
            })
        ], IgxLayoutModule);
        return IgxLayoutModule;
    }());

    /**
     * @hidden
     */
    var MASK_FLAGS = ['C', '&', 'a', 'A', '?', 'L', '9', '0', '#'];
    /**
     * @hidden
     */
    var KEYS = {
        Ctrl: 17,
        Z: 90,
        Y: 89,
        X: 88,
        BACKSPACE: 8,
        DELETE: 46
    };
    /**
     * @hidden
     */
    var MaskHelper = /** @class */ (function () {
        function MaskHelper() {
        }
        Object.defineProperty(MaskHelper.prototype, "cursor", {
            get: function () {
                return this._cursor;
            },
            enumerable: true,
            configurable: true
        });
        MaskHelper.prototype.parseValueByMask = function (value, maskOptions, cursor) {
            var inputValue = value;
            var mask = maskOptions.format;
            var literals = this.getMaskLiterals(mask);
            var literalKeys = Array.from(literals.keys());
            var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
            if (inputValue.length < mask.length) { // BACKSPACE, DELETE
                if (inputValue === '' && cursor === -1) {
                    this._cursor = 0;
                    return this.parseValueByMaskOnInit(value, maskOptions);
                } // workaround for IE 'x' button
                if (nonLiteralIndeces.indexOf(cursor + 1) !== -1) {
                    inputValue = this.insertCharAt(inputValue, cursor + 1, maskOptions.promptChar);
                    this._cursor = cursor + 1;
                }
                else {
                    inputValue = this.insertCharAt(inputValue, cursor + 1, mask[cursor + 1]);
                    this._cursor = cursor + 1;
                    for (var i = this._cursor; i < 0; i--) {
                        if (literalKeys.indexOf(this._cursor) !== -1) {
                            this._cursor--;
                        }
                        else {
                            break;
                        }
                    }
                }
            }
            else {
                var char = inputValue[cursor];
                var isCharValid = this.validateCharOnPostion(char, cursor, mask);
                if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                    inputValue = this.replaceCharAt(inputValue, cursor, '');
                    if (isCharValid) {
                        inputValue = this.replaceCharAt(inputValue, cursor, char);
                        this._cursor = cursor + 1;
                    }
                    else {
                        this._cursor = cursor;
                    }
                }
                else {
                    inputValue = this.replaceCharAt(inputValue, cursor, '');
                    this._cursor = ++cursor;
                    for (var i = cursor; i < mask.length; i++) {
                        if (literalKeys.indexOf(this._cursor) !== -1) {
                            this._cursor = ++cursor;
                        }
                        else {
                            isCharValid = this.validateCharOnPostion(char, cursor, mask);
                            if (isCharValid) {
                                inputValue = this.replaceCharAt(inputValue, cursor, char);
                                this._cursor = ++cursor;
                                break;
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
            }
            return inputValue;
        };
        MaskHelper.prototype.parseMask = function (maskOptions) {
            var e_1, _a;
            var _this = this;
            var outputVal = '';
            var mask = maskOptions.format;
            var literals = this.getMaskLiterals(mask);
            try {
                for (var mask_1 = __values(mask), mask_1_1 = mask_1.next(); !mask_1_1.done; mask_1_1 = mask_1.next()) {
                    var maskSym = mask_1_1.value;
                    outputVal += maskOptions.promptChar;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (mask_1_1 && !mask_1_1.done && (_a = mask_1.return)) _a.call(mask_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            literals.forEach(function (val, key) {
                outputVal = _this.replaceCharAt(outputVal, key, val);
            });
            return outputVal;
        };
        MaskHelper.prototype.parseValueByMaskOnInit = function (inputVal, maskOptions) {
            var e_2, _a, e_3, _b;
            var _this = this;
            var outputVal = '';
            var value = '';
            var mask = maskOptions.format;
            var literals = this.getMaskLiterals(mask);
            var literalKeys = Array.from(literals.keys());
            var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
            var literalValues = Array.from(literals.values());
            if (inputVal != null) {
                value = inputVal.toString();
            }
            try {
                for (var mask_2 = __values(mask), mask_2_1 = mask_2.next(); !mask_2_1.done; mask_2_1 = mask_2.next()) {
                    var maskSym = mask_2_1.value;
                    outputVal += maskOptions.promptChar;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (mask_2_1 && !mask_2_1.done && (_a = mask_2.return)) _a.call(mask_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            literals.forEach(function (val, key) {
                outputVal = _this.replaceCharAt(outputVal, key, val);
            });
            if (!value) {
                return outputVal;
            }
            var nonLiteralValues = this.getNonLiteralValues(value, literalValues);
            for (var i = 0; i < nonLiteralValues.length; i++) {
                var char = nonLiteralValues[i];
                var isCharValid = this.validateCharOnPostion(char, nonLiteralIndeces[i], mask);
                if (!isCharValid && char !== maskOptions.promptChar) {
                    nonLiteralValues[i] = maskOptions.promptChar;
                }
            }
            if (nonLiteralValues.length > nonLiteralIndeces.length) {
                nonLiteralValues.splice(nonLiteralIndeces.length);
            }
            var pos = 0;
            try {
                for (var nonLiteralValues_1 = __values(nonLiteralValues), nonLiteralValues_1_1 = nonLiteralValues_1.next(); !nonLiteralValues_1_1.done; nonLiteralValues_1_1 = nonLiteralValues_1.next()) {
                    var nonLiteralValue = nonLiteralValues_1_1.value;
                    var char = nonLiteralValue;
                    outputVal = this.replaceCharAt(outputVal, nonLiteralIndeces[pos++], char);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (nonLiteralValues_1_1 && !nonLiteralValues_1_1.done && (_b = nonLiteralValues_1.return)) _b.call(nonLiteralValues_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return outputVal;
        };
        MaskHelper.prototype.restoreValueFromMask = function (value, maskOptions) {
            var e_4, _a;
            var outputVal = '';
            var mask = maskOptions.format;
            var literals = this.getMaskLiterals(mask);
            var literalValues = Array.from(literals.values());
            try {
                for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                    var val = value_1_1.value;
                    if (literalValues.indexOf(val) === -1) {
                        if (val !== maskOptions.promptChar) {
                            outputVal += val;
                        }
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            return outputVal;
        };
        MaskHelper.prototype.parseValueByMaskUponSelection = function (value, maskOptions, cursor, selection) {
            var isCharValid;
            var inputValue = value;
            var char = inputValue[cursor];
            var mask = maskOptions.format;
            var literals = this.getMaskLiterals(mask);
            var literalKeys = Array.from(literals.keys());
            var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
            if (!this.data) {
                this._cursor = cursor < 0 ? ++cursor : cursor;
                if (nonLiteralIndeces.indexOf(this._cursor) !== -1) {
                    isCharValid = this.validateCharOnPostion(char, this._cursor, mask);
                    inputValue = isCharValid ? this.replaceCharAt(inputValue, this._cursor++, char) :
                        inputValue = this.replaceCharAt(inputValue, this._cursor++, maskOptions.promptChar);
                    selection--;
                    if (selection > 0) {
                        for (var i = 0; i < selection; i++) {
                            cursor++;
                            inputValue = nonLiteralIndeces.indexOf(cursor) !== -1 ?
                                this.insertCharAt(inputValue, cursor, maskOptions.promptChar) :
                                this.insertCharAt(inputValue, cursor, mask[cursor]);
                        }
                    }
                }
                else {
                    inputValue = this.replaceCharAt(inputValue, this._cursor, mask[this._cursor]);
                    this._cursor++;
                    selection--;
                    var isMarked = false;
                    if (selection > 0) {
                        cursor = this._cursor;
                        for (var i = 0; i < selection; i++) {
                            if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                                isCharValid = this.validateCharOnPostion(char, cursor, mask);
                                if (isCharValid && !isMarked) {
                                    inputValue = this.insertCharAt(inputValue, cursor, char);
                                    cursor++;
                                    this._cursor++;
                                    isMarked = true;
                                }
                                else {
                                    inputValue = this.insertCharAt(inputValue, cursor, maskOptions.promptChar);
                                    cursor++;
                                }
                            }
                            else {
                                inputValue = this.insertCharAt(inputValue, cursor, mask[cursor]);
                                if (cursor === this._cursor) {
                                    this._cursor++;
                                }
                                cursor++;
                            }
                        }
                    }
                }
            }
            else {
                if (inputValue === '' && cursor === -1) {
                    this._cursor = 0;
                    return this.parseValueByMaskOnInit(value, maskOptions);
                } // workaround for IE 'x' button
                if (this._cursor < 0) {
                    this._cursor++;
                    cursor++;
                }
                cursor++;
                this._cursor = cursor;
                for (var i = 0; i < selection; i++) {
                    if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                        inputValue = this.insertCharAt(inputValue, cursor, maskOptions.promptChar);
                        cursor++;
                    }
                    else {
                        inputValue = this.insertCharAt(inputValue, cursor, mask[cursor]);
                        cursor++;
                    }
                }
            }
            return inputValue;
        };
        MaskHelper.prototype.parseValueByMaskUponCopyPaste = function (value, maskOptions, cursor, clipboardData, selection) {
            var e_5, _a;
            var inputValue = value;
            var mask = maskOptions.format;
            var literals = this.getMaskLiterals(mask);
            var literalKeys = Array.from(literals.keys());
            var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
            var selectionEnd = cursor + selection;
            this._cursor = cursor;
            try {
                for (var clipboardData_1 = __values(clipboardData), clipboardData_1_1 = clipboardData_1.next(); !clipboardData_1_1.done; clipboardData_1_1 = clipboardData_1.next()) {
                    var clipboardSym = clipboardData_1_1.value;
                    var char = clipboardSym;
                    if (this._cursor > mask.length) {
                        return inputValue;
                    }
                    if (nonLiteralIndeces.indexOf(this._cursor) !== -1) {
                        var isCharValid = this.validateCharOnPostion(char, this._cursor, mask);
                        if (isCharValid) {
                            inputValue = this.replaceCharAt(inputValue, this._cursor++, char);
                        }
                    }
                    else {
                        for (var i = cursor; i < mask.length; i++) {
                            if (literalKeys.indexOf(this._cursor) !== -1) {
                                this._cursor++;
                            }
                            else {
                                var isCharValid = this.validateCharOnPostion(char, this._cursor, mask);
                                if (isCharValid) {
                                    inputValue = this.replaceCharAt(inputValue, this._cursor++, char);
                                }
                                break;
                            }
                        }
                    }
                    selection--;
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (clipboardData_1_1 && !clipboardData_1_1.done && (_a = clipboardData_1.return)) _a.call(clipboardData_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
            if (selection > 0) {
                for (var i = this._cursor; i < selectionEnd; i++) {
                    if (literalKeys.indexOf(this._cursor) !== -1) {
                        this._cursor++;
                    }
                    else {
                        inputValue = this.replaceCharAt(inputValue, this._cursor++, maskOptions.promptChar);
                    }
                }
            }
            return inputValue;
        };
        MaskHelper.prototype.validateCharOnPostion = function (inputChar, position, mask) {
            var regex;
            var isValid;
            var letterOrDigitRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
            var letterDigitOrSpaceRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
            var letterRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
            var letteSpaceRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
            var digitRegEx = '[\\d]';
            var digitSpaceRegEx = '[\\d\\u0020]';
            var digitSpecialRegEx = '[\\d-\\+]';
            switch (mask.charAt(position)) {
                case 'C':
                    isValid = inputChar !== '';
                    break;
                case '&':
                    regex = new RegExp('[\\u0020]');
                    isValid = !regex.test(inputChar);
                    break;
                case 'a':
                    regex = new RegExp(letterDigitOrSpaceRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case 'A':
                    regex = new RegExp(letterOrDigitRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case '?':
                    regex = new RegExp(letteSpaceRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case 'L':
                    regex = new RegExp(letterRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case '0':
                    regex = new RegExp(digitRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case '9':
                    regex = new RegExp(digitSpaceRegEx);
                    isValid = regex.test(inputChar);
                    break;
                case '#':
                    regex = new RegExp(digitSpecialRegEx);
                    isValid = regex.test(inputChar);
                    break;
                default: {
                    isValid = null;
                }
            }
            return isValid;
        };
        MaskHelper.prototype.replaceCharAt = function (strValue, index, char) {
            if (strValue !== undefined) {
                return strValue.substring(0, index) + char + strValue.substring(index + 1);
            }
        };
        MaskHelper.prototype.insertCharAt = function (strValue, index, char) {
            if (strValue !== undefined) {
                return strValue.substring(0, index) + char + strValue.substring(index);
            }
        };
        MaskHelper.prototype.getMaskLiterals = function (mask) {
            var literals = new Map();
            for (var i = 0; i < mask.length; i++) {
                var char = mask.charAt(i);
                if (MASK_FLAGS.indexOf(char) === -1) {
                    literals.set(i, char);
                }
            }
            return literals;
        };
        MaskHelper.prototype.getNonLiteralIndeces = function (mask, literalKeys) {
            var nonLiteralsIndeces = new Array();
            for (var i = 0; i < mask.length; i++) {
                if (literalKeys.indexOf(i) === -1) {
                    nonLiteralsIndeces.push(i);
                }
            }
            return nonLiteralsIndeces;
        };
        MaskHelper.prototype.getNonLiteralValues = function (value, literalValues) {
            var e_6, _a;
            var nonLiteralValues = new Array();
            try {
                for (var value_2 = __values(value), value_2_1 = value_2.next(); !value_2_1.done; value_2_1 = value_2.next()) {
                    var val = value_2_1.value;
                    if (literalValues.indexOf(val) === -1) {
                        nonLiteralValues.push(val);
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (value_2_1 && !value_2_1.done && (_a = value_2.return)) _a.call(value_2);
                }
                finally { if (e_6) throw e_6.error; }
            }
            return nonLiteralValues;
        };
        return MaskHelper;
    }());

    var noop = function () { };
    var ɵ0 = noop;
    var IgxMaskDirective = /** @class */ (function () {
        function IgxMaskDirective(elementRef) {
            this.elementRef = elementRef;
            /**
             * Emits an event each time the value changes.
             * Provides `rawValue: string` and `formattedValue: string` as event arguments.
             * ```html
             * <input (onValueChange) = "onValueChange(rawValue: string, formattedValue: string)">
             * ```
             */
            this.onValueChange = new core.EventEmitter();
            /**
             *@hidden
             */
            this._maskOptions = {
                format: '',
                promptChar: ''
            };
            /**
             *@hidden
             */
            this._onTouchedCallback = noop;
            /**
             *@hidden
             */
            this._onChangeCallback = noop;
            this.maskHelper = new MaskHelper();
        }
        IgxMaskDirective_1 = IgxMaskDirective;
        Object.defineProperty(IgxMaskDirective.prototype, "placeholder", {
            get: function () {
                return this._placeholder;
            },
            /**
             * Specifies a placeholder.
             * ```html
             * <input placeholder = "enter text...">
             * ```
             * @memberof IgxMaskDirective
             */
            set: function (val) {
                this._placeholder = val;
                this.nativeElement.setAttribute('placeholder', this._placeholder);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "value", {
            /**
             *@hidden
             */
            get: function () {
                return this.nativeElement.value;
            },
            /**
             *@hidden
             */
            set: function (val) {
                this.nativeElement.value = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "nativeElement", {
            /**
             *@hidden
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "selectionStart", {
            /**
             *@hidden
             */
            get: function () {
                return this.nativeElement.selectionStart;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMaskDirective.prototype, "selectionEnd", {
            /**
             *@hidden
             */
            get: function () {
                return this.nativeElement.selectionEnd;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.ngOnInit = function () {
            if (this.promptChar && this.promptChar.length > 1) {
                this._maskOptions.promptChar = this.promptChar = this.promptChar.substring(0, 1);
            }
            this._maskOptions.format = this.mask ? this.mask : 'CCCCCCCCCC';
            this._maskOptions.promptChar = this.promptChar ? this.promptChar : '_';
            this.nativeElement.setAttribute('placeholder', this.placeholder ? this.placeholder : this._maskOptions.format);
        };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.onKeydown = function (event) {
            var key = event.keyCode || event.charCode;
            if (isIE() && this._stopPropagation) {
                this._stopPropagation = false;
            }
            if (key === KEYS.Ctrl) {
                this._ctrlDown = true;
            }
            if ((this._ctrlDown && key === KEYS.Z) || (this._ctrlDown && key === KEYS.Y)) {
                event.preventDefault();
            }
            this._key = key;
            this._selection = Math.abs(this.selectionEnd - this.selectionStart);
        };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.onKeyup = function (event) {
            var key = event.keyCode || event.charCode;
            if (key === KEYS.Ctrl) {
                this._ctrlDown = false;
            }
        };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.onPaste = function (event) {
            this._paste = true;
            this._valOnPaste = this.value;
            this._cursorOnPaste = this.getCursorPosition();
        };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.onInputChanged = function (event) {
            if (isIE() && this._stopPropagation) {
                this._stopPropagation = false;
                return;
            }
            if (this._paste) {
                this._paste = false;
                var clipboardData = this.value.substring(this._cursorOnPaste, this.getCursorPosition());
                this.value = this.maskHelper.parseValueByMaskUponCopyPaste(this._valOnPaste, this._maskOptions, this._cursorOnPaste, clipboardData, this._selection);
                this.setCursorPosition(this.maskHelper.cursor);
            }
            else {
                var currentCursorPos = this.getCursorPosition();
                this.maskHelper.data = (this._key === KEYS.BACKSPACE) || (this._key === KEYS.DELETE);
                this.value = this._selection && this._selection !== 0 ?
                    this.maskHelper.parseValueByMaskUponSelection(this.value, this._maskOptions, currentCursorPos - 1, this._selection) :
                    this.maskHelper.parseValueByMask(this.value, this._maskOptions, currentCursorPos - 1);
                this.setCursorPosition(this.maskHelper.cursor);
            }
            var rawVal = this.maskHelper.restoreValueFromMask(this.value, this._maskOptions);
            this.dataValue = this.includeLiterals ? this.value : rawVal;
            this._onChangeCallback(this.dataValue);
            this.onValueChange.emit({ rawValue: rawVal, formattedValue: this.value });
        };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.onFocus = function (value) {
            if (this.focusedValuePipe) {
                if (isIE()) {
                    this._stopPropagation = true;
                }
                this.value = this.focusedValuePipe.transform(value);
            }
            else {
                this.value = this.maskHelper.parseValueByMaskOnInit(this.value, this._maskOptions);
            }
        };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.onBlur = function (value) {
            if (this.displayValuePipe) {
                this.value = this.displayValuePipe.transform(value);
            }
            else if (value === this.maskHelper.parseMask(this._maskOptions)) {
                this.value = '';
            }
        };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.getCursorPosition = function () {
            return this.nativeElement.selectionStart;
        };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.setCursorPosition = function (start, end) {
            if (end === void 0) { end = start; }
            this.nativeElement.setSelectionRange(start, end);
        };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.writeValue = function (value) {
            if (this.promptChar && this.promptChar.length > 1) {
                this._maskOptions.promptChar = this.promptChar.substring(0, 1);
            }
            this.value = value ? this.maskHelper.parseValueByMaskOnInit(value, this._maskOptions) : '';
            if (this.displayValuePipe) {
                this.value = this.displayValuePipe.transform(this.value);
            }
            this.dataValue = this.includeLiterals ? this.value : value;
            this._onChangeCallback(this.dataValue);
            this.onValueChange.emit({ rawValue: value, formattedValue: this.value });
        };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.registerOnChange = function (fn) { this._onChangeCallback = fn; };
        /**
         *@hidden
         */
        IgxMaskDirective.prototype.registerOnTouched = function (fn) { this._onTouchedCallback = fn; };
        var IgxMaskDirective_1;
        IgxMaskDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input('igxMask')
        ], IgxMaskDirective.prototype, "mask", void 0);
        __decorate([
            core.Input()
        ], IgxMaskDirective.prototype, "promptChar", void 0);
        __decorate([
            core.Input()
        ], IgxMaskDirective.prototype, "includeLiterals", void 0);
        __decorate([
            core.Input()
        ], IgxMaskDirective.prototype, "placeholder", null);
        __decorate([
            core.Input()
        ], IgxMaskDirective.prototype, "displayValuePipe", void 0);
        __decorate([
            core.Input()
        ], IgxMaskDirective.prototype, "focusedValuePipe", void 0);
        __decorate([
            core.Input()
        ], IgxMaskDirective.prototype, "dataValue", void 0);
        __decorate([
            core.Output()
        ], IgxMaskDirective.prototype, "onValueChange", void 0);
        __decorate([
            core.HostListener('keydown', ['$event'])
        ], IgxMaskDirective.prototype, "onKeydown", null);
        __decorate([
            core.HostListener('keyup', ['$event'])
        ], IgxMaskDirective.prototype, "onKeyup", null);
        __decorate([
            core.HostListener('paste', ['$event'])
        ], IgxMaskDirective.prototype, "onPaste", null);
        __decorate([
            core.HostListener('input', ['$event'])
        ], IgxMaskDirective.prototype, "onInputChanged", null);
        __decorate([
            core.HostListener('focus', ['$event.target.value'])
        ], IgxMaskDirective.prototype, "onFocus", null);
        __decorate([
            core.HostListener('blur', ['$event.target.value'])
        ], IgxMaskDirective.prototype, "onBlur", null);
        IgxMaskDirective = IgxMaskDirective_1 = __decorate([
            core.Directive({
                providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxMaskDirective_1, multi: true }],
                selector: '[igxMask]'
            })
        ], IgxMaskDirective);
        return IgxMaskDirective;
    }());
    /**
     * @hidden
     */
    var IgxMaskModule = /** @class */ (function () {
        function IgxMaskModule() {
        }
        IgxMaskModule = __decorate([
            core.NgModule({
                declarations: [IgxMaskDirective],
                exports: [IgxMaskDirective],
                imports: [common.CommonModule]
            })
        ], IgxMaskModule);
        return IgxMaskModule;
    }());


    (function (RadioLabelPosition) {
        RadioLabelPosition["BEFORE"] = "before";
        RadioLabelPosition["AFTER"] = "after";
    })(exports.RadioLabelPosition || (exports.RadioLabelPosition = {}));
    var nextId = 0;
    var noop$1 = function () { };
    var ɵ0$1 = noop$1;
    /**
     * **Ignite UI for Angular Radio Button** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
     *
     * The Ignite UI Radio Button allows the user to select a single option from an available set of options that are listed side by side.
     *
     * Example:
     * ```html
     * <igx-radio>
     *   Simple radio button
     * </igx-radio>
     * ```
     */
    var IgxRadioComponent = /** @class */ (function () {
        function IgxRadioComponent() {
            /**
             * Sets/gets the `id` of the radio component.
             * If not set, the `id` of the first radio component will be `"igx-radio-0"`.
             * ```html
             * <igx-radio id = "my-first-radio"></igx-radio>
             * ```
             * ```typescript
             * let radioId =  this.radio.id;
             * ```
             * @memberof IgxRadioComponent
             */
            this.id = "igx-radio-" + nextId++;
            /**
             * Sets/gets the id of the `label` element in the radio component.
             * If not set, the id of the `label` in the first radio component will be `"igx-radio-0-label"`.
             * ```html
             * <igx-radio labelId = "Label1"></igx-radio>
             * ```
             * ```typescript
             * let labelId =  this.radio.labelId;
             * ```
             * @memberof IgxRadioComponent
             */
            this.labelId = this.id + "-label";
            /**
             * Sets/gets the position of the `label` in the radio component.
             * If not set, `labelPosition` will have value `"after"`.
             * ```html
             * <igx-radio labelPosition = "before"></igx-radio>
             * ```
             * ```typescript
             * let labelPosition =  this.radio.labelPosition;
             * ```
             * @memberof IgxRadioComponent
             */
            this.labelPosition = 'after';
            /**
             * Sets the value of the `tabindex` attribute.
             * ```html
             * <igx-radio [tabindex] = "1"></igx-radio>
             * ```
             * ```typescript
             * let tabIndex =  this.radio.tabindex;
             * ```
             * @memberof IgxRadioComponent
             */
            this.tabindex = null;
            /**
             * Enables/disables the ripple effect on the radio button..
             * If not set, the `disableRipple` will have value `false`.
             * ```html
             * <igx-radio [disableRipple] = "true"></igx-radio>
             * ```
             * ```typescript
             * let isDisabledRipple =  this.radio.disableRipple;
             * ```
             * @memberof IgxRadioComponent
             */
            this.disableRipple = false;
            /**
             * Sets/gets whether the radio button is required.
             * If not set, `required` will have value `false`.
             * ```html
             * <igx-radio [required] = "true"></igx-radio>
             * ```
             * ```typescript
             * let isRequired =  this.radio.required;
             * ```
             * @memberof IgxRadioComponent
             */
            this.required = false;
            /**
             * Sets/gets the `aria-labelledby` attribute of the radio component.
             * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
             * ```html
             * <igx-radio aria-labelledby = "Radio1"></igx-radio>
             * ```
             * ```typescript
             * let ariaLabelledBy = this.radio.ariaLabelledBy;
             * ```
             * @memberof IgxRadioComponent
             */
            this.ariaLabelledBy = this.labelId;
            /**
             * Sets/gets the `aria-label` attribute of the radio component.
             * ```html
             * <igx-radio aria-label = "Radio1"></igx-radio>
             * ```
             * ```typescript
             * let ariaLabel =  this.radio.ariaLabel;
             * ```
             * @memberof IgxRadioComponent
             */
            this.ariaLabel = null;
            /**
             * An event that is emitted after the radio `value` is changed.
             * Provides references to the `IgxRadioComponent` and the `value` property as event arguments.
             * @memberof IgxRadioComponent
             */
            this.change = new core.EventEmitter();
            /**
             * Returns the class of the radio component.
             * ```typescript
             * let radioClass = this.radio.cssClass;
             * ```
             * @memberof IgxRadioComponent
             */
            this.cssClass = 'igx-radio';
            /**
             * Sets/gets  the `checked` attribute.
             * Default value is `false`.
             * ```html
             * <igx-radio [checked] = "true"></igx-radio>
             * ```
             * ```typescript
             * let isChecked =  this.radio.checked;
             * ```
             * @memberof IgxRadioComponent
             */
            this.checked = false;
            /**
             * Sets/gets  the `disabled` attribute.
             * Default value is `false`.
             * ```html
             * <igx-radio [disabled] = "true"></igx-radio>
             * ```
             * ```typescript
             * let isDisabled =  this.radio.disabled;
             * ```
             * @memberof IgxRadioComponent
             */
            this.disabled = false;
            /**
             * Sets/gets whether the radio component is on focus.
             * Default value is `false`.
             * ```typescript
             * this.radio.focus = true;
             * ```
             * ```typescript
             * let isFocused =  this.radio.focused;
             * ```
             * @memberof IgxRadioComponent
             */
            this.focused = false;
            /**
             *@hidden
             */
            this.inputId = this.id + "-input";
            /**
             *@hidden
             */
            this._value = null;
            /**
             *@hidden
             */
            this._onTouchedCallback = noop$1;
            /**
             *@hidden
             */
            this._onChangeCallback = noop$1;
        }
        IgxRadioComponent_1 = IgxRadioComponent;
        /**
         *@hidden
         */
        IgxRadioComponent.prototype._onRadioChange = function (event) {
            event.stopPropagation();
        };
        /**
         *@hidden
         */
        IgxRadioComponent.prototype._onRadioClick = function (event) {
            event.stopPropagation();
            this.select();
            if (isIE()) {
                this.nativeRadio.nativeElement.blur();
            }
        };
        /**
         *@hidden
         */
        IgxRadioComponent.prototype._onLabelClick = function () {
            this.select();
        };
        /**
         * Selects the current radio button.
         * ```typescript
         * this.radio.select();
         * ```
         * @memberof IgxRadioComponent
         */
        IgxRadioComponent.prototype.select = function () {
            if (this.disabled) {
                return;
            }
            this.checked = true;
            this.focused = false;
            this.change.emit({ value: this.value, radio: this });
            this._onChangeCallback(this.value);
        };
        /**
         * Checks whether the provided value is consistent to the current radio button.
         * If it is, the checked attribute will have value `true`;
         * ```typescript
         * this.radio.writeValue('radioButtonValue');
         * ```
         */
        IgxRadioComponent.prototype.writeValue = function (value) {
            this._value = value;
            this.checked = (this._value === this.value);
        };
        /** @hidden */
        IgxRadioComponent.prototype.getEditElement = function () {
            return this.nativeRadio.nativeElement;
        };
        Object.defineProperty(IgxRadioComponent.prototype, "labelClass", {
            /**
             *@hidden
             */
            get: function () {
                switch (this.labelPosition) {
                    case exports.RadioLabelPosition.BEFORE:
                        return this.cssClass + "__label--before";
                    case exports.RadioLabelPosition.AFTER:
                    default:
                        return this.cssClass + "__label";
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxRadioComponent.prototype.onFocus = function () {
            this.focused = true;
        };
        /**
         *@hidden
         */
        IgxRadioComponent.prototype.onBlur = function () {
            this.focused = false;
            this._onTouchedCallback();
        };
        /**
         *@hidden
         */
        IgxRadioComponent.prototype.registerOnChange = function (fn) { this._onChangeCallback = fn; };
        /**
         *@hidden
         */
        IgxRadioComponent.prototype.registerOnTouched = function (fn) { this._onTouchedCallback = fn; };
        var IgxRadioComponent_1;
        __decorate([
            core.ViewChild('radio', { static: true })
        ], IgxRadioComponent.prototype, "nativeRadio", void 0);
        __decorate([
            core.ViewChild('nativeLabel', { static: true })
        ], IgxRadioComponent.prototype, "nativeLabel", void 0);
        __decorate([
            core.ViewChild('placeholderLabel', { static: true })
        ], IgxRadioComponent.prototype, "placeholderLabel", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxRadioComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxRadioComponent.prototype, "labelId", void 0);
        __decorate([
            core.Input()
        ], IgxRadioComponent.prototype, "labelPosition", void 0);
        __decorate([
            core.Input()
        ], IgxRadioComponent.prototype, "value", void 0);
        __decorate([
            core.Input()
        ], IgxRadioComponent.prototype, "name", void 0);
        __decorate([
            core.Input()
        ], IgxRadioComponent.prototype, "tabindex", void 0);
        __decorate([
            core.Input()
        ], IgxRadioComponent.prototype, "disableRipple", void 0);
        __decorate([
            core.Input()
        ], IgxRadioComponent.prototype, "required", void 0);
        __decorate([
            core.Input('aria-labelledby')
        ], IgxRadioComponent.prototype, "ariaLabelledBy", void 0);
        __decorate([
            core.Input('aria-label')
        ], IgxRadioComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Output()
        ], IgxRadioComponent.prototype, "change", void 0);
        __decorate([
            core.HostBinding('class.igx-radio')
        ], IgxRadioComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('class.igx-radio--checked'),
            core.Input()
        ], IgxRadioComponent.prototype, "checked", void 0);
        __decorate([
            core.HostBinding('class.igx-radio--disabled'),
            core.Input()
        ], IgxRadioComponent.prototype, "disabled", void 0);
        __decorate([
            core.HostBinding('class.igx-radio--focused')
        ], IgxRadioComponent.prototype, "focused", void 0);
        IgxRadioComponent = IgxRadioComponent_1 = __decorate([
            core.Component({
                providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxRadioComponent_1, multi: true }],
                selector: 'igx-radio',
                template: "<input #radio class=\"igx-radio__input\" type=\"radio\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (click)=\"_onRadioClick($event)\"\n    (change)=\"_onRadioChange($event)\"\n    (focus)=\"onFocus()\"\n    (blur)=\"onBlur()\" />\n\n<label #nativeLabel class=\"igx-radio__composite\" igxRipple\n    igxRippleTarget=\".igx-radio__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    [for]=\"inputId\">\n    <div class=\"igx-radio__ripple\"></div>\n</label>\n\n<span #placeholderLabel role=\"label\"\n    [id]=\"labelId\"\n    [class]=\"labelClass\"\n    (click)=\"_onLabelClick()\">\n    <ng-content></ng-content>\n</span>\n"
            })
        ], IgxRadioComponent);
        return IgxRadioComponent;
    }());

    var IgxRippleDirective = /** @class */ (function () {
        function IgxRippleDirective(builder, elementRef, renderer, zone) {
            this.builder = builder;
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.zone = zone;
            /**
             * Sets/gets the ripple target.
             * ```html
             * <div  #rippleContainer class="div-1" igxRipple [igxRippleTarget] = "'.div-1'"></div>
             * ```
             * ```typescript
             * @ViewChild('rippleContainer', {read: IgxRippleDirective})
             * public ripple: IgxRippleDirective;
             * let rippleTarget = this.ripple.rippleTarget;
             * ```
             * Can set the ripple to activate on a child element inside the parent where igxRipple is defined.
             * ```html
             * <div #rippleContainer [igxRippleTarget] = "'#child"'>
             *  <button id="child">Click</button>
             * </div>
             * ```
             * @memberof IgxRippleDirective
             */
            this.rippleTarget = '';
            /**
             * Sets/gets the ripple duration(in milliseconds).
             * Default value is `600`.
             * ```html
             * <button #rippleContainer igxRipple [igxRippleDuration] = "800"></button>
             * ```
             * ```typescript
             * @ViewChild('rippleContainer', {read: IgxRippleDirective})
             * public ripple: IgxRippleDirective;
             * let rippleDuration = this.ripple.rippleDuration;
             * ```
             * @memberof IgxRippleDirective
             */
            this.rippleDuration = 600;
            /**
             * Sets/gets whether the ripple is disabled.
             * Default value is `false`.
             * ```html
             * <button #rippleContainer igxRipple [igxRippleDisabled] = "true"></button>
             * ```
             * ```typescript
             * @ViewChild('rippleContainer', {read: IgxRippleDirective})
             * public ripple: IgxRippleDirective;
             * let isRippleDisabled = this.ripple.rippleDisabled;
             * ```
             * @memberof IgxRippleDirective
             */
            this.rippleDisabled = false;
            this.rippleElementClass = 'igx-ripple__inner';
            this.rippleHostClass = 'igx-ripple';
            this._centered = false;
            this.animationQueue = [];
        }
        Object.defineProperty(IgxRippleDirective.prototype, "centered", {
            /**
             * Enables/disables the ripple to be centered.
             * ```html
             * <button #rippleContainer igxRipple [igxRippleCentered] = "true"></button>
             * ```
             * @memberof IgxRippleDirective
             */
            set: function (value) {
                this._centered = value || this.centered;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRippleDirective.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxRippleDirective.prototype.onMouseDown = function (event) {
            var _this = this;
            this.zone.runOutsideAngular(function () { return _this._ripple(event); });
        };
        IgxRippleDirective.prototype.setStyles = function (rippleElement, styleParams) {
            this.renderer.addClass(rippleElement, this.rippleElementClass);
            this.renderer.setStyle(rippleElement, 'width', styleParams.radius + "px");
            this.renderer.setStyle(rippleElement, 'height', styleParams.radius + "px");
            this.renderer.setStyle(rippleElement, 'top', styleParams.top + "px");
            this.renderer.setStyle(rippleElement, 'left', styleParams.left + "px");
            if (this.rippleColor) {
                this.renderer.setStyle(rippleElement, 'background', this.rippleColor);
            }
        };
        IgxRippleDirective.prototype._ripple = function (event) {
            var _this = this;
            if (this.rippleDisabled) {
                return;
            }
            var target = (this.rippleTarget ? this.nativeElement.querySelector(this.rippleTarget) || this.nativeElement : this.nativeElement);
            var rectBounds = target.getBoundingClientRect();
            var radius = Math.max(rectBounds.width, rectBounds.height);
            var left = event.clientX - rectBounds.left - radius / 2;
            var top = event.clientY - rectBounds.top - radius / 2;
            if (this._centered) {
                left = top = 0;
            }
            var dimensions = {
                radius: radius,
                top: top,
                left: left
            };
            var rippleElement = this.renderer.createElement('span');
            this.setStyles(rippleElement, dimensions);
            this.renderer.addClass(target, this.rippleHostClass);
            this.renderer.appendChild(target, rippleElement);
            var animation = this.builder.build([
                animations.style({ opacity: 0.5, transform: 'scale(.3)' }),
                animations.animate(this.rippleDuration, animations.style({ opacity: 0, transform: 'scale(2)' }))
            ]).create(rippleElement);
            this.animationQueue.push(animation);
            animation.onDone(function () {
                _this.animationQueue.splice(_this.animationQueue.indexOf(animation), 1);
                target.removeChild(rippleElement);
                if (_this.animationQueue.length < 1) {
                    _this.renderer.removeClass(target, _this.rippleHostClass);
                }
            });
            animation.play();
        };
        IgxRippleDirective.ctorParameters = function () { return [
            { type: animations.AnimationBuilder },
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.Input('igxRippleTarget')
        ], IgxRippleDirective.prototype, "rippleTarget", void 0);
        __decorate([
            core.Input('igxRipple')
        ], IgxRippleDirective.prototype, "rippleColor", void 0);
        __decorate([
            core.Input('igxRippleDuration')
        ], IgxRippleDirective.prototype, "rippleDuration", void 0);
        __decorate([
            core.Input('igxRippleCentered')
        ], IgxRippleDirective.prototype, "centered", null);
        __decorate([
            core.Input('igxRippleDisabled')
        ], IgxRippleDirective.prototype, "rippleDisabled", void 0);
        __decorate([
            core.HostListener('mousedown', ['$event'])
        ], IgxRippleDirective.prototype, "onMouseDown", null);
        IgxRippleDirective = __decorate([
            core.Directive({
                selector: '[igxRipple]'
            })
        ], IgxRippleDirective);
        return IgxRippleDirective;
    }());
    /**
     * @hidden
     */
    var IgxRippleModule = /** @class */ (function () {
        function IgxRippleModule() {
        }
        IgxRippleModule = __decorate([
            core.NgModule({
                declarations: [IgxRippleDirective],
                exports: [IgxRippleDirective]
            })
        ], IgxRippleModule);
        return IgxRippleModule;
    }());

    var noop$2 = function () { };
    var ɵ0$2 = noop$2;
    var nextId$1 = 0;
    /**
     * Radio group directive renders set of radio buttons.
     *
     * @igxModule IgxRadioModule
     *
     * @igxTheme igx-radio-theme
     *
     * @igxKeywords radiogroup, radio, button, input
     *
     * @igxGroup Data Entry & Display
     *
     * @remarks
     * The Ignite UI Radio Group allows the user to select a single option from an available set of options that are listed side by side.
     *
     * @example:
     * ```html
     * <igx-radio-group name="radioGroup">
     *   <igx-radio *ngFor="let item of ['Foo', 'Bar', 'Baz']" value="{{item}}">
     *      {{item}}
     *   </igx-radio>
     * </igx-radio-group>
     * ```
     */
    var IgxRadioGroupDirective = /** @class */ (function () {
        function IgxRadioGroupDirective() {
            /**
             * An event that is emitted after the radio group `value` is changed.
             *
             * @remarks
             * Provides references to the selected `IgxRadioComponent` and the `value` property as event arguments.
             *
             * @example
             * ```html
             * <igx-radio-group (change)="handler($event)"></igx-radio-group>
             * ```
             */
            this.change = new core.EventEmitter();
            /**
             * The css class applied to the component.
             * @hidden
             * @internal
             */
            this.cssClass = 'igx-radio-group';
            /**
             * @hidden
             * @internal
             */
            this._onChangeCallback = noop$2;
            /**
             * @hidden
             * @internal
             */
            this._name = "igx-radio-group-" + nextId$1++;
            /**
             * @hidden
             * @internal
             */
            this._value = null;
            /**
             * @hidden
             * @internal
             */
            this._selected = null;
            /**
             * @hidden
             * @internal
             */
            this._isInitialized = false;
            /**
             * @hidden
             * @internal
             */
            this._labelPosition = 'after';
            /**
             * @hidden
             * @internal
             */
            this._disabled = false;
            /**
             * @hidden
             * @internal
             */
            this._required = false;
            /**
             * @hidden
             * @internal
             */
            this.destroy$ = new rxjs.Subject();
        }
        IgxRadioGroupDirective_1 = IgxRadioGroupDirective;
        Object.defineProperty(IgxRadioGroupDirective.prototype, "value", {
            /**
             * Sets/gets the `value` attribute.
             *
             * @example
             * ```html
             * <igx-radio-group [value] = "'radioButtonValue'"></igx-radio-group>
             * ```
             */
            get: function () { return this._value; },
            set: function (newValue) {
                if (this._value !== newValue) {
                    this._value = newValue;
                    this._selectRadioButton();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "name", {
            /**
             * Sets/gets the `name` attribute of the radio group component. All child radio buttons inherits this name.
             *
             * @example
             * ```html
             * <igx-radio-group name = "Radio1"></igx-radio-group>
             *  ```
             */
            get: function () { return this._name; },
            set: function (newValue) {
                if (this._name !== newValue) {
                    this._name = newValue;
                    this._setRadioButtonNames();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "required", {
            /**
             * Sets/gets whether the radio group is required.
             *
             * @remarks
             * If not set, `required` will have value `false`.
             *
             * @example
             * ```html
             * <igx-radio-group [required] = "true"></igx-radio-group>
             * ```
             */
            get: function () { return this._required; },
            set: function (newValue) {
                if (this._required !== newValue) {
                    this._required = newValue;
                    this._setRadioButtonsRequired();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "disabled", {
            /**
             * An @Input property that allows you to disable the radio group. By default it's false.
             *
             * @example
             *  ```html
             * <igx-radio-group [disabled]="true"></igx-radio-group>
             * ```
             */
            get: function () { return this._disabled; },
            set: function (newValue) {
                if (this._disabled !== newValue) {
                    this._disabled = newValue;
                    this._disableRadioButtons();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "labelPosition", {
            /**
             * Sets/gets the position of the `label` in the child radio buttons.
             *
             * @remarks
             * If not set, `labelPosition` will have value `"after"`.
             *
             * @example
             * ```html
             * <igx-radio-group labelPosition = "before"></igx-radio-group>
             * ```
             */
            get: function () { return this._labelPosition; },
            set: function (newValue) {
                if (this._labelPosition !== newValue) {
                    this._labelPosition = newValue === exports.RadioLabelPosition.BEFORE ? exports.RadioLabelPosition.BEFORE : exports.RadioLabelPosition.AFTER;
                    this._setRadioButtonLabelPosition();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRadioGroupDirective.prototype, "selected", {
            /**
             * Sets/gets the selected child radio button.
             *
             * @example
             * ```typescript
             * let selectedButton = this.radioGroup.selected;
             * this.radioGroup.selected = selectedButton;
             * ```
             */
            get: function () { return this._selected; },
            set: function (selected) {
                if (this._selected !== selected) {
                    this._selected = selected;
                    this.value = selected ? selected.value : null;
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxRadioGroupDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            // The initial value can possibly be set by NgModel and it is possible that
            // the OnInit of the NgModel occurs after the OnInit of this class.
            this._isInitialized = true;
            setTimeout(function () { _this._initRadioButtons(); });
        };
        /**
         * Sets the "checked" property value on the radio input element.
         *
         * @remarks
         * Checks whether the provided value is consistent to the current radio button.
         * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.
         *
         * @example
         * ```typescript
         * this.radioGroup.writeValue('radioButtonValue');
         * ```
         */
        IgxRadioGroupDirective.prototype.writeValue = function (value) {
            this.value = value;
        };
        /**
         * Registers a function called when the control value changes.
         *
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype.registerOnChange = function (fn) { this._onChangeCallback = fn; };
        /**
         * Registers a function called when the control is touched.
         *
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype.registerOnTouched = function (fn) {
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    button.registerOnTouched(fn);
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._initRadioButtons = function () {
            var _this = this;
            if (this.radioButtons) {
                var props_1 = { name: this._name, labelPosition: this._labelPosition, disabled: this._disabled, required: this._required };
                this.radioButtons.forEach(function (button) {
                    Object.assign(button, props_1);
                    if (button.value === _this._value) {
                        button.checked = true;
                        _this._selected = button;
                    }
                    button.change.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (ev) { return _this._selectedRadioButtonChanged(ev); });
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._selectedRadioButtonChanged = function (args) {
            if (this._selected !== args.radio) {
                if (this._selected) {
                    this._selected.checked = false;
                }
                this._selected = args.radio;
            }
            this._value = args.value;
            if (this._isInitialized) {
                this.change.emit(args);
                this._onChangeCallback(this.value);
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._setRadioButtonNames = function () {
            var _this = this;
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    button.name = _this._name;
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._selectRadioButton = function () {
            var _this = this;
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    if (!_this._value) {
                        // no value - uncheck all radio buttons
                        if (button.checked) {
                            button.checked = false;
                        }
                    }
                    else {
                        if (_this._value === button.value) {
                            // selected button
                            if (_this._selected !== button) {
                                _this._selected = button;
                            }
                            if (!button.checked) {
                                button.select();
                            }
                        }
                        else {
                            // non-selected button
                            if (button.checked) {
                                button.checked = false;
                            }
                        }
                    }
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._setRadioButtonLabelPosition = function () {
            var _this = this;
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    button.labelPosition = _this._labelPosition;
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._disableRadioButtons = function () {
            var _this = this;
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    button.disabled = _this._disabled;
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxRadioGroupDirective.prototype._setRadioButtonsRequired = function () {
            var _this = this;
            if (this.radioButtons) {
                this.radioButtons.forEach(function (button) {
                    button.required = _this._required;
                });
            }
        };
        var IgxRadioGroupDirective_1;
        __decorate([
            core.ContentChildren(IgxRadioComponent, { descendants: true })
        ], IgxRadioGroupDirective.prototype, "radioButtons", void 0);
        __decorate([
            core.Input()
        ], IgxRadioGroupDirective.prototype, "value", null);
        __decorate([
            core.Input()
        ], IgxRadioGroupDirective.prototype, "name", null);
        __decorate([
            core.Input()
        ], IgxRadioGroupDirective.prototype, "required", null);
        __decorate([
            core.Input()
        ], IgxRadioGroupDirective.prototype, "disabled", null);
        __decorate([
            core.Input()
        ], IgxRadioGroupDirective.prototype, "labelPosition", null);
        __decorate([
            core.Input()
        ], IgxRadioGroupDirective.prototype, "selected", null);
        __decorate([
            core.Output()
        ], IgxRadioGroupDirective.prototype, "change", void 0);
        __decorate([
            core.HostBinding('class.igx-radio-group')
        ], IgxRadioGroupDirective.prototype, "cssClass", void 0);
        IgxRadioGroupDirective = IgxRadioGroupDirective_1 = __decorate([
            core.Directive({
                exportAs: 'igxRadioGroup',
                selector: 'igx-radio-group, [igxRadioGroup]',
                providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxRadioGroupDirective_1, multi: true }]
            })
        ], IgxRadioGroupDirective);
        return IgxRadioGroupDirective;
    }());
    /**
     * @hidden
     */
    var IgxRadioModule = /** @class */ (function () {
        function IgxRadioModule() {
        }
        IgxRadioModule = __decorate([
            core.NgModule({
                declarations: [IgxRadioGroupDirective, IgxRadioComponent],
                exports: [IgxRadioGroupDirective, IgxRadioComponent],
                imports: [IgxRippleModule]
            })
        ], IgxRadioModule);
        return IgxRadioModule;
    }());

    var IgxTextHighlightDirective = /** @class */ (function () {
        function IgxTextHighlightDirective(element, renderer) {
            var _this = this;
            this.element = element;
            this.renderer = renderer;
            this._div = null;
            this._observer = null;
            this._nodeWasRemoved = false;
            this._forceEvaluation = false;
            this._activeElementIndex = -1;
            this._defaultCssClass = 'igx-highlight';
            this._defaultActiveCssClass = 'igx-highlight--active';
            /**
             * Identifies the highlight within a unique group.
             * This allows it to have several different highlight groups,
             * with each of them having their own active highlight.
             *
             * ```html
             * <div
             *   igxTextHighlight
             *   [groupName]="myGroupName">
             * </div>
             * ```
             */
            this.groupName = '';
            this._value = '';
            this.destroy$ = new rxjs.Subject();
            IgxTextHighlightDirective_1.onActiveElementChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function (groupName) {
                if (_this.groupName === groupName) {
                    if (_this._activeElementIndex !== -1) {
                        _this.deactivate();
                    }
                    _this.activateIfNecessary();
                }
            });
        }
        IgxTextHighlightDirective_1 = IgxTextHighlightDirective;
        Object.defineProperty(IgxTextHighlightDirective.prototype, "value", {
            /**
             * The underlying value of the element that will be highlighted.
             *
             * ```typescript
             * // get
             * const elementValue = this.textHighlight.value;
             * ```
             *
             * ```html
             * <!--set-->
             * <div
             *   igxTextHighlight
             *   [value]="newValue">
             * </div>
             * ```
             */
            get: function () {
                return this._value;
            },
            set: function (value) {
                if (value === undefined || value === null) {
                    this._value = '';
                }
                else {
                    this._value = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTextHighlightDirective.prototype, "lastSearchInfo", {
            /**
             * @hidden
             */
            get: function () {
                return this._lastSearchInfo;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Activates the highlight at a given index.
         * (if such index exists)
         */
        IgxTextHighlightDirective.setActiveHighlight = function (groupName, highlight) {
            IgxTextHighlightDirective_1.highlightGroupsMap.set(groupName, highlight);
            IgxTextHighlightDirective_1.onActiveElementChanged.emit(groupName);
        };
        /**
         * Clears any existing highlight.
         */
        IgxTextHighlightDirective.clearActiveHighlight = function (groupName) {
            IgxTextHighlightDirective_1.highlightGroupsMap.set(groupName, {
                index: -1
            });
            IgxTextHighlightDirective_1.onActiveElementChanged.emit(groupName);
        };
        /**
         * @hidden
         */
        IgxTextHighlightDirective.prototype.ngOnDestroy = function () {
            this.clearHighlight();
            if (this._observer !== null) {
                this._observer.disconnect();
            }
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         */
        IgxTextHighlightDirective.prototype.ngOnChanges = function (changes) {
            if (changes.value && !changes.value.firstChange) {
                this._valueChanged = true;
            }
            else if ((changes.row !== undefined && !changes.row.firstChange) ||
                (changes.column !== undefined && !changes.column.firstChange) ||
                (changes.page !== undefined && !changes.page.firstChange)) {
                if (this._activeElementIndex !== -1) {
                    this.deactivate();
                }
                this.activateIfNecessary();
            }
        };
        /**
         * @hidden
         */
        IgxTextHighlightDirective.prototype.ngAfterViewInit = function () {
            this.parentElement = this.renderer.parentNode(this.element.nativeElement);
            if (IgxTextHighlightDirective_1.highlightGroupsMap.has(this.groupName) === false) {
                IgxTextHighlightDirective_1.highlightGroupsMap.set(this.groupName, {
                    index: -1
                });
            }
            this._lastSearchInfo = {
                searchedText: '',
                content: this.value,
                matchCount: 0,
                caseSensitive: false,
                exactMatch: false
            };
            this._container = this.parentElement.firstElementChild;
        };
        /**
         * @hidden
         */
        IgxTextHighlightDirective.prototype.ngAfterViewChecked = function () {
            if (this._valueChanged) {
                this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
                this.activateIfNecessary();
                this._valueChanged = false;
            }
        };
        /**
         * Clears the existing highlight and highlights the searched text.
         * Returns how many times the element contains the searched text.
         */
        IgxTextHighlightDirective.prototype.highlight = function (text, caseSensitive, exactMatch) {
            var caseSensitiveResolved = caseSensitive ? true : false;
            var exactMatchResolved = exactMatch ? true : false;
            if (this.searchNeedsEvaluation(text, caseSensitiveResolved, exactMatchResolved)) {
                this._lastSearchInfo.searchedText = text;
                this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
                this._lastSearchInfo.exactMatch = exactMatchResolved;
                this._lastSearchInfo.content = this.value;
                if (text === '' || text === undefined || text === null) {
                    this.clearHighlight();
                }
                else {
                    this.clearChildElements(true);
                    this._lastSearchInfo.matchCount = this.getHighlightedText(text, caseSensitive, exactMatch);
                }
            }
            else if (this._nodeWasRemoved) {
                this._lastSearchInfo.searchedText = text;
                this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
                this._lastSearchInfo.exactMatch = exactMatchResolved;
            }
            return this._lastSearchInfo.matchCount;
        };
        /**
         * Clears any existing highlight.
         */
        IgxTextHighlightDirective.prototype.clearHighlight = function () {
            this.clearChildElements(false);
            this._lastSearchInfo.searchedText = '';
            this._lastSearchInfo.matchCount = 0;
        };
        /**
         * Activates the highlight if it is on the currently active row, column and page.
         */
        IgxTextHighlightDirective.prototype.activateIfNecessary = function () {
            var group = IgxTextHighlightDirective_1.highlightGroupsMap.get(this.groupName);
            var column = group.columnIndex === undefined ? group.column : group.columnIndex;
            var row = group.rowIndex === undefined ? group.row : group.rowIndex;
            if (column === this.column && row === this.row && group.page === this.page) {
                this.activate(group.index);
            }
        };
        /**
         * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.
         * Should be used only when necessary as using many observers may lead to performance degradation.
         */
        IgxTextHighlightDirective.prototype.observe = function () {
            var _this = this;
            if (this._observer === null) {
                var callback = function (mutationList) {
                    mutationList.forEach(function (mutation) {
                        var removedNodes = Array.from(mutation.removedNodes);
                        removedNodes.forEach(function (n) {
                            if (n === _this._container) {
                                _this._nodeWasRemoved = true;
                                _this.clearChildElements(false);
                            }
                        });
                        var addedNodes = Array.from(mutation.addedNodes);
                        addedNodes.forEach(function (n) {
                            if (n === _this.parentElement.firstElementChild && _this._nodeWasRemoved) {
                                _this._container = _this.parentElement.firstElementChild;
                                _this._nodeWasRemoved = false;
                                _this._forceEvaluation = true;
                                _this.highlight(_this._lastSearchInfo.searchedText, _this._lastSearchInfo.caseSensitive, _this._lastSearchInfo.exactMatch);
                                _this._forceEvaluation = false;
                                _this.activateIfNecessary();
                                _this._observer.disconnect();
                                _this._observer = null;
                            }
                        });
                    });
                };
                this._observer = new MutationObserver(callback);
                this._observer.observe(this.parentElement, { childList: true });
            }
        };
        IgxTextHighlightDirective.prototype.activate = function (index) {
            this.deactivate();
            if (this._div !== null) {
                var spans = this._div.querySelectorAll('span');
                this._activeElementIndex = index;
                if (spans.length <= index) {
                    return;
                }
                var elementToActivate = spans[index];
                this.renderer.addClass(elementToActivate, this._defaultActiveCssClass);
                this.renderer.addClass(elementToActivate, this.activeCssClass);
            }
        };
        IgxTextHighlightDirective.prototype.deactivate = function () {
            if (this._activeElementIndex === -1) {
                return;
            }
            var spans = this._div.querySelectorAll('span');
            if (spans.length <= this._activeElementIndex) {
                this._activeElementIndex = -1;
                return;
            }
            var elementToDeactivate = spans[this._activeElementIndex];
            this.renderer.removeClass(elementToDeactivate, this._defaultActiveCssClass);
            this.renderer.removeClass(elementToDeactivate, this.activeCssClass);
            this._activeElementIndex = -1;
        };
        IgxTextHighlightDirective.prototype.clearChildElements = function (originalContentHidden) {
            this.renderer.setProperty(this.element.nativeElement, 'hidden', originalContentHidden);
            if (this._div !== null) {
                this.renderer.removeChild(this.parentElement, this._div);
                this._div = null;
                this._activeElementIndex = -1;
            }
        };
        IgxTextHighlightDirective.prototype.getHighlightedText = function (searchText, caseSensitive, exactMatch) {
            this.appendDiv();
            var stringValue = String(this.value);
            var contentStringResolved = !caseSensitive ? stringValue.toLowerCase() : stringValue;
            var searchTextResolved = !caseSensitive ? searchText.toLowerCase() : searchText;
            var matchCount = 0;
            if (exactMatch) {
                if (contentStringResolved === searchTextResolved) {
                    // tslint:disable-next-line:max-line-length
                    this.appendSpan("<span class=\"" + this._defaultCssClass + " " + (this.cssClass ? this.cssClass : '') + "\">" + stringValue + "</span>");
                    matchCount++;
                }
                else {
                    this.appendText(stringValue);
                }
            }
            else {
                var foundIndex = contentStringResolved.indexOf(searchTextResolved, 0);
                var previousMatchEnd = 0;
                while (foundIndex !== -1) {
                    var start = foundIndex;
                    var end = foundIndex + searchTextResolved.length;
                    this.appendText(stringValue.substring(previousMatchEnd, start));
                    // tslint:disable-next-line:max-line-length
                    this.appendSpan("<span class=\"" + this._defaultCssClass + " " + (this.cssClass ? this.cssClass : '') + "\">" + stringValue.substring(start, end) + "</span>");
                    previousMatchEnd = end;
                    matchCount++;
                    foundIndex = contentStringResolved.indexOf(searchTextResolved, end);
                }
                this.appendText(stringValue.substring(previousMatchEnd, stringValue.length));
            }
            return matchCount;
        };
        IgxTextHighlightDirective.prototype.appendText = function (text) {
            var textElement = this.renderer.createText(text);
            this.renderer.appendChild(this._div, textElement);
        };
        IgxTextHighlightDirective.prototype.appendSpan = function (outerHTML) {
            var span = this.renderer.createElement('span');
            this.renderer.appendChild(this._div, span);
            this.renderer.setProperty(span, 'outerHTML', outerHTML);
        };
        IgxTextHighlightDirective.prototype.appendDiv = function () {
            this._div = this.renderer.createElement('div');
            if (this.containerClass) {
                this.renderer.addClass(this._div, this.containerClass);
            }
            this.renderer.appendChild(this.parentElement, this._div);
        };
        IgxTextHighlightDirective.prototype.searchNeedsEvaluation = function (text, caseSensitive, exactMatch) {
            var searchedText = this._lastSearchInfo.searchedText;
            return !this._nodeWasRemoved &&
                (searchedText === null ||
                    searchedText !== text ||
                    this._lastSearchInfo.content !== this.value ||
                    this._lastSearchInfo.caseSensitive !== caseSensitive ||
                    this._lastSearchInfo.exactMatch !== exactMatch ||
                    this._forceEvaluation);
        };
        var IgxTextHighlightDirective_1;
        IgxTextHighlightDirective.onActiveElementChanged = new core.EventEmitter();
        IgxTextHighlightDirective.highlightGroupsMap = new Map();
        IgxTextHighlightDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 }
        ]; };
        __decorate([
            core.Input('cssClass')
        ], IgxTextHighlightDirective.prototype, "cssClass", void 0);
        __decorate([
            core.Input('activeCssClass')
        ], IgxTextHighlightDirective.prototype, "activeCssClass", void 0);
        __decorate([
            core.Input('containerClass')
        ], IgxTextHighlightDirective.prototype, "containerClass", void 0);
        __decorate([
            core.Input('groupName')
        ], IgxTextHighlightDirective.prototype, "groupName", void 0);
        __decorate([
            core.Input('value')
        ], IgxTextHighlightDirective.prototype, "value", null);
        __decorate([
            core.Input('row')
        ], IgxTextHighlightDirective.prototype, "row", void 0);
        __decorate([
            core.Input('column')
        ], IgxTextHighlightDirective.prototype, "column", void 0);
        __decorate([
            core.Input('page'),
            DeprecateProperty("IgxTextHighlightDirective 'page' input property is deprecated.")
        ], IgxTextHighlightDirective.prototype, "page", void 0);
        IgxTextHighlightDirective = IgxTextHighlightDirective_1 = __decorate([
            core.Directive({
                selector: '[igxTextHighlight]'
            })
        ], IgxTextHighlightDirective);
        return IgxTextHighlightDirective;
    }());
    /**
     * @hidden
     */
    var IgxTextHighlightModule = /** @class */ (function () {
        function IgxTextHighlightModule() {
        }
        IgxTextHighlightModule = __decorate([
            core.NgModule({
                declarations: [IgxTextHighlightDirective],
                exports: [IgxTextHighlightDirective]
            })
        ], IgxTextHighlightModule);
        return IgxTextHighlightModule;
    }());

    var IgxTextSelectionDirective = /** @class */ (function () {
        function IgxTextSelectionDirective(element) {
            this.element = element;
            this.selectionState = true;
        }
        Object.defineProperty(IgxTextSelectionDirective.prototype, "selected", {
            /**
             * Returns whether the input element is selectable through the directive.
             *
             * ```typescript
             * // get
             * @ViewChild('firstName',
             *  {read: IgxTextSelectionDirective})
             * public firstName: IgxTextSelectionDirective;
             *
             * public getFirstNameSelectionStatus() {
             *  return this.firstName.selected;
             * }
             * ```
             */
            get: function () {
                return this.selectionState;
            },
            /**
             *  Determines whether the input element could be selected through the directive.
             *
             *```html
             * <!--set-->
             * <input
             *   type="text"
             *   id="firstName"
             *   [igxTextSelection]="true">
             * </input>
             *
             * <input
             *   type="text"
             *   id="lastName"
             *   igxTextSelection
             *   [selected]="true">
             * </input>
             * ```
             */
            set: function (val) {
                this.selectionState = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTextSelectionDirective.prototype, "nativeElement", {
            /**
             * Returns the nativeElement of the element where the directive was applied.
             *
             * ```html
             * <input
             *   type="text"
            *    id="firstName"
             *   igxTextSelection>
             * </input>
             * ```
             *
             * ```typescript
             * @ViewChild('firstName',
             *  {read: IgxTextSelectionDirective})
             * public inputElement: IgxTextSelectionDirective;
             *
             * public getNativeElement() {
             *  return this.inputElement.nativeElement;
             * }
             * ```
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTextSelectionDirective.prototype.onFocus = function () {
            this.trigger();
        };
        /**
         * Triggers the selection of the element if it is marked as selectable.
         *
         * ```html
         * <input
         *   type="text"
         *   id="firstName"
         *   igxTextSelection>
         * </input>
         * ```
         *
         * ```typescript
         * @ViewChild('firstName',
         *  {read: IgxTextSelectionDirective})
         * public inputElement: IgxTextSelectionDirective;
         *
         * public triggerElementSelection() {
         *  this.inputElement.trigger();
         * }
         * ```
         */
        IgxTextSelectionDirective.prototype.trigger = function () {
            var _this = this;
            if (this.selected && this.nativeElement.value.length) {
                requestAnimationFrame(function () { return _this.nativeElement.setSelectionRange(0, _this.nativeElement.value.length); });
            }
        };
        IgxTextSelectionDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input('igxTextSelection')
        ], IgxTextSelectionDirective.prototype, "selected", null);
        __decorate([
            core.HostListener('focus')
        ], IgxTextSelectionDirective.prototype, "onFocus", null);
        IgxTextSelectionDirective = __decorate([
            core.Directive({
                exportAs: 'igxTextSelection',
                selector: '[igxTextSelection]'
            })
        ], IgxTextSelectionDirective);
        return IgxTextSelectionDirective;
    }());
    /**
     * @hidden
     */
    var IgxTextSelectionModule = /** @class */ (function () {
        function IgxTextSelectionModule() {
        }
        IgxTextSelectionModule = __decorate([
            core.NgModule({
                declarations: [IgxTextSelectionDirective],
                exports: [IgxTextSelectionDirective]
            })
        ], IgxTextSelectionModule);
        return IgxTextSelectionModule;
    }());

    /**
     * **Ignite UI for Angular Tooltip Target** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip.html)
     *
     * The Ignite UI for Angular Tooltip Target directive is used to mark an HTML element in the markup as one that has a tooltip.
     * The tooltip target is used in combination with the Ignite UI for Angular Tooltip by assigning the exported tooltip reference to the
     * target's selector property.
     *
     * Example:
     * ```html
     * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
     * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
     * ```
     */
    var IgxTooltipTargetDirective = /** @class */ (function (_super) {
        __extends(IgxTooltipTargetDirective, _super);
        function IgxTooltipTargetDirective(_element, _navigationService) {
            var _this = _super.call(this, _element, _navigationService) || this;
            _this._element = _element;
            _this._navigationService = _navigationService;
            /**
             * Gets/sets the amount of milliseconds that should pass before showing the tooltip.
             *
             * ```typescript
             * // get
             * let tooltipShowDelay = this.tooltipTarget.showDelay;
             * ```
             *
             * ```html
             * <!--set-->
             * <button [igxTooltipTarget]="tooltipRef" showDelay="1500">Hover me</button>
             * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
             * ```
             */
            _this.showDelay = 500;
            /**
             * Gets/sets the amount of milliseconds that should pass before hiding the tooltip.
             *
             * ```typescript
             * // get
             * let tooltipHideDelay = this.tooltipTarget.hideDelay;
             * ```
             *
             * ```html
             * <!--set-->
             * <button [igxTooltipTarget]="tooltipRef" hideDelay="1500">Hover me</button>
             * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
             * ```
             */
            _this.hideDelay = 500;
            /**
             * Specifies if the tooltip should not show when hovering its target with the mouse. (defaults to false)
             * While setting this property to 'true' will disable the user interactions that shows/hides the tooltip,
             * the developer will still be able to show/hide the tooltip through the API.
             *
             * ```typescript
             * // get
             * let tooltipDisabledValue = this.tooltipTarget.tooltipDisabled;
             * ```
             *
             * ```html
             * <!--set-->
             * <button [igxTooltipTarget]="tooltipRef" [tooltipDisabled]="true">Hover me</button>
             * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
             * ```
             */
            _this.tooltipDisabled = false;
            /**
             * Emits an event when the tooltip that is associated with this target starts showing.
             * This event is fired before the start of the countdown to showing the tooltip.
             *
             * ```typescript
             * tooltipShowing(args: ITooltipShowEventArgs) {
             *    alert("Tooltip started showing!");
             * }
             * ```
             *
             * ```html
             * <button [igxTooltipTarget]="tooltipRef"
             *         (onTooltipShow)='tooltipShowing($event)'>Hover me</button>
             * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
             * ```
             */
            _this.onTooltipShow = new core.EventEmitter();
            /**
             * Emits an event when the tooltip that is associated with this target starts hiding.
             * This event is fired before the start of the countdown to hiding the tooltip.
             *
             * ```typescript
             * tooltipHiding(args: ITooltipHideEventArgs) {
             *    alert("Tooltip started hiding!");
             * }
             * ```
             *
             * ```html
             * <button [igxTooltipTarget]="tooltipRef"
             *         (onTooltipHide)='tooltipHiding($event)'>Hover me</button>
             * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
             * ```
             */
            _this.onTooltipHide = new core.EventEmitter();
            return _this;
        }
        Object.defineProperty(IgxTooltipTargetDirective.prototype, "target", {
            /**
             * @hidden
             */
            get: function () {
                if (typeof this._target === 'string') {
                    return this._navigationService.get(this._target);
                }
                return this._target;
            },
            /**
             * @hidden
             */
            set: function (target) {
                if (target !== null && target !== '') {
                    this._target = target;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTooltipTargetDirective.prototype, "nativeElement", {
            /**
             * Gets the respective native element of the directive.
             *
             * ```typescript
             * let tooltipTargetElement = this.tooltipTarget.nativeElement;
             * ```
             */
            get: function () {
                return this._element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTooltipTargetDirective.prototype, "tooltipHidden", {
            /**
             * Indicates if the tooltip that is is associated with this target is currently hidden.
             *
             * ```typescript
             * let tooltipHiddenValue = this.tooltipTarget.tooltipHidden;
             * ```
             */
            get: function () {
                return !this.target || this.target.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            var positionSettings = {
                target: this.nativeElement,
                horizontalDirection: exports.HorizontalAlignment.Center,
                horizontalStartPoint: exports.HorizontalAlignment.Center,
                openAnimation: animations.useAnimation(scaleInCenter, { params: { duration: '150ms' } }),
                closeAnimation: animations.useAnimation(fadeOut, { params: { duration: '75ms' } })
            };
            this._overlayDefaults.positionStrategy = new AutoPositionStrategy(positionSettings);
            this._overlayDefaults.closeOnOutsideClick = false;
        };
        IgxTooltipTargetDirective.prototype.checkOutletAndOutsideClick = function () {
            if (this.outlet) {
                this._overlayDefaults.outlet = this.outlet;
            }
        };
        Object.defineProperty(IgxTooltipTargetDirective.prototype, "mergedOverlaySettings", {
            get: function () {
                return Object.assign({}, this._overlayDefaults, this.overlaySettings);
            },
            enumerable: true,
            configurable: true
        });
        // Return true if the execution in onMouseEnter should be terminated after this method
        IgxTooltipTargetDirective.prototype.preMouseEnterCheck = function () {
            // If tooltip is about to be opened
            if (this.target.toBeShown) {
                clearTimeout(this.target.timeoutId);
                this.target.toBeShown = false;
            }
            // If Tooltip is opened or about to be hidden
            if (!this.target.collapsed || this.target.toBeHidden) {
                clearTimeout(this.target.timeoutId);
                var hidingArgs = { target: this, tooltip: this.target, cancel: false };
                this.onTooltipHide.emit(hidingArgs);
                if (hidingArgs.cancel) {
                    return true;
                }
                //  if close animation has started finish it, or close the tooltip with no animation
                this.target.forceClose(this.mergedOverlaySettings);
                this.target.toBeHidden = false;
            }
            return false;
        };
        // Return true if the execution in onMouseLeave should be terminated after this method
        IgxTooltipTargetDirective.prototype.preMouseLeaveCheck = function () {
            clearTimeout(this.target.timeoutId);
            // If tooltip is about to be opened
            if (this.target.toBeShown) {
                this.target.toBeShown = false;
                this.target.toBeHidden = false;
                return true;
            }
            return false;
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onKeydownEscape = function (event) {
            var hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return;
            }
            this.target.toBeHidden = true;
            this.target.close();
            this.target.toBeHidden = false;
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onClick = function () {
            if (!this.target.collapsed) {
                var hidingArgs = { target: this, tooltip: this.target, cancel: false };
                this.onTooltipHide.emit(hidingArgs);
                if (hidingArgs.cancel) {
                    return;
                }
                this.target.forceClose(this.mergedOverlaySettings);
            }
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onMouseEnter = function () {
            var _this = this;
            if (this.tooltipDisabled) {
                return;
            }
            this.checkOutletAndOutsideClick();
            var shouldReturn = this.preMouseEnterCheck();
            if (shouldReturn) {
                return;
            }
            var showingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipShow.emit(showingArgs);
            if (showingArgs.cancel) {
                return;
            }
            this.target.toBeShown = true;
            this.target.timeoutId = setTimeout(function () {
                _this.target.open(_this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
                _this.target.toBeShown = false;
            }, this.showDelay);
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onMouseLeave = function () {
            var _this = this;
            if (this.tooltipDisabled) {
                return;
            }
            this.checkOutletAndOutsideClick();
            var shouldReturn = this.preMouseLeaveCheck();
            if (shouldReturn || this.target.collapsed) {
                return;
            }
            var hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return;
            }
            this.target.toBeHidden = true;
            this.target.timeoutId = setTimeout(function () {
                _this.target.close(); // Call close() of IgxTooltipDirective
                _this.target.toBeHidden = false;
            }, this.hideDelay);
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onTouchStart = function (event) {
            if (this.tooltipDisabled) {
                return;
            }
            this.showTooltip();
        };
        /**
         * @hidden
         */
        IgxTooltipTargetDirective.prototype.onDocumentTouchStart = function (event) {
            if (this.tooltipDisabled) {
                return;
            }
            if (this.nativeElement !== event.target &&
                !this.nativeElement.contains(event.target)) {
                this.hideTooltip();
            }
        };
        /**
         * Shows the tooltip by respecting the 'showDelay' property.
         *
         * ```typescript
         * this.tooltipTarget.showTooltip();
         * ```
         */
        IgxTooltipTargetDirective.prototype.showTooltip = function () {
            var _this = this;
            clearTimeout(this.target.timeoutId);
            if (!this.target.collapsed) {
                var hidingArgs = { target: this, tooltip: this.target, cancel: false };
                this.onTooltipHide.emit(hidingArgs);
                if (hidingArgs.cancel) {
                    return;
                }
                //  if close animation has started finish it, or close the tooltip with no animation
                this.target.forceClose(this.mergedOverlaySettings);
                this.target.toBeHidden = false;
            }
            var showingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipShow.emit(showingArgs);
            if (showingArgs.cancel) {
                return;
            }
            this.target.toBeShown = true;
            this.target.timeoutId = setTimeout(function () {
                _this.target.open(_this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
                _this.target.toBeShown = false;
            }, this.showDelay);
        };
        /**
         * Hides the tooltip by respecting the 'hideDelay' property.
         *
         * ```typescript
         * this.tooltipTarget.hideTooltip();
         * ```
         */
        IgxTooltipTargetDirective.prototype.hideTooltip = function () {
            var _this = this;
            if (this.target.collapsed && this.target.toBeShown) {
                clearTimeout(this.target.timeoutId);
            }
            if (this.target.collapsed || this.target.toBeHidden) {
                return;
            }
            var hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return;
            }
            this.target.toBeHidden = true;
            this.target.timeoutId = setTimeout(function () {
                _this.target.close(); // Call close() of IgxTooltipDirective
                _this.target.toBeHidden = false;
            }, this.hideDelay);
        };
        IgxTooltipTargetDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: IgxNavigationService, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.Input('showDelay')
        ], IgxTooltipTargetDirective.prototype, "showDelay", void 0);
        __decorate([
            core.Input('hideDelay')
        ], IgxTooltipTargetDirective.prototype, "hideDelay", void 0);
        __decorate([
            core.Input('tooltipDisabled')
        ], IgxTooltipTargetDirective.prototype, "tooltipDisabled", void 0);
        __decorate([
            core.Input('igxTooltipTarget')
        ], IgxTooltipTargetDirective.prototype, "target", null);
        __decorate([
            core.Output()
        ], IgxTooltipTargetDirective.prototype, "onTooltipShow", void 0);
        __decorate([
            core.Output()
        ], IgxTooltipTargetDirective.prototype, "onTooltipHide", void 0);
        __decorate([
            core.HostListener('document:keydown.escape', ['$event'])
        ], IgxTooltipTargetDirective.prototype, "onKeydownEscape", null);
        __decorate([
            core.HostListener('click')
        ], IgxTooltipTargetDirective.prototype, "onClick", null);
        __decorate([
            core.HostListener('mouseenter')
        ], IgxTooltipTargetDirective.prototype, "onMouseEnter", null);
        __decorate([
            core.HostListener('mouseleave')
        ], IgxTooltipTargetDirective.prototype, "onMouseLeave", null);
        __decorate([
            core.HostListener('touchstart', ['$event'])
        ], IgxTooltipTargetDirective.prototype, "onTouchStart", null);
        __decorate([
            core.HostListener('document:touchstart', ['$event'])
        ], IgxTooltipTargetDirective.prototype, "onDocumentTouchStart", null);
        IgxTooltipTargetDirective = __decorate([
            core.Directive({
                exportAs: 'tooltipTarget',
                selector: '[igxTooltipTarget]'
            }),
            __param(1, core.Optional())
        ], IgxTooltipTargetDirective);
        return IgxTooltipTargetDirective;
    }(IgxToggleActionDirective));
    var NEXT_ID$6 = 0;
    /**
     * **Ignite UI for Angular Tooltip** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip.html)
     *
     * The Ignite UI for Angular Tooltip directive is used to mark an HTML element in the markup as one that should behave as a tooltip.
     * The tooltip is used in combination with the Ignite UI for Angular Tooltip Target by assigning the exported tooltip reference to the
     * respective target's selector property.
     *
     * Example:
     * ```html
     * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
     * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
     * ```
     */
    var IgxTooltipDirective = /** @class */ (function (_super) {
        __extends(IgxTooltipDirective, _super);
        /** @hidden */
        function IgxTooltipDirective(elementRef, cdr, overlayService, navigationService) {
            var _this = 
            // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
            _super.call(this, elementRef, cdr, overlayService, navigationService) || this;
            /**
             * @hidden
             * Returns whether close time out has started
             */
            _this.toBeHidden = false;
            /**
             * @hidden
             * Returns whether open time out has started
             */
            _this.toBeShown = false;
            /**
             * Identifier for the tooltip.
             * If this is property is not explicitly set, it will be automatically generated.
             *
             * ```typescript
             * let tooltipId = this.tooltip.id;
             * ```
             */
            _this.id = "igx-tooltip-" + NEXT_ID$6++;
            return _this;
        }
        Object.defineProperty(IgxTooltipDirective.prototype, "hiddenClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTooltipDirective.prototype, "defaultClass", {
            /**
             * @hidden
             */
            get: function () {
                return !this.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTooltipDirective.prototype, "role", {
            /**
             * Get the role attribute of the tooltip.
             *
             * ```typescript
             * let tooltipRole = this.tooltip.role;
             * ```
             */
            get: function () {
                return 'tooltip';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * If there is open animation in progress this method will finish is.
         * If there is no open animation in progress this method will open the toggle with no animation.
         * @param overlaySettings setting to use for opening the toggle
         */
        IgxTooltipDirective.prototype.forceOpen = function (overlaySettings) {
            var info = this.overlayService.getOverlayById(this._overlayId);
            var hasOpenAnimation = info ? info.openAnimationPlayer : false;
            if (hasOpenAnimation) {
                info.openAnimationPlayer.finish();
                info.openAnimationPlayer.reset();
                info.openAnimationPlayer = null;
            }
            else if (this.collapsed) {
                var animation = overlaySettings.positionStrategy.settings.openAnimation;
                overlaySettings.positionStrategy.settings.openAnimation = null;
                this.open(overlaySettings);
                overlaySettings.positionStrategy.settings.openAnimation = animation;
            }
        };
        /**
         * If there is close animation in progress this method will finish is.
         * If there is no close animation in progress this method will close the toggle with no animation.
         * @param overlaySettings settings to use for closing the toggle
         */
        IgxTooltipDirective.prototype.forceClose = function (overlaySettings) {
            var info = this.overlayService.getOverlayById(this._overlayId);
            var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
            if (hasCloseAnimation) {
                info.closeAnimationPlayer.finish();
                info.closeAnimationPlayer.reset();
                info.closeAnimationPlayer = null;
            }
            else if (!this.collapsed) {
                var animation = overlaySettings.positionStrategy.settings.closeAnimation;
                overlaySettings.positionStrategy.settings.closeAnimation = null;
                this.close();
                overlaySettings.positionStrategy.settings.closeAnimation = animation;
            }
        };
        IgxTooltipDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: IgxOverlayService, decorators: [{ type: core.Inject, args: [IgxOverlayService,] }] },
            { type: IgxNavigationService, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.HostBinding('class.igx-tooltip--hidden')
        ], IgxTooltipDirective.prototype, "hiddenClass", null);
        __decorate([
            core.HostBinding('class.igx-tooltip--desktop')
        ], IgxTooltipDirective.prototype, "defaultClass", null);
        __decorate([
            core.Input('context')
        ], IgxTooltipDirective.prototype, "context", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxTooltipDirective.prototype, "id", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxTooltipDirective.prototype, "role", null);
        IgxTooltipDirective = __decorate([
            core.Directive({
                exportAs: 'tooltip',
                selector: '[igxTooltip]'
            }),
            __param(2, core.Inject(IgxOverlayService)),
            __param(3, core.Optional())
        ], IgxTooltipDirective);
        return IgxTooltipDirective;
    }(IgxToggleDirective));
    /**
     * @hidden
     */
    var IgxTooltipModule = /** @class */ (function () {
        function IgxTooltipModule() {
        }
        IgxTooltipModule = __decorate([
            core.NgModule({
                declarations: [IgxTooltipDirective, IgxTooltipTargetDirective],
                exports: [IgxTooltipDirective, IgxTooltipTargetDirective],
                imports: [common.CommonModule],
                providers: [IgxOverlayService]
            })
        ], IgxTooltipModule);
        return IgxTooltipModule;
    }());

    /**
     * Provides base filtering operations
     * Implementations should be Singleton
     *
     * @export
     */
    var IgxFilteringOperand = /** @class */ (function () {
        function IgxFilteringOperand() {
            var _this = this;
            this.operations = [{
                    name: 'null',
                    isUnary: true,
                    iconName: 'is_null',
                    logic: function (target) {
                        return target === null;
                    }
                }, {
                    name: 'notNull',
                    isUnary: true,
                    iconName: 'is_not_null',
                    logic: function (target) {
                        return target !== null;
                    }
                }, {
                    name: 'in',
                    isUnary: false,
                    iconName: 'is_in',
                    hidden: true,
                    logic: function (target, searchVal) {
                        return _this.findValueInSet(target, searchVal);
                    }
                }];
        }
        IgxFilteringOperand.instance = function () {
            return this._instance || (this._instance = new this());
        };
        /**
         * @hidden
         */
        IgxFilteringOperand.prototype.findValueInSet = function (target, searchVal) {
            return searchVal.has(target);
        };
        /**
         * Returns an array of names of the conditions which are visible in the UI
         */
        IgxFilteringOperand.prototype.conditionList = function () {
            return this.operations.filter(function (f) { return !f.hidden; }).map(function (element) { return element.name; });
        };
        /**
         * Returns an instance of the condition with the specified name.
         * @param name The name of the condition.
         */
        IgxFilteringOperand.prototype.condition = function (name) {
            return this.operations.find(function (element) { return element.name === name; });
        };
        /**
         * Adds a new condition to the filtering operations.
         * @param operation The filtering operation.
         */
        IgxFilteringOperand.prototype.append = function (operation) {
            this.operations.push(operation);
        };
        IgxFilteringOperand._instance = null;
        return IgxFilteringOperand;
    }());
    /**
     * Provides filtering operations for booleans
     *
     * @export
     */
    var IgxBooleanFilteringOperand = /** @class */ (function (_super) {
        __extends(IgxBooleanFilteringOperand, _super);
        function IgxBooleanFilteringOperand() {
            var _this = _super.call(this) || this;
            _this.operations = [{
                    name: 'all',
                    isUnary: true,
                    iconName: 'all',
                    logic: function (target) {
                        return true;
                    }
                }, {
                    name: 'true',
                    isUnary: true,
                    iconName: 'is_true',
                    logic: function (target) {
                        return !!(target && target !== null && target !== undefined);
                    }
                }, {
                    name: 'false',
                    isUnary: true,
                    iconName: 'is_false',
                    logic: function (target) {
                        return !target && target !== null && target !== undefined;
                    }
                }, {
                    name: 'empty',
                    isUnary: true,
                    iconName: 'empty',
                    logic: function (target) {
                        return target === null || target === undefined;
                    }
                }, {
                    name: 'notEmpty',
                    isUnary: true,
                    iconName: 'not_empty',
                    logic: function (target) {
                        return target !== null && target !== undefined;
                    }
                }].concat(_this.operations);
            return _this;
        }
        return IgxBooleanFilteringOperand;
    }(IgxFilteringOperand));
    /**
     * Provides filtering operations for Dates
     *
     * @export
     */
    var IgxDateFilteringOperand = /** @class */ (function (_super) {
        __extends(IgxDateFilteringOperand, _super);
        function IgxDateFilteringOperand() {
            var _this = _super.call(this) || this;
            _this.operations = [{
                    name: 'equals',
                    isUnary: false,
                    iconName: 'equals',
                    logic: function (target, searchVal) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                        var searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                        return targetp.year === searchp.year &&
                            targetp.month === searchp.month &&
                            targetp.day === searchp.day;
                    }
                }, {
                    name: 'doesNotEqual',
                    isUnary: false,
                    iconName: 'not_equal',
                    logic: function (target, searchVal) {
                        if (!target) {
                            return true;
                        }
                        _this.validateInputData(target);
                        var targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                        var searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                        return targetp.year !== searchp.year ||
                            targetp.month !== searchp.month ||
                            targetp.day !== searchp.day;
                    }
                }, {
                    name: 'before',
                    isUnary: false,
                    iconName: 'is_before',
                    logic: function (target, searchVal) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        return target < searchVal;
                    }
                }, {
                    name: 'after',
                    isUnary: false,
                    iconName: 'is_after',
                    logic: function (target, searchVal) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        return target > searchVal;
                    }
                }, {
                    name: 'today',
                    isUnary: true,
                    iconName: 'today',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yMd');
                        return d.year === now.year &&
                            d.month === now.month &&
                            d.day === now.day;
                    }
                }, {
                    name: 'yesterday',
                    isUnary: true,
                    iconName: 'yesterday',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var td = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                        var y = (function (d) { return new Date(d.setDate(d.getDate() - 1)); })(new Date());
                        var yesterday = IgxDateFilteringOperand.getDateParts(y, 'yMd');
                        return td.year === yesterday.year &&
                            td.month === yesterday.month &&
                            td.day === yesterday.day;
                    }
                }, {
                    name: 'thisMonth',
                    isUnary: true,
                    iconName: 'this_month',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                        return d.year === now.year &&
                            d.month === now.month;
                    }
                }, {
                    name: 'lastMonth',
                    isUnary: true,
                    iconName: 'last_month',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                        if (!now.month) {
                            now.month = 11;
                            now.year -= 1;
                        }
                        else {
                            now.month--;
                        }
                        return d.year === now.year &&
                            d.month === now.month;
                    }
                }, {
                    name: 'nextMonth',
                    isUnary: true,
                    iconName: 'next_month',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                        if (now.month === 11) {
                            now.month = 0;
                            now.year += 1;
                        }
                        else {
                            now.month++;
                        }
                        return d.year === now.year &&
                            d.month === now.month;
                    }
                }, {
                    name: 'thisYear',
                    isUnary: true,
                    iconName: 'this_year',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'y');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                        return d.year === now.year;
                    }
                }, {
                    name: 'lastYear',
                    isUnary: true,
                    iconName: 'last_year',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'y');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                        return d.year === now.year - 1;
                    }
                }, {
                    name: 'nextYear',
                    isUnary: true,
                    iconName: 'next_year',
                    logic: function (target) {
                        if (!target) {
                            return false;
                        }
                        _this.validateInputData(target);
                        var d = IgxDateFilteringOperand.getDateParts(target, 'y');
                        var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                        return d.year === now.year + 1;
                    }
                }, {
                    name: 'empty',
                    isUnary: true,
                    iconName: 'empty',
                    logic: function (target) {
                        return target === null || target === undefined;
                    }
                }, {
                    name: 'notEmpty',
                    isUnary: true,
                    iconName: 'not_empty',
                    logic: function (target) {
                        return target !== null && target !== undefined;
                    }
                }].concat(_this.operations);
            return _this;
        }
        /**
         * Splits a Date object into parts
         *
         * @memberof IgxDateFilteringOperand
         */
        IgxDateFilteringOperand.getDateParts = function (date, dateFormat) {
            var res = {
                day: null,
                hours: null,
                milliseconds: null,
                minutes: null,
                month: null,
                seconds: null,
                year: null
            };
            if (!date || !dateFormat) {
                return res;
            }
            if (dateFormat.indexOf('y') >= 0) {
                res.year = date.getFullYear();
            }
            if (dateFormat.indexOf('M') >= 0) {
                res.month = date.getMonth();
            }
            if (dateFormat.indexOf('d') >= 0) {
                res.day = date.getDate();
            }
            if (dateFormat.indexOf('h') >= 0) {
                res.hours = date.getHours();
            }
            if (dateFormat.indexOf('m') >= 0) {
                res.minutes = date.getMinutes();
            }
            if (dateFormat.indexOf('s') >= 0) {
                res.seconds = date.getSeconds();
            }
            if (dateFormat.indexOf('f') >= 0) {
                res.milliseconds = date.getMilliseconds();
            }
            return res;
        };
        IgxDateFilteringOperand.prototype.validateInputData = function (target) {
            if (!(target instanceof Date)) {
                throw new Error('Could not perform filtering on \'date\' column because the datasource object type is not \'Date\'.');
            }
        };
        IgxDateFilteringOperand.prototype.findValueInSet = function (target, searchVal) {
            if (!target) {
                return false;
            }
            return searchVal.has(new Date(target.getFullYear(), target.getMonth(), target.getDate()).toISOString());
        };
        return IgxDateFilteringOperand;
    }(IgxFilteringOperand));
    /**
     * Provides filtering operations for numbers
     *
     * @export
     */
    var IgxNumberFilteringOperand = /** @class */ (function (_super) {
        __extends(IgxNumberFilteringOperand, _super);
        function IgxNumberFilteringOperand() {
            var _this = _super.call(this) || this;
            _this.operations = [{
                    name: 'equals',
                    isUnary: false,
                    iconName: 'equals',
                    logic: function (target, searchVal) {
                        return target === searchVal;
                    }
                }, {
                    name: 'doesNotEqual',
                    isUnary: false,
                    iconName: 'not_equal',
                    logic: function (target, searchVal) {
                        return target !== searchVal;
                    }
                }, {
                    name: 'greaterThan',
                    isUnary: false,
                    iconName: 'greater_than',
                    logic: function (target, searchVal) {
                        return target > searchVal;
                    }
                }, {
                    name: 'lessThan',
                    isUnary: false,
                    iconName: 'less_than',
                    logic: function (target, searchVal) {
                        return target < searchVal;
                    }
                }, {
                    name: 'greaterThanOrEqualTo',
                    isUnary: false,
                    iconName: 'greater_than_or_equal',
                    logic: function (target, searchVal) {
                        return target >= searchVal;
                    }
                }, {
                    name: 'lessThanOrEqualTo',
                    isUnary: false,
                    iconName: 'less_than_or_equal',
                    logic: function (target, searchVal) {
                        return target <= searchVal;
                    }
                }, {
                    name: 'empty',
                    isUnary: true,
                    iconName: 'empty',
                    logic: function (target) {
                        return target === null || target === undefined || isNaN(target);
                    }
                }, {
                    name: 'notEmpty',
                    isUnary: true,
                    iconName: 'not_empty',
                    logic: function (target) {
                        return target !== null && target !== undefined && !isNaN(target);
                    }
                }].concat(_this.operations);
            return _this;
        }
        return IgxNumberFilteringOperand;
    }(IgxFilteringOperand));
    /**
     * Provides filtering operations for strings
     *
     * @export
     */
    var IgxStringFilteringOperand = /** @class */ (function (_super) {
        __extends(IgxStringFilteringOperand, _super);
        function IgxStringFilteringOperand() {
            var _this = _super.call(this) || this;
            _this.operations = [{
                    name: 'contains',
                    isUnary: false,
                    iconName: 'contains',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target.indexOf(search) !== -1;
                    }
                }, {
                    name: 'doesNotContain',
                    isUnary: false,
                    iconName: 'does_not_contain',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target.indexOf(search) === -1;
                    }
                }, {
                    name: 'startsWith',
                    isUnary: false,
                    iconName: 'starts_with',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target.startsWith(search);
                    }
                }, {
                    name: 'endsWith',
                    isUnary: false,
                    iconName: 'ends_with',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target.endsWith(search);
                    }
                }, {
                    name: 'equals',
                    isUnary: false,
                    iconName: 'equals',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target === search;
                    }
                }, {
                    name: 'doesNotEqual',
                    isUnary: false,
                    iconName: 'not_equal',
                    logic: function (target, searchVal, ignoreCase) {
                        var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                        target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                        return target !== search;
                    }
                }, {
                    name: 'empty',
                    isUnary: true,
                    iconName: 'empty',
                    logic: function (target) {
                        return target === null || target === undefined || target.length === 0;
                    }
                }, {
                    name: 'notEmpty',
                    isUnary: true,
                    iconName: 'not_empty',
                    logic: function (target) {
                        return target !== null && target !== undefined && target.length > 0;
                    }
                }].concat(_this.operations);
            return _this;
        }
        /**
         * Applies case sensitivity on strings if provided
         *
         * @memberof IgxStringFilteringOperand
         */
        IgxStringFilteringOperand.applyIgnoreCase = function (a, ignoreCase) {
            a = a || '';
            // bulletproof
            return ignoreCase ? ('' + a).toLowerCase() : a;
        };
        return IgxStringFilteringOperand;
    }(IgxFilteringOperand));

    var filteringStateDefaults = {
        strategy: new FilteringStrategy()
    };

    /**
     * @hidden
     */
    var GroupedRecords = /** @class */ (function (_super) {
        __extends(GroupedRecords, _super);
        function GroupedRecords() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return GroupedRecords;
    }(Array));

    /**
     * **Ignite UI for Angular Icon Service** -
     *
     * The Ignite UI Icon Service makes it easy for developers to include custom SVG images and use them with IgxIconComponent.
     * In addition it could be used to associate a custom class to be applied on IgxIconComponent according to given fontSet.
     *
     * Example:
     * ```typescript
     * this.iconService.registerFontSetAlias('material', 'material-icons');
     * this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
     * ```
     */
    var IgxIconService = /** @class */ (function () {
        function IgxIconService(_sanitizer, _document) {
            this._sanitizer = _sanitizer;
            this._document = _document;
            this._fontSet = 'material-icons';
            this._fontSetAliases = new Map();
            this._cachedSvgIcons = new Set();
        }
        Object.defineProperty(IgxIconService.prototype, "defaultFontSet", {
            /**
             *  Returns the default font set.
             *```typescript
             *   const defaultFontSet = this.iconService.defaultFontSet;
             * ```
             */
            get: function () {
                return this._fontSet;
            },
            /**
             *  Sets the default font set.
             *```typescript
             *   this.iconService.defaultFontSet = 'svg-flags';
             * ```
             */
            set: function (className) {
                this._fontSet = className;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *  Registers a custom class to be applied to IgxIconComponent for a given fontSet.
         *```typescript
         *   this.iconService.registerFontSetAlias('material', 'material-icons');
         * ```
         */
        IgxIconService.prototype.registerFontSetAlias = function (alias, className) {
            if (className === void 0) { className = alias; }
            this._fontSetAliases.set(alias, className);
            return this;
        };
        /**
         *  Returns the custom class, if any, associated to a given fontSet.
         *```typescript
         *   const fontSetClass = this.iconService.fontSetClassName('material');
         * ```
         */
        IgxIconService.prototype.fontSetClassName = function (alias) {
            return this._fontSetAliases.get(alias) || alias;
        };
        /**
         *  Adds an SVG image to the cache. SVG source is an url.
         *```typescript
         *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
         * ```
         */
        IgxIconService.prototype.addSvgIcon = function (iconName, url, fontSet) {
            if (fontSet === void 0) { fontSet = ''; }
            if (iconName && url) {
                var safeUrl = this._sanitizer.bypassSecurityTrustResourceUrl(url);
                if (!safeUrl) {
                    throw new Error("The provided URL could not be processed as trusted resource URL by Angular's DomSanitizer: \"" + url + "\".");
                }
                var sanitizedUrl = this._sanitizer.sanitize(core.SecurityContext.RESOURCE_URL, safeUrl);
                if (!sanitizedUrl) {
                    throw new Error("The URL provided was not trusted as a resource URL: \"" + url + "\".");
                }
                this.fetchSvg(iconName, url, fontSet);
            }
            else {
                throw new Error('You should provide at least `iconName` and `url` to register an svg icon.');
            }
        };
        /**
         *  Adds an SVG image to the cache. SVG source is its text.
         *```typescript
         *   this.iconService.addSvgIcon('simple', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
         *   <path d="M74 74h54v54H74" /></svg>', 'svg-flags');
         * ```
         */
        IgxIconService.prototype.addSvgIconFromText = function (iconName, iconText, fontSet) {
            if (fontSet === void 0) { fontSet = ''; }
            if (iconName && iconText) {
                this.cacheSvgIcon(iconName, iconText, fontSet);
            }
            else {
                throw new Error('You should provide at least `iconName` and `iconText` to register an svg icon.');
            }
        };
        /**
         *  Returns whether a given SVG image is present in the cache.
         *```typescript
         *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');
         * ```
         */
        IgxIconService.prototype.isSvgIconCached = function (iconName, fontSet) {
            if (fontSet === void 0) { fontSet = ''; }
            var iconKey = this.getSvgIconKey(iconName, fontSet);
            return this._cachedSvgIcons.has(iconKey);
        };
        /**
         *  Returns the key of a cached SVG image.
         *```typescript
         *   const svgIconKey = this.iconService.getSvgIconKey('aruba', 'svg-flags');
         * ```
         */
        IgxIconService.prototype.getSvgIconKey = function (iconName, fontSet) {
            if (fontSet === void 0) { fontSet = ''; }
            return fontSet + '_' + iconName;
        };
        /**
         * @hidden
         */
        IgxIconService.prototype.fetchSvg = function (iconName, url, fontSet) {
            if (fontSet === void 0) { fontSet = ''; }
            var instance = this;
            var httpRequest = new XMLHttpRequest();
            httpRequest.open('GET', url, true);
            httpRequest.responseType = 'text';
            // load – when the result is ready, that includes HTTP errors like 404.
            httpRequest.onload = function (event) {
                if (event) {
                    var request = event.target;
                    if (request.status === 200) {
                        instance.cacheSvgIcon(iconName, request.responseText, fontSet);
                    }
                    else {
                        throw new Error("Could not fetch SVG from url: " + url + "; error: " + request.status + " (" + request.statusText + ")");
                    }
                }
                else {
                    throw new Error("Could not fetch SVG from url: " + url + ";");
                }
            };
            // error – when the request couldn’t be made, e.g.network down or invalid URL.
            httpRequest.onerror = function (event) {
                if (event) {
                    var request = event.target;
                    throw new Error("Could not fetch SVG from url: " + url + "; error status code: " + request.status + " (" + request.statusText + ")");
                }
                throw new Error("Could not fetch SVG from url: " + url + ";");
            };
            httpRequest.send();
        };
        /**
         * @hidden
         */
        IgxIconService.prototype.cacheSvgIcon = function (iconName, value, fontSet) {
            if (fontSet === void 0) { fontSet = ''; }
            if (iconName && value) {
                this.ensureSvgContainerCreated();
                var div = this._document.createElement('DIV');
                div.innerHTML = value;
                var svg = div.querySelector('svg');
                if (svg) {
                    var iconKey = this.getSvgIconKey(iconName, fontSet);
                    svg.setAttribute('id', iconKey);
                    svg.setAttribute('fit', '');
                    svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
                    if (this._cachedSvgIcons.has(iconKey)) {
                        var oldChild = this._svgContainer.querySelector("svg[id='" + iconKey + "']");
                        this._svgContainer.removeChild(oldChild);
                    }
                    this._svgContainer.appendChild(svg);
                    this._cachedSvgIcons.add(iconKey);
                }
            }
        };
        /**
         * @hidden
         */
        IgxIconService.prototype.ensureSvgContainerCreated = function () {
            if (!this._svgContainer) {
                this._svgContainer = this._document.documentElement.querySelector('.igx-svg-container');
                if (!this._svgContainer) {
                    this._svgContainer = this._document.createElement('DIV');
                    this._svgContainer.classList.add('igx-svg-container');
                    this._document.documentElement.appendChild(this._svgContainer);
                }
            }
        };
        IgxIconService.ctorParameters = function () { return [
            { type: platformBrowser.DomSanitizer },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        IgxIconService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function IgxIconService_Factory() { return new IgxIconService(core["ɵɵinject"](platformBrowser.DomSanitizer), core["ɵɵinject"](common.DOCUMENT)); }, token: IgxIconService, providedIn: "root" });
        IgxIconService = __decorate([
            core.Injectable({
                providedIn: 'root'
            }),
            __param(1, core.Inject(common.DOCUMENT))
        ], IgxIconService);
        return IgxIconService;
    }());

    /**
     * Icon provides a way to include material icons to markup
     *
     * @igxModule IgxIconModule
     *
     * @igxTheme igx-icon-theme
     *
     * @igxKeywords icon, picture
     *
     * @igxGroup Display
     *
     * @remarks
     *
     * The Ignite UI Icon makes it easy for developers to include material design icons directly in their markup. The icons
     * support custom colors and can be marked as active or disabled using the `isActive` property. This will change the appearance
     * of the icon.
     *
     * @example
     * ```html
     * <igx-icon color="#00ff00" isActive="true">home</igx-icon>
     * ```
     */
    var NEXT_ID$7 = 0;
    var IgxIconComponent = /** @class */ (function () {
        function IgxIconComponent(_el, iconService) {
            this._el = _el;
            this.iconService = iconService;
            /**
             *  This allows you to change the value of `class.igx-icon`. By default it's `igx-icon`.
             *
             * @hidden
             * @internal
             */
            this.cssClass = 'igx-icon';
            /**
             *  This allows you to disable the `aria-hidden` attribute. By default it's applied.
             * @example
             *```typescript
             *@ViewChild("MyIcon") public icon: IgxIconComponent;
             *constructor(private cdRef:ChangeDetectorRef) {}
             *ngAfterViewInit() {
             *    this.icon.ariaHidden = false;
             *    this.cdRef.detectChanges();
             *}
             * ```
             */
            this.ariaHidden = true;
            /**
            *  An @Input property that sets the value of the `id` attribute.
            * @example
            *```html
            *<igx-icon id="igx-icon-1" fontSet="material">settings</igx-icon>
            *```
            */
            this.id = "igx-icon-" + NEXT_ID$7++;
            /**
            *  An @Input property that allows you to disable the `active` property. By default it's applied.
            * @example
            *```html
            *<igx-icon [isActive]="false">settings</igx-icon>
            *```
            */
            this.active = true;
            this.el = _el;
            this.font = this.iconService.defaultFontSet;
            this.iconService.registerFontSetAlias('material', 'material-icons');
        }
        /**
         * @hidden
         * @internal
         */
        IgxIconComponent.prototype.ngOnInit = function () {
            this.updateIconClass();
        };
        Object.defineProperty(IgxIconComponent.prototype, "getFontSet", {
            /**
             *  An accessor that returns the value of the font property.
             * @example
             *```typescript
             *@ViewChild("MyIcon")
             *public icon: IgxIconComponent;
             *ngAfterViewInit() {
             *    let iconFont = this.icon.getFontSet;
             * }
             * ```
             */
            get: function () {
                return this.font;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "getActive", {
            /**
             *  An accessor that returns the value of the active property.
             * @example
             *```typescript
             *@ViewChild("MyIcon")
             *public icon: IgxIconComponent;
             *ngAfterViewInit() {
             *    let iconActive = this.icon.getActive;
             * }
             * ```
             */
            get: function () {
                return this.active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "getInactive", {
            /**
             *  An accessor that returns inactive property.
             * @example
             *```typescript
             *@ViewChild("MyIcon")
             *public icon: IgxIconComponent;
             *ngAfterViewInit() {
             *    let iconActive = this.icon.getInactive;
             * }
             * ```
             */
            get: function () {
                return !this.active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "getIconColor", {
            /**
             *  An accessor that returns the opposite value of the `iconColor` property.
             * @example
             *```typescript
             *@ViewChild("MyIcon")
             *public icon: IgxIconComponent;
             *ngAfterViewInit() {
             *    let iconColor = this.icon.getIconColor;
             * }
             * ```
             */
            get: function () {
                return this.iconColor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "getIconName", {
            /**
             *  An accessor that returns the value of the iconName property.
             * @example
             *```typescript
             *@ViewChild("MyIcon")
             *public icon: IgxIconComponent;
             *ngAfterViewInit() {
             *    let iconName = this.icon.getIconName;
             * }
             * ```
             */
            get: function () {
                return this.iconName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "getSvgKey", {
            /**
             *  An accessor that returns the key of the SVG image.
             *  The key consists of the fontSet and the iconName separated by underscore.
             * @example
             *```typescript
             *@ViewChild("MyIcon")
             *public icon: IgxIconComponent;
             *ngAfterViewInit() {
             *    let svgKey = this.icon.getSvgKey;
             * }
             * ```
             */
            get: function () {
                if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
                    return '#' + this.iconService.getSvgIconKey(this.iconName, this.font);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxIconComponent.prototype, "template", {
            /**
             *   An accessor that returns a TemplateRef to explicit, svg or no ligature.
             * @example
             *```typescript
             *@ViewChild("MyIcon")
             *public icon: IgxIconComponent;
             *ngAfterViewInit() {
             *    let iconTemplate = this.icon.template;
             * }
             * ```
             */
            get: function () {
                if (this.iconName) {
                    if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
                        return this.svgImage;
                    }
                    return this.noLigature;
                }
                return this.explicitLigature;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxIconComponent.prototype.updateIconClass = function () {
            var className = this.iconService.fontSetClassName(this.font);
            this.el.nativeElement.classList.add(className);
            if (this.iconName && !this.iconService.isSvgIconCached(this.iconName, this.font)) {
                this.el.nativeElement.classList.add(this.iconName);
            }
        };
        IgxIconComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: IgxIconService }
        ]; };
        __decorate([
            core.ViewChild('noLigature', { read: core.TemplateRef, static: true })
        ], IgxIconComponent.prototype, "noLigature", void 0);
        __decorate([
            core.ViewChild('explicitLigature', { read: core.TemplateRef, static: true })
        ], IgxIconComponent.prototype, "explicitLigature", void 0);
        __decorate([
            core.ViewChild('svgImage', { read: core.TemplateRef, static: true })
        ], IgxIconComponent.prototype, "svgImage", void 0);
        __decorate([
            core.HostBinding('class.igx-icon')
        ], IgxIconComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('attr.aria-hidden')
        ], IgxIconComponent.prototype, "ariaHidden", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxIconComponent.prototype, "id", void 0);
        __decorate([
            core.Input('fontSet')
        ], IgxIconComponent.prototype, "font", void 0);
        __decorate([
            core.Input('isActive')
        ], IgxIconComponent.prototype, "active", void 0);
        __decorate([
            core.Input('color')
        ], IgxIconComponent.prototype, "iconColor", void 0);
        __decorate([
            core.Input('name')
        ], IgxIconComponent.prototype, "iconName", void 0);
        __decorate([
            core.HostBinding('class.igx-icon--inactive')
        ], IgxIconComponent.prototype, "getInactive", null);
        __decorate([
            core.HostBinding('style.color')
        ], IgxIconComponent.prototype, "getIconColor", null);
        IgxIconComponent = __decorate([
            core.Component({
                selector: 'igx-icon',
                template: "<ng-template #noLigature></ng-template>\n\n<ng-template #explicitLigature>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #svgImage>\n    <svg>\n        <use [attr.href]=\"getSvgKey\"></use>\n    </svg>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
            })
        ], IgxIconComponent);
        return IgxIconComponent;
    }());

    /**
     * @hidden
     */
    var IgxIconModule = /** @class */ (function () {
        function IgxIconModule() {
        }
        IgxIconModule = __decorate([
            core.NgModule({
                declarations: [IgxIconComponent],
                exports: [IgxIconComponent],
                imports: [common.CommonModule]
            })
        ], IgxIconModule);
        return IgxIconModule;
    }());

    var NEXT_ID$8 = 0;

    (function (IgxAvatarSize) {
        IgxAvatarSize["SMALL"] = "small";
        IgxAvatarSize["MEDIUM"] = "medium";
        IgxAvatarSize["LARGE"] = "large";
    })(exports.IgxAvatarSize || (exports.IgxAvatarSize = {}));

    (function (IgxAvatarType) {
        IgxAvatarType["INITIALS"] = "initials";
        IgxAvatarType["IMAGE"] = "image";
        IgxAvatarType["ICON"] = "icon";
        IgxAvatarType["CUSTOM"] = "custom";
    })(exports.IgxAvatarType || (exports.IgxAvatarType = {}));
    /**
     * **Ignite UI for Angular Avatar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/avatar.html)
     *
     * The Ignite UI Avatar provides an easy way to add an avatar icon to your application.  This icon can be an
     * image, someone's initials or a material icon from the google material icon set.
     *
     * Example:
     * ```html
     * <igx-avatar initials="MS" roundShape="true" size="large">
     * </igx-avatar>
     * ```
     */
    var IgxAvatarComponent = /** @class */ (function () {
        function IgxAvatarComponent(elementRef) {
            this.elementRef = elementRef;
            /**
             * Returns the `aria-label` of the avatar.
             *
             * ```typescript
             * let ariaLabel = this.avatar.ariaLabel;
             * ```
             *
             */
            this.ariaLabel = 'avatar';
            /**
             * Returns the `role` attribute of the avatar.
             *
             * ```typescript
             * let avatarRole = this.avatar.role;
             * ```
             *
             * @memberof IgxAvatarComponent
             */
            this.role = 'img';
            /**
             * Returns the class of the avatar.
             *
             * ```typescript
             * let avatarCLass =  this.avatar.cssClass;
             * ```
             *
             * @memberof IgxAvatarComponent
             */
            this.cssClass = 'igx-avatar';
            /**
             * @hidden
             */
            this._size = exports.IgxAvatarSize.SMALL;
            /**
             * Sets the `id` of the avatar. If not set, the first avatar component will have `id` = `"igx-avatar-0"`.
             *
             * ```html
             * <igx-avatar id="my-first-avatar"></igx-avatar>
             * ```
             *
             * @memberof IgxAvatarComponent
             */
            this.id = "igx-avatar-" + NEXT_ID$8++;
            /**
             * Sets a round shape to the avatar if `roundShape` is `"true"`.
             * By default the shape of the avatar is a square.
             *
             * ```html
             * <igx-avatar roundShape = "true" ></igx-avatar>
             * ```
             *
             * @memberof IgxAvatarComponent
             */
            this.roundShape = false;
        }
        Object.defineProperty(IgxAvatarComponent.prototype, "size", {
            /**
             * Returns the `size` of the avatar.
             *
             * ```typescript
             *let avatarSize =  this.avatar.size;
             * ```
             *
             * @memberof IgxAvatarComponent
             */
            get: function () {
                return this._size;
            },
            /**
             * Sets the `size`  of the avatar.
             * By default the `size` is `"small"`. It can be set to `"medium"` or `"large"`.
             *
             * ```
             * <igx-avatar size="large"></igx-avatar>
             * ```
             *
             * @memberof IgxAvatarComponent
             */
            set: function (value) {
                switch (value) {
                    case 'small':
                    case 'medium':
                    case 'large':
                        this._size = value;
                        break;
                    default:
                        this._size = 'small';
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAvatarComponent.prototype, "type", {
            /**
             * Returns the type of the avatar.
             *
             * ```typescript
             * let avatarType = this.avatar.type;
             * ```
             *
             * @memberof IgxAvatarComponent
             */
            get: function () {
                if (this.src) {
                    return exports.IgxAvatarType.IMAGE;
                }
                if (this.icon) {
                    return exports.IgxAvatarType.ICON;
                }
                if (this.initials) {
                    return exports.IgxAvatarType.INITIALS;
                }
                return exports.IgxAvatarType.CUSTOM;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAvatarComponent.prototype, "template", {
            /**
             * Returns the template of the avatar.
             *
             * ```typescript
             * let template = this.avatar.template;
             * ```
             *
             * @memberof IgxAvatarComponent
             */
            get: function () {
                switch (this.type) {
                    case exports.IgxAvatarType.IMAGE:
                        return this.imageTemplate;
                    case exports.IgxAvatarType.INITIALS:
                        return this.initialsTemplate;
                    case exports.IgxAvatarType.ICON:
                        return this.iconTemplate;
                    default:
                        return this.defaultTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxAvatarComponent.prototype.ngOnInit = function () {
            this.roleDescription = this.getRole();
        };
        /**
         *@hidden
         */
        IgxAvatarComponent.prototype.ngAfterViewInit = function () {
            if (this.type !== exports.IgxAvatarType.CUSTOM) {
                this.elementRef.nativeElement.classList.add("igx-avatar--" + this.type);
            }
            this.elementRef.nativeElement.classList.add("igx-avatar--" + this._size);
        };
        /**
         * @hidden
         */
        IgxAvatarComponent.prototype.getRole = function () {
            switch (this.type) {
                case exports.IgxAvatarType.IMAGE:
                    return 'image avatar';
                case exports.IgxAvatarType.ICON:
                    return 'icon avatar';
                case exports.IgxAvatarType.INITIALS:
                    return 'initials avatar';
                default:
                    return 'custom avatar';
            }
        };
        /**
         * Returns the url of the `image`.
         *
         * ```typescript
         * let imageSourceUrl = this.avatar.getSrcUrl();
         * ```
         *
         * @memberof IgxAvatarComponent
         */
        IgxAvatarComponent.prototype.getSrcUrl = function () {
            return "url(" + this.src + ")";
        };
        IgxAvatarComponent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.ViewChild('image')
        ], IgxAvatarComponent.prototype, "image", void 0);
        __decorate([
            core.ViewChild('defaultTemplate', { read: core.TemplateRef, static: true })
        ], IgxAvatarComponent.prototype, "defaultTemplate", void 0);
        __decorate([
            core.ViewChild('imageTemplate', { read: core.TemplateRef, static: true })
        ], IgxAvatarComponent.prototype, "imageTemplate", void 0);
        __decorate([
            core.ViewChild('initialsTemplate', { read: core.TemplateRef, static: true })
        ], IgxAvatarComponent.prototype, "initialsTemplate", void 0);
        __decorate([
            core.ViewChild('iconTemplate', { read: core.TemplateRef, static: true })
        ], IgxAvatarComponent.prototype, "iconTemplate", void 0);
        __decorate([
            core.HostBinding('attr.aria-label')
        ], IgxAvatarComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxAvatarComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('class.igx-avatar')
        ], IgxAvatarComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('attr.aria-roledescription')
        ], IgxAvatarComponent.prototype, "roleDescription", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxAvatarComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('class.igx-avatar--rounded'),
            core.Input()
        ], IgxAvatarComponent.prototype, "roundShape", void 0);
        __decorate([
            core.HostBinding('style.color'),
            core.Input()
        ], IgxAvatarComponent.prototype, "color", void 0);
        __decorate([
            core.HostBinding('style.background'),
            core.Input()
        ], IgxAvatarComponent.prototype, "bgColor", void 0);
        __decorate([
            core.Input()
        ], IgxAvatarComponent.prototype, "initials", void 0);
        __decorate([
            core.Input()
        ], IgxAvatarComponent.prototype, "icon", void 0);
        __decorate([
            core.Input()
        ], IgxAvatarComponent.prototype, "src", void 0);
        __decorate([
            core.Input()
        ], IgxAvatarComponent.prototype, "size", null);
        IgxAvatarComponent = __decorate([
            core.Component({
                selector: 'igx-avatar',
                template: "<ng-template #defaultTemplate>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #imageTemplate>\n    <div #image class=\"igx-avatar__image\" [style.backgroundImage]=\"getSrcUrl()\"></div>\n</ng-template>\n\n<ng-template #initialsTemplate>\n    <span>{{initials.substring(0, 2)}}</span>\n</ng-template>\n\n<ng-template #iconTemplate>\n     <igx-icon>{{icon}}</igx-icon>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
            })
        ], IgxAvatarComponent);
        return IgxAvatarComponent;
    }());
    /**
     * @hidden
     */
    var IgxAvatarModule = /** @class */ (function () {
        function IgxAvatarModule() {
        }
        IgxAvatarModule = __decorate([
            core.NgModule({
                declarations: [IgxAvatarComponent],
                exports: [IgxAvatarComponent],
                imports: [common.CommonModule, IgxIconModule]
            })
        ], IgxAvatarModule);
        return IgxAvatarModule;
    }());

    var NEXT_ID$9 = 0;
    /**
     * Determines the igxBadge type
     */

    (function (IgxBadgeType) {
        IgxBadgeType["PRIMARY"] = "primary";
        IgxBadgeType["INFO"] = "info";
        IgxBadgeType["SUCCESS"] = "success";
        IgxBadgeType["WARNING"] = "warning";
        IgxBadgeType["ERROR"] = "error";
    })(exports.IgxBadgeType || (exports.IgxBadgeType = {}));
    /**
     * Badge provides visual notifications used to decorate avatars, menus, etc.
     *
     * @igxModule IgxBadgeModule
     *
     * @igxTheme igx-badge-theme
     *
     * @igxKeywords badge, icon, notification
     *
     * @igxGroup Data Entry & Display
     *
     * @remarks
     * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
     * application when visual notification is needed. They are usually designed as icons with a predefined
     * style to communicate information, success, warnings, or errors.
     *
     * @example
     * ```html
     * <igx-avatar>
     *   <igx-badge icon="check" type="success"></igx-badge>
     * </igx-avatar>
     */
    var IgxBadgeComponent = /** @class */ (function () {
        function IgxBadgeComponent() {
            /**
            * Sets/gets the `id` of the badge.
            *
            * @remarks
            * If not set, the `id` will have value `"igx-badge-0"`.
            *
            * @example
            * ```html
            * <igx-badge id="igx-badge-2"></igx-badge>
            * ```
            */
            this.id = "igx-badge-" + NEXT_ID$9++;
            /**
            * Sets/gets the type of the badge.
            *
            * @remarks
            * Allowed values are `primary`, `info`, `success`, `warning`, `error`.
            * Providing an invalid value won't display a badge.
            *
            * @example
            * ```html
            * <igx-badge type="success"></igx-badge>
            * ```
            */
            this.type = exports.IgxBadgeType.PRIMARY;
            /**
            * Sets/gets the value to be displayed inside the badge.
            *
            * @remarks
            * If an `icon` property is already set the `icon` will be displayed.
            * If neither a `value` nor an `icon` is set the content of the badge will be empty.
            *
            * @example
            * ```html
            * <igx-badge value="11"></igx-badge>
            * ```
            */
            this.value = '';
            /**
             * Sets/gets the role attribute value.
             *
             * @example
             * ```typescript
             * @ViewChild("MyBadge", { read: IgxBadgeComponent })
             * public badge: IgxBadgeComponent;
             *
             * badge.role = 'status';
             * ```
             */
            this.role = 'status';
            /**
             * Sets/gets the the css class to use on the badge.
             *
             * @example
             * ```typescript
             * @ViewChild("MyBadge", { read: IgxBadgeComponent })
             * public badge: IgxBadgeComponent;
             *
             * badge.cssClass = 'my-badge-class';
             * ```
             */
            this.cssClass = 'igx-badge';
            /**
             * Sets/gets the aria-label attribute value.
             *
             * @example
             * ```typescript
             * @ViewChild("MyBadge", { read: IgxBadgeComponent })
             * public badge: IgxBadgeComponent;
             *
             * badge.label = 'badge';
             * ```
             */
            this.label = 'badge';
        }
        Object.defineProperty(IgxBadgeComponent.prototype, "roleDescription", {
            /**
             * Defines a human-readable, accessor, author-localized description for
             * the `type` and the `icon` or `value` of the element.
             * @hidden
             * @internal
             */
            get: function () {
                var message;
                // tslint:disable-next-line:prefer-conditional-expression
                if (this.icon) {
                    message = this.type + ' type badge with icon type ' + this.icon;
                }
                else if (this.value) {
                    message = this.type + ' badge type with value ' + this.value;
                }
                else {
                    message = this.type + ' badge type without value';
                }
                return message;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Method which makes the name of the class more descriptive.
         * This helps the styling of the badges.
         * @hidden
         * @internal
         */
        IgxBadgeComponent.prototype.setClasses = function () {
            var _a, _b, _c, _d, _e;
            var classes = {};
            switch (exports.IgxBadgeType[this.type.toUpperCase()]) {
                case exports.IgxBadgeType.INFO:
                    classes = (_a = {},
                        _a[this.cssClass + "__circle--info"] = true,
                        _a);
                    break;
                case exports.IgxBadgeType.SUCCESS:
                    classes = (_b = {},
                        _b[this.cssClass + "__circle--success"] = true,
                        _b);
                    break;
                case exports.IgxBadgeType.WARNING:
                    classes = (_c = {},
                        _c[this.cssClass + "__circle--warning"] = true,
                        _c);
                    break;
                case exports.IgxBadgeType.ERROR:
                    classes = (_d = {},
                        _d[this.cssClass + "__circle--error"] = true,
                        _d);
                    break;
                default:
                    classes = (_e = {},
                        _e[this.cssClass + "__circle--default"] = true,
                        _e);
            }
            return classes;
        };
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxBadgeComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxBadgeComponent.prototype, "type", void 0);
        __decorate([
            core.Input()
        ], IgxBadgeComponent.prototype, "value", void 0);
        __decorate([
            core.Input()
        ], IgxBadgeComponent.prototype, "icon", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxBadgeComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('class.igx-badge')
        ], IgxBadgeComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('attr.aria-label')
        ], IgxBadgeComponent.prototype, "label", void 0);
        IgxBadgeComponent = __decorate([
            core.Component({
                selector: 'igx-badge',
                template: "<div class=\"igx-badge__circle\" [ngClass]=\"setClasses()\" [attr.aria-roledescription]=\"roleDescription\">\n    <span *ngIf=\"!icon\" class=\"igx-badge__circle-value\">{{value}}</span>\n    <igx-icon *ngIf=\"icon\" fontSet=\"material\">{{icon}}</igx-icon>\n</div>\n"
            })
        ], IgxBadgeComponent);
        return IgxBadgeComponent;
    }());
    /**
     * @hidden
     */
    var IgxBadgeModule = /** @class */ (function () {
        function IgxBadgeModule() {
        }
        IgxBadgeModule = __decorate([
            core.NgModule({
                declarations: [IgxBadgeComponent],
                exports: [IgxBadgeComponent],
                imports: [common.CommonModule, IgxIconModule]
            })
        ], IgxBadgeModule);
        return IgxBadgeModule;
    }());

    /** @hidden */
    var IGX_EXPANSION_PANEL_COMPONENT = new core.InjectionToken('IgxExpansionPanelToken');

    var IgxExpansionPanelBodyComponent = /** @class */ (function () {
        function IgxExpansionPanelBodyComponent(panel, element, cdr) {
            this.panel = panel;
            this.element = element;
            this.cdr = cdr;
            this._labelledBy = '';
            this._label = '';
            /**
             * @hidden
             */
            this.cssClass = "igx-expansion-panel__body";
            /**
             * Gets/sets the `role` attribute of the panel body
             * Default is 'region';
             * Get
             * ```typescript
             *  const currentRole = this.panel.body.role;
             * ```
             * Set
             * ```typescript
             *  this.panel.body.role = 'content';
             * ```
             * ```html
             *  <igx-expansion-panel-body [role]="'custom'"></igx-expansion-panel-body>
             * ```
             */
            this.role = 'region';
        }
        Object.defineProperty(IgxExpansionPanelBodyComponent.prototype, "label", {
            /**
             * Gets the `aria-label` attribute of the panel body
             * Defaults to the panel id with '-region' in the end;
             * Get
             * ```typescript
             *  const currentLabel = this.panel.body.label;
             * ```
             */
            get: function () {
                return this._label || this.panel.id + '-region';
            },
            /**
             * Sets the `aria-label` attribute of the panel body
             * ```typescript
             *  this.panel.body.label = 'my-custom-label';
             * ```
             * ```html
             *  <igx-expansion-panel-body [label]="'my-custom-label'"></igx-expansion-panel-body>
             * ```
             */
            set: function (val) {
                this._label = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExpansionPanelBodyComponent.prototype, "labelledBy", {
            /**
             * Gets the `aria-labelledby` attribute of the panel body
             * Defaults to the panel header id;
             * Get
             * ```typescript
             *  const currentLabel = this.panel.body.labelledBy;
             * ```
             */
            get: function () {
                return this._labelledBy;
            },
            /**
             * Sets the `aria-labelledby` attribute of the panel body
             * ```typescript
             *  this.panel.body.labelledBy = 'my-custom-id';
             * ```
             * ```html
             *  <igx-expansion-panel-body [labelledBy]="'my-custom-id'"></igx-expansion-panel-body>
             * ```
             */
            set: function (val) {
                this._labelledBy = val;
            },
            enumerable: true,
            configurable: true
        });
        IgxExpansionPanelBodyComponent.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.HostBinding('class.igx-expansion-panel__body')
        ], IgxExpansionPanelBodyComponent.prototype, "cssClass", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('attr.aria-label')
        ], IgxExpansionPanelBodyComponent.prototype, "label", null);
        __decorate([
            core.Input(),
            core.HostBinding('attr.aria-labelledby')
        ], IgxExpansionPanelBodyComponent.prototype, "labelledBy", null);
        __decorate([
            core.Input(),
            core.HostBinding('attr.role')
        ], IgxExpansionPanelBodyComponent.prototype, "role", void 0);
        IgxExpansionPanelBodyComponent = __decorate([
            core.Component({
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-body',
                template: "<ng-content></ng-content>"
            }),
            __param(0, core.Inject(IGX_EXPANSION_PANEL_COMPONENT))
        ], IgxExpansionPanelBodyComponent);
        return IgxExpansionPanelBodyComponent;
    }());

    /**
     * @hidden
     */
    var IgxExpansionPanelTitleDirective = /** @class */ (function () {
        function IgxExpansionPanelTitleDirective() {
            this.cssClass = "igx-expansion-panel__header-title";
        }
        __decorate([
            core.HostBinding('class.igx-expansion-panel__header-title')
        ], IgxExpansionPanelTitleDirective.prototype, "cssClass", void 0);
        IgxExpansionPanelTitleDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-title'
            })
        ], IgxExpansionPanelTitleDirective);
        return IgxExpansionPanelTitleDirective;
    }());
    /**
     * @hidden
     */
    var IgxExpansionPanelDescriptionDirective = /** @class */ (function () {
        function IgxExpansionPanelDescriptionDirective() {
            this.cssClass = "igx-expansion-panel__header-description";
        }
        __decorate([
            core.HostBinding('class.igx-expansion-panel__header-description')
        ], IgxExpansionPanelDescriptionDirective.prototype, "cssClass", void 0);
        IgxExpansionPanelDescriptionDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-description'
            })
        ], IgxExpansionPanelDescriptionDirective);
        return IgxExpansionPanelDescriptionDirective;
    }());
    /**
     * @hidden
     */
    var IgxExpansionPanelIconDirective = /** @class */ (function () {
        function IgxExpansionPanelIconDirective() {
        }
        IgxExpansionPanelIconDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-icon'
            })
        ], IgxExpansionPanelIconDirective);
        return IgxExpansionPanelIconDirective;
    }());

    /**
     * @hidden
     */
    var ICON_POSITION;
    (function (ICON_POSITION) {
        ICON_POSITION["LEFT"] = "left";
        ICON_POSITION["NONE"] = "none";
        ICON_POSITION["RIGHT"] = "right";
    })(ICON_POSITION || (ICON_POSITION = {}));
    var IgxExpansionPanelHeaderComponent = /** @class */ (function () {
        function IgxExpansionPanelHeaderComponent(panel, cdr, elementRef) {
            this.panel = panel;
            this.cdr = cdr;
            this.elementRef = elementRef;
            // properties section
            this._iconTemplate = false;
            /**
             * Sets/gets the `id` of the expansion panel header.
             * ```typescript
             * let panelHeaderId =  this.panel.header.id;
             * ```
             * @memberof IgxExpansionPanelComponent
             */
            this.id = '';
            /**
             * Gets/sets the `aria-level` attribute of the header
             * Get
             * ```typescript
             *  const currentAriaLevel = this.panel.header.lv;
             * ```
             * Set
             * ```typescript
             *  this.panel.header.lv = '5';
             * ```
             * ```html
             *  <igx-expansion-panel-header [lv]="myCustomLevel"></igx-expansion-panel-header>
             * ```
             */
            this.lv = '3';
            /**
             * Gets/sets the `role` attribute of the header
             * Get
             * ```typescript
             *  const currentRole = this.panel.header.role;
             * ```
             * Set
             * ```typescript
             *  this.panel.header.role = '5';
             * ```
             * ```html
             *  <igx-expansion-panel-header [role]="'custom'"></igx-expansion-panel-header>
             * ```
             */
            this.role = 'heading';
            /**
             * Gets/sets the position of the expansion-panel-header expand/collapse icon
             * Accepts `left`, `right` or `none`
             * ```typescript
             *  const currentIconPosition = this.panel.header.iconPosition;
             * ```
             * Set
             * ```typescript
             *  this.panel.header.iconPosition = 'left';
             * ```
             * ```html
             *  <igx-expansion-panel-header [iconPosition]="'right'"></igx-expansion-panel-header>
             * ```
             */
            this.iconPosition = ICON_POSITION.LEFT;
            /**
             * Emitted whenever a user interacts with the header host
             * ```typescript
             *  handleInteraction(event: IExpansionPanelEventArgs) {
             *  ...
             * }
             * ```
             * ```html
             *  <igx-expansion-panel-header (onInteraction)="handleInteraction($event)">
             *      ...
             *  </igx-expansion-panel-header>
             * ```
             */
            this.onInteraction = new core.EventEmitter();
            /**
             * @hidden
             */
            this.cssClass = 'igx-expansion-panel__header';
            /**
             * Gets/sets the whether the header is disabled
             * When disabled, the header will not handle user events and will stop their propagation
             *
             * ```typescript
             *  const isDisabled = this.panel.header.disabled;
             * ```
             * Set
             * ```typescript
             *  this.panel.header.disabled = true;
             * ```
             * ```html
             *  <igx-expansion-panel-header [disabled]="true">
             *     ...
             *  </igx-expansion-panel-header>
             * ```
             */
            this.disabled = false;
            this.id = this.panel.id + "-header";
        }
        Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "iconTemplate", {
            /**
             * @hidden
             */
            get: function () {
                return this._iconTemplate;
            },
            /**
             * @hidden
             */
            set: function (val) {
                this._iconTemplate = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "controls", {
            /**
             * @hidden
             */
            get: function () {
                return this.panel.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "isExpanded", {
            /**
            * @hidden
            */
            get: function () {
                return !this.panel.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @hidden
        */
        IgxExpansionPanelHeaderComponent.prototype.onAction = function (evt) {
            if (this.disabled) {
                evt.stopPropagation();
                return;
            }
            this.onInteraction.emit({ event: evt, panel: this.panel });
            this.panel.toggle(evt);
            evt.preventDefault();
        };
        /** @hidden @internal */
        IgxExpansionPanelHeaderComponent.prototype.openPanel = function (event) {
            if (event.altKey) {
                this.panel.expand(event);
                this.onInteraction.emit({ event: event, panel: this.panel });
            }
        };
        /** @hidden @internal */
        IgxExpansionPanelHeaderComponent.prototype.closePanel = function (event) {
            if (event.altKey) {
                this.panel.collapse(event);
                this.onInteraction.emit({ event: event, panel: this.panel });
            }
        };
        Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "iconPositionClass", {
            /**
            * @hidden
            */
            get: function () {
                switch (this.iconPosition) {
                    case (ICON_POSITION.LEFT):
                        return "igx-expansion-panel__header-icon--start";
                    case (ICON_POSITION.RIGHT):
                        return "igx-expansion-panel__header-icon--end";
                    case (ICON_POSITION.NONE):
                        return "igx-expansion-panel__header-icon--none";
                    default:
                        return '';
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxExpansionPanelHeaderComponent.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Host }, { type: core.Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.ContentChild(IgxExpansionPanelIconDirective)
        ], IgxExpansionPanelHeaderComponent.prototype, "iconTemplate", null);
        __decorate([
            core.HostBinding('attr.aria-level'),
            core.Input()
        ], IgxExpansionPanelHeaderComponent.prototype, "lv", void 0);
        __decorate([
            core.HostBinding('attr.role'),
            core.Input()
        ], IgxExpansionPanelHeaderComponent.prototype, "role", void 0);
        __decorate([
            core.Input()
        ], IgxExpansionPanelHeaderComponent.prototype, "iconPosition", void 0);
        __decorate([
            core.Output()
        ], IgxExpansionPanelHeaderComponent.prototype, "onInteraction", void 0);
        __decorate([
            core.HostBinding('class.igx-expansion-panel__header')
        ], IgxExpansionPanelHeaderComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('class.igx-expansion-panel__header--expanded')
        ], IgxExpansionPanelHeaderComponent.prototype, "isExpanded", null);
        __decorate([
            core.Input(),
            core.HostBinding('class.igx-expansion-panel--disabled')
        ], IgxExpansionPanelHeaderComponent.prototype, "disabled", void 0);
        __decorate([
            core.HostListener('keydown.Enter', ['$event']),
            core.HostListener('keydown.Space', ['$event']),
            core.HostListener('keydown.Spacebar', ['$event']),
            core.HostListener('click', ['$event'])
        ], IgxExpansionPanelHeaderComponent.prototype, "onAction", null);
        __decorate([
            core.HostListener('keydown.Alt.ArrowDown', ['$event'])
        ], IgxExpansionPanelHeaderComponent.prototype, "openPanel", null);
        __decorate([
            core.HostListener('keydown.Alt.ArrowUp', ['$event'])
        ], IgxExpansionPanelHeaderComponent.prototype, "closePanel", null);
        IgxExpansionPanelHeaderComponent = __decorate([
            core.Component({
                selector: 'igx-expansion-panel-header',
                template: "<div class=\"igx-expansion-panel__header-inner\" tabindex=\"0\" role=\"button\" [attr.id]=\"id\"\n[attr.aria-disabled]=\"disabled\" [attr.aria-expanded]=\"isExpanded\" [attr.aria-controls]=\"controls\">\n    <div class=\"igx-expansion-panel__title-wrapper\">\n        <ng-content select=\"igx-expansion-panel-title\"></ng-content>\n        <ng-content select=\"igx-expansion-panel-description\"></ng-content>\n    </div>\n    <ng-content></ng-content>\n    <div [class]=\"iconPositionClass\">\n        <ng-content *ngIf=\"iconTemplate\" select=\"igx-expansion-panel-icon\"></ng-content>\n        <igx-icon *ngIf=\"!iconTemplate\" fontSet=\"material\">\n            {{panel.collapsed? 'expand_more':'expand_less'}}\n        </igx-icon>\n    </div>\n</div>\n"
            }),
            __param(0, core.Host()), __param(0, core.Inject(IGX_EXPANSION_PANEL_COMPONENT))
        ], IgxExpansionPanelHeaderComponent);
        return IgxExpansionPanelHeaderComponent;
    }());

    var NEXT_ID$a = 0;
    var IgxExpansionPanelComponent = /** @class */ (function () {
        function IgxExpansionPanelComponent(cdr, builder) {
            this.cdr = cdr;
            this.builder = builder;
            this._collapsed = true;
            /**
             * Sets/gets the animation settings of the expansion panel component
             * Open and Close animation should be passed
             *
             * Get
             * ```typescript
             *  const currentAnimations = this.panel.animationSettings;
             * ```
             * Set
             * ```typescript
             *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
             *  ...
             *  this.panel.animationsSettings = {
             *      openAnimation: slideInLeft,
             *      closeAnimation: slideOutRight
             * };
             * ```
             * or via template
             * ```typescript
             *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
             *  ...
             *  myCustomAnimationObject = {
             *      openAnimation: slideInLeft,
             *      closeAnimation: slideOutRight
             * };
             * ```html
             *  <igx-expansion-panel [animationSettings]='myCustomAnimationObject'>
             *  ...
             *  </igx-expansion-panel>
             * ```
             */
            this.animationSettings = {
                openAnimation: growVerIn,
                closeAnimation: growVerOut
            };
            /**
             * Sets/gets the `id` of the expansion panel component.
             * If not set, `id` will have value `"igx-expansion-panel-0"`;
             * ```html
             * <igx-expansion-panel id = "my-first-expansion-panel"></igx-expansion-panel>
             * ```
             * ```typescript
             * let panelId =  this.panel.id;
             * ```
             * @memberof IgxExpansionPanelComponent
             */
            this.id = "igx-expansion-panel-" + NEXT_ID$a++;
            /**
             * @hidden
             */
            this.cssClass = 'igx-expansion-panel';
            /**
             *@hidden
             */
            this.collapsedChange = new core.EventEmitter();
            /**
             * Emitted when the expansion panel finishes collapsing
             * ```typescript
             *  handleCollapsed(event: {
             *  panel: IgxExpansionPanelComponent,
             *  event: Event
             * })
             * ```
             * ```html
             *  <igx-expansion-panel (onCollapsed)="handleCollapsed($event)">
             *      ...
             *  </igx-expansion-panel>
             * ```
             */
            this.onCollapsed = new core.EventEmitter();
            /**
             * Emitted when the expansion panel finishes expanding
             * ```typescript
             *  handleExpanded(event: {
             *  panel: IgxExpansionPanelComponent,
             *  event: Event
             * })
             * ```
             * ```html
             *  <igx-expansion-panel (onExpanded)="handleExpanded($event)">
             *      ...
             *  </igx-expansion-panel>
             * ```
             */
            this.onExpanded = new core.EventEmitter();
        }
        IgxExpansionPanelComponent_1 = IgxExpansionPanelComponent;
        Object.defineProperty(IgxExpansionPanelComponent.prototype, "collapsed", {
            /**
             * Gets/sets whether the component is collapsed (its content is hidden)
             * Get
             * ```typescript
             *  const myPanelState: boolean = this.panel.collapsed;
             * ```
             * Set
             * ```html
             *  this.panel.collapsed = true;
             * ```
             *
             * Two-way data binding:
             * ```html
             * <igx-expansion-panel [(collapsed)]="model.isCollapsed"></igx-expansion-panel>
             * ```
             */
            get: function () {
                return this._collapsed;
            },
            set: function (value) {
                this._collapsed = value;
                this.collapsedChange.emit(this._collapsed);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExpansionPanelComponent.prototype, "headerId", {
            /**
             * @hidden
             */
            get: function () {
                return this.header ? this.id + "-header" : '';
            },
            enumerable: true,
            configurable: true
        });
        /** @hidden */
        IgxExpansionPanelComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (this.body && this.header) {
                // schedule at end of turn:
                Promise.resolve().then(function () {
                    _this.body.labelledBy = _this.body.labelledBy || _this.headerId;
                    _this.body.label = _this.body.label || _this.id + '-region';
                });
            }
        };
        IgxExpansionPanelComponent.prototype.playOpenAnimation = function (cb) {
            if (!this.body) { // if not body element is passed, there is nothing to animate
                return;
            }
            var animation = animations.useAnimation(this.animationSettings.openAnimation);
            var animationBuilder = this.builder.build(animation);
            var openAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
            openAnimationPlayer.onDone(function () {
                cb();
                openAnimationPlayer.reset();
            });
            openAnimationPlayer.play();
        };
        IgxExpansionPanelComponent.prototype.playCloseAnimation = function (cb) {
            if (!this.body) { // if not body element is passed, there is nothing to animate
                return;
            }
            var animation = animations.useAnimation(this.animationSettings.closeAnimation);
            var animationBuilder = this.builder.build(animation);
            var closeAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
            closeAnimationPlayer.onDone(function () {
                cb();
                closeAnimationPlayer.reset();
            });
            closeAnimationPlayer.play();
        };
        /**
         * Collapses the panel
         *
         * ```html
         *  <igx-expansion-panel #myPanel>
         *      ...
         *  </igx-expansion-panel>
         *  <button (click)="myPanel.collapse($event)">Collpase Panel</button>
         * ```
         */
        IgxExpansionPanelComponent.prototype.collapse = function (evt) {
            var _this = this;
            if (this.collapsed) { // If expansion panel is already collapsed, do nothing
                return;
            }
            this.playCloseAnimation(function () {
                _this.onCollapsed.emit({ event: evt, panel: _this });
                _this.collapsed = true;
            });
        };
        /**
         * Expands the panel
         *
         * ```html
         *  <igx-expansion-panel #myPanel>
         *      ...
         *  </igx-expansion-panel>
         *  <button (click)="myPanel.expand($event)">Expand Panel</button>
         * ```
         */
        IgxExpansionPanelComponent.prototype.expand = function (evt) {
            var _this = this;
            if (!this.collapsed) { // If the panel is already opened, do nothing
                return;
            }
            this.collapsed = false;
            this.cdr.detectChanges();
            this.playOpenAnimation(function () {
                _this.onExpanded.emit({ event: evt, panel: _this });
            });
        };
        /**
         * Toggles the panel
         *
         * ```html
         *  <igx-expansion-panel #myPanel>
         *      ...
         *  </igx-expansion-panel>
         *  <button (click)="myPanel.toggle($event)">Expand Panel</button>
         * ```
         */
        IgxExpansionPanelComponent.prototype.toggle = function (evt) {
            if (this.collapsed) {
                this.open(evt);
            }
            else {
                this.close(evt);
            }
        };
        IgxExpansionPanelComponent.prototype.open = function (evt) {
            this.expand(evt);
        };
        IgxExpansionPanelComponent.prototype.close = function (evt) {
            this.collapse(evt);
        };
        var IgxExpansionPanelComponent_1;
        IgxExpansionPanelComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: animations.AnimationBuilder }
        ]; };
        __decorate([
            core.Input()
        ], IgxExpansionPanelComponent.prototype, "animationSettings", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxExpansionPanelComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('class.igx-expansion-panel')
        ], IgxExpansionPanelComponent.prototype, "cssClass", void 0);
        __decorate([
            core.Input()
        ], IgxExpansionPanelComponent.prototype, "collapsed", null);
        __decorate([
            core.Output()
        ], IgxExpansionPanelComponent.prototype, "collapsedChange", void 0);
        __decorate([
            core.Output()
        ], IgxExpansionPanelComponent.prototype, "onCollapsed", void 0);
        __decorate([
            core.Output()
        ], IgxExpansionPanelComponent.prototype, "onExpanded", void 0);
        __decorate([
            core.ContentChild(IgxExpansionPanelBodyComponent, { read: IgxExpansionPanelBodyComponent })
        ], IgxExpansionPanelComponent.prototype, "body", void 0);
        __decorate([
            core.ContentChild(IgxExpansionPanelHeaderComponent, { read: IgxExpansionPanelHeaderComponent })
        ], IgxExpansionPanelComponent.prototype, "header", void 0);
        IgxExpansionPanelComponent = IgxExpansionPanelComponent_1 = __decorate([
            core.Component({
                selector: 'igx-expansion-panel',
                template: "<ng-content select=\"igx-expansion-panel-header\"></ng-content>\n<ng-content *ngIf=\"!collapsed\" select=\"igx-expansion-panel-body\"></ng-content>\n",
                providers: [{ provide: IGX_EXPANSION_PANEL_COMPONENT, useExisting: IgxExpansionPanelComponent_1 }]
            })
        ], IgxExpansionPanelComponent);
        return IgxExpansionPanelComponent;
    }());

    /**
     * @hidden
     */
    var IgxExpansionPanelModule = /** @class */ (function () {
        function IgxExpansionPanelModule() {
        }
        IgxExpansionPanelModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxExpansionPanelComponent,
                    IgxExpansionPanelHeaderComponent,
                    IgxExpansionPanelBodyComponent,
                    IgxExpansionPanelDescriptionDirective,
                    IgxExpansionPanelTitleDirective,
                    IgxExpansionPanelIconDirective
                ],
                entryComponents: [],
                exports: [
                    IgxExpansionPanelComponent,
                    IgxExpansionPanelHeaderComponent,
                    IgxExpansionPanelBodyComponent,
                    IgxExpansionPanelDescriptionDirective,
                    IgxExpansionPanelTitleDirective,
                    IgxExpansionPanelIconDirective
                ],
                imports: [
                    common.CommonModule,
                    IgxRippleModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxAvatarModule
                ]
            })
        ], IgxExpansionPanelModule);
        return IgxExpansionPanelModule;
    }());

    // tslint:disable:directive-selector
    var IgxBannerActionsDirective = /** @class */ (function () {
        function IgxBannerActionsDirective() {
        }
        IgxBannerActionsDirective = __decorate([
            core.Directive({
                selector: 'igx-banner-actions'
            })
        ], IgxBannerActionsDirective);
        return IgxBannerActionsDirective;
    }());

    /**
     * **Ignite UI for Angular Banner** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/banner.html)
     *
     * The Ignite UI Banner provides a highly templateable and easy to use banner that can be shown in your application.
     *
     * Usage:
     *
     * ```html
     * <igx-banner #banner>
     *   Our privacy settings have changed.
     *  <igx-banner-actions>
     *      <button igxButton="raised">Read More</button>
     *      <button igxButton="raised">Accept and Continue</button>
     *  </igx-banner-actions>
     * </igx-banner>
     * ```
     */
    var IgxBannerComponent = /** @class */ (function () {
        function IgxBannerComponent(elementRef) {
            this.elementRef = elementRef;
            /**
             * Fires after the banner shows up
             * ```typescript
             * public handleOpened(event) {
             *  ...
             * }
             * ```
             * ```html
             * <igx-banner (onOpened)="handleOpened($event)"></igx-banner>
             * ```
             */
            this.onOpened = new core.EventEmitter();
            /**
             * Fires before the banner shows up
             * ```typescript
             * public handleOpening(event) {
             *  ...
             * }
             * ```
             * ```html
             * <igx-banner (onOpening)="handleOpening($event)"></igx-banner>
             * ```
             */
            this.onOpening = new core.EventEmitter();
            /**
             * Fires after the banner hides
             * ```typescript
             * public handleClosed(event) {
             *  ...
             * }
             * ```
             * ```html
             * <igx-banner (onClosed)="handleClosed($event)"></igx-banner>
             * ```
             */
            this.onClosed = new core.EventEmitter();
            /**
             * Fires before the banner hides
             * ```typescript
             * public handleClosing(event) {
             *  ...
             * }
             * ```
             * ```html
             * <igx-banner (onClosing)="handleClosing($event)"></igx-banner>
             * ```
             */
            this.onClosing = new core.EventEmitter();
        }
        Object.defineProperty(IgxBannerComponent.prototype, "useDefaultTemplate", {
            /** @hidden */
            get: function () {
                return !this._bannerActionTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxBannerComponent.prototype, "animationSettings", {
            /**
             * Get the animation settings used by the banner open/close methods
             * ```typescript
             * let currentAnimations: AnimationSettings = banner.animationSettings
             * ```
             */
            get: function () {
                return this._animationSettings ? this._animationSettings : this._expansionPanel.animationSettings;
            },
            /**
             * Set the animation settings used by the banner open/close methods
             * ```typescript
             * import { slideInLeft, slideOutRight } from 'igniteui-angular';
             * ...
             * banner.animationSettings: AnimationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight };
             * ```
             */
            set: function (settings) {
                this._animationSettings = settings;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxBannerComponent.prototype, "collapsed", {
            /**
             * Gets whether banner is collapsed
             *
             * ```typescript
             * const isCollapsed: boolean = banner.collapsed;
             * ```
             */
            get: function () {
                return this._expansionPanel.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxBannerComponent.prototype, "element", {
            /**
             * Returns the native element of the banner component
             * ```typescript
             *  const myBannerElement: HTMLElement = banner.element;
             * ```
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxBannerComponent.prototype, "displayStyle", {
            /**
             * @hidden
             */
            get: function () {
                return this.collapsed ? '' : 'block';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Opens the banner
         *
         * ```typescript
         *  myBanner.open();
         * ```
         *
         * ```html
         * <igx-banner #banner>
         * ...
         * </igx-banner>
         * <button (click)="banner.open()">Open Banner</button>
         * ```
         */
        IgxBannerComponent.prototype.open = function (event) {
            this._bannerEvent = { banner: this, event: event };
            var openingArgs = {
                banner: this,
                event: event,
                cancel: false
            };
            this.onOpening.emit(openingArgs);
            if (openingArgs.cancel) {
                return;
            }
            this._expansionPanel.open(event);
        };
        /**
         * Closes the banner
         *
         * ```typescript
         *  myBanner.close();
         * ```
         *
         * ```html
         * <igx-banner #banner>
         * ...
         * </igx-banner>
         * <button (click)="banner.close()">Close Banner</button>
         * ```
         */
        IgxBannerComponent.prototype.close = function (event) {
            this._bannerEvent = { banner: this, event: event };
            var closingArgs = {
                banner: this,
                event: event,
                cancel: false
            };
            this.onClosing.emit(closingArgs);
            if (closingArgs.cancel) {
                return;
            }
            this._expansionPanel.close(event);
        };
        /**
         * Toggles the banner
         *
         * ```typescript
         *  myBanner.toggle();
         * ```
         *
         * ```html
         * <igx-banner #banner>
         * ...
         * </igx-banner>
         * <button (click)="banner.toggle()">Toggle Banner</button>
         * ```
         */
        IgxBannerComponent.prototype.toggle = function (event) {
            if (this.collapsed) {
                this.open(event);
            }
            else {
                this.close(event);
            }
        };
        /** @hidden */
        IgxBannerComponent.prototype.onExpansionPanelOpen = function () {
            this.onOpened.emit(this._bannerEvent);
        };
        /** @hidden */
        IgxBannerComponent.prototype.onExpansionPanelClose = function () {
            this.onClosed.emit(this._bannerEvent);
        };
        IgxBannerComponent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.ViewChild('expansionPanel', { static: true })
        ], IgxBannerComponent.prototype, "_expansionPanel", void 0);
        __decorate([
            core.ContentChild(IgxBannerActionsDirective)
        ], IgxBannerComponent.prototype, "_bannerActionTemplate", void 0);
        __decorate([
            core.ContentChild(IgxIconComponent)
        ], IgxBannerComponent.prototype, "bannerIcon", void 0);
        __decorate([
            core.Output()
        ], IgxBannerComponent.prototype, "onOpened", void 0);
        __decorate([
            core.Output()
        ], IgxBannerComponent.prototype, "onOpening", void 0);
        __decorate([
            core.Output()
        ], IgxBannerComponent.prototype, "onClosed", void 0);
        __decorate([
            core.Output()
        ], IgxBannerComponent.prototype, "onClosing", void 0);
        __decorate([
            core.Input()
        ], IgxBannerComponent.prototype, "animationSettings", null);
        __decorate([
            core.HostBinding('style.display')
        ], IgxBannerComponent.prototype, "displayStyle", null);
        IgxBannerComponent = __decorate([
            core.Component({
                selector: 'igx-banner',
                template: "<igx-expansion-panel #expansionPanel [animationSettings]=\"animationSettings\" (onCollapsed)=\"onExpansionPanelClose()\" (onExpanded)=\"onExpansionPanelOpen()\"\n    [collapsed]=\"collapsed\" aria-live=\"polite\" [attr.aria-hidden]=\"collapsed\">\n    <igx-expansion-panel-body>\n        <div class=\"igx-banner\">\n            <div class=\"igx-banner__message\">\n                <div *ngIf=\"bannerIcon\" class=\"igx-banner__illustration\">\n                    <ng-content select=\"igx-icon\"></ng-content>\n                </div>\n                <span class=\"igx-banner__text\">\n                    <ng-content></ng-content>\n                </span>\n            </div>\n            <div class=\"igx-banner__actions\">\n                <div class=\"igx-banner__row\">\n                    <ng-container *ngIf=\"useDefaultTemplate\">\n                        <button igxButton=\"flat\" igxRipple (click)=\"close()\">\n                            Dismiss\n                        </button>\n                    </ng-container>\n                    <ng-container *ngIf=\"!useDefaultTemplate\">\n                        <ng-content select=\"igx-banner-actions\"></ng-content>\n                    </ng-container>\n                </div>\n            </div>\n        </div>\n    </igx-expansion-panel-body>\n</igx-expansion-panel>"
            })
        ], IgxBannerComponent);
        return IgxBannerComponent;
    }());
    /**
     * @hidden
     */
    var IgxBannerModule = /** @class */ (function () {
        function IgxBannerModule() {
        }
        IgxBannerModule = __decorate([
            core.NgModule({
                declarations: [IgxBannerComponent, IgxBannerActionsDirective],
                exports: [IgxBannerComponent, IgxBannerActionsDirective],
                imports: [common.CommonModule, IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]
            })
        ], IgxBannerModule);
        return IgxBannerModule;
    }());


    (function (ButtonGroupAlignment) {
        ButtonGroupAlignment[ButtonGroupAlignment["horizontal"] = 0] = "horizontal";
        ButtonGroupAlignment[ButtonGroupAlignment["vertical"] = 1] = "vertical";
    })(exports.ButtonGroupAlignment || (exports.ButtonGroupAlignment = {}));
    var NEXT_ID$b = 0;
    /**
     * **Ignite UI for Angular Button Group** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/buttongroup.html)
     *
     * The Ignite UI Button Group displays a group of buttons either vertically or horizontally.  The group supports
     * single, multiple and toggle selection.
     *
     * Example:
     * ```html
     * <igx-buttongroup multiSelection="true" [values]="fontOptions">
     * </igx-buttongroup>
     * ```
     * The `fontOptions` value shown above is defined as:
     * ```typescript
     * this.fontOptions = [
     *   { icon: 'format_bold', selected: false },
     *   { icon: 'format_italic', selected: false },
     *   { icon: 'format_underlined', selected: false }];
     * ```
     */
    var IgxButtonGroupComponent = /** @class */ (function (_super) {
        __extends(IgxButtonGroupComponent, _super);
        function IgxButtonGroupComponent(_cdr, _renderer, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this._cdr = _cdr;
            _this._renderer = _renderer;
            _this._displayDensityOptions = _displayDensityOptions;
            _this._disabled = false;
            _this.buttonClickNotifier$ = new rxjs.Subject();
            _this.queryListNotifier$ = new rxjs.Subject();
            /**
             * An @Input property that sets the value of the `id` attribute. If not set it will be automatically generated.
             * ```html
             *  <igx-buttongroup [id]="'igx-dialog-56'" [multiSelection]="!multi" [values]="alignOptions">
             * ```
             */
            _this.id = "igx-buttongroup-" + NEXT_ID$b++;
            /**
             * @hidden
             */
            _this.zIndex = 0;
            /**
             * An @Input property that enables selecting multiple buttons. By default, multi-selection is false.
             * ```html
             * <igx-buttongroup [multiSelection]="false" [alignment]="alignment"></igx-buttongroup>
             * ```
             */
            _this.multiSelection = false;
            /**
             * @hidden
             */
            _this.selectedIndexes = [];
            /**
             * An @Ouput property that emits an event when a button is selected.
             *```typescript
             *@ViewChild("toast")
             *private toast: IgxToastComponent;
             *public onSelect(buttongroup){
             *    this.toast.show()
             *}
             * //...
             *```
             *```html
             * <igx-buttongroup #MyChild [multiSelection]="!multi" (onSelect)="onSelect($event)"></igx-buttongroup>
             *<igx-toast #toast message="You have made a selection!"></igx-toast>
             *```
             */
            _this.onSelect = new core.EventEmitter();
            /**
             * An @Ouput property that emits an event when a button is deselected.
             *```typescript
             *@ViewChild("toast")
             *private toast: IgxToastComponent;
             *public onUnselect(buttongroup){
             *    this.toast.show()
             *}
             * //...
             *```
             *```html
             * igx-buttongroup #MyChild [multiSelection]="multi" (onUnselect)="onUnselect($event)"></igx-buttongroup>
             *<igx-toast #toast message="You have deselected a button!"></igx-toast>
             *```
             */
            _this.onUnselect = new core.EventEmitter();
            return _this;
        }
        Object.defineProperty(IgxButtonGroupComponent.prototype, "buttons", {
            /**
             * A collection containing all buttons inside the button group.
             */
            get: function () {
                return __spread(this.viewButtons.toArray(), this.templateButtons.toArray());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonGroupComponent.prototype, "itemContentCssClass", {
            /**
             * Returns the CSS class of the item content of the `IgxButtonGroup`.
             *```typescript
             *@ViewChild("MyChild")
             *public buttonG: IgxButtonGroupComponent;
             *ngAfterViewInit(){
             *   let buttonSelect = this.buttonG.itemContentCssClass;
             *}
             *```
             */
            get: function () {
                return this._itemContentCssClass;
            },
            /**
             * Allows you to set a style using the `itemContentCssClass` input.
             * The value should be the CSS class name that will be applied to the button group.
             *```typescript
             *public style1 = "styleClass";
             * //..
             *```
             * ```html
             *<igx-buttongroup [itemContentCssClass]="style1" [multiSelection]="!multi" [values]="alignOptions">
             *```
             */
            set: function (value) {
                this._itemContentCssClass = value || this._itemContentCssClass;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonGroupComponent.prototype, "disabled", {
            /**
             * An @Input property that allows you to disable the `igx-buttongroup` component. By default it's false.
             * ```html
             * <igx-buttongroup [disabled]="true" [multiSelection]="multi" [values]="fontOptions"></igx-buttongroup>
             * ```
             */
            get: function () {
                return this._disabled;
            },
            set: function (value) {
                var _this = this;
                if (this._disabled !== value) {
                    this._disabled = value;
                    if (this.viewButtons && this.templateButtons) {
                        this.buttons.forEach(function (b) { return b.disabled = _this._disabled; });
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonGroupComponent.prototype, "alignment", {
            /**
             * Returns the alignment of the `igx-buttongroup`.
             *```typescript
             *@ViewChild("MyChild")
             *public buttonG: IgxButtonGroupComponent;
             *ngAfterViewInit(){
             *    let buttonAlignment = this.buttonG.alignment;
             *}
             *```
             */
            get: function () {
                return this._isVertical ? exports.ButtonGroupAlignment.vertical : exports.ButtonGroupAlignment.horizontal;
            },
            /**
             * Allows you to set the button group alignment.
             * Available options are `ButtonGroupAlignment.horizontal` (default) and `ButtonGroupAlignment.vertical`.
             * ```typescript
             *public alignment = ButtonGroupAlignment.vertical;
             * //..
             * ```
             * ```html
             *<igx-buttongroup [multiSelection]="false" [values]="cities" [alignment]="alignment"></igx-buttongroup>
             * ```
             */
            set: function (value) {
                this._isVertical = value === exports.ButtonGroupAlignment.vertical;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonGroupComponent.prototype, "isVertical", {
            /**
             * Returns true if the `igx-buttongroup` alignment is vertical.
             * Note that in order for the accessor to work correctly the property should be set explicitly.
             * ```html
             * <igx-buttongroup #MyChild [alignment]="alignment" [values]="alignOptions">
             * ```
             * ```typescript
             * //...
             *@ViewChild("MyChild")
             *private buttonG: IgxButtonGroupComponent;
             *ngAfterViewInit(){
             *    let orientation = this.buttonG.isVertical;
             *}
             *```
             */
            get: function () {
                return this._isVertical;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxButtonGroupComponent.prototype, "selectedButtons", {
            /**
             * Gets the selected button/buttons.
             *```typescript
             *@ViewChild("MyChild")
             *private buttonG: IgxButtonGroupComponent;
             *ngAfterViewInit(){
             *    let selectedButton = this.buttonG.selectedButtons;
             *}
             *```
             */
            get: function () {
                var _this = this;
                return this.buttons.filter(function (b, i) {
                    return _this.selectedIndexes.indexOf(i) !== -1;
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Selects a button by its index.
         *```typescript
         *@ViewChild("MyChild")
         *private buttonG: IgxButtonGroupComponent;
         *ngAfterViewInit(){
         *    this.buttonG.selectButton(2);
         *    this.cdr.detectChanges();
         *}
         *```
         * @memberOf {@link IgxButtonGroupComponent}
         */
        IgxButtonGroupComponent.prototype.selectButton = function (index) {
            var _this = this;
            if (index >= this.buttons.length || index < 0) {
                return;
            }
            var button = this.buttons[index];
            var buttonElement = button.nativeElement;
            this.selectedIndexes.push(index);
            button.selected = true;
            this._renderer.setAttribute(buttonElement, 'aria-pressed', 'true');
            this._renderer.addClass(buttonElement, 'igx-button-group__item--selected');
            this.onSelect.emit({ button: button, index: index });
            var indexInViewButtons = this.viewButtons.toArray().indexOf(button);
            if (indexInViewButtons !== -1) {
                this.values[indexInViewButtons].selected = true;
            }
            // deselect other buttons if multiSelection is not enabled
            if (!this.multiSelection && this.selectedIndexes.length > 1) {
                this.buttons.forEach(function (b, i) {
                    if (i !== index && _this.selectedIndexes.indexOf(i) !== -1) {
                        _this.deselectButton(i);
                    }
                });
            }
        };
        /**
         * Deselects a button by its index.
         * ```typescript
         *@ViewChild("MyChild")
         *private buttonG: IgxButtonGroupComponent;
         *ngAfterViewInit(){
         *    this.buttonG.deselectButton(2);
         *    this.cdr.detectChanges();
         *}
         * ```
         * @memberOf {@link IgxButtonGroupComponent}
         */
        IgxButtonGroupComponent.prototype.deselectButton = function (index) {
            if (index >= this.buttons.length || index < 0) {
                return;
            }
            var button = this.buttons[index];
            var buttonElement = button.nativeElement;
            this.selectedIndexes.splice(this.selectedIndexes.indexOf(index), 1);
            button.selected = false;
            this._renderer.setAttribute(buttonElement, 'aria-pressed', 'false');
            this._renderer.removeClass(buttonElement, 'igx-button-group__item--selected');
            this.onUnselect.emit({ button: button, index: index });
            var indexInViewButtons = this.viewButtons.toArray().indexOf(button);
            if (indexInViewButtons !== -1) {
                this.values[indexInViewButtons].selected = false;
            }
        };
        /**
         * @hidden
         */
        IgxButtonGroupComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.templateButtons.forEach(function (button) {
                if (!button.initialDensity) {
                    button.displayDensity = _this.displayDensity;
                }
            });
        };
        /**
         * @hidden
         */
        IgxButtonGroupComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            var initButtons = function () {
                // Cancel any existing buttonClick subscriptions
                _this.buttonClickNotifier$.next();
                _this.selectedIndexes.splice(0, _this.selectedIndexes.length);
                // initial configuration
                _this.buttons.forEach(function (button, index) {
                    var buttonElement = button.nativeElement;
                    if (_this.disabled) {
                        button.disabled = true;
                    }
                    if (button.selected) {
                        _this.selectButton(index);
                    }
                    button.buttonClick.pipe(operators.takeUntil(_this.buttonClickNotifier$)).subscribe(function (ev) { return _this._clickHandler(ev, index); });
                    _this._renderer.addClass(buttonElement, 'igx-button-group__item');
                });
            };
            this.viewButtons.changes.pipe(operators.takeUntil(this.queryListNotifier$)).subscribe(function () { return initButtons(); });
            this.templateButtons.changes.pipe(operators.takeUntil(this.queryListNotifier$)).subscribe(function () { return initButtons(); });
            initButtons();
            this._cdr.detectChanges();
        };
        /**
         * @hidden
         */
        IgxButtonGroupComponent.prototype.ngOnDestroy = function () {
            this.buttonClickNotifier$.next();
            this.buttonClickNotifier$.complete();
            this.queryListNotifier$.next();
            this.queryListNotifier$.complete();
        };
        /**
         *@hidden
         */
        IgxButtonGroupComponent.prototype._clickHandler = function (event, i) {
            if (this.selectedIndexes.indexOf(i) !== -1) {
                this.deselectButton(i);
            }
            else {
                this.selectButton(i);
            }
        };
        IgxButtonGroupComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.ViewChildren(IgxButtonDirective)
        ], IgxButtonGroupComponent.prototype, "viewButtons", void 0);
        __decorate([
            core.ContentChildren(IgxButtonDirective)
        ], IgxButtonGroupComponent.prototype, "templateButtons", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxButtonGroupComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('style.zIndex')
        ], IgxButtonGroupComponent.prototype, "zIndex", void 0);
        __decorate([
            core.Input()
        ], IgxButtonGroupComponent.prototype, "itemContentCssClass", null);
        __decorate([
            core.Input()
        ], IgxButtonGroupComponent.prototype, "multiSelection", void 0);
        __decorate([
            core.Input()
        ], IgxButtonGroupComponent.prototype, "values", void 0);
        __decorate([
            core.Input()
        ], IgxButtonGroupComponent.prototype, "disabled", null);
        __decorate([
            core.Input()
        ], IgxButtonGroupComponent.prototype, "alignment", null);
        __decorate([
            core.Output()
        ], IgxButtonGroupComponent.prototype, "onSelect", void 0);
        __decorate([
            core.Output()
        ], IgxButtonGroupComponent.prototype, "onUnselect", void 0);
        IgxButtonGroupComponent = __decorate([
            core.Component({
                selector: 'igx-buttongroup',
                template: "<div class=\"igx-button-group\" role=\"group\" [class.igx-button-group--vertical]=\"isVertical\">\n    <button *ngFor=\"let button of values; let i = 'index'\"\n        type=\"button\"\n        igxButton=\"flat\"\n        [displayDensity]=\"displayDensity\"\n        [selected]=\"button.selected\"\n        [attr.data-togglable]=\"button.togglable\"\n        [disabled]=\"disabled || button.disabled\"\n        [igxButtonColor]=\"button.color\"\n        [igxButtonBackground]=\"button.bgcolor\"\n        [igxLabel]=\"button.label\"\n        [igxRipple]=\"button.ripple\"\n    >\n        <span class=\"igx-button-group__item-content {{ itemContentCssClass }}\">\n            <igx-icon *ngIf=\"button.icon\" fontSet=\"material\">{{button.icon}}</igx-icon>\n            <span class=\"igx-button-group__button-text\" *ngIf=\"button.label\">{{button.label}}</span>\n        </span>\n    </button>\n    <ng-content></ng-content>\n</div>\n"
            }),
            __param(2, core.Optional()), __param(2, core.Inject(DisplayDensityToken))
        ], IgxButtonGroupComponent);
        return IgxButtonGroupComponent;
    }(DisplayDensityBase));
    /**
     * @hidden
     */
    var IgxButtonGroupModule = /** @class */ (function () {
        function IgxButtonGroupModule() {
        }
        IgxButtonGroupModule = __decorate([
            core.NgModule({
                declarations: [IgxButtonGroupComponent],
                exports: [IgxButtonGroupComponent],
                imports: [IgxButtonModule, common.CommonModule, IgxRippleModule, IgxIconModule]
            })
        ], IgxButtonGroupModule);
        return IgxButtonGroupModule;
    }());


    (function (DateRangeType) {
        DateRangeType[DateRangeType["After"] = 0] = "After";
        DateRangeType[DateRangeType["Before"] = 1] = "Before";
        DateRangeType[DateRangeType["Between"] = 2] = "Between";
        DateRangeType[DateRangeType["Specific"] = 3] = "Specific";
        DateRangeType[DateRangeType["Weekdays"] = 4] = "Weekdays";
        DateRangeType[DateRangeType["Weekends"] = 5] = "Weekends";
    })(exports.DateRangeType || (exports.DateRangeType = {}));

    /**
     * @hidden
     */
    var TimeDeltaInterval;
    (function (TimeDeltaInterval) {
        TimeDeltaInterval["Month"] = "month";
        TimeDeltaInterval["Year"] = "year";
    })(TimeDeltaInterval || (TimeDeltaInterval = {}));
    var MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var FEBRUARY = 1;
    function range(start, stop, step) {
        if (start === void 0) { start = 0; }
        if (step === void 0) { step = 1; }
        var res = [];
        var cur = (stop === undefined) ? 0 : start;
        var max = (stop === undefined) ? start : stop;
        for (var i = cur; step < 0 ? i > max : i < max; i += step) {
            res.push(i);
        }
        return res;
    }
    /**
     * Returns true for leap years, false for non-leap years.
     *
     * @export
     * @param year
     * @returns
     */
    function isLeap(year) {
        return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
    }
    function weekDay(year, month, day) {
        return new Date(year, month, day).getDay();
    }
    /**
     * Return weekday and number of days for year, month.
     *
     * @export
     * @param year
     * @param month
     * @returns
     */
    function monthRange(year, month) {
        if ((month < 0) || (month > 11)) {
            throw new Error('Invalid month specified');
        }
        var day = weekDay(year, month, 1);
        var nDays = MDAYS[month];
        if ((month === FEBRUARY) && (isLeap(year))) {
            nDays++;
        }
        return [day, nDays];
    }
    function isDateInRanges(date, ranges) {
        var e_1, _a, e_2, _b;
        date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        var dateInMs = date.getTime();
        if (!ranges) {
            return false;
        }
        try {
            for (var ranges_1 = __values(ranges), ranges_1_1 = ranges_1.next(); !ranges_1_1.done; ranges_1_1 = ranges_1.next()) {
                var descriptor = ranges_1_1.value;
                var dRanges = descriptor.dateRange ? descriptor.dateRange.map(function (r) { return new Date(r.getFullYear(), r.getMonth(), r.getDate()); }) : undefined;
                switch (descriptor.type) {
                    case (exports.DateRangeType.After):
                        if (dateInMs > dRanges[0].getTime()) {
                            return true;
                        }
                        break;
                    case (exports.DateRangeType.Before):
                        if (dateInMs < dRanges[0].getTime()) {
                            return true;
                        }
                        break;
                    case (exports.DateRangeType.Between):
                        var dRange = dRanges.map(function (d) { return d.getTime(); });
                        var min = Math.min(dRange[0], dRange[1]);
                        var max = Math.max(dRange[0], dRange[1]);
                        if (dateInMs >= min && dateInMs <= max) {
                            return true;
                        }
                        break;
                    case (exports.DateRangeType.Specific):
                        var datesInMs = dRanges.map(function (d) { return d.getTime(); });
                        try {
                            for (var datesInMs_1 = (e_2 = void 0, __values(datesInMs)), datesInMs_1_1 = datesInMs_1.next(); !datesInMs_1_1.done; datesInMs_1_1 = datesInMs_1.next()) {
                                var specificDateInMs = datesInMs_1_1.value;
                                if (dateInMs === specificDateInMs) {
                                    return true;
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (datesInMs_1_1 && !datesInMs_1_1.done && (_b = datesInMs_1.return)) _b.call(datesInMs_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        break;
                    case (exports.DateRangeType.Weekdays):
                        var day = date.getDay();
                        if (day % 6 !== 0) {
                            return true;
                        }
                        break;
                    case (exports.DateRangeType.Weekends):
                        var weekday = date.getDay();
                        if (weekday % 6 === 0) {
                            return true;
                        }
                        break;
                    default:
                        return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ranges_1_1 && !ranges_1_1.done && (_a = ranges_1.return)) _a.call(ranges_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    }

    (function (WEEKDAYS) {
        WEEKDAYS[WEEKDAYS["SUNDAY"] = 0] = "SUNDAY";
        WEEKDAYS[WEEKDAYS["MONDAY"] = 1] = "MONDAY";
        WEEKDAYS[WEEKDAYS["TUESDAY"] = 2] = "TUESDAY";
        WEEKDAYS[WEEKDAYS["WEDNESDAY"] = 3] = "WEDNESDAY";
        WEEKDAYS[WEEKDAYS["THURSDAY"] = 4] = "THURSDAY";
        WEEKDAYS[WEEKDAYS["FRIDAY"] = 5] = "FRIDAY";
        WEEKDAYS[WEEKDAYS["SATURDAY"] = 6] = "SATURDAY";
    })(exports.WEEKDAYS || (exports.WEEKDAYS = {}));
    var Calendar = /** @class */ (function () {
        function Calendar(firstWeekDay) {
            if (firstWeekDay === void 0) { firstWeekDay = exports.WEEKDAYS.SUNDAY; }
            this._firstWeekDay = firstWeekDay;
        }
        Object.defineProperty(Calendar.prototype, "firstWeekDay", {
            get: function () {
                return this._firstWeekDay % 7;
            },
            set: function (value) {
                this._firstWeekDay = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns an array of weekdays for one week starting
         * with the currently set `firstWeekDay`
         *
         * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
         * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
         *
         * @returns
         *
         * @memberof Calendar
         */
        Calendar.prototype.weekdays = function () {
            var e_3, _a;
            var res = [];
            try {
                for (var _b = __values(range(this.firstWeekDay, this.firstWeekDay + 7)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var i = _c.value;
                    res.push(i % 7);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return res;
        };
        /**
         * Returns the date values for one month. It will always iterate throught
         * complete weeks, so it will contain dates outside the specified month.
         *
         * @param year
         * @param month
         * @param boolean
         * @returns
         *
         * @memberof Calendar
         */
        Calendar.prototype.monthdates = function (year, month, extraWeek) {
            var e_4, _a;
            if (extraWeek === void 0) { extraWeek = false; }
            var date = new Date(year, month, 1);
            var days = (date.getDay() - this.firstWeekDay) % 7;
            if (days < 0) {
                days = 7 - Math.abs(days);
            }
            date = this.timedelta(date, 'day', -days);
            var res = [];
            var value;
            while (true) {
                value = this.generateICalendarDate(date, year, month);
                res.push(value);
                date = this.timedelta(date, 'day', 1);
                if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                    if (extraWeek && res.length <= 35) {
                        try {
                            for (var _b = (e_4 = void 0, __values(range(0, 7))), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var _ = _c.value;
                                value = this.generateICalendarDate(date, year, month);
                                res.push(value);
                                date = this.timedelta(date, 'day', 1);
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                    }
                    break;
                }
            }
            return res;
        };
        /**
         * Returns a matrix (array of arrays) representing a month's calendar.
         * Each row represents a full week; week entries are ICalendarDate objects.
         *
         * @param year
         * @param month
         * @returns
         *
         * @memberof Calendar
         */
        Calendar.prototype.monthdatescalendar = function (year, month, extraWeek) {
            var e_5, _a;
            if (extraWeek === void 0) { extraWeek = false; }
            var dates = this.monthdates(year, month, extraWeek);
            var res = [];
            try {
                for (var _b = __values(range(0, dates.length, 7)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var i = _c.value;
                    res.push(dates.slice(i, i + 7));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
            }
            return res;
        };
        Calendar.prototype.timedelta = function (date, interval, units) {
            var ret = new Date(date);
            var checkRollover = function () {
                if (ret.getDate() !== date.getDate()) {
                    ret.setDate(0);
                }
            };
            switch (interval.toLowerCase()) {
                case 'year':
                    ret.setFullYear(ret.getFullYear() + units);
                    checkRollover();
                    break;
                case 'quarter':
                    ret.setMonth(ret.getMonth() + 3 * units);
                    checkRollover();
                    break;
                case 'month':
                    ret.setMonth(ret.getMonth() + units);
                    checkRollover();
                    break;
                case 'week':
                    ret.setDate(ret.getDate() + 7 * units);
                    break;
                case 'day':
                    ret.setDate(ret.getDate() + units);
                    break;
                case 'hour':
                    ret.setTime(ret.getTime() + units * 3600000);
                    break;
                case 'minute':
                    ret.setTime(ret.getTime() + units * 60000);
                    break;
                case 'second':
                    ret.setTime(ret.getTime() + units * 1000);
                    break;
                default:
                    throw new Error('Invalid interval specifier');
            }
            return ret;
        };
        Calendar.prototype.formatToParts = function (date, locale, options, parts) {
            var e_6, _a, e_7, _b;
            var formatter = new Intl.DateTimeFormat(locale, options);
            var result = {
                date: date,
                full: formatter.format(date)
            };
            if (formatter.formatToParts) {
                var formattedParts_1 = formatter.formatToParts(date);
                var toType = function (partType) {
                    var index = formattedParts_1.findIndex(function (_a) {
                        var type = _a.type;
                        return type === partType;
                    });
                    var o = { value: '', literal: '', combined: '' };
                    if (partType === 'era' && index > -1) {
                        o.value = formattedParts_1[index].value;
                        return o;
                    }
                    else if (partType === 'era' && index === -1) {
                        return o;
                    }
                    o.value = formattedParts_1[index].value;
                    o.literal = formattedParts_1[index + 1] ? formattedParts_1[index + 1].value : '';
                    o.combined = [o.value, o.literal].join('');
                    return o;
                };
                try {
                    for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
                        var each = parts_1_1.value;
                        result[each] = toType(each);
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
            else {
                try {
                    for (var parts_2 = __values(parts), parts_2_1 = parts_2.next(); !parts_2_1.done; parts_2_1 = parts_2.next()) {
                        var each = parts_2_1.value;
                        result[each] = { value: '', literal: '', combined: '' };
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (parts_2_1 && !parts_2_1.done && (_b = parts_2.return)) _b.call(parts_2);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
            }
            return result;
        };
        Calendar.prototype.getFirstViewDate = function (date, interval, activeViewIdx) {
            return this.timedelta(date, interval, -activeViewIdx);
        };
        Calendar.prototype.getNextMonth = function (date) {
            return this.timedelta(date, TimeDeltaInterval.Month, 1);
        };
        Calendar.prototype.getPrevMonth = function (date) {
            return this.timedelta(date, TimeDeltaInterval.Month, -1);
        };
        Calendar.prototype.getNextYear = function (date) {
            return this.timedelta(date, TimeDeltaInterval.Year, 1);
        };
        Calendar.prototype.getPrevYear = function (date) {
            return this.timedelta(date, TimeDeltaInterval.Year, -1);
        };
        Calendar.prototype.generateICalendarDate = function (date, year, month) {
            return {
                date: date,
                isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
                isNextMonth: this.isNextMonth(date, year, month),
                isPrevMonth: this.isPreviousMonth(date, year, month)
            };
        };
        Calendar.prototype.isPreviousMonth = function (date, year, month) {
            if (date.getFullYear() === year) {
                return date.getMonth() < month;
            }
            return date.getFullYear() < year;
        };
        Calendar.prototype.isNextMonth = function (date, year, month) {
            if (date.getFullYear() === year) {
                return date.getMonth() > month;
            }
            return date.getFullYear() > year;
        };
        return Calendar;
    }());

    /**
     * @hidden
     */
    var IgxCalendarYearDirective = /** @class */ (function () {
        function IgxCalendarYearDirective() {
            this.onYearSelection = new core.EventEmitter();
        }
        Object.defineProperty(IgxCalendarYearDirective.prototype, "defaultCSS", {
            get: function () {
                return !this.isCurrentYear;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarYearDirective.prototype, "currentCSS", {
            get: function () {
                return this.isCurrentYear;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarYearDirective.prototype, "isCurrentYear", {
            get: function () {
                return this.date.getFullYear() === this.value.getFullYear();
            },
            enumerable: true,
            configurable: true
        });
        IgxCalendarYearDirective.prototype.onClick = function () {
            this.onYearSelection.emit(this.value);
        };
        __decorate([
            core.Input('igxCalendarYear')
        ], IgxCalendarYearDirective.prototype, "value", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarYearDirective.prototype, "date", void 0);
        __decorate([
            core.Output()
        ], IgxCalendarYearDirective.prototype, "onYearSelection", void 0);
        __decorate([
            core.HostBinding('class.igx-calendar__year')
        ], IgxCalendarYearDirective.prototype, "defaultCSS", null);
        __decorate([
            core.HostBinding('class.igx-calendar__year--current')
        ], IgxCalendarYearDirective.prototype, "currentCSS", null);
        __decorate([
            core.HostListener('click')
        ], IgxCalendarYearDirective.prototype, "onClick", null);
        IgxCalendarYearDirective = __decorate([
            core.Directive({
                selector: '[igxCalendarYear]'
            })
        ], IgxCalendarYearDirective);
        return IgxCalendarYearDirective;
    }());
    var IgxCalendarMonthDirective = /** @class */ (function () {
        function IgxCalendarMonthDirective(elementRef) {
            this.elementRef = elementRef;
            this.onMonthSelection = new core.EventEmitter();
            this.tabindex = 0;
        }
        Object.defineProperty(IgxCalendarMonthDirective.prototype, "defaultCSS", {
            get: function () {
                return !this.isCurrentMonth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarMonthDirective.prototype, "currentCSS", {
            get: function () {
                return this.isCurrentMonth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarMonthDirective.prototype, "isCurrentMonth", {
            get: function () {
                return this.date.getMonth() === this.value.getMonth();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarMonthDirective.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        IgxCalendarMonthDirective.prototype.onClick = function () {
            var date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());
            this.onMonthSelection.emit(date);
        };
        IgxCalendarMonthDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input('igxCalendarMonth')
        ], IgxCalendarMonthDirective.prototype, "value", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarMonthDirective.prototype, "date", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarMonthDirective.prototype, "index", void 0);
        __decorate([
            core.Output()
        ], IgxCalendarMonthDirective.prototype, "onMonthSelection", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxCalendarMonthDirective.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('class.igx-calendar__month')
        ], IgxCalendarMonthDirective.prototype, "defaultCSS", null);
        __decorate([
            core.HostBinding('class.igx-calendar__month--current')
        ], IgxCalendarMonthDirective.prototype, "currentCSS", null);
        __decorate([
            core.HostListener('click')
        ], IgxCalendarMonthDirective.prototype, "onClick", null);
        IgxCalendarMonthDirective = __decorate([
            core.Directive({
                selector: '[igxCalendarMonth]'
            })
        ], IgxCalendarMonthDirective);
        return IgxCalendarMonthDirective;
    }());
    /**
     * @hidden
     */
    var IgxCalendarHeaderTemplateDirective = /** @class */ (function () {
        function IgxCalendarHeaderTemplateDirective(template) {
            this.template = template;
        }
        IgxCalendarHeaderTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxCalendarHeaderTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxCalendarHeader]'
            })
        ], IgxCalendarHeaderTemplateDirective);
        return IgxCalendarHeaderTemplateDirective;
    }());
    /**
     * @hidden
     */
    var IgxCalendarSubheaderTemplateDirective = /** @class */ (function () {
        function IgxCalendarSubheaderTemplateDirective(template) {
            this.template = template;
        }
        IgxCalendarSubheaderTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxCalendarSubheaderTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxCalendarSubheader]'
            })
        ], IgxCalendarSubheaderTemplateDirective);
        return IgxCalendarSubheaderTemplateDirective;
    }());
    /**
     * @hidden
     */
    var IgxCalendarScrollMonthDirective = /** @class */ (function () {
        function IgxCalendarScrollMonthDirective(element, zone) {
            this.element = element;
            this.zone = zone;
            /**
             * @hidden
             */
            this.destroy$ = new rxjs.Subject();
        }
        /**
         * @hidden
         */
        IgxCalendarScrollMonthDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            rxjs.fromEvent(this.element.nativeElement, 'keyup').pipe(operators.debounce(function () { return rxjs.interval(100); }), operators.takeUntil(this.destroy$)).subscribe(function (event) {
                _this.stopScroll(event);
            });
            this.zone.runOutsideAngular(function () {
                rxjs.fromEvent(_this.element.nativeElement, 'keydown').pipe(operators.tap(function (event) {
                    if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                }), operators.debounce(function () { return rxjs.interval(100); }), operators.takeUntil(_this.destroy$)).subscribe(function (event) {
                    if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                        _this.zone.run(function () { return _this.startScroll(true); });
                    }
                });
            });
        };
        /**
         * @hidden
         */
        IgxCalendarScrollMonthDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         */
        IgxCalendarScrollMonthDirective.prototype.onMouseDown = function () {
            this.startScroll();
        };
        /**
         * @hidden
         */
        IgxCalendarScrollMonthDirective.prototype.onMouseUp = function (event) {
            this.stopScroll(event);
        };
        IgxCalendarScrollMonthDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.Input()
        ], IgxCalendarScrollMonthDirective.prototype, "startScroll", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarScrollMonthDirective.prototype, "stopScroll", void 0);
        __decorate([
            core.HostListener('mousedown')
        ], IgxCalendarScrollMonthDirective.prototype, "onMouseDown", null);
        __decorate([
            core.HostListener('mouseup', ['$event'])
        ], IgxCalendarScrollMonthDirective.prototype, "onMouseUp", null);
        IgxCalendarScrollMonthDirective = __decorate([
            core.Directive({
                selector: '[igxCalendarScrollMonth]'
            })
        ], IgxCalendarScrollMonthDirective);
        return IgxCalendarScrollMonthDirective;
    }());

    /**
     * Sets the selction type - single, multi or range.
     */
    var CalendarSelection;
    (function (CalendarSelection) {
        CalendarSelection["SINGLE"] = "single";
        CalendarSelection["MULTI"] = "multi";
        CalendarSelection["RANGE"] = "range";
    })(CalendarSelection || (CalendarSelection = {}));
    var ScrollMonth;
    (function (ScrollMonth) {
        ScrollMonth["PREV"] = "prev";
        ScrollMonth["NEXT"] = "next";
        ScrollMonth["NONE"] = "none";
    })(ScrollMonth || (ScrollMonth = {}));
    /** @hidden @internal */
    var IgxCalendarBaseDirective = /** @class */ (function () {
        /**
         * @hidden
         */
        function IgxCalendarBaseDirective() {
            /**
             * Sets/gets whether the outside dates (dates that are out of the current month) will be hidden.
             * Default value is `false`.
             * ```html
             * <igx-calendar [hideOutsideDays] = "true"></igx-calendar>
             * ```
             * ```typescript
             * let hideOutsideDays = this.calendar.hideOutsideDays;
             * ```
             */
            this.hideOutsideDays = false;
            /**
             * Emits an event when a date is selected.
             * Provides reference the `selectedDates` property.
             */
            this.onSelection = new core.EventEmitter();
            /**
             *@hidden
             */
            this._selection = CalendarSelection.SINGLE;
            /**
             *@hidden
             */
            this.rangeStarted = false;
            /**
            *@hidden
            */
            this._locale = 'en';
            /**
             *@hidden
             */
            this._disabledDates = null;
            /**
             *@hidden
             */
            this._specialDates = null;
            /**
             *@hidden
             */
            this._formatOptions = {
                day: 'numeric',
                month: 'short',
                weekday: 'short',
                year: 'numeric'
            };
            /**
             *@hidden
             */
            this._formatViews = {
                day: false,
                month: true,
                year: false
            };
            /**
             * @hidden
             */
            this.monthScrollDirection = ScrollMonth.NONE;
            /**
             *@hidden
             */
            this.scrollMonth$ = new rxjs.Subject();
            /**
             *@hidden
             */
            this.stopMonthScroll$ = new rxjs.Subject();
            /**
             *@hidden
             */
            this.startMonthScroll$ = new rxjs.Subject();
            /**
             *@hidden
             */
            this._onTouchedCallback = function () { };
            /**
             *@hidden
             */
            this._onChangeCallback = function () { };
            this.calendarModel = new Calendar();
            this.viewDate = this.viewDate ? this.viewDate : new Date();
            this.calendarModel.firstWeekDay = this.weekStart;
            this.initFormatters();
        }
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "weekStart", {
            /**
             * Gets the start day of the week.
             * Can return a numeric or an enum representation of the week day.
             * Defaults to `Sunday` / `0`.
             */
            get: function () {
                return this.calendarModel.firstWeekDay;
            },
            /**
             * Sets the start day of the week.
             * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
             */
            set: function (value) {
                this.calendarModel.firstWeekDay = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "locale", {
            /**
             * Gets the `locale` of the calendar.
             * Default value is `"en"`.
             */
            get: function () {
                return this._locale;
            },
            /**
             * Sets the `locale` of the calendar.
             * Expects a valid BCP 47 language tag.
             * Default value is `"en"`.
             */
            set: function (value) {
                this._locale = value;
                this.initFormatters();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "formatOptions", {
            /**
             * Gets the date format options of the days view.
             */
            get: function () {
                return this._formatOptions;
            },
            /**
             * Sets the date format options of the days view.
             * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }
             */
            set: function (formatOptions) {
                this._formatOptions = Object.assign(this._formatOptions, formatOptions);
                this.initFormatters();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "formatViews", {
            /**
             * Gets whether the `day`, `month` and `year` should be rendered
             * according to the locale and formatOptions, if any.
             */
            get: function () {
                return this._formatViews;
            },
            /**
             * Gets whether the `day`, `month` and `year` should be rendered
             * according to the locale and formatOptions, if any.
             */
            set: function (formatViews) {
                this._formatViews = Object.assign(this._formatViews, formatViews);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "selection", {
            /**
             *
             * Gets the selection type.
             * Default value is `"single"`.
             * Changing the type of selection resets the currently
             * selected values if any.
             */
            get: function () {
                return this._selection;
            },
            /**
             * Sets the selection.
             */
            set: function (value) {
                switch (value) {
                    case CalendarSelection.SINGLE:
                        this.selectedDates = null;
                        break;
                    case CalendarSelection.MULTI:
                    case CalendarSelection.RANGE:
                        this.selectedDates = [];
                        break;
                    default:
                        throw new Error('Invalid selection value');
                }
                this._onChangeCallback(this.selectedDates);
                this.rangeStarted = false;
                this._selection = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "value", {
            /**
             * Gets the selected date(s).
             *
             * When selection is set to `single`, it returns
             * a single `Date` object.
             * Otherwise it is an array of `Date` objects.
             */
            get: function () {
                return this.selectedDates;
            },
            /**
             * Sets the selected date(s).
             *
             * When selection is set to `single`, it accepts
             * a single `Date` object.
             * Otherwise it is an array of `Date` objects.
             */
            set: function (value) {
                if (!value || !!value && value.length === 0) {
                    return;
                }
                this.selectDate(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "viewDate", {
            /**
             * Gets the date that is presented.
             * By default it is the current date.
             */
            get: function () {
                return this._viewDate;
            },
            /**
             * Sets the date that will be presented in the default view when the component renders.
             */
            set: function (value) {
                this._viewDate = this.getDateOnly(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "disabledDates", {
            /**
             * Gets the disabled dates descriptors.
             */
            get: function () {
                return this._disabledDates;
            },
            /**
             * Sets the disabled dates' descriptors.
             * ```typescript
             *@ViewChild("MyCalendar")
             *public calendar: IgxCalendarComponent;
             *ngOnInit(){
             *    this.calendar.disabledDates = [
             *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
             *     {type: DateRangeType.Weekends}];
             *}
             *```
             */
            set: function (value) {
                this._disabledDates = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarBaseDirective.prototype, "specialDates", {
            /**
             * Gets the special dates descriptors.
             */
            get: function () {
                return this._specialDates;
            },
            /**
             * Sets the special dates' descriptors.
             * ```typescript
             *@ViewChild("MyCalendar")
             *public calendar: IgxCalendarComponent;
             *ngOnInit(){
             *    this.calendar.specialDates = [
             *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
             *     {type: DateRangeType.Weekends}];
             *}
             *```
             */
            set: function (value) {
                this._specialDates = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxCalendarBaseDirective.prototype.getDateOnlyInMs = function (date) {
            return this.getDateOnly(date).getTime();
        };
        /**
         *@hidden
         */
        IgxCalendarBaseDirective.prototype.generateDateRange = function (start, end) {
            var result = [];
            start = this.getDateOnly(start);
            end = this.getDateOnly(end);
            while (start.getTime() !== end.getTime()) {
                start = this.calendarModel.timedelta(start, 'day', 1);
                result.push(start);
            }
            return result;
        };
        /**
         * Performs a single selection.
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.selectSingle = function (value) {
            this.selectedDates = this.getDateOnly(value);
            this._onChangeCallback(this.selectedDates);
        };
        /**
         * Performs a multiple selection
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.selectMultiple = function (value) {
            var _this = this;
            if (Array.isArray(value)) {
                var newDates = value.map(function (v) { return _this.getDateOnly(v).getTime(); });
                var selDates = this.selectedDates.map(function (v) { return _this.getDateOnly(v).getTime(); });
                if (JSON.stringify(newDates) === JSON.stringify(selDates)) {
                    return;
                }
                this.selectedDates = Array.from(new Set(__spread(newDates, selDates))).map(function (v) { return new Date(v); });
            }
            else {
                var valueDateOnly_1 = this.getDateOnly(value);
                var newSelection = [];
                if (this.selectedDates.every(function (date) { return date.getTime() !== valueDateOnly_1.getTime(); })) {
                    newSelection.push(valueDateOnly_1);
                }
                else {
                    this.selectedDates = this.selectedDates.filter(function (date) { return date.getTime() !== valueDateOnly_1.getTime(); });
                }
                if (newSelection.length > 0) {
                    this.selectedDates = this.selectedDates.concat(newSelection);
                }
            }
            this.selectedDates = this.selectedDates.filter(function (d) { return !_this.isDateDisabled(d); });
            this.selectedDates.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
            this._onChangeCallback(this.selectedDates);
        };
        /**
         *@hidden
         */
        IgxCalendarBaseDirective.prototype.selectRange = function (value, excludeDisabledDates) {
            var _this = this;
            if (excludeDisabledDates === void 0) { excludeDisabledDates = false; }
            var start;
            var end;
            if (Array.isArray(value)) {
                // this.rangeStarted = false;
                value.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
                start = this.getDateOnly(value[0]);
                end = this.getDateOnly(value[value.length - 1]);
                this.selectedDates = __spread([start], this.generateDateRange(start, end));
            }
            else {
                if (!this.rangeStarted) {
                    this.rangeStarted = true;
                    this.selectedDates = [value];
                }
                else {
                    this.rangeStarted = false;
                    if (this.selectedDates[0].getTime() === value.getTime()) {
                        this.selectedDates = [];
                        this._onChangeCallback(this.selectedDates);
                        return;
                    }
                    this.selectedDates.push(value);
                    this.selectedDates.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
                    start = this.selectedDates.shift();
                    end = this.selectedDates.pop();
                    this.selectedDates = __spread([start], this.generateDateRange(start, end));
                }
            }
            if (excludeDisabledDates) {
                this.selectedDates = this.selectedDates.filter(function (d) { return !_this.isDateDisabled(d); });
            }
            this._onChangeCallback(this.selectedDates);
        };
        /**
         * Performs a single deselection.
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.deselectSingle = function (value) {
            if (this.selectedDates !== null &&
                this.getDateOnlyInMs(value) === this.getDateOnlyInMs(this.selectedDates)) {
                this.selectedDates = null;
                this._onChangeCallback(this.selectedDates);
            }
        };
        /**
         * Performs a multiple deselection.
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.deselectMultiple = function (value) {
            var _this = this;
            value = value.filter(function (v) { return v !== null; });
            var selectedDatesCount = this.selectedDates.length;
            var datesInMsToDeselect = new Set(value.map(function (v) { return _this.getDateOnlyInMs(v); }));
            for (var i = this.selectedDates.length - 1; i >= 0; i--) {
                if (datesInMsToDeselect.has(this.getDateOnlyInMs(this.selectedDates[i]))) {
                    this.selectedDates.splice(i, 1);
                }
            }
            if (this.selectedDates.length !== selectedDatesCount) {
                this._onChangeCallback(this.selectedDates);
            }
        };
        /**
         * Performs deselection of a single value, when selection is multi
         * Usually performed by the selectMultiple method, but leads to bug when multiple months are in view
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.deselectMultipleInMonth = function (value) {
            var valueDateOnly = this.getDateOnly(value);
            this.selectedDates = this.selectedDates.filter(function (date) { return date.getTime() !== valueDateOnly.getTime(); });
        };
        /**
         * Performs a range deselection.
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.deselectRange = function (value) {
            value = value.filter(function (v) { return v !== null; });
            if (value.length < 1) {
                return;
            }
            value.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
            var valueStart = this.getDateOnlyInMs(value[0]);
            var valueEnd = this.getDateOnlyInMs(value[value.length - 1]);
            this.selectedDates.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
            var selectedDatesStart = this.getDateOnlyInMs(this.selectedDates[0]);
            var selectedDatesEnd = this.getDateOnlyInMs(this.selectedDates[this.selectedDates.length - 1]);
            if (!(valueEnd < selectedDatesStart) && !(valueStart > selectedDatesEnd)) {
                this.selectedDates = [];
                this.rangeStarted = false;
                this._onChangeCallback(this.selectedDates);
            }
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.initFormatters = function () {
            this.formatterDay = new Intl.DateTimeFormat(this._locale, { day: this._formatOptions.day });
            this.formatterWeekday = new Intl.DateTimeFormat(this._locale, { weekday: this._formatOptions.weekday });
            this.formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month });
            this.formatterYear = new Intl.DateTimeFormat(this._locale, { year: this._formatOptions.year });
            this.formatterMonthday = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month, day: this._formatOptions.day });
        };
        /**
         *@hidden
         */
        IgxCalendarBaseDirective.prototype.getDateOnly = function (date) {
            return new Date(date.getFullYear(), date.getMonth(), date.getDate());
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.writeValue = function (value) {
            this.selectDate(value);
        };
        /**
         * Checks whether a date is disabled.
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.isDateDisabled = function (date) {
            if (this.disabledDates === null) {
                return false;
            }
            return isDateInRanges(date, this.disabledDates);
        };
        /**
         * Selects date(s) (based on the selection type).
         */
        IgxCalendarBaseDirective.prototype.selectDate = function (value) {
            if (value === null || value === undefined || (Array.isArray(value) && value.length === 0)) {
                return;
            }
            switch (this.selection) {
                case CalendarSelection.SINGLE:
                    if (isDate(value) && !this.isDateDisabled(value)) {
                        this.selectSingle(value);
                    }
                    break;
                case CalendarSelection.MULTI:
                    this.selectMultiple(value);
                    break;
                case CalendarSelection.RANGE:
                    this.selectRange(value, true);
                    break;
            }
        };
        /**
         * Deselects date(s) (based on the selection type).
         */
        IgxCalendarBaseDirective.prototype.deselectDate = function (value) {
            if (!this.selectedDates || this.selectedDates.length === 0) {
                return;
            }
            if (value === null || value === undefined) {
                this.selectedDates = this.selection === CalendarSelection.SINGLE ? null : [];
                this.rangeStarted = false;
                this._onChangeCallback(this.selectedDates);
                return;
            }
            switch (this.selection) {
                case CalendarSelection.SINGLE:
                    this.deselectSingle(value);
                    break;
                case CalendarSelection.MULTI:
                    this.deselectMultiple(value);
                    break;
                case CalendarSelection.RANGE:
                    this.deselectRange(value);
                    break;
            }
        };
        /**
         * @hidden
         */
        IgxCalendarBaseDirective.prototype.selectDateFromClient = function (value) {
            switch (this.selection) {
                case CalendarSelection.SINGLE:
                case CalendarSelection.MULTI:
                    this.selectDate(value);
                    break;
                case CalendarSelection.RANGE:
                    this.selectRange(value, true);
                    break;
            }
        };
        __decorate([
            core.Input()
        ], IgxCalendarBaseDirective.prototype, "weekStart", null);
        __decorate([
            core.Input()
        ], IgxCalendarBaseDirective.prototype, "locale", null);
        __decorate([
            core.Input()
        ], IgxCalendarBaseDirective.prototype, "formatOptions", null);
        __decorate([
            core.Input()
        ], IgxCalendarBaseDirective.prototype, "formatViews", null);
        __decorate([
            core.Input()
        ], IgxCalendarBaseDirective.prototype, "selection", null);
        __decorate([
            core.Input()
        ], IgxCalendarBaseDirective.prototype, "value", null);
        __decorate([
            core.Input()
        ], IgxCalendarBaseDirective.prototype, "viewDate", null);
        __decorate([
            core.Input()
        ], IgxCalendarBaseDirective.prototype, "disabledDates", null);
        __decorate([
            core.Input()
        ], IgxCalendarBaseDirective.prototype, "specialDates", null);
        __decorate([
            core.Input()
        ], IgxCalendarBaseDirective.prototype, "hideOutsideDays", void 0);
        __decorate([
            core.Output()
        ], IgxCalendarBaseDirective.prototype, "onSelection", void 0);
        IgxCalendarBaseDirective = __decorate([
            core.Directive({
                selector: '[igxCalendarBase]'
            })
        ], IgxCalendarBaseDirective);
        return IgxCalendarBaseDirective;
    }());

    /**
     * Sets the calender view - days, months or years.
     */

    (function (CalendarView) {
        CalendarView[CalendarView["DEFAULT"] = 0] = "DEFAULT";
        CalendarView[CalendarView["YEAR"] = 1] = "YEAR";
        CalendarView[CalendarView["DECADE"] = 2] = "DECADE";
    })(exports.CalendarView || (exports.CalendarView = {}));
    var IgxMonthPickerBaseDirective = /** @class */ (function (_super) {
        __extends(IgxMonthPickerBaseDirective, _super);
        function IgxMonthPickerBaseDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Holds month view index we are operating on.
             */
            _this.activeViewIdx = 0;
            /**
             * The default `tabindex` attribute for the component.
             *
             * @hidden
             */
            _this.tabindex = 0;
            /**
             *@hidden
             */
            _this._activeView = exports.CalendarView.DEFAULT;
            return _this;
        }
        Object.defineProperty(IgxMonthPickerBaseDirective.prototype, "activeView", {
            /**
             * Gets the current active view.
             */
            get: function () {
                return this._activeView;
            },
            /**
             * Sets the current active view.
             */
            set: function (val) {
                this._activeView = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMonthPickerBaseDirective.prototype, "isDefaultView", {
            /**
             * @hidden
             */
            get: function () {
                return this._activeView === exports.CalendarView.DEFAULT;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMonthPickerBaseDirective.prototype, "isDecadeView", {
            /**
             * @hidden
             */
            get: function () {
                return this._activeView === exports.CalendarView.DECADE;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxMonthPickerBaseDirective.prototype.changeYear = function (event) {
            var _this = this;
            this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
            this.activeView = exports.CalendarView.DEFAULT;
            requestAnimationFrame(function () {
                if (_this.yearsBtns && _this.yearsBtns.length) {
                    _this.yearsBtns.find(function (e, idx) { return idx === _this.activeViewIdx; }).nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         */
        IgxMonthPickerBaseDirective.prototype.activeViewDecade = function (activeViewIdx) {
            if (activeViewIdx === void 0) { activeViewIdx = 0; }
            this._activeView = exports.CalendarView.DECADE;
            this.activeViewIdx = activeViewIdx;
        };
        /**
         * @hidden
         */
        IgxMonthPickerBaseDirective.prototype.activeViewDecadeKB = function (event, activeViewIdx) {
            if (activeViewIdx === void 0) { activeViewIdx = 0; }
            if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                event.preventDefault();
                this.activeViewDecade(activeViewIdx);
            }
        };
        /**
         * Returns the locale representation of the year in the year view if enabled,
         * otherwise returns the default `Date.getFullYear()` value.
         *
         * @hidden
         */
        IgxMonthPickerBaseDirective.prototype.formattedYear = function (value) {
            if (this.formatViews.year) {
                return this.formatterYear.format(value);
            }
            return "" + value.getFullYear();
        };
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxMonthPickerBaseDirective.prototype, "tabindex", void 0);
        __decorate([
            core.ViewChildren('yearsBtn')
        ], IgxMonthPickerBaseDirective.prototype, "yearsBtns", void 0);
        IgxMonthPickerBaseDirective = __decorate([
            core.Directive({
                selector: '[igxMonthPickerBase]'
            })
        ], IgxMonthPickerBaseDirective);
        return IgxMonthPickerBaseDirective;
    }(IgxCalendarBaseDirective));

    var NEXT_ID$c = 0;
    var IgxMonthsViewComponent = /** @class */ (function () {
        function IgxMonthsViewComponent(el) {
            this.el = el;
            /**
             * Sets/gets the `id` of the months view.
             * If not set, the `id` will have value `"igx-months-view-0"`.
             * ```html
             * <igx-months-view id="my-months-view"></igx-months-view>
             * ```
             * ```typescript
             * let monthsViewId =  this.monthsView.id;
             * ```
             * @memberof IgxMonthsViewComponent
             */
            this.id = "igx-months-view-" + NEXT_ID$c++;
            /**
             * Gets/sets the selected date of the months view.
             * By default it is the current date.
             * ```html
             * <igx-months-view [date]="myDate"></igx-months-view>
             * ```
             * ```typescript
             * let date =  this.monthsView.date;
             * ```
             * @memberof IgxMonthsViewComponent
             */
            this.date = new Date();
            /**
             * Gets/sets whether the view should be rendered
             * according to the locale and monthFormat, if any.
             */
            this.formatView = true;
            /**
             * Emits an event when a selection is made in the months view.
             * Provides reference the `date` property in the `IgxMonthsViewComponent`.
             * ```html
             * <igx-months-view (onSelection)="onSelection($event)"></igx-months-view>
             * ```
             * @memberof IgxMonthsViewComponent
             */
            this.onSelection = new core.EventEmitter();
            /**
             * The default css class applied to the component.
             *
             * @hidden
             */
            this.styleClass = true;
            /**
             * The default `tabindex` attribute for the component.
             *
             * @hidden
             */
            this.tabindex = 0;
            /**
             *@hidden
             */
            this._locale = 'en';
            /**
             *@hidden
             */
            this._monthFormat = 'short';
            /**
             *@hidden
             */
            this._onTouchedCallback = function () { };
            /**
             *@hidden
             */
            this._onChangeCallback = function () { };
            this.initMonthFormatter();
            this._calendarModel = new Calendar();
        }
        IgxMonthsViewComponent_1 = IgxMonthsViewComponent;
        Object.defineProperty(IgxMonthsViewComponent.prototype, "monthFormat", {
            /**
             * Gets the month format option of the months view.
             * ```typescript
             * let monthFormat = this.monthsView.monthFormat.
             * ```
             */
            get: function () {
                return this._monthFormat;
            },
            /**
             * Sets the month format option of the months view.
             * ```html
             * <igx-months-view> [monthFormat] = "short'"</igx-months-view>
             * ```
             * @memberof IgxMonthsViewComponent
             */
            set: function (value) {
                this._monthFormat = value;
                this.initMonthFormatter();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMonthsViewComponent.prototype, "locale", {
            /**
             * Gets the `locale` of the months view.
             * Default value is `"en"`.
             * ```typescript
             * let locale =  this.monthsView.locale;
             * ```
             * @memberof IgxMonthsViewComponent
             */
            get: function () {
                return this._locale;
            },
            /**
             * Sets the `locale` of the months view.
             * Expects a valid BCP 47 language tag.
             * Default value is `"en"`.
             * ```html
             * <igx-months-view [locale]="de"></igx-months-view>
             * ```
             * @memberof IgxMonthsViewComponent
             */
            set: function (value) {
                this._locale = value;
                this.initMonthFormatter();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMonthsViewComponent.prototype, "months", {
            /**
             * Returns an array of date objects which are then used to
             * properly render the month names.
             *
             * Used in the template of the component
             *
             * @hidden
             */
            get: function () {
                var start = new Date(this.date.getFullYear(), 0, 1);
                var result = [];
                for (var i = 0; i < 12; i++) {
                    result.push(start);
                    start = this._calendarModel.timedelta(start, 'month', 1);
                }
                return result;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the locale representation of the month in the months view.
         *
         * @hidden
         */
        IgxMonthsViewComponent.prototype.formattedMonth = function (value) {
            if (this.formatView) {
                return this._formatterMonth.format(value);
            }
            return "" + value.getMonth();
        };
        /**
         *@hidden
         */
        IgxMonthsViewComponent.prototype.selectMonth = function (event) {
            this.onSelection.emit(event);
            this.date = event;
            this._onChangeCallback(this.date);
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.writeValue = function (value) {
            if (value) {
                this.date = value;
            }
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.monthTracker = function (index, item) {
            return item.getMonth() + "}";
        };
        /**
         *@hidden
         */
        IgxMonthsViewComponent.prototype.initMonthFormatter = function () {
            this._formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this.monthFormat });
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownArrowUp = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var node = this.monthsRef.find(function (date) { return date.nativeElement === event.target; });
            if (!node) {
                return;
            }
            var months = this.monthsRef.toArray();
            var nodeRect = node.nativeElement.getBoundingClientRect();
            for (var index = months.indexOf(node) - 1; index >= 0; index--) {
                var nextNodeRect = months[index].nativeElement.getBoundingClientRect();
                var tolerance = 6;
                if (nodeRect.top !== nextNodeRect.top && (nextNodeRect.left - nodeRect.left) < tolerance) {
                    months[index].nativeElement.focus();
                    break;
                }
            }
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownArrowDown = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var node = this.monthsRef.find(function (date) { return date.nativeElement === event.target; });
            if (!node) {
                return;
            }
            var months = this.monthsRef.toArray();
            var nodeRect = node.nativeElement.getBoundingClientRect();
            for (var index = months.indexOf(node) + 1; index < months.length; index++) {
                var nextNodeRect = months[index].nativeElement.getBoundingClientRect();
                var tolerance = 6;
                if (nextNodeRect.top !== nodeRect.top && (nodeRect.left - nextNodeRect.left) < tolerance) {
                    months[index].nativeElement.focus();
                    break;
                }
            }
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownArrowRight = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var node = this.monthsRef.find(function (date) { return date.nativeElement === event.target; });
            if (!node) {
                return;
            }
            var months = this.monthsRef.toArray();
            if (months.indexOf(node) + 1 < months.length) {
                var month = months[months.indexOf(node) + 1];
                month.nativeElement.focus();
            }
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownArrowLeft = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var node = this.monthsRef.find(function (date) { return date.nativeElement === event.target; });
            if (!node) {
                return;
            }
            var months = this.monthsRef.toArray();
            if (months.indexOf(node) - 1 >= 0) {
                var month = months[months.indexOf(node) - 1];
                month.nativeElement.focus();
            }
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownHome = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var month = this.monthsRef.toArray()[0];
            month.nativeElement.focus();
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownEnd = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var months = this.monthsRef.toArray();
            var month = months[months.length - 1];
            month.nativeElement.focus();
        };
        /**
         * @hidden
         */
        IgxMonthsViewComponent.prototype.onKeydownEnter = function (event) {
            var value = this.monthsRef.find(function (date) { return date.nativeElement === event.target; }).value;
            this.date = new Date(value.getFullYear(), value.getMonth(), this.date.getDate());
            this.onSelection.emit(this.date);
            this._onChangeCallback(this.date);
        };
        var IgxMonthsViewComponent_1;
        IgxMonthsViewComponent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxMonthsViewComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxMonthsViewComponent.prototype, "date", void 0);
        __decorate([
            core.Input()
        ], IgxMonthsViewComponent.prototype, "monthFormat", null);
        __decorate([
            core.Input()
        ], IgxMonthsViewComponent.prototype, "locale", null);
        __decorate([
            core.Input()
        ], IgxMonthsViewComponent.prototype, "formatView", void 0);
        __decorate([
            core.Output()
        ], IgxMonthsViewComponent.prototype, "onSelection", void 0);
        __decorate([
            core.HostBinding('class.igx-calendar')
        ], IgxMonthsViewComponent.prototype, "styleClass", void 0);
        __decorate([
            core.ViewChildren(IgxCalendarMonthDirective, { read: IgxCalendarMonthDirective })
        ], IgxMonthsViewComponent.prototype, "monthsRef", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxMonthsViewComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostListener('keydown.arrowup', ['$event'])
        ], IgxMonthsViewComponent.prototype, "onKeydownArrowUp", null);
        __decorate([
            core.HostListener('keydown.arrowdown', ['$event'])
        ], IgxMonthsViewComponent.prototype, "onKeydownArrowDown", null);
        __decorate([
            core.HostListener('keydown.arrowright', ['$event'])
        ], IgxMonthsViewComponent.prototype, "onKeydownArrowRight", null);
        __decorate([
            core.HostListener('keydown.arrowleft', ['$event'])
        ], IgxMonthsViewComponent.prototype, "onKeydownArrowLeft", null);
        __decorate([
            core.HostListener('keydown.home', ['$event'])
        ], IgxMonthsViewComponent.prototype, "onKeydownHome", null);
        __decorate([
            core.HostListener('keydown.end', ['$event'])
        ], IgxMonthsViewComponent.prototype, "onKeydownEnd", null);
        __decorate([
            core.HostListener('keydown.enter', ['$event'])
        ], IgxMonthsViewComponent.prototype, "onKeydownEnter", null);
        IgxMonthsViewComponent = IgxMonthsViewComponent_1 = __decorate([
            core.Component({
                providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxMonthsViewComponent_1, multi: true }],
                selector: 'igx-months-view',
                template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-row--wrap\">\n        <div [igxCalendarMonth]=\"month\" [date]=\"date\" (onMonthSelection)=\"selectMonth($event)\" [index]=\"i\" *ngFor=\"let month of months; index as i; trackBy: monthTracker\">\n            {{ formattedMonth(month) | titlecase }}\n        </div>\n    </div>\n</div>\n\n"
            })
        ], IgxMonthsViewComponent);
        return IgxMonthsViewComponent;
    }());

    var NEXT_ID$d = 0;
    var CalendarHammerConfig = /** @class */ (function (_super) {
        __extends(CalendarHammerConfig, _super);
        function CalendarHammerConfig() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.overrides = {
                pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
            };
            return _this;
        }
        CalendarHammerConfig = __decorate([
            core.Injectable()
        ], CalendarHammerConfig);
        return CalendarHammerConfig;
    }(platformBrowser.HammerGestureConfig));
    var IgxYearsViewComponent = /** @class */ (function () {
        function IgxYearsViewComponent(el) {
            this.el = el;
            /**
             * Sets/gets the `id` of the years view.
             * If not set, the `id` will have value `"igx-years-view-0"`.
             * ```html
             * <igx-years-view id = "my-years-view"></igx-years-view>
             * ```
             * ```typescript
             * let yearsViewId =  this.yearsView.id;
             * ```
             * @memberof IgxCalendarComponent
             */
            this.id = "igx-years-view-" + NEXT_ID$d++;
            /**
             * Gets/sets the selected date of the years view.
             * By default it is the current date.
             * ```html
             * <igx-years-view [date]="myDate"></igx-years-view>
             * ```
             * ```typescript
             * let date =  this.yearsView.date;
             * ```
             * @memberof IgxYearsViewComponent
             */
            this.date = new Date();
            /**
             * Emits an event when a selection is made in the years view.
             * Provides reference the `date` property in the `IgxYearsViewComponent`.
             * ```html
             * <igx-years-view (onSelection)="onSelection($event)"></igx-years-view>
             * ```
             * @memberof IgxYearsViewComponent
             */
            this.onSelection = new core.EventEmitter();
            /**
             * The default css class applied to the component.
             *
             * @hidden
             */
            this.styleClass = true;
            /**
             * The default `tabindex` attribute for the component.
             *
             * @hidden
             */
            this.tabindex = 0;
            /**
             *@hidden
             */
            this._locale = 'en';
            /**
             *@hidden
             */
            this._yearFormat = 'numeric';
            /**
             *@hidden
             */
            this._onTouchedCallback = function () { };
            /**
             *@hidden
             */
            this._onChangeCallback = function () { };
            this.initYearFormatter();
            this._calendarModel = new Calendar();
        }
        IgxYearsViewComponent_1 = IgxYearsViewComponent;
        Object.defineProperty(IgxYearsViewComponent.prototype, "yearFormat", {
            /**
             * Gets the year format option of the years view.
             * ```typescript
             * let yearFormat = this.yearsView.yearFormat.
             * ```
             */
            get: function () {
                return this._yearFormat;
            },
            /**
             * Sets the year format option of the years view.
             * ```html
             * <igx-years-view [yearFormat]="numeric"></igx-years-view>
             * ```
             * @memberof IgxYearsViewComponent
             */
            set: function (value) {
                this._yearFormat = value;
                this.initYearFormatter();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxYearsViewComponent.prototype, "locale", {
            /**
             * Gets the `locale` of the years view.
             * Default value is `"en"`.
             * ```typescript
             * let locale =  this.yearsView.locale;
             * ```
             * @memberof IgxYearsViewComponent
             */
            get: function () {
                return this._locale;
            },
            /**
             * Sets the `locale` of the years view.
             * Expects a valid BCP 47 language tag.
             * Default value is `"en"`.
             * ```html
             * <igx-years-view [locale]="de"></igx-years-view>
             * ```
             * @memberof IgxYearsViewComponent
             */
            set: function (value) {
                this._locale = value;
                this.initYearFormatter();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxYearsViewComponent.prototype, "decade", {
            /**
             * Returns an array of date objects which are then used to properly
             * render the years.
             *
             * Used in the template of the component.
             *
             * @hidden
             */
            get: function () {
                var e_1, _a;
                var result = [];
                var start = this.date.getFullYear() - 3;
                var end = this.date.getFullYear() + 4;
                try {
                    for (var _b = __values(range(start, end)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var year = _c.value;
                        result.push(new Date(year, this.date.getMonth(), this.date.getDate()));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return result;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the locale representation of the year in the years view.
         *
         * @hidden
         */
        IgxYearsViewComponent.prototype.formattedYear = function (value) {
            if (this.formatView) {
                return this._formatterYear.format(value);
            }
            return "" + value.getFullYear();
        };
        /**
         *@hidden
         */
        IgxYearsViewComponent.prototype.selectYear = function (event) {
            this.date = event;
            this.onSelection.emit(this.date);
            this._onChangeCallback(this.date);
        };
        /**
         *@hidden
         */
        IgxYearsViewComponent.prototype.scroll = function (event) {
            event.preventDefault();
            event.stopPropagation();
            var delta = event.deltaY < 0 ? -1 : 1;
            this.generateYearRange(delta);
        };
        /**
         *@hidden
         */
        IgxYearsViewComponent.prototype.pan = function (event) {
            var delta = event.deltaY < 0 ? 1 : -1;
            this.generateYearRange(delta);
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.yearTracker = function (index, item) {
            return item.getFullYear() + "}";
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.writeValue = function (value) {
            if (value) {
                this.date = value;
            }
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.onKeydownArrowDown = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.generateYearRange(1);
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.onKeydownArrowUp = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.generateYearRange(-1);
        };
        /**
         * @hidden
         */
        IgxYearsViewComponent.prototype.onKeydownEnter = function () {
            this.onSelection.emit(this.date);
            this._onChangeCallback(this.date);
        };
        /**
         *@hidden
         */
        IgxYearsViewComponent.prototype.initYearFormatter = function () {
            this._formatterYear = new Intl.DateTimeFormat(this._locale, { year: this.yearFormat });
        };
        /**
         *@hidden
         */
        IgxYearsViewComponent.prototype.generateYearRange = function (delta) {
            var currentYear = new Date().getFullYear();
            if ((delta > 0 && this.date.getFullYear() - currentYear >= 95) ||
                (delta < 0 && currentYear - this.date.getFullYear() >= 95)) {
                return;
            }
            this.date = this._calendarModel.timedelta(this.date, 'year', delta);
        };
        var IgxYearsViewComponent_1;
        IgxYearsViewComponent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxYearsViewComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxYearsViewComponent.prototype, "date", void 0);
        __decorate([
            core.Input()
        ], IgxYearsViewComponent.prototype, "yearFormat", null);
        __decorate([
            core.Input()
        ], IgxYearsViewComponent.prototype, "locale", null);
        __decorate([
            core.Input()
        ], IgxYearsViewComponent.prototype, "formatView", void 0);
        __decorate([
            core.Output()
        ], IgxYearsViewComponent.prototype, "onSelection", void 0);
        __decorate([
            core.HostBinding('class.igx-calendar')
        ], IgxYearsViewComponent.prototype, "styleClass", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxYearsViewComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostListener('keydown.arrowdown', ['$event'])
        ], IgxYearsViewComponent.prototype, "onKeydownArrowDown", null);
        __decorate([
            core.HostListener('keydown.arrowup', ['$event'])
        ], IgxYearsViewComponent.prototype, "onKeydownArrowUp", null);
        __decorate([
            core.HostListener('keydown.enter')
        ], IgxYearsViewComponent.prototype, "onKeydownEnter", null);
        IgxYearsViewComponent = IgxYearsViewComponent_1 = __decorate([
            core.Component({
                providers: [
                    {
                        provide: forms.NG_VALUE_ACCESSOR,
                        useExisting: IgxYearsViewComponent_1,
                        multi: true
                    },
                    {
                        provide: platformBrowser.HAMMER_GESTURE_CONFIG,
                        useClass: CalendarHammerConfig
                    }
                ],
                selector: 'igx-years-view',
                template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-column\" (wheel)=\"scroll($event)\" (pan)=\"pan($event)\">\n        <span [igxCalendarYear]=\"year\" [date]=\"date\" (onYearSelection)=\"selectYear($event)\" *ngFor=\"let year of decade; trackBy: yearTracker\">\n            {{ formattedYear(year) }}\n        </span>\n    </div>\n</div>\n"
            })
        ], IgxYearsViewComponent);
        return IgxYearsViewComponent;
    }());

    /**
     *@hidden
    */
    var IgxDayItemComponent = /** @class */ (function () {
        function IgxDayItemComponent(elementRef) {
            this.elementRef = elementRef;
            this.hideOutsideDays = false;
            this.isLastInRange = false;
            this.isFirstInRange = false;
            this.isWithinRange = false;
            this.onDateSelection = new core.EventEmitter();
            this._selected = false;
        }
        Object.defineProperty(IgxDayItemComponent.prototype, "selected", {
            /**
             * Returns boolean indicating if the day is selected
             *
             */
            get: function () {
                return this._selected;
            },
            /**
             * Selects the day
             */
            set: function (value) {
                this._selected = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isCurrentMonth", {
            get: function () {
                return this.date.isCurrentMonth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isPreviousMonth", {
            get: function () {
                return this.date.isPrevMonth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isNextMonth", {
            get: function () {
                return this.date.isNextMonth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "nativeElement", {
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isSelectedCSS", {
            get: function () {
                return (!this.isDisabled && this.selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isInactive", {
            get: function () {
                return this.date.isNextMonth || this.date.isPrevMonth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isHidden", {
            get: function () {
                return this.hideOutsideDays && this.isInactive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isToday", {
            get: function () {
                var today = new Date(Date.now());
                var date = this.date.date;
                return (date.getFullYear() === today.getFullYear() &&
                    date.getMonth() === today.getMonth() &&
                    date.getDate() === today.getDate());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isWeekend", {
            get: function () {
                var day = this.date.date.getDay();
                return day === 0 || day === 6;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isDisabled", {
            get: function () {
                if (this.disabledDates === null) {
                    return false;
                }
                return isDateInRanges(this.date.date, this.disabledDates);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isOutOfRange", {
            get: function () {
                if (!this.outOfRangeDates) {
                    return false;
                }
                return isDateInRanges(this.date.date, this.outOfRangeDates);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isFocusable", {
            get: function () {
                return this.isCurrentMonth && !this.isHidden && !this.isDisabled && !this.isOutOfRange;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isWithinRangeCSS", {
            get: function () {
                return !this.isSingleSelection && this.isWithinRange;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isSpecial", {
            get: function () {
                if (this.specialDates === null) {
                    return false;
                }
                return isDateInRanges(this.date.date, this.specialDates);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "defaultCSS", {
            get: function () {
                return this.date.isCurrentMonth && !(this.isWeekend && this.selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isDisabledCSS", {
            get: function () {
                return this.isHidden || this.isDisabled || this.isOutOfRange;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "isSingleSelection", {
            get: function () {
                return this.selection !== CalendarSelection.RANGE;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDayItemComponent.prototype, "tabindex", {
            get: function () {
                return this.isDisabled || this.isHidden ? -1 : 0;
            },
            enumerable: true,
            configurable: true
        });
        IgxDayItemComponent.prototype.onSelect = function () {
            this.onDateSelection.emit(this.date);
        };
        IgxDayItemComponent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxDayItemComponent.prototype, "date", void 0);
        __decorate([
            core.Input()
        ], IgxDayItemComponent.prototype, "selection", void 0);
        __decorate([
            core.Input()
        ], IgxDayItemComponent.prototype, "selected", null);
        __decorate([
            core.Input()
        ], IgxDayItemComponent.prototype, "disabledDates", void 0);
        __decorate([
            core.Input()
        ], IgxDayItemComponent.prototype, "outOfRangeDates", void 0);
        __decorate([
            core.Input()
        ], IgxDayItemComponent.prototype, "specialDates", void 0);
        __decorate([
            core.Input()
        ], IgxDayItemComponent.prototype, "hideOutsideDays", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('class.igx-calendar__date--last')
        ], IgxDayItemComponent.prototype, "isLastInRange", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('class.igx-calendar__date--first')
        ], IgxDayItemComponent.prototype, "isFirstInRange", void 0);
        __decorate([
            core.Input()
        ], IgxDayItemComponent.prototype, "isWithinRange", void 0);
        __decorate([
            core.Output()
        ], IgxDayItemComponent.prototype, "onDateSelection", void 0);
        __decorate([
            core.HostBinding('class.igx-calendar__date--selected')
        ], IgxDayItemComponent.prototype, "isSelectedCSS", null);
        __decorate([
            core.HostBinding('class.igx-calendar__date--inactive')
        ], IgxDayItemComponent.prototype, "isInactive", null);
        __decorate([
            core.HostBinding('class.igx-calendar__date--hidden')
        ], IgxDayItemComponent.prototype, "isHidden", null);
        __decorate([
            core.HostBinding('class.igx-calendar__date--current')
        ], IgxDayItemComponent.prototype, "isToday", null);
        __decorate([
            core.HostBinding('class.igx-calendar__date--weekend')
        ], IgxDayItemComponent.prototype, "isWeekend", null);
        __decorate([
            core.HostBinding('class.igx-calendar__date--range')
        ], IgxDayItemComponent.prototype, "isWithinRangeCSS", null);
        __decorate([
            core.HostBinding('class.igx-calendar__date--special')
        ], IgxDayItemComponent.prototype, "isSpecial", null);
        __decorate([
            core.HostBinding('class.igx-calendar__date')
        ], IgxDayItemComponent.prototype, "defaultCSS", null);
        __decorate([
            core.HostBinding('class.igx-calendar__date--disabled')
        ], IgxDayItemComponent.prototype, "isDisabledCSS", null);
        __decorate([
            core.HostBinding('class.igx-calendar__date--single')
        ], IgxDayItemComponent.prototype, "isSingleSelection", null);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxDayItemComponent.prototype, "tabindex", null);
        __decorate([
            core.HostListener('click'),
            core.HostListener('keydown.enter')
        ], IgxDayItemComponent.prototype, "onSelect", null);
        IgxDayItemComponent = __decorate([
            core.Component({
                selector: 'igx-day-item',
                template: "<span class=\"igx-calendar__date-content\">\n    <ng-content></ng-content>\n</span>\n"
            })
        ], IgxDayItemComponent);
        return IgxDayItemComponent;
    }());

    var Direction;
    (function (Direction) {
        Direction["Up"] = "ArrowUp";
        Direction["Down"] = "ArrowDown";
        Direction["Left"] = "ArrowLeft";
        Direction["Right"] = "ArrowRight";
    })(Direction || (Direction = {}));
    var ARROW = 'Arrow';
    /** @hidden */
    var IgxDaysViewNavigationService = /** @class */ (function () {
        function IgxDaysViewNavigationService() {
        }
        /**
         * Implements kb navigation in all MoveDirections. nextDate and nextMonthView naming convention is used for both previous/next
         * @hidden
         */
        IgxDaysViewNavigationService.prototype.focusNextDate = function (target, key, nextView) {
            if (nextView === void 0) { nextView = false; }
            if (target.childElementCount === 0) {
                target = target.parentElement;
            }
            if (key.indexOf('Arrow') === -1) {
                key = ARROW.concat(key);
            }
            var monthView = this.monthView;
            var node = monthView.dates.find(function (date) { return date.nativeElement === target; });
            var dates = monthView.dates.toArray(), day, step, i, nextDate;
            var index = dates.indexOf(node);
            if (!node) {
                return;
            }
            // focus item in current month
            switch (key) {
                case Direction.Left: {
                    step = -1;
                    nextDate = this.timedelta(node.date.date, step);
                    for (i = index; i > 0; i--) {
                        day = nextView ? dates[i] : dates[i - 1];
                        nextDate = day.date.date;
                        if (day.date.isPrevMonth) {
                            break;
                        }
                        if (day && day.isFocusable) {
                            day.nativeElement.focus();
                            return;
                        }
                    }
                    break;
                }
                case Direction.Right: {
                    step = 1;
                    nextDate = this.timedelta(node.date.date, step);
                    for (i = index; i < dates.length - 1; i++) {
                        day = nextView ? dates[i] : dates[i + 1];
                        nextDate = day.date.date;
                        if (day.date.isNextMonth) {
                            break;
                        }
                        if (day && day.isFocusable) {
                            day.nativeElement.focus();
                            return;
                        }
                    }
                    break;
                }
                case Direction.Up: {
                    step = -7;
                    nextDate = this.timedelta(node.date.date, step);
                    for (i = index; i - 7 > -1; i -= 7) {
                        day = nextView ? dates[i] : dates[i - 7];
                        nextDate = day.date.date;
                        if (day.date.isPrevMonth) {
                            break;
                        }
                        if (day && day.isFocusable) {
                            day.nativeElement.focus();
                            return;
                        }
                    }
                    break;
                }
                case Direction.Down: {
                    step = 7;
                    nextDate = this.timedelta(node.date.date, step);
                    for (i = index; i + 7 < 42; i += 7) {
                        day = nextView ? dates[i] : dates[i + 7];
                        nextDate = day.date.date;
                        if (day.date.isNextMonth) {
                            break;
                        }
                        if (day && day.isFocusable) {
                            day.nativeElement.focus();
                            return;
                        }
                    }
                    break;
                }
            }
            // focus item in prev/next visible month
            var nextMonthView = step > 0 ? monthView.nextMonthView : monthView.prevMonthView;
            if (nextMonthView) {
                dates = nextMonthView.dates.toArray();
                day = dates.find(function (item) { return item.date.date.getTime() === nextDate.getTime(); });
                if (day && day.isFocusable) {
                    day.nativeElement.focus();
                    return;
                }
                nextMonthView.daysNavService.focusNextDate(day.nativeElement, key);
            }
            // if iterating in the visible prev/next moths above found a day that is not focusable, ie is disabled, hidden, etc
            // then it is needed to recalculate the next day, which is going to be part of the prev/next months
            if (day && !day.isFocusable) {
                day = dates[i + step];
                if (!day) {
                    nextDate = this.timedelta(node.date.date, step + i - index);
                }
            }
            // focus item in prev/next month, which is currently out of view
            var dayIsNextMonth; // determine what we need to check for next date - if it belongs to prev or next month
            if (day) {
                dayIsNextMonth = step > 0 ? day.date.isNextMonth : day.date.isPrevMonth;
            }
            if (monthView.changeDaysView && !nextMonthView && ((day && dayIsNextMonth) || !day)) {
                var monthAction = step > 0 ? ScrollMonth.NEXT : ScrollMonth.PREV;
                monthView.onViewChanging.emit({ monthAction: monthAction, key: key, nextDate: nextDate });
            }
        };
        /**
         * Focuses first focusable day in the month. Will go to next visible month, if no day in the first month is focusable
         * @hidden
         */
        IgxDaysViewNavigationService.prototype.focusHomeDate = function () {
            var monthView = this.monthView;
            while (!this.focusFirstDay(monthView) && monthView.nextMonthView) {
                monthView = monthView.nextMonthView;
            }
        };
        /**
         * Focuses last focusable day in the month. Will go to previous visible month, if no day in the first month is focusable
         * @hidden
         */
        IgxDaysViewNavigationService.prototype.focusEndDate = function () {
            var monthView = this.monthView;
            while (!this.focusLastDay(monthView) && monthView.prevMonthView) {
                monthView = monthView.prevMonthView;
            }
        };
        IgxDaysViewNavigationService.prototype.timedelta = function (date, units) {
            var ret = new Date(date);
            ret.setDate(ret.getDate() + units);
            return ret;
        };
        IgxDaysViewNavigationService.prototype.focusFirstDay = function (monthView) {
            var dates = monthView.dates.filter(function (d) { return d.isCurrentMonth; });
            for (var i = 0; i < dates.length; i++) {
                if (dates[i].isFocusable) {
                    dates[i].nativeElement.focus();
                    return true;
                }
            }
            return false;
        };
        IgxDaysViewNavigationService.prototype.focusLastDay = function (monthView) {
            var dates = monthView.dates.filter(function (d) { return d.isCurrentMonth; });
            for (var i = dates.length - 1; i >= 0; i--) {
                if (dates[i].isFocusable) {
                    dates[i].nativeElement.focus();
                    return true;
                }
            }
            return false;
        };
        IgxDaysViewNavigationService = __decorate([
            core.Injectable()
        ], IgxDaysViewNavigationService);
        return IgxDaysViewNavigationService;
    }());

    var NEXT_ID$e = 0;
    var IgxDaysViewComponent = /** @class */ (function (_super) {
        __extends(IgxDaysViewComponent, _super);
        /**
         * @hidden
         */
        function IgxDaysViewComponent(daysNavService) {
            var _this = _super.call(this) || this;
            _this.daysNavService = daysNavService;
            /**
             * Sets/gets the `id` of the days view.
             * If not set, the `id` will have value `"igx-days-view-0"`.
             * ```html
             * <igx-days-view id="my-days-view"></igx-days-view>
             * ```
             * ```typescript
             * let daysViewId =  this.daysView.id;
             * ```
             */
            _this.id = "igx-days-view-" + NEXT_ID$e++;
            /**
             * @hidden
             */
            _this.changeDaysView = false;
            /**
             * @hidden
             */
            _this.onDateSelection = new core.EventEmitter();
            /**
             * @hidden
             */
            _this.onViewChanging = new core.EventEmitter();
            /**
             * The default css class applied to the component.
             *
             * @hidden
             */
            _this.styleClass = true;
            return _this;
        }
        IgxDaysViewComponent_1 = IgxDaysViewComponent;
        Object.defineProperty(IgxDaysViewComponent.prototype, "getCalendarMonth", {
            /**
             * @hidden
             */
            get: function () {
                return this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth(), true);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.ngOnInit = function () {
            this.daysNavService.monthView = this;
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.ngDoCheck = function () {
            if (!this.changeDaysView && this.dates) {
                this.disableOutOfRangeDates();
            }
        };
        /**
         * Returns the locale representation of the date in the days view.
         *
         * @hidden
         */
        IgxDaysViewComponent.prototype.formattedDate = function (value) {
            if (this.formatViews.day) {
                return this.formatterDay.format(value);
            }
            return "" + value.getDate();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.generateWeekHeader = function () {
            var e_1, _a;
            var dayNames = [];
            var rv = this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth())[0];
            try {
                for (var rv_1 = __values(rv), rv_1_1 = rv_1.next(); !rv_1_1.done; rv_1_1 = rv_1.next()) {
                    var day = rv_1_1.value;
                    dayNames.push(this.formatterWeekday.format(day.date));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (rv_1_1 && !rv_1_1.done && (_a = rv_1.return)) _a.call(rv_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return dayNames;
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.rowTracker = function (index, item) {
            return "" + item[index].date.getMonth() + item[index].date.getDate();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.dateTracker = function (index, item) {
            return item.date.getMonth() + "--" + item.date.getDate();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isCurrentMonth = function (value) {
            return this.viewDate.getMonth() === value.getMonth();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isCurrentYear = function (value) {
            return this.viewDate.getFullYear() === value.getFullYear();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isSelected = function (date) {
            var selectedDates;
            if (this.isDateDisabled(date.date) || !this.value ||
                (Array.isArray(this.value) && this.value.length === 0)) {
                return false;
            }
            if (this.selection === CalendarSelection.SINGLE) {
                selectedDates = this.value;
                return this.getDateOnly(selectedDates).getTime() === date.date.getTime();
            }
            selectedDates = this.value;
            if (this.selection === CalendarSelection.RANGE && selectedDates.length === 1) {
                return this.getDateOnly(selectedDates[0]).getTime() === date.date.getTime();
            }
            if (this.selection === CalendarSelection.MULTI) {
                var start = this.getDateOnly(selectedDates[0]);
                var end = this.getDateOnly(selectedDates[selectedDates.length - 1]);
                if (this.isWithinRange(date.date, false, start, end)) {
                    var currentDate = selectedDates.find(function (element) { return element.getTime() === date.date.getTime(); });
                    return !!currentDate;
                }
                else {
                    return false;
                }
            }
            else {
                return this.isWithinRange(date.date, true);
            }
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isLastInRange = function (date) {
            if (this.isSingleSelection || !this.value) {
                return false;
            }
            var dates = this.value;
            var lastDate = dates[dates.length - 1];
            return isEqual(lastDate, date.date);
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isFirstInRange = function (date) {
            if (this.isSingleSelection || !this.value) {
                return false;
            }
            return isEqual(this.value[0], date.date);
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.isWithinRange = function (date, checkForRange, min, max) {
            if (checkForRange && !(Array.isArray(this.value) && this.value.length > 1)) {
                return false;
            }
            min = min ? min : this.value[0];
            max = max ? max : this.value[this.value.length - 1];
            return isDateInRanges(date, [
                {
                    type: exports.DateRangeType.Between,
                    dateRange: [min, max]
                }
            ]);
        };
        /**
         *@hidden
         */
        IgxDaysViewComponent.prototype.focusActiveDate = function () {
            var date = this.dates.find(function (d) { return d.selected; });
            if (!date) {
                date = this.dates.find(function (d) { return d.isToday; });
            }
            if (date.isFocusable) {
                date.nativeElement.focus();
            }
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.selectDay = function (event) {
            this.selectDateFromClient(event.date);
            this.onDateSelection.emit(event);
            this.onSelection.emit(this.selectedDates);
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.disableOutOfRangeDates = function () {
            var dateRange = [];
            this.dates.toArray().forEach(function (date) {
                if (!date.isCurrentMonth) {
                    dateRange.push(date.date.date);
                }
            });
            this.outOfRangeDates = [{
                    type: exports.DateRangeType.Specific,
                    dateRange: dateRange
                }];
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.getFirstMonthView = function () {
            var monthView = this;
            while (monthView.prevMonthView) {
                monthView = monthView.prevMonthView;
            }
            return monthView;
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.getLastMonthView = function () {
            var monthView = this;
            while (monthView.nextMonthView) {
                monthView = monthView.nextMonthView;
            }
            return monthView;
        };
        Object.defineProperty(IgxDaysViewComponent.prototype, "isSingleSelection", {
            /**
             * @hidden
             */
            get: function () {
                return this.selection !== CalendarSelection.RANGE;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.onKeydownArrow = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.daysNavService.focusNextDate(event.target, event.key);
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.onKeydownHome = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.getFirstMonthView().daysNavService.focusHomeDate();
        };
        /**
         * @hidden
         */
        IgxDaysViewComponent.prototype.onKeydownEnd = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.getLastMonthView().daysNavService.focusEndDate();
        };
        var IgxDaysViewComponent_1;
        IgxDaysViewComponent.ctorParameters = function () { return [
            { type: IgxDaysViewNavigationService }
        ]; };
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxDaysViewComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxDaysViewComponent.prototype, "changeDaysView", void 0);
        __decorate([
            core.Output()
        ], IgxDaysViewComponent.prototype, "onDateSelection", void 0);
        __decorate([
            core.Output()
        ], IgxDaysViewComponent.prototype, "onViewChanging", void 0);
        __decorate([
            core.ViewChildren(IgxDayItemComponent, { read: IgxDayItemComponent })
        ], IgxDaysViewComponent.prototype, "dates", void 0);
        __decorate([
            core.HostBinding('class.igx-calendar')
        ], IgxDaysViewComponent.prototype, "styleClass", void 0);
        __decorate([
            core.HostListener('keydown.arrowleft', ['$event']),
            core.HostListener('keydown.arrowright', ['$event']),
            core.HostListener('keydown.arrowup', ['$event']),
            core.HostListener('keydown.arrowdown', ['$event'])
        ], IgxDaysViewComponent.prototype, "onKeydownArrow", null);
        __decorate([
            core.HostListener('keydown.home', ['$event'])
        ], IgxDaysViewComponent.prototype, "onKeydownHome", null);
        __decorate([
            core.HostListener('keydown.end', ['$event'])
        ], IgxDaysViewComponent.prototype, "onKeydownEnd", null);
        IgxDaysViewComponent = IgxDaysViewComponent_1 = __decorate([
            core.Component({
                providers: [
                    {
                        multi: true,
                        provide: forms.NG_VALUE_ACCESSOR,
                        useExisting: IgxDaysViewComponent_1
                    },
                    { provide: IgxDaysViewNavigationService, useClass: IgxDaysViewNavigationService }
                ],
                selector: 'igx-days-view',
                template: "<div class=\"igx-calendar__body-row\">\n    <span *ngFor=\"let dayName of generateWeekHeader()\" class=\"igx-calendar__label\">\n        {{ dayName | titlecase }}\n    </span>\n</div>\n\n<div *ngFor=\"let week of getCalendarMonth; last as isLast; index as i; trackBy: rowTracker\"\n    class=\"igx-calendar__body-row\">\n    <igx-day-item\n        *ngFor=\"let day of week; trackBy: dateTracker\"\n        [date]=\"day\"\n        [selection]=\"selection\"\n        [selected]=\"isSelected(day)\"\n        [isLastInRange]=\"isLastInRange(day)\"\n        [isFirstInRange]=\"isFirstInRange(day)\"\n        [isWithinRange]=\"isWithinRange(day.date, true)\"\n        [disabledDates]=\"disabledDates\"\n        [specialDates]=\"specialDates\"\n        [outOfRangeDates]=\"outOfRangeDates\"\n        [hideOutsideDays]=\"hideOutsideDays\"\n        (onDateSelection)=\"selectDay($event)\">\n        {{ formattedDate(day.date) }}\n    </igx-day-item>\n</div>\n"
            })
        ], IgxDaysViewComponent);
        return IgxDaysViewComponent;
    }(IgxCalendarBaseDirective));

    var NEXT_ID$f = 0;
    /**
     * Calendar provides a way to display date information.
     *
     * @igxModule IgxCalendarModule
     *
     * @igxTheme igx-calendar-theme, igx-icon-theme
     *
     * @igxKeywords calendar, datepicker, schedule, date
     *
     * @igxGroup Scheduling
     *
     * @remarks
     * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple
     * or range selection.
     *
     * @example:
     * ```html
     * <igx-calendar selection="range"></igx-calendar>
     * ```
     */
    var IgxCalendarComponent = /** @class */ (function (_super) {
        __extends(IgxCalendarComponent, _super);
        function IgxCalendarComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Sets/gets the `id` of the calendar.
             *
             * @remarks
             * If not set, the `id` will have value `"igx-calendar-0"`.
             *
             * @example
             * ```html
             * <igx-calendar id="my-first-calendar"></igx-calendar>
             * ```
             * @memberof IgxCalendarComponent
             */
            _this.id = "igx-calendar-" + NEXT_ID$f++;
            /**
             * Sets/gets whether the calendar has header.
             * Default value is `true`.
             *
             * @example
             * ```html
             * <igx-calendar [hasHeader]="false"></igx-calendar>
             * ```
             */
            _this.hasHeader = true;
            /**
             * Sets/gets whether the calendar header will be in vertical position.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-calendar [vertical] = "true"></igx-calendar>
             * ```
             */
            _this.vertical = false;
            /**
             * Apply the different states for the transitions of animateChange
             * @hidden
             * @internal
             */
            _this.animationAction = '';
            /**
             * Denote if the calendar view was changed with the keyboard
             *
             * @hidden
             * @internal
             */
            _this.isKeydownTrigger = false;
            /**
             * The default `tabindex` attribute for the component.
             *
             * @hidden
             * @internal
             */
            _this.tabindex = 0;
            /**
             * The default aria role attribute for the component.
             *
             * @hidden
             * @internal
             */
            _this.role = 'grid';
            /**
             * The default aria lebelled by attribute for the component.
             *
             * @hidden
             * @internal
             */
            _this.ariaLabelledBy = 'calendar';
            /**
             * The default css class applied to the component.
             *
             * @hidden
             * @internal
             */
            _this.styleClass = true;
            /**
             * @hidden
             * @internal
             */
            _this._monthsViewNumber = 1;
            /**
             * Continious navigation through the previous months
             * @hidden
             * @internal
             */
            _this.startPrevMonthScroll = function (isKeydownTrigger) {
                if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
                _this.startMonthScroll$.next();
                _this.monthScrollDirection = ScrollMonth.PREV;
                _this.previousMonth(isKeydownTrigger);
            };
            /**
             * Continious navigation through the next months
             * @hidden
             * @internal
             */
            _this.startNextMonthScroll = function (isKeydownTrigger) {
                if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
                _this.startMonthScroll$.next();
                _this.monthScrollDirection = ScrollMonth.NEXT;
                _this.nextMonth(isKeydownTrigger);
            };
            /**
             * Stop continuous navigation
             * @hidden
             * @internal
             */
            _this.stopMonthScroll = function (event) {
                event.stopPropagation();
                // generally the scrolling is built on the calendar component
                // and all start/stop scrolling methods are called on the calendar
                // if we change below lines to call stopMonthScroll$ on the calendar instead of on the views,
                // strange bug is introduced --> after changing number of months, continuous scrolling on mouse click does not happen
                _this.daysView.stopMonthScroll$.next(true);
                _this.daysView.stopMonthScroll$.complete();
                if (_this.monthScrollDirection === ScrollMonth.PREV) {
                    _this.prevMonthBtn.nativeElement.focus();
                }
                else if (_this.monthScrollDirection === ScrollMonth.NEXT) {
                    _this.nextMonthBtn.nativeElement.focus();
                }
                _this.monthScrollDirection = ScrollMonth.NONE;
            };
            return _this;
        }
        IgxCalendarComponent_1 = IgxCalendarComponent;
        Object.defineProperty(IgxCalendarComponent.prototype, "monthsViewNumber", {
            /**
             * Sets/gets the number of month views displayed.
             * Default value is `1`.
             *
             * @example
             * ```html
             * <igx-calendar [monthsViewNumber]="2"></igx-calendar>
             * ```
             */
            get: function () {
                return this._monthsViewNumber;
            },
            set: function (val) {
                if (val < 1) {
                    return;
                }
                this._monthsViewNumber = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "styleVerticalClass", {
            /**
             * The default css class applied to the component.
             *
             * @hidden
             * @internal
             */
            get: function () {
                return this.vertical;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "isYearView", {
            /**
             * Denote if the year view is active.
             * @hidden
             * @internal
             */
            get: function () {
                return this.activeView === exports.CalendarView.YEAR;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "headerTemplate", {
            /**
             * Gets the header template.
             *
             * @example
             * ```typescript
             * let headerTemplate =  this.calendar.headerTeamplate;
             * ```
             * @memberof IgxCalendarComponent
             */
            get: function () {
                if (this.headerTemplateDirective) {
                    return this.headerTemplateDirective.template;
                }
                return null;
            },
            /**
             * Sets the header template.
             *
             * @example
             * ```html
             * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
             * ```
             * @memberof IgxCalendarComponent
             */
            set: function (directive) {
                this.headerTemplateDirective = directive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "subheaderTemplate", {
            /**
             * Gets the subheader template.
             *
             * @example
             * ```typescript
             * let subheaderTemplate = this.calendar.subheaderTemplate;
             * ```
             */
            get: function () {
                if (this.subheaderTemplateDirective) {
                    return this.subheaderTemplateDirective.template;
                }
                return null;
            },
            /**
             * Sets the subheader template.
             *
             * @example
             * ```html
             * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
             * ```
             * @memberof IgxCalendarComponent
             */
            set: function (directive) {
                this.subheaderTemplateDirective = directive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "headerContext", {
            /**
             * Gets the context for the template marked with the `igxCalendarHeader` directive.
             *
             * @example
             * ```typescript
             * let headerContext =  this.calendar.headerContext;
             * ```
             */
            get: function () {
                var date = this.headerDate;
                return this.generateContext(date);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "context", {
            /**
             * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
             * or `igxCalendarSubHeaderYear` directive.
             *
             * @example
             * ```typescript
             * let context =  this.calendar.context;
             * ```
             */
            get: function () {
                var date = this.viewDate;
                return this.generateContext(date);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarComponent.prototype, "headerDate", {
            /**
             * Date displayed in header
             *
             * @hidden
             * @internal
             */
            get: function () {
                return this.selectedDates ? this.selectedDates : new Date();
            },
            enumerable: true,
            configurable: true
        });
        IgxCalendarComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.setSiblingMonths(this.monthViews);
            this._monthViewsChanges$ = this.monthViews.changes.subscribe(function (c) {
                _this.setSiblingMonths(c);
            });
            this.startMonthScroll$.pipe(operators.takeUntil(this.stopMonthScroll$), operators.switchMap(function () { return _this.scrollMonth$.pipe(operators.skipLast(1), operators.debounce(function () { return rxjs.interval(300); }), operators.takeUntil(_this.stopMonthScroll$)); })).subscribe(function () {
                switch (_this.monthScrollDirection) {
                    case ScrollMonth.PREV:
                        _this.previousMonth();
                        break;
                    case ScrollMonth.NEXT:
                        _this.nextMonth();
                        break;
                    case ScrollMonth.NONE:
                    default:
                        break;
                }
            });
        };
        /**
         * Returns the locale representation of the month in the month view if enabled,
         * otherwise returns the default `Date.getMonth()` value.
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.formattedMonth = function (value) {
            if (this.formatViews.month) {
                return this.formatterMonth.format(value);
            }
            return "" + value.getMonth();
        };
        /**
         * Change to previous month
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.previousMonth = function (isKeydownTrigger) {
            if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
            this.viewDate = this.calendarModel.getPrevMonth(this.viewDate);
            this.animationAction = ScrollMonth.PREV;
            this.isKeydownTrigger = isKeydownTrigger;
        };
        /**
         * Change to next month
         *
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.nextMonth = function (isKeydownTrigger) {
            if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
            this.viewDate = this.calendarModel.getNextMonth(this.viewDate);
            this.animationAction = ScrollMonth.NEXT;
            this.isKeydownTrigger = isKeydownTrigger;
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onActiveViewDecade = function (args, activeViewIdx) {
            var _this = this;
            _super.prototype.activeViewDecade.call(this, activeViewIdx);
            requestAnimationFrame(function () {
                if (_this.dacadeView) {
                    _this.dacadeView.date = args;
                    _this.dacadeView.el.nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onActiveViewDecadeKB = function (event, args, activeViewIdx) {
            var _this = this;
            _super.prototype.activeViewDecadeKB.call(this, event, activeViewIdx);
            requestAnimationFrame(function () {
                if (_this.dacadeView) {
                    _this.dacadeView.date = args;
                    _this.dacadeView.el.nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.getFormattedDate = function () {
            var date = this.headerDate;
            return {
                monthday: this.formatterMonthday.format(date),
                weekday: this.formatterWeekday.format(date),
            };
        };
        /**
         * Handles invoked on date selection
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.childClicked = function (instance) {
            if (instance.isPrevMonth) {
                this.previousMonth();
            }
            if (instance.isNextMonth) {
                this.nextMonth();
            }
            this.selectDateFromClient(instance.date);
            if (this.selection === 'multi') {
                this.deselectDateInMonthViews(instance.date);
            }
            this.onSelection.emit(this.selectedDates);
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.viewChanging = function (args) {
            var _this = this;
            this.animationAction = args.monthAction;
            this.isKeydownTrigger = true;
            this.nextDate = args.nextDate;
            this.callback = function (next) {
                var day = _this.daysView.dates.find(function (item) { return item.date.date.getTime() === next.getTime(); });
                if (day) {
                    _this.daysView.daysNavService.focusNextDate(day.nativeElement, args.key, true);
                }
            };
            this.viewDate = this.nextDate;
        };
        /**
         * @hidden
         * @intenal
         */
        IgxCalendarComponent.prototype.changeMonth = function (event) {
            var _this = this;
            this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
            this.activeView = exports.CalendarView.DEFAULT;
            requestAnimationFrame(function () {
                var elem = _this.monthsBtns.find(function (e, idx) { return idx === _this.activeViewIdx; });
                if (elem) {
                    elem.nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onActiveViewYear = function (args, activeViewIdx, event) {
            var _this = this;
            this.activeView = exports.CalendarView.YEAR;
            this.activeViewIdx = activeViewIdx;
            requestAnimationFrame(function () {
                _this.monthsView.date = args;
                _this.focusMonth(event.target);
            });
        };
        IgxCalendarComponent.prototype.focusMonth = function (target) {
            var month = this.monthsView.monthsRef.find(function (e) {
                return e.index === parseInt(target.parentElement.attributes['data-month'].value, 10);
            });
            if (month) {
                month.nativeElement.focus();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onActiveViewYearKB = function (args, event, activeViewIdx) {
            if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                event.preventDefault();
                this.onActiveViewYear(args, activeViewIdx, event);
            }
        };
        /**
         * Deselects date(s) (based on the selection type).
         *
         * @example
         *```typescript
         * this.calendar.deselectDate(new Date(`2018-06-12`));
         *````
         */
        IgxCalendarComponent.prototype.deselectDate = function (value) {
            var _this = this;
            _super.prototype.deselectDate.call(this, value);
            this.monthViews.forEach(function (view) {
                view.selectedDates = _this.selectedDates;
                view.rangeStarted = false;
            });
            this._onChangeCallback(this.selectedDates);
        };
        /**
         * Helper method that does deselection for all month views when selection is "multi"
         * If not called, selection in other month views stays
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.deselectDateInMonthViews = function (value) {
            this.monthViews.forEach(function (m) {
                m.deselectMultipleInMonth(value);
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.getViewDate = function (i) {
            var date = this.calendarModel.timedelta(this.viewDate, 'month', i);
            return date;
        };
        /**
         * Getter for the context object inside the calendar templates.
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.getContext = function (i) {
            var date = this.getViewDate(i);
            return this.generateContext(date, i);
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.animationDone = function (event) {
            if (this.monthScrollDirection !== ScrollMonth.NONE) {
                this.scrollMonth$.next();
            }
            if (this.activeView !== exports.CalendarView.DEFAULT) {
                return;
            }
            var monthView = this.daysView;
            var date = monthView.dates.find(function (d) { return d.selected; });
            while (!date && monthView.nextMonthView) {
                monthView = monthView.nextMonthView;
                date = monthView.dates.find(function (d) { return d.selected; });
            }
            if (date && date.isFocusable && !this.isKeydownTrigger) {
                setTimeout(function () {
                    date.nativeElement.focus();
                }, parseInt(slideInRight.options.params.duration, 10));
            }
            else if (this.callback && (event.toState === ScrollMonth.NEXT || event.toState === ScrollMonth.PREV)) {
                this.callback(this.nextDate);
            }
            this.animationAction = ScrollMonth.NONE;
        };
        /**
         * Keyboard navigation of the calendar
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onKeydownPageDown = function (event) {
            var _this = this;
            event.preventDefault();
            if (this.activeView !== exports.CalendarView.DEFAULT) {
                return;
            }
            var isPageDown = event.key === 'PageDown';
            var step = isPageDown ? 1 : -1;
            var monthView = this.daysView;
            var activeDate;
            while (!activeDate && monthView) {
                activeDate = monthView.dates.find(function (date) { return date.nativeElement === document.activeElement; });
                monthView = monthView.nextMonthView;
            }
            if (activeDate) {
                this.nextDate = new Date(activeDate.date.date);
                var year = this.nextDate.getFullYear();
                var month = this.nextDate.getMonth() + step;
                if (isPageDown) {
                    if (month > 11) {
                        month = 0;
                        year += step;
                    }
                }
                else {
                    if (month < 0) {
                        month = 11;
                        year += step;
                    }
                }
                var range = monthRange(this.nextDate.getFullYear(), month);
                var day = this.nextDate.getDate();
                if (day > range[1]) {
                    day = range[1];
                }
                this.nextDate.setDate(day);
                this.nextDate.setMonth(month);
                this.nextDate.setFullYear(year);
                this.callback = function (next) {
                    monthView = _this.daysView;
                    var dayItem;
                    while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                        dayItem = monthView.dates.find(function (d) { return d.date.date.getTime() === next.getTime(); });
                        monthView = monthView.nextMonthView;
                    }
                    if (dayItem && dayItem.isFocusable) {
                        dayItem.nativeElement.focus();
                    }
                };
            }
            if (isPageDown) {
                this.nextMonth(true);
            }
            else {
                this.previousMonth(true);
            }
        };
        /**
         * Keyboard navigation of the calendar
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onKeydownShiftPageUp = function (event) {
            var _this = this;
            event.preventDefault();
            if (this.activeView !== exports.CalendarView.DEFAULT) {
                return;
            }
            var isPageDown = event.key === 'PageDown';
            var step = isPageDown ? 1 : -1;
            this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', step);
            this.animationAction = isPageDown ? ScrollMonth.NEXT : ScrollMonth.PREV;
            this.isKeydownTrigger = true;
            var monthView = this.daysView;
            var activeDate;
            while (!activeDate && monthView) {
                activeDate = monthView.dates.find(function (date) { return date.nativeElement === document.activeElement; });
                monthView = monthView.nextMonthView;
            }
            if (activeDate) {
                this.nextDate = new Date(activeDate.date.date);
                var year = this.nextDate.getFullYear() + step;
                var range = monthRange(year, this.nextDate.getMonth());
                var day = this.nextDate.getDate();
                if (day > range[1]) {
                    day = range[1];
                }
                this.nextDate.setDate(day);
                this.nextDate.setFullYear(year);
                this.callback = function (next) {
                    monthView = _this.daysView;
                    var dayItem;
                    while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                        dayItem = monthView.dates.find(function (d) { return d.date.date.getTime() === next.getTime(); });
                        monthView = monthView.nextMonthView;
                    }
                    if (dayItem && dayItem.isFocusable) {
                        dayItem.nativeElement.focus();
                    }
                };
            }
        };
        /**
         * Keyboard navigation of the calendar
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onKeydownHome = function (event) {
            if (this.daysView) {
                this.daysView.onKeydownHome(event);
            }
        };
        /**
         * Keyboard navigation of the calendar
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onKeydownEnd = function (event) {
            if (this.daysView) {
                this.daysView.onKeydownEnd(event);
            }
        };
        /**
         * Stop continuous navigation on mouseup event
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.onMouseUp = function (event) {
            if (this.monthScrollDirection !== ScrollMonth.NONE) {
                this.stopMonthScroll(event);
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.ngOnDestroy = function () {
            if (this._monthViewsChanges$) {
                this._monthViewsChanges$.unsubscribe();
            }
        };
        /**
         * Helper method building and returning the context object inside
         * the calendar templates.
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.generateContext = function (value, i) {
            var _this = this;
            var formatObject = __assign({ index: i, monthView: function () { return _this.onActiveViewYear(value, i); }, yearView: function () { return _this.onActiveViewDecade(value, i); } }, this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday']));
            return { $implicit: formatObject };
        };
        /**
         * Helper method that sets references for prev/next months for each month in the view
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.setSiblingMonths = function (monthViews) {
            var _this = this;
            monthViews.forEach(function (item, index) {
                var prevMonthView = _this.getMonthView(index - 1);
                var nextMonthView = _this.getMonthView(index + 1);
                item.nextMonthView = nextMonthView;
                item.prevMonthView = prevMonthView;
            });
        };
        /**
         * Helper method returning previous/next day views
         * @hidden
         * @internal
         */
        IgxCalendarComponent.prototype.getMonthView = function (index) {
            if (index === -1 || index === this.monthViews.length) {
                return null;
            }
            else {
                return this.monthViews.toArray()[index];
            }
        };
        var IgxCalendarComponent_1;
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxCalendarComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarComponent.prototype, "hasHeader", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarComponent.prototype, "vertical", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarComponent.prototype, "monthsViewNumber", null);
        __decorate([
            core.Input()
        ], IgxCalendarComponent.prototype, "animationAction", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxCalendarComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxCalendarComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.aria-labelledby')
        ], IgxCalendarComponent.prototype, "ariaLabelledBy", void 0);
        __decorate([
            core.HostBinding('class.igx-calendar--vertical')
        ], IgxCalendarComponent.prototype, "styleVerticalClass", null);
        __decorate([
            core.HostBinding('class.igx-calendar')
        ], IgxCalendarComponent.prototype, "styleClass", void 0);
        __decorate([
            core.ViewChild('months', { read: IgxMonthsViewComponent })
        ], IgxCalendarComponent.prototype, "monthsView", void 0);
        __decorate([
            core.ViewChildren('monthsBtn')
        ], IgxCalendarComponent.prototype, "monthsBtns", void 0);
        __decorate([
            core.ViewChild('decade', { read: IgxYearsViewComponent })
        ], IgxCalendarComponent.prototype, "dacadeView", void 0);
        __decorate([
            core.ViewChild('days', { read: IgxDaysViewComponent })
        ], IgxCalendarComponent.prototype, "daysView", void 0);
        __decorate([
            core.ViewChildren('days', { read: IgxDaysViewComponent })
        ], IgxCalendarComponent.prototype, "monthViews", void 0);
        __decorate([
            core.ViewChild('prevMonthBtn')
        ], IgxCalendarComponent.prototype, "prevMonthBtn", void 0);
        __decorate([
            core.ViewChild('nextMonthBtn')
        ], IgxCalendarComponent.prototype, "nextMonthBtn", void 0);
        __decorate([
            core.ContentChild(core.forwardRef(function () { return IgxCalendarHeaderTemplateDirective; }), { read: IgxCalendarHeaderTemplateDirective, static: true })
        ], IgxCalendarComponent.prototype, "headerTemplateDirective", void 0);
        __decorate([
            core.ContentChild(core.forwardRef(function () { return IgxCalendarSubheaderTemplateDirective; }), { read: IgxCalendarSubheaderTemplateDirective, static: true })
        ], IgxCalendarComponent.prototype, "subheaderTemplateDirective", void 0);
        __decorate([
            core.HostListener('keydown.pagedown', ['$event']),
            core.HostListener('keydown.pageup', ['$event'])
        ], IgxCalendarComponent.prototype, "onKeydownPageDown", null);
        __decorate([
            core.HostListener('keydown.shift.pageup', ['$event']),
            core.HostListener('keydown.shift.pagedown', ['$event'])
        ], IgxCalendarComponent.prototype, "onKeydownShiftPageUp", null);
        __decorate([
            core.HostListener('keydown.home', ['$event'])
        ], IgxCalendarComponent.prototype, "onKeydownHome", null);
        __decorate([
            core.HostListener('keydown.end', ['$event'])
        ], IgxCalendarComponent.prototype, "onKeydownEnd", null);
        __decorate([
            core.HostListener('document:mouseup', ['$event'])
        ], IgxCalendarComponent.prototype, "onMouseUp", null);
        IgxCalendarComponent = IgxCalendarComponent_1 = __decorate([
            core.Component({
                providers: [
                    {
                        multi: true,
                        provide: forms.NG_VALUE_ACCESSOR,
                        useExisting: IgxCalendarComponent_1
                    }
                ],
                animations: [
                    animations.trigger('animateView', [
                        animations.transition('void => 0', animations.useAnimation(fadeIn)),
                        animations.transition('void => *', animations.useAnimation(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    animations.trigger('animateChange', [
                        animations.transition('* => prev', animations.useAnimation(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        animations.transition('* => next', animations.useAnimation(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-calendar',
                template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth let-obj>\n    <span tabindex=\"0\" #monthsBtn (keydown)=\"onActiveViewYearKB(getViewDate(obj.index), $event, obj.index)\" (click)=\"onActiveViewYear(getViewDate(obj.index), obj.index, $event)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedMonth(getViewDate(obj.index)) }}\n    </span>\n    <span tabindex=\"0\" #yearsBtn (keydown)=\"onActiveViewDecadeKB($event, getViewDate(obj.index), obj.index)\" (click)=\"onActiveViewDecade(getViewDate(obj.index), obj.index)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedYear(getViewDate(obj.index)) }}\n    </span>\n</ng-template>\n\n<div *ngIf=\"selection === 'single' && hasHeader\" class=\"igx-calendar__header\">\n    <h5 class=\"igx-calendar__header-year\">{{ formattedYear(headerDate) }}</h5>\n    <h2 class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</div>\n\n<div *ngIf=\"isDefaultView\" class=\"igx-calendar__body\" [@animateView]=\"activeView\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" #prevMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startPrevMonthScroll\" [stopScroll]=\"stopMonthScroll\"  [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div class=\"igx-calendar-picker__dates\" *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [style.width.%]=\"100/monthsViewNumber\" [attr.data-month]=\"i | IgxGetViewDate:viewDate:false\">\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: getContext(i)\">\n            </ng-container>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" #nextMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startNextMonthScroll\" [stopScroll]=\"stopMonthScroll\" [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <div style=\"display: flex\"\n        [@animateChange]=\"animationAction\"\n        (@animateChange.done)=\"animationDone($event)\">\n        <igx-days-view *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [changeDaysView]=\"true\" #days\n                [selection]=\"selection\"\n                [locale]=\"locale\"\n                [value]=\"value\"\n                [viewDate]=\"i | IgxGetViewDate:viewDate\"\n                [weekStart]=\"weekStart\"\n                [formatOptions]=\"formatOptions\"\n                [formatViews]=\"formatViews\"\n                [disabledDates]=\"disabledDates\"\n                [specialDates]=\"specialDates\"\n                [hideOutsideDays]=\"hideOutsideDays\"\n                (onViewChanging)=\"viewChanging($event)\"\n                (onDateSelection)=\"childClicked($event)\">\n        </igx-days-view>\n    </div>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\" [@animateView]=\"activeView\" #months\n                 [date]=\"viewDate\"\n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\"\n                 (onSelection)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"changeYear($event)\">\n</igx-years-view>\n"
            })
        ], IgxCalendarComponent);
        return IgxCalendarComponent;
    }(IgxMonthPickerBaseDirective));

    var NEXT_ID$g = 0;
    var IgxMonthPickerComponent = /** @class */ (function (_super) {
        __extends(IgxMonthPickerComponent, _super);
        function IgxMonthPickerComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Sets/gets the `id` of the month picker.
             * If not set, the `id` will have value `"igx-month-picker-0"`.
             */
            _this.id = "igx-month-picker-" + NEXT_ID$g++;
            /**
             * The default css class applied to the component.
             *
             * @hidden
             */
            _this.styleClass = true;
            /**
             * @hidden
             */
            _this.yearAction = '';
            return _this;
        }
        IgxMonthPickerComponent_1 = IgxMonthPickerComponent;
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.animationDone = function () {
            this.yearAction = '';
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.activeViewDecadeKB = function (event) {
            var _this = this;
            _super.prototype.activeViewDecadeKB.call(this, event);
            if (event.key === "ArrowRight" /* RIGHT_ARROW */ || event.key === "Right" /* RIGHT_ARROW_IE */) {
                event.preventDefault();
                this.nextYear();
            }
            if (event.key === "ArrowLeft" /* LEFT_ARROW */ || event.key === "Left" /* LEFT_ARROW_IE */) {
                event.preventDefault();
                this.previousYear();
            }
            requestAnimationFrame(function () {
                if (_this.dacadeView) {
                    _this.dacadeView.el.nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.activeViewDecade = function () {
            var _this = this;
            _super.prototype.activeViewDecade.call(this);
            requestAnimationFrame(function () {
                _this.dacadeView.el.nativeElement.focus();
            });
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.nextYear = function () {
            this.yearAction = 'next';
            this.viewDate = this.calendarModel.getNextYear(this.viewDate);
            this.selectDate(this.viewDate);
            this.onSelection.emit(this.selectedDates);
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.nextYearKB = function (event) {
            if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                event.preventDefault();
                event.stopPropagation();
                this.nextYear();
            }
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.previousYear = function () {
            this.yearAction = 'prev';
            this.viewDate = this.calendarModel.getPrevYear(this.viewDate);
            this.selectDate(this.viewDate);
            this.onSelection.emit(this.selectedDates);
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.previousYearKB = function (event) {
            if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                event.preventDefault();
                event.stopPropagation();
                this.previousYear();
            }
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.selectYear = function (event) {
            var _this = this;
            this.viewDate = new Date(event.getFullYear(), event.getMonth(), event.getDate());
            this.activeView = exports.CalendarView.DEFAULT;
            this.selectDate(event);
            this.onSelection.emit(this.selectedDates);
            requestAnimationFrame(function () {
                if (_this.yearsBtn) {
                    _this.yearsBtn.nativeElement.focus();
                }
            });
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.selectMonth = function (event) {
            this.selectDate(event);
            this.onSelection.emit(this.selectedDates);
        };
        /**
         * Selects a date.
         *```typescript
         * this.monPicker.selectDate(new Date(`2018-06-12`));
         *```
         */
        IgxMonthPickerComponent.prototype.selectDate = function (value) {
            if (!value) {
                return new Date();
            }
            // TO DO: to be refactored after discussion on the desired behavior
            _super.prototype.selectDate.call(this, value);
            this.viewDate = value;
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.writeValue = function (value) {
            // TO DO: to be refactored after discussion on the desired behavior
            if (value) {
                this.viewDate = this.selectedDates = value;
            }
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.onKeydownPageUp = function (event) {
            event.preventDefault();
            this.yearAction = 'prev';
            this.viewDate = this.calendarModel.getPrevYear(this.viewDate);
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.onKeydownPageDown = function (event) {
            event.preventDefault();
            this.yearAction = 'next';
            this.viewDate = this.calendarModel.getNextYear(this.viewDate);
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.onKeydownHome = function (event) {
            if (this.monthsView) {
                this.monthsView.el.nativeElement.focus();
                this.monthsView.onKeydownHome(event);
            }
        };
        /**
         * @hidden
         */
        IgxMonthPickerComponent.prototype.onKeydownEnd = function (event) {
            if (this.monthsView) {
                this.monthsView.el.nativeElement.focus();
                this.monthsView.onKeydownEnd(event);
            }
        };
        var IgxMonthPickerComponent_1;
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxMonthPickerComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('class.igx-calendar')
        ], IgxMonthPickerComponent.prototype, "styleClass", void 0);
        __decorate([
            core.ViewChild('months', { read: IgxMonthsViewComponent })
        ], IgxMonthPickerComponent.prototype, "monthsView", void 0);
        __decorate([
            core.ViewChild('decade', { read: IgxYearsViewComponent })
        ], IgxMonthPickerComponent.prototype, "dacadeView", void 0);
        __decorate([
            core.ViewChild('days', { read: IgxDaysViewComponent })
        ], IgxMonthPickerComponent.prototype, "daysView", void 0);
        __decorate([
            core.ViewChild('yearsBtn')
        ], IgxMonthPickerComponent.prototype, "yearsBtn", void 0);
        __decorate([
            core.HostListener('keydown.pageup', ['$event'])
        ], IgxMonthPickerComponent.prototype, "onKeydownPageUp", null);
        __decorate([
            core.HostListener('keydown.pagedown', ['$event'])
        ], IgxMonthPickerComponent.prototype, "onKeydownPageDown", null);
        __decorate([
            core.HostListener('keydown.home', ['$event'])
        ], IgxMonthPickerComponent.prototype, "onKeydownHome", null);
        __decorate([
            core.HostListener('keydown.end', ['$event'])
        ], IgxMonthPickerComponent.prototype, "onKeydownEnd", null);
        IgxMonthPickerComponent = IgxMonthPickerComponent_1 = __decorate([
            core.Component({
                providers: [
                    {
                        multi: true,
                        provide: forms.NG_VALUE_ACCESSOR,
                        useExisting: IgxMonthPickerComponent_1
                    }
                ],
                animations: [
                    animations.trigger('animateView', [
                        animations.transition('void => 0', animations.useAnimation(fadeIn)),
                        animations.transition('void => *', animations.useAnimation(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    animations.trigger('animateChange', [
                        animations.transition('* => prev', animations.useAnimation(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        animations.transition('* => next', animations.useAnimation(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-month-picker',
                template: "<div *ngIf=\"isDefaultView\" [@animateView]=\"activeView\" class=\"igx-calendar__body\" (swiperight)=\"previousYear()\" (swipeleft)=\"nextYear()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" (click)=\"previousYear()\" (keydown)=\"previousYearKB($event)\" [ngStyle]=\"{\n            'min-width.%': 25,\n            'left': 0\n        }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div [style.width.%]=\"100\">\n            <span tabindex=\"0\" #yearsBtn (keydown)=\"activeViewDecadeKB($event)\" (click)=\"activeViewDecade()\" class=\"igx-calendar-picker__date\">\n                {{ formattedYear(viewDate) }}\n            </span>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" (click)=\"nextYear()\" (keydown)=\"nextYearKB($event)\" [ngStyle]=\"{\n            'min-width.%': 25,\n            'right': 0\n        }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <igx-months-view [@animateChange]=\"yearAction\" #months\n                     (@animateChange.done)=\"animationDone()\"\n                     [date]=\"viewDate\"\n                     [locale]=\"locale\"\n                     [formatView]=\"formatViews.month\"\n                     [monthFormat]=\"formatOptions.month\"\n                     (onSelection)=\"selectMonth($event)\">\n    </igx-months-view>\n</div>\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"selectYear($event)\">\n</igx-years-view>\n"
            })
        ], IgxMonthPickerComponent);
        return IgxMonthPickerComponent;
    }(IgxMonthPickerBaseDirective));

    var IgxMonthViewSlotsCalendar = /** @class */ (function () {
        function IgxMonthViewSlotsCalendar() {
        }
        IgxMonthViewSlotsCalendar.prototype.transform = function (monthViews) {
            return new Array(monthViews);
        };
        IgxMonthViewSlotsCalendar = __decorate([
            core.Pipe({
                name: 'IgxMonthViewSlots'
            })
        ], IgxMonthViewSlotsCalendar);
        return IgxMonthViewSlotsCalendar;
    }());
    var IgxGetViewDateCalendar = /** @class */ (function () {
        function IgxGetViewDateCalendar() {
            this.calendar = new Calendar();
        }
        IgxGetViewDateCalendar.prototype.transform = function (index, viewDate, wholeDate) {
            if (wholeDate === void 0) { wholeDate = true; }
            var date = this.calendar.timedelta(viewDate, 'month', index);
            return wholeDate ? date : date.getMonth();
        };
        IgxGetViewDateCalendar = __decorate([
            core.Pipe({
                name: 'IgxGetViewDate'
            })
        ], IgxGetViewDateCalendar);
        return IgxGetViewDateCalendar;
    }());

    /**
     * @hidden
     */
    var IgxCalendarModule = /** @class */ (function () {
        function IgxCalendarModule() {
        }
        IgxCalendarModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxCalendarBaseDirective,
                    IgxMonthPickerBaseDirective,
                    IgxDayItemComponent,
                    IgxDaysViewComponent,
                    IgxCalendarComponent,
                    IgxCalendarHeaderTemplateDirective,
                    IgxCalendarMonthDirective,
                    IgxCalendarYearDirective,
                    IgxCalendarSubheaderTemplateDirective,
                    IgxCalendarScrollMonthDirective,
                    IgxMonthsViewComponent,
                    IgxYearsViewComponent,
                    IgxMonthPickerComponent,
                    IgxMonthViewSlotsCalendar,
                    IgxGetViewDateCalendar
                ],
                exports: [
                    IgxCalendarComponent,
                    IgxDaysViewComponent,
                    IgxMonthsViewComponent,
                    IgxYearsViewComponent,
                    IgxMonthPickerComponent,
                    IgxCalendarHeaderTemplateDirective,
                    IgxCalendarMonthDirective,
                    IgxCalendarYearDirective,
                    IgxCalendarSubheaderTemplateDirective
                ],
                imports: [common.CommonModule, forms.FormsModule, IgxIconModule]
            })
        ], IgxCalendarModule);
        return IgxCalendarModule;
    }());

    var NEXT_ID$h = 0;
    /**
     * IgxCardMedia is container for the card media section.
     * Use it to wrap images and videos.
     */
    var IgxCardMediaDirective = /** @class */ (function () {
        function IgxCardMediaDirective() {
            /** @hidden @internal */
            this.cssClass = 'igx-card__media';
            /**
             * An @Input property that sets the `width` and `min-width` style property
             * of the media container. If not provided it will be set to `auto`.
             *
             * @example
             * ```html
             * <igx-card-media width="300px"></igx-card-media>
             * ```
             */
            this.width = 'auto';
            /**
             * An @Input property that sets the `height` style property of the media container.
             * If not provided it will be set to `auto`.
             *
             * @example
             * ```html
             * <igx-card-media height="50%"></igx-card-media>
             * ```
             */
            this.height = 'auto';
            /**
             * An @Input property that sets the `role` attribute of the media container.
             */
            this.role = 'img';
        }
        __decorate([
            core.HostBinding('class.igx-card__media')
        ], IgxCardMediaDirective.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('style.width'),
            core.HostBinding('style.min-width'),
            core.Input()
        ], IgxCardMediaDirective.prototype, "width", void 0);
        __decorate([
            core.HostBinding('style.height'),
            core.Input()
        ], IgxCardMediaDirective.prototype, "height", void 0);
        __decorate([
            core.HostBinding('attr.role'),
            core.Input()
        ], IgxCardMediaDirective.prototype, "role", void 0);
        IgxCardMediaDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-media'
            })
        ], IgxCardMediaDirective);
        return IgxCardMediaDirective;
    }());
    /**
     * IgxCardHeader is container for the card header
     */
    var IgxCardHeaderComponent = /** @class */ (function () {
        function IgxCardHeaderComponent() {
            /** @hidden @internal */
            this.cssClass = 'igx-card-header';
            /**
             * An @Input property that sets the layout style of the header.
             * By default the header elements(thumbnail and title/subtitle) are aligned horizontally.
             *
             * @example
             * ```html
             * <igx-card-header [vertical]="true"></igx-card-header>
             * ```
             */
            this.vertical = false;
            /**
             * An @Input property that sets the value of the `role` attribute of the card header.
             * By default the value is set to `header`.
             *
             * @example
             * ```html
             * <igx-card-header role="header"></igx-card-header>
             * ```
             */
            this.role = 'header';
        }
        __decorate([
            core.HostBinding('class.igx-card-header')
        ], IgxCardHeaderComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('class.igx-card-header--vertical'),
            core.Input()
        ], IgxCardHeaderComponent.prototype, "vertical", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxCardHeaderComponent.prototype, "role", void 0);
        IgxCardHeaderComponent = __decorate([
            core.Component({
                selector: 'igx-card-header',
                template: "<div class=\"igx-card-header__thumbnail\">\n    <ng-content select=\"igx-avatar, igx-card-media, [igxCardThumbnail]\"></ng-content>\n</div>\n\n<div class=\"igx-card-header__titles\">\n    <ng-content select=\"\n        [igxCardHeaderTitle],\n        [igxCardHeaderSubtitle],\n        .igx-card-header__title,\n        .igx-card-header__subtitle\">\n    </ng-content>\n</div>\n\n<ng-content></ng-content>\n"
            })
        ], IgxCardHeaderComponent);
        return IgxCardHeaderComponent;
    }());
    /**
     * IgxCardThumbnail is container for the card thumbnail section.
     * Use it to wrap anything you want to be used as a thumbnail.
     */
    var IgxCardThumbnailDirective = /** @class */ (function () {
        function IgxCardThumbnailDirective() {
        }
        IgxCardThumbnailDirective = __decorate([
            core.Directive({
                selector: '[igxCardThumbnail]'
            })
        ], IgxCardThumbnailDirective);
        return IgxCardThumbnailDirective;
    }());
    /**
     * igxCardHeaderTitle is used to denote the header title in a card.
     * Use it to tag text nodes.
     */
    var IgxCardHeaderTitleDirective = /** @class */ (function () {
        function IgxCardHeaderTitleDirective() {
            /** @hidden @internal */
            this.cssClass = 'igx-card__header__title';
        }
        __decorate([
            core.HostBinding('class.igx-card-header__title')
        ], IgxCardHeaderTitleDirective.prototype, "cssClass", void 0);
        IgxCardHeaderTitleDirective = __decorate([
            core.Directive({
                selector: '[igxCardHeaderTitle]'
            })
        ], IgxCardHeaderTitleDirective);
        return IgxCardHeaderTitleDirective;
    }());
    /**
     * igxCardHeaderSubtitle is used to denote the header subtitle in a card.
     * Use it to tag text nodes.
     */
    var IgxCardHeaderSubtitleDirective = /** @class */ (function () {
        function IgxCardHeaderSubtitleDirective() {
            /** @hidden @internal */
            this.cssClass = 'igx-card-header__subtitle';
        }
        __decorate([
            core.HostBinding('class.igx-card-header__subtitle')
        ], IgxCardHeaderSubtitleDirective.prototype, "cssClass", void 0);
        IgxCardHeaderSubtitleDirective = __decorate([
            core.Directive({
                selector: '[igxCardHeaderSubtitle]'
            })
        ], IgxCardHeaderSubtitleDirective);
        return IgxCardHeaderSubtitleDirective;
    }());
    /**
     * IgxCardContent is container for the card content.
     */
    var IgxCardContentDirective = /** @class */ (function () {
        function IgxCardContentDirective() {
            /** @hidden @internal */
            this.cssClass = 'igx-card-content';
        }
        __decorate([
            core.HostBinding('class.igx-card-content')
        ], IgxCardContentDirective.prototype, "cssClass", void 0);
        IgxCardContentDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-content'
            })
        ], IgxCardContentDirective);
        return IgxCardContentDirective;
    }());
    /**
     * IgxCardFooter is container for the card footer
     */
    var IgxCardFooterDirective = /** @class */ (function () {
        function IgxCardFooterDirective() {
            /**
             * An @Input property that sets the value of the `role` attribute of the card footer.
             * By default the value is set to `footer`.
             *
             * @example
             * ```html
             * <igx-card-footer role="footer"></igx-card-footer>
             * ```
             */
            this.role = 'footer';
        }
        __decorate([
            core.HostBinding('attr.role'),
            core.Input()
        ], IgxCardFooterDirective.prototype, "role", void 0);
        IgxCardFooterDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-footer'
            })
        ], IgxCardFooterDirective);
        return IgxCardFooterDirective;
    }());
    /**
     * Card provides a way to display organized content in appealing way.
     *
     * @igxModule IgxCardModule
     *
     * @igxTheme igx-card-theme, igx-icon-theme, igx-button-theme
     *
     * @igxKeywords card, button, avatar, icon
     *
     * @igxGroup Layouts
     *
     * @remarks
     * The Ignite UI Card serves as a container that allows custom content to be organized in an appealing way. There are
     * five sections in a card that you can use to organize your content. These are header, media, content, actions, and footer.
     *
     * @example
     * ```html
     * <igx-card>
     *   <igx-card-header>
     *     <h3 igxCardHeaderTitle>{{title}}</h3>
     *     <h5 igxCardHeaderSubtitle>{{subtitle}}</h5>
     *   </igx-card-header>
     *   <igx-card-actions>
     *       <button igxButton igxRipple>Share</button>
     *       <button igxButton igxRipple>Play Album</button>
     *   </igx-card-actions>
     * </igx-card>
     * ```
     */

    (function (IgxCardType) {
        IgxCardType["ELEVATED"] = "elevated";
        IgxCardType["OUTLINED"] = "outlined";
    })(exports.IgxCardType || (exports.IgxCardType = {}));
    var IgxCardComponent = /** @class */ (function () {
        function IgxCardComponent() {
            /**
             * Sets/gets the `id` of the card.
             * If not set, `id` will have value `"igx-card-0"`;
             *
             * @example
             * ```html
             * <igx-card id = "my-first-card"></igx-card>
             * ```
             * ```typescript
             * let cardId =  this.card.id;
             * ```
             */
            this.id = "igx-card-" + NEXT_ID$h++;
            /**
             * An @Input property that sets the value of the `role` attribute of the card.
             * By default the value is set to `group`.
             *
             * @example
             * ```html
             * <igx-card role="group"></igx-card>
             * ```
             */
            this.role = 'group';
            /**
             * An @Input property that sets the value of the `type` attribute of the card.
             * By default the value is set to `default`. You can make the card use the
             * outlined style by setting the value to `outlined`.
             *
             * @example
             * ```html
             * <igx-card type="outlined"></igx-card>
             * ```
             */
            this.type = exports.IgxCardType.ELEVATED;
            /**
             * An @Input property that sets the value of the `horizontal` attribute of the card.
             * Setting this to `true` will make the different card sections align horizontally,
             * essentially flipping the card to the side.
             *
             * @example
             * ```html
             * <igx-card [horizontal]="true"></igx-card>
             * ```
             */
            this.horizontal = false;
        }
        Object.defineProperty(IgxCardComponent.prototype, "isOutlinedCard", {
            /**
             * A getter which will return true if the card type is `outlined`.
             */
            get: function () {
                return this.type === exports.IgxCardType.OUTLINED;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxCardComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('attr.role'),
            core.Input()
        ], IgxCardComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('class.igx-card'),
            core.Input()
        ], IgxCardComponent.prototype, "type", void 0);
        __decorate([
            core.HostBinding('class.igx-card--outlined')
        ], IgxCardComponent.prototype, "isOutlinedCard", null);
        __decorate([
            core.HostBinding('class.igx-card--horizontal'),
            core.Input()
        ], IgxCardComponent.prototype, "horizontal", void 0);
        IgxCardComponent = __decorate([
            core.Component({
                selector: 'igx-card',
                template: "<ng-container select='igx-card-media'></ng-container>\n\n<ng-container select='igx-card-header'></ng-container>\n<ng-container select='igx-card-content'>\n    <ng-content></ng-content>\n</ng-container>\n\n<ng-container select='igx-card-actions'></ng-container>\n"
            })
        ], IgxCardComponent);
        return IgxCardComponent;
    }());

    (function (IgxCardActionsLayout) {
        IgxCardActionsLayout["START"] = "start";
        IgxCardActionsLayout["JUSTIFY"] = "justify";
    })(exports.IgxCardActionsLayout || (exports.IgxCardActionsLayout = {}));
    /**
     * IgxCardActions is container for the card actions.
     */
    var IgxCardActionsComponent = /** @class */ (function () {
        function IgxCardActionsComponent(card) {
            this.card = card;
            this.isVerticalSet = false;
            /**
             * An @Input property that sets the layout style of the actions.
             * By default icons and icon buttons, as well as regular buttons
             * are split into two containers, which are then positioned on both ends
             * of the card-actions area.
             * You can justify the elements in those groups so they are positioned equally
             * from one another taking up all the space available along the card actions axis.
             *
             * @example
             * ```html
             * <igx-card-actions layout="justify"></igx-card-actions>
             * ```
             */
            this.layout = exports.IgxCardActionsLayout.START;
            /**
             * An @Input property that sets order of the buttons the actions area.
             * By default all icons/icon buttons are placed at the end of the action
             * area. Any regular buttons(flat, raised) will appear before the icons/icon buttons
             * placed in the actions area.
             * If you want to reverse their positions so that icons appear first, use the `reverse`
             * attribute.
             *
             * @example
             * ```html
             * <igx-card-actions [reverse]="true"></igx-card-actions>
             * ```
             */
            this.reverse = false;
        }
        Object.defineProperty(IgxCardActionsComponent.prototype, "isJustifyLayout", {
            /**
             * A getter that returns `true` when the layout has been
             * set to `justify`.
             */
            get: function () {
                return this.layout === exports.IgxCardActionsLayout.JUSTIFY;
            },
            enumerable: true,
            configurable: true
        });
        IgxCardActionsComponent.prototype.ngOnChanges = function (changes) {
            for (var prop in changes) {
                if (prop === 'vertical') {
                    this.isVerticalSet = true;
                }
            }
        };
        IgxCardActionsComponent.prototype.ngOnInit = function () {
            this.vertical = !this.isVerticalSet && this.card.horizontal;
        };
        IgxCardActionsComponent.ctorParameters = function () { return [
            { type: IgxCardComponent, decorators: [{ type: core.Optional }, { type: core.Inject, args: [IgxCardComponent,] }] }
        ]; };
        __decorate([
            core.HostBinding('class.igx-card-actions'),
            core.Input()
        ], IgxCardActionsComponent.prototype, "layout", void 0);
        __decorate([
            core.HostBinding('class.igx-card-actions--vertical'),
            core.Input()
        ], IgxCardActionsComponent.prototype, "vertical", void 0);
        __decorate([
            core.HostBinding('class.igx-card-actions--justify')
        ], IgxCardActionsComponent.prototype, "isJustifyLayout", null);
        __decorate([
            core.HostBinding('class.igx-card-actions--reverse'),
            core.Input()
        ], IgxCardActionsComponent.prototype, "reverse", void 0);
        IgxCardActionsComponent = __decorate([
            core.Component({
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-actions',
                template: "<div class=\"igx-card-actions__icons\">\n    <ng-content select=\"igx-icon, [igxButton='icon']\"></ng-content>\n</div>\n\n<div #buttons class=\"igx-card-actions__buttons\">\n    <ng-content select=\"[igxButton]\"></ng-content>\n</div>\n\n\n<ng-content></ng-content>\n"
            }),
            __param(0, core.Optional()), __param(0, core.Inject(IgxCardComponent))
        ], IgxCardActionsComponent);
        return IgxCardActionsComponent;
    }());
    /**
     * @hidden
     */
    var IgxCardModule = /** @class */ (function () {
        function IgxCardModule() {
        }
        IgxCardModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxCardComponent,
                    IgxCardHeaderComponent,
                    IgxCardMediaDirective,
                    IgxCardContentDirective,
                    IgxCardActionsComponent,
                    IgxCardFooterDirective,
                    IgxCardHeaderTitleDirective,
                    IgxCardHeaderSubtitleDirective,
                    IgxCardThumbnailDirective,
                ],
                exports: [
                    IgxCardComponent,
                    IgxCardHeaderComponent,
                    IgxCardMediaDirective,
                    IgxCardContentDirective,
                    IgxCardActionsComponent,
                    IgxCardFooterDirective,
                    IgxCardHeaderTitleDirective,
                    IgxCardHeaderSubtitleDirective,
                    IgxCardThumbnailDirective,
                ],
                imports: [common.CommonModule, IgxButtonModule]
            })
        ], IgxCardModule);
        return IgxCardModule;
    }());

    var IgxCarouselIndicatorDirective = /** @class */ (function () {
        function IgxCarouselIndicatorDirective() {
        }
        IgxCarouselIndicatorDirective = __decorate([
            core.Directive({
                selector: '[igxCarouselIndicator]'
            })
        ], IgxCarouselIndicatorDirective);
        return IgxCarouselIndicatorDirective;
    }());
    var IgxCarouselNextButtonDirective = /** @class */ (function () {
        function IgxCarouselNextButtonDirective() {
        }
        IgxCarouselNextButtonDirective = __decorate([
            core.Directive({
                selector: '[igxCarouselNextButton]'
            })
        ], IgxCarouselNextButtonDirective);
        return IgxCarouselNextButtonDirective;
    }());
    var IgxCarouselPrevButtonDirective = /** @class */ (function () {
        function IgxCarouselPrevButtonDirective() {
        }
        IgxCarouselPrevButtonDirective = __decorate([
            core.Directive({
                selector: '[igxCarouselPrevButton]'
            })
        ], IgxCarouselPrevButtonDirective);
        return IgxCarouselPrevButtonDirective;
    }());

    var Direction$1;
    (function (Direction) {
        Direction[Direction["NONE"] = 0] = "NONE";
        Direction[Direction["NEXT"] = 1] = "NEXT";
        Direction[Direction["PREV"] = 2] = "PREV";
    })(Direction$1 || (Direction$1 = {}));
    /**
     * A slide component that usually holds an image and/or a caption text.
     * IgxSlideComponent is usually a child component of an IgxCarouselComponent.
     *
     * ```
     * <igx-slide [input bindings] >
     *    <ng-content></ng-content>
     * </igx-slide>
     * ```
     *
     * @export
     */
    var IgxSlideComponent = /** @class */ (function () {
        function IgxSlideComponent(elementRef) {
            this.elementRef = elementRef;
            this._active = false;
            this._destroy$ = new rxjs.Subject();
            /**
             * Returns the class of the slide component.
             * ```typescript
             * let class =  this.slide.cssClass;
             * ```
             * @memberof IgxSlideComponent
             */
            this.cssClass = 'igx-slide';
            this.previous = false;
            /**
             *@hidden
             */
            this.activeChange = new core.EventEmitter();
        }
        Object.defineProperty(IgxSlideComponent.prototype, "tabIndex", {
            /**
             * Returns the `tabIndex` of the slide component.
             * ```typescript
             * let tabIndex =  this.carousel.tabIndex;
             * ```
             * @memberof IgxSlideComponent
             */
            get: function () {
                return this.active ? 0 : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSlideComponent.prototype, "ariaSelected", {
            /**
             * Returns the `aria-selected` of the slide.
             *
             * ```typescript
             * let slide = this.slide.ariaSelected;
             * ```
             *
             */
            get: function () {
                return this.active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSlideComponent.prototype, "ariaLive", {
            /**
             * Returns the `aria-live` of the slide.
             *
             * ```typescript
             * let slide = this.slide.ariaLive;
             * ```
             *
             */
            get: function () {
                return this.active ? 'polite' : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSlideComponent.prototype, "active", {
            /**
             * Gets/sets the `active` state of the slide.
             * ```html
             * <igx-carousel>
             *  <igx-slide [active] ="false"></igx-slide>
             * <igx-carousel>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-carousel>
             *  <igx-slide [(active)] ="model.isActive"></igx-slide>
             * <igx-carousel>
             * ```
             * @memberof IgxSlideComponent
             */
            get: function () {
                return this._active;
            },
            set: function (value) {
                this._active = !!value;
                this.activeChange.emit(this._active);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSlideComponent.prototype, "nativeElement", {
            /**
            * Returns a reference to the carousel element in the DOM.
            * ```typescript
            * let nativeElement =  this.slide.nativeElement;
            * ```
            * @memberof IgxSlideComponent
            */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSlideComponent.prototype, "isDestroyed", {
            /**
            * @hidden
            */
            get: function () {
                return this._destroy$;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxSlideComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next(true);
            this._destroy$.complete();
        };
        IgxSlideComponent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxSlideComponent.prototype, "index", void 0);
        __decorate([
            core.Input()
        ], IgxSlideComponent.prototype, "direction", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxSlideComponent.prototype, "tabIndex", null);
        __decorate([
            core.HostBinding('attr.aria-selected')
        ], IgxSlideComponent.prototype, "ariaSelected", null);
        __decorate([
            core.HostBinding('attr.aria-selected')
        ], IgxSlideComponent.prototype, "ariaLive", null);
        __decorate([
            core.HostBinding('class.igx-slide')
        ], IgxSlideComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('class.igx-slide--current'),
            core.Input()
        ], IgxSlideComponent.prototype, "active", null);
        __decorate([
            core.HostBinding('class.igx-slide--previous'),
            core.Input()
        ], IgxSlideComponent.prototype, "previous", void 0);
        __decorate([
            core.Output()
        ], IgxSlideComponent.prototype, "activeChange", void 0);
        IgxSlideComponent = __decorate([
            core.Component({
                selector: 'igx-slide',
                template: "<ng-content></ng-content>\n"
            })
        ], IgxSlideComponent);
        return IgxSlideComponent;
    }());

    var GridResourceStringsEN = {
        igx_grid_groupByArea_message: 'Drag a column header and drop it here to group by that column.',
        igx_grid_emptyFilteredGrid_message: 'No records found.',
        igx_grid_emptyGrid_message: 'Grid has no data.',
        igx_grid_filter: 'Filter',
        igx_grid_filter_row_close: 'Close',
        igx_grid_filter_row_reset: 'Reset',
        igx_grid_filter_row_placeholder: 'Add filter value',
        igx_grid_filter_row_boolean_placeholder: 'All',
        igx_grid_filter_row_date_placeholder: 'Pick up date',
        igx_grid_filter_operator_and: 'And',
        igx_grid_filter_operator_or: 'Or',
        igx_grid_complex_filter: 'Complex Filter',
        igx_grid_filter_contains: 'Contains',
        igx_grid_filter_doesNotContain: 'Does Not Contain',
        igx_grid_filter_startsWith: 'Starts With',
        igx_grid_filter_endsWith: 'Ends With',
        igx_grid_filter_equals: 'Equals',
        igx_grid_filter_doesNotEqual: 'Does Not Equal',
        igx_grid_filter_empty: 'Empty',
        igx_grid_filter_notEmpty: 'Not Empty',
        igx_grid_filter_null: 'Null',
        igx_grid_filter_notNull: 'Not Null',
        igx_grid_filter_before: 'Before',
        igx_grid_filter_after: 'After',
        igx_grid_filter_today: 'Today',
        igx_grid_filter_yesterday: 'Yesterday',
        igx_grid_filter_thisMonth: 'This Month',
        igx_grid_filter_lastMonth: 'Last Month',
        igx_grid_filter_nextMonth: 'Next Month',
        igx_grid_filter_thisYear: 'This Year',
        igx_grid_filter_lastYear: 'Last Year',
        igx_grid_filter_nextYear: 'Next Year',
        igx_grid_filter_greaterThan: 'Greater Than',
        igx_grid_filter_lessThan: 'Less Than',
        igx_grid_filter_greaterThanOrEqualTo: 'Greater Than Or Equal To',
        igx_grid_filter_lessThanOrEqualTo: 'Less Than Or Equal To',
        igx_grid_filter_true: 'True',
        igx_grid_filter_false: 'False',
        igx_grid_filter_all: 'All',
        igx_grid_filter_condition_placeholder: 'Select filter',
        igx_grid_summary_count: 'Count',
        igx_grid_summary_min: 'Min',
        igx_grid_summary_max: 'Max',
        igx_grid_summary_sum: 'Sum',
        igx_grid_summary_average: 'Avg',
        igx_grid_summary_earliest: 'Earliest',
        igx_grid_summary_latest: 'Latest',
        igx_grid_excel_filter_moving_left: 'move left',
        igx_grid_excel_filter_moving_left_short: 'left',
        igx_grid_excel_filter_moving_right: 'move right',
        igx_grid_excel_filter_moving_right_short: 'right',
        igx_grid_excel_filter_moving_header: 'move',
        igx_grid_excel_filter_sorting_asc: 'ascending',
        igx_grid_excel_filter_sorting_asc_short: 'asc',
        igx_grid_excel_filter_sorting_desc: 'descending',
        igx_grid_excel_filter_sorting_desc_short: 'desc',
        igx_grid_excel_filter_sorting_header: 'sort',
        igx_grid_excel_filter_clear: 'Clear column filters',
        igx_grid_excel_custom_dialog_add: 'add filter',
        igx_grid_excel_custom_dialog_clear: 'Clear filter',
        igx_grid_excel_custom_dialog_header: 'Custom auto-filter on column: ',
        igx_grid_excel_cancel: 'cancel',
        igx_grid_excel_apply: 'apply',
        igx_grid_excel_search_placeholder: 'Search',
        igx_grid_excel_select_all: 'Select All',
        igx_grid_excel_blanks: '(Blanks)',
        igx_grid_excel_hide: 'Hide column',
        igx_grid_excel_show: 'Show column',
        igx_grid_excel_pin: 'Pin column',
        igx_grid_excel_unpin: 'Unpin column',
        igx_grid_excel_text_filter: 'Text filter',
        igx_grid_excel_number_filter: 'Number filter',
        igx_grid_excel_date_filter: 'Date filter',
        igx_grid_excel_boolean_filter: 'Boolean filter',
        igx_grid_excel_custom_filter: 'Custom filter...',
        igx_grid_advanced_filter_title: 'Advanced Filtering',
        igx_grid_advanced_filter_and_group: '"And" Group',
        igx_grid_advanced_filter_or_group: '"Or" Group',
        igx_grid_advanced_filter_end_group: 'End Group',
        igx_grid_advanced_filter_create_and_group: 'Create "And" Group',
        igx_grid_advanced_filter_create_or_group: 'Create "Or" Group',
        igx_grid_advanced_filter_and_label: 'and',
        igx_grid_advanced_filter_or_label: 'or',
        igx_grid_advanced_filter_add_condition: 'Condition',
        igx_grid_advanced_filter_ungroup: 'Ungroup',
        igx_grid_advanced_filter_delete: 'Delete',
        igx_grid_advanced_filter_delete_filters: 'Delete filters',
        igx_grid_advanced_filter_initial_text: 'Start with creating a group of conditions linked with "And" or "Or"',
        igx_grid_advanced_filter_column_placeholder: 'Select column',
        igx_grid_advanced_filter_value_placeholder: 'Value'
    };

    var TimePickerResourceStringsEN = {
        igx_time_picker_ok: 'OK',
        igx_time_picker_cancel: 'Cancel'
    };

    var PaginatorResourceStringsEN = {
        igx_paginator_label: 'Items per page'
    };

    var CarouselResourceStringsEN = {
        igx_carousel_of: 'of'
    };

    /**
     * @hidden
     */
    var CurrentResourceStrings = {
        GridResStrings: cloneValue(GridResourceStringsEN),
        TimePickerResStrings: cloneValue(TimePickerResourceStringsEN),
        PaginatorResStrings: cloneValue(PaginatorResourceStringsEN),
        CarouselResStrings: cloneValue(CarouselResourceStringsEN),
    };
    function updateResourceStrings(currentStrings, newStrings) {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(newStrings)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (key in currentStrings) {
                    currentStrings[key] = newStrings[key];
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /**
     * Changes the resource strings for all components in the application
     * ```
     * @param resourceStrings to be applied
     */
    function changei18n(resourceStrings) {
        var e_2, _a;
        try {
            for (var _b = __values(Object.keys(CurrentResourceStrings)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                updateResourceStrings(CurrentResourceStrings[key], resourceStrings);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    /**
     * Returns current resource strings for all components
     */
    function getCurrentResourceStrings() {
        return __assign(__assign({}, CurrentResourceStrings.GridResStrings), CurrentResourceStrings.TimePickerResStrings);
    }

    var NEXT_ID$i = 0;

    (function (CarouselIndicatorsOrientation) {
        CarouselIndicatorsOrientation["bottom"] = "bottom";
        CarouselIndicatorsOrientation["top"] = "top";
    })(exports.CarouselIndicatorsOrientation || (exports.CarouselIndicatorsOrientation = {}));

    (function (CarouselAnimationType) {
        CarouselAnimationType["none"] = "none";
        CarouselAnimationType["slide"] = "slide";
        CarouselAnimationType["fade"] = "fade";
    })(exports.CarouselAnimationType || (exports.CarouselAnimationType = {}));
    var CarouselHammerConfig = /** @class */ (function (_super) {
        __extends(CarouselHammerConfig, _super);
        function CarouselHammerConfig() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.overrides = {
                pan: { direction: Hammer.DIRECTION_HORIZONTAL }
            };
            return _this;
        }
        CarouselHammerConfig = __decorate([
            core.Injectable()
        ], CarouselHammerConfig);
        return CarouselHammerConfig;
    }(platformBrowser.HammerGestureConfig));
    /**
     * **Ignite UI for Angular Carousel** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/carousel.html)
     *
     * The Ignite UI Carousel is used to browse or navigate through a collection of slides. Slides can contain custom
     * content such as images or cards and be used for things such as on-boarding tutorials or page-based interfaces.
     * It can be used as a separate fullscreen element or inside another component.
     *
     * Example:
     * ```html
     * <igx-carousel>
     *   <igx-slide>
     *     <h3>First Slide Header</h3>
     *     <p>First slide Content</p>
     *   <igx-slide>
     *   <igx-slide>
     *     <h3>Second Slide Header</h3>
     *     <p>Second Slide Content</p>
     * </igx-carousel>
     * ```
     */
    var IgxCarouselComponent = /** @class */ (function () {
        function IgxCarouselComponent(element, iterableDiffers, builder, platformUtil) {
            this.element = element;
            this.iterableDiffers = iterableDiffers;
            this.builder = builder;
            this.platformUtil = platformUtil;
            /**
             * Returns the `role` attribute of the carousel.
             * ```typescript
             * let carouselRole =  this.carousel.role;
             * ```
             * @memberof IgxCarouselComponent
             */
            this.role = 'region';
            /**
             * Sets the `id` of the carousel.
             * If not set, the `id` of the first carousel component will be `"igx-carousel-0"`.
             * ```html
             * <igx-carousel id="my-first-carousel"></igx-carousel>
             * ```
             * @memberof IgxCarouselComponent
             */
            this.id = "igx-carousel-" + NEXT_ID$i++;
            /**
             * Returns the `aria-label` of the carousel.
             *
             * ```typescript
             * let carousel = this.carousel.ariaLabel;
             * ```
             *
             */
            this.ariaLabel = 'carousel';
            /**
             * Returns the class of the carousel component.
             * ```typescript
             * let class =  this.carousel.cssClass;
             * ```
             * @memberof IgxCarouselComponent
             */
            this.cssClass = 'igx-carousel';
            /**
             * Sets whether the carousel should `loop` back to the first slide after reaching the last slide.
             * Default value is `true`.
             * ```html
             * <igx-carousel [loop]="false"></igx-carousel>
             * ```
             * @memberOf IgxCarouselComponent
             */
            this.loop = true;
            /**
             * Sets whether the carousel will `pause` the slide transitions on user interactions.
             * Default value is `true`.
             * ```html
             *  <igx-carousel [pause]="false"></igx-carousel>
             * ```
             * @memberOf IgxCarouselComponent
             */
            this.pause = true;
            /**
             * Controls whether the carousel should render the left/right `navigation` buttons.
             * Default value is `true`.
             * ```html
             * <igx-carousel [navigation] = "false"></igx-carousel>
             * ```
             * @memberOf IgxCarouselComponent
             */
            this.navigation = true;
            /**
            * Controls whether the carousel should support keyboard navigation.
            * Default value is `true`.
            * ```html
            * <igx-carousel [keyboardSupport] = "false"></igx-carousel>
            * ```
            * @memberOf IgxCarouselComponent
            */
            this.keyboardSupport = true;
            /**
          * Controls whether the carousel should support gestures.
          * Default value is `true`.
          * ```html
          * <igx-carousel [gesturesSupport] = "false"></igx-carousel>
          * ```
          * @memberOf IgxCarouselComponent
          */
            this.gesturesSupport = true;
            /**
             * Controls the maximum indexes that can be shown.
             * Default value is `5`.
             * ```html
             * <igx-carousel [maximumIndicatorsCount] = "10"></igx-carousel>
             * ```
             * @memberOf IgxCarouselComponent
             */
            this.maximumIndicatorsCount = 5;
            /**
            * Gets/sets the display mode of carousel indicators. It can be top or bottom.
            * Default value is `bottom`.
            * ```html
            * <igx-carousel indicatorsOrientation='top'>
            * <igx-carousel>
            * ```
            * @memberOf IgxSlideComponent
            */
            this.indicatorsOrientation = exports.CarouselIndicatorsOrientation.bottom;
            /**
           * Gets/sets the animation type of carousel.
           * Default value is `slide`.
           * ```html
           * <igx-carousel animationType='none'>
           * <igx-carousel>
           * ```
           * @memberOf IgxSlideComponent
           */
            this.animationType = exports.CarouselAnimationType.slide;
            /**
             * The custom template, if any, that should be used when rendering carousel indicators
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.carousel.indicatorTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-carousel #carousel>
             *      ...
             *      <ng-template igxCarouselIndicator let-slide>
             *         <igx-icon *ngIf="slide.active"  fontSet="material">brightness_7</igx-icon>
             *         <igx-icon *ngIf="!slide.active"  fontSet="material">brightness_5</igx-icon>
             *      </ng-template>
             *  </igx-carousel>
             * ```
             */
            this.indicatorTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering carousel next button
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.carousel.nextButtonTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-carousel #carousel>
             *      ...
             *      <ng-template igxCarouselNextButton let-disabled>
             *            <button igxButton="fab" igxRipple="white" [disabled]="disabled">
             *                <igx-icon fontSet="material">add</igx-icon>
             *           </button>
             *      </ng-template>
             *  </igx-carousel>
             * ```
             */
            this.nextButtonTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering carousel previous button
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.carousel.nextButtonTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-carousel #carousel>
             *      ...
             *      <ng-template igxCarouselPrevButton let-disabled>
             *            <button igxButton="fab" igxRipple="white" [disabled]="disabled">
             *                <igx-icon fontSet="material">remove</igx-icon>
             *           </button>
             *      </ng-template>
             *  </igx-carousel>
             * ```
             */
            this.prevButtonTemplate = null;
            /**
             * An event that is emitted after a slide transition has happened.
             * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
             * ```html
             * <igx-carousel (onSlideChanged)="onSlideChanged($event)"></igx-carousel>
             * ```
             * @memberOf IgxCarouselComponent
             */
            this.onSlideChanged = new core.EventEmitter();
            /**
             * An event that is emitted after a slide has been added to the carousel.
             * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
             * ```html
             * <igx-carousel (onSlideAdded)="onSlideAdded($event)"></igx-carousel>
             * ```
             * @memberOf IgxCarouselComponent
             */
            this.onSlideAdded = new core.EventEmitter();
            /**
             * An event that is emitted after a slide has been removed from the carousel.
             * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
             * ```html
             * <igx-carousel (onSlideRemoved)="onSlideRemoved($event)"></igx-carousel>
             * ```
             * @memberOf IgxCarouselComponent
             */
            this.onSlideRemoved = new core.EventEmitter();
            /**
             * An event that is emitted after the carousel has been paused.
             * Provides a reference to the `IgxCarouselComponent` as an event argument.
             * ```html
             * <igx-carousel (onCarouselPaused)="onCarouselPaused($event)"></igx-carousel>
             * ```
             * @memberOf IgxCarouselComponent
             */
            this.onCarouselPaused = new core.EventEmitter();
            /**
             * An event that is emitted after the carousel has resumed transitioning between `slides`.
             * Provides a reference to the `IgxCarouselComponent` as an event argument.
             * ```html
             * <igx-carousel (onCarouselPlaying)="onCarouselPlaying($event)"></igx-carousel>
             * ```
             * @memberOf IgxCarouselComponent
             */
            this.onCarouselPlaying = new core.EventEmitter();
            this._resourceStrings = CurrentResourceStrings.CarouselResStrings;
            this.destroy$ = new rxjs.Subject();
            this.differ = null;
            this.animationDuration = 320;
            this.animationPosition = 0;
            this.newDuration = 0;
            this.differ = this.iterableDiffers.find([]).create(null);
        }
        Object.defineProperty(IgxCarouselComponent.prototype, "tabIndex", {
            /**
             * Returns the `tabIndex` of the carousel component.
             * ```typescript
             * let tabIndex =  this.carousel.tabIndex;
             * ```
             * @memberof IgxCarouselComponent
             */
            get: function () {
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "touchAction", {
            /**
            * Gets the `touch-action` style of the `list item`.
            * ```typescript
            * let touchAction = this.listItem.touchAction;
            * ```
            */
            get: function () {
                return this.gesturesSupport ? 'pan-y' : 'auto';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "interval", {
            /**
             * Returns the time `interval` in milliseconds before the slide changes.
             * ```typescript
             * let timeInterval = this.carousel.interval;
             * ```
             * @memberof IgxCarouselComponent
             */
            get: function () {
                return this._interval;
            },
            /**
             * Sets the time `interval` in milliseconds before the slide changes.
             * If not set, the carousel will not change `slides` automatically.
             * ```html
             * <igx-carousel [interval] = "1000"></igx-carousel>
             * ```
             * @memberof IgxCarouselComponent
             */
            set: function (value) {
                this._interval = +value;
                this.restartInterval();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "resourceStrings", {
            /**
             * An accessor that returns the resource strings.
            */
            get: function () {
                return this._resourceStrings;
            },
            /**
            * An accessor that sets the resource strings.
            * By default it uses EN resources.
            */
            set: function (value) {
                this._resourceStrings = Object.assign({}, this._resourceStrings, value);
            },
            enumerable: true,
            configurable: true
        });
        /** @hidden */
        IgxCarouselComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.slides.changes
                .pipe(operators.takeUntil(this.destroy$))
                .subscribe(function (change) { _this.initSlides(change); });
            this.initSlides(this.slides);
        };
        /** @hidden */
        IgxCarouselComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
            this.destroyed = true;
            if (this.lastInterval) {
                clearInterval(this.lastInterval);
            }
        };
        IgxCarouselComponent.prototype.unsubscriber = function (slide) {
            return rxjs.merge(this.destroy$, slide.isDestroyed);
        };
        IgxCarouselComponent.prototype.onSlideActivated = function (slide) {
            var _this = this;
            if (slide.active && slide !== this.currentSlide) {
                if (slide.direction === Direction$1.NONE) {
                    var newIndex = slide.index;
                    slide.direction = newIndex > this.current ? Direction$1.NEXT : Direction$1.PREV;
                }
                if (this.currentSlide) {
                    var animationWasStarted = this.finishAnimations();
                    this.currentSlide.direction = slide.direction;
                    this.currentSlide.active = false;
                    this.previousSlide = this.currentSlide;
                    this.currentSlide = slide;
                    if (this.animationType !== exports.CarouselAnimationType.none) {
                        if (animationWasStarted) {
                            requestAnimationFrame(function () {
                                _this.playAnimations();
                            });
                        }
                        else {
                            this.playAnimations();
                        }
                    }
                }
                else {
                    this.currentSlide = slide;
                }
                this.onSlideChanged.emit({ carousel: this, slide: slide });
                this.restartInterval();
            }
        };
        IgxCarouselComponent.prototype.playAnimations = function () {
            this.playLeaveAnimation();
            this.playEnterAnimation();
        };
        IgxCarouselComponent.prototype.finishAnimations = function () {
            var animationWasStarted = false;
            if (this.previousSlide && this.previousSlide.previous) {
                this.previousSlide.previous = false;
            }
            if (this.leaveAnimationPlayer) {
                animationWasStarted = true;
                this.leaveAnimationPlayer.finish();
            }
            if (this.enterAnimationPlayer) {
                animationWasStarted = true;
                this.enterAnimationPlayer.finish();
            }
            return animationWasStarted;
        };
        IgxCarouselComponent.prototype.getAnimation = function () {
            var duration;
            if (this.newDuration) {
                duration = this.animationPosition ? this.animationPosition * this.newDuration : this.newDuration;
            }
            else {
                duration = this.animationPosition ? this.animationPosition * this.animationDuration : this.animationDuration;
            }
            switch (this.animationType) {
                case exports.CarouselAnimationType.slide:
                    var trans = this.animationPosition ? this.animationPosition * 100 : 100;
                    return {
                        enterAnimation: animations.useAnimation(slideInLeft, {
                            params: {
                                delay: '0s',
                                duration: duration + "ms",
                                endOpacity: 1,
                                startOpacity: 1,
                                fromPosition: "translateX(" + (this.currentSlide.direction === 1 ? trans : -trans) + "%)",
                                toPosition: 'translateX(0%)'
                            }
                        }),
                        leaveAnimation: animations.useAnimation(slideInLeft, {
                            params: {
                                delay: '0s',
                                duration: duration + "ms",
                                endOpacity: 1,
                                startOpacity: 1,
                                fromPosition: "translateX(0%)",
                                toPosition: "translateX(" + (this.currentSlide.direction === 1 ? -trans : trans) + "%)",
                            }
                        })
                    };
                case exports.CarouselAnimationType.fade:
                    return {
                        enterAnimation: animations.useAnimation(fadeIn, { params: { duration: duration + "ms", startOpacity: "" + this.animationPosition } }),
                        leaveAnimation: null
                    };
            }
            return {
                enterAnimation: null,
                leaveAnimation: null
            };
        };
        IgxCarouselComponent.prototype.playEnterAnimation = function () {
            var _this = this;
            if (!this.getAnimation().enterAnimation) {
                return;
            }
            var animationBuilder = this.builder.build(this.getAnimation().enterAnimation);
            this.enterAnimationPlayer = animationBuilder.create(this.currentSlide.nativeElement);
            this.enterAnimationPlayer.onDone(function () {
                if (_this.enterAnimationPlayer) {
                    _this.enterAnimationPlayer.reset();
                    _this.enterAnimationPlayer = null;
                }
                _this.animationPosition = 0;
                _this.newDuration = 0;
                _this.previousSlide.previous = false;
            });
            this.previousSlide.previous = true;
            this.enterAnimationPlayer.play();
        };
        IgxCarouselComponent.prototype.playLeaveAnimation = function () {
            var _this = this;
            if (!this.getAnimation().leaveAnimation) {
                return;
            }
            var animationBuilder = this.builder.build(this.getAnimation().leaveAnimation);
            this.leaveAnimationPlayer = animationBuilder.create(this.previousSlide.nativeElement);
            this.leaveAnimationPlayer.onDone(function () {
                if (_this.leaveAnimationPlayer) {
                    _this.leaveAnimationPlayer.reset();
                    _this.leaveAnimationPlayer = null;
                }
                _this.animationPosition = 0;
                _this.newDuration = 0;
            });
            this.leaveAnimationPlayer.play();
        };
        IgxCarouselComponent.prototype.initSlides = function (change) {
            var _this = this;
            var diff = this.differ.diff(change.toArray());
            if (diff) {
                this.slides.reduce(function (any, c, ind) { return c.index = ind; }, 0); // reset slides indexes
                diff.forEachAddedItem(function (record) {
                    var slide = record.item;
                    _this.onSlideAdded.emit({ carousel: _this, slide: slide });
                    if (slide.active) {
                        _this.currentSlide = slide;
                    }
                    slide.activeChange.pipe(operators.takeUntil(_this.unsubscriber(slide))).subscribe(function () { return _this.onSlideActivated(slide); });
                });
                diff.forEachRemovedItem(function (record) {
                    var slide = record.item;
                    _this.onSlideRemoved.emit({ carousel: _this, slide: slide });
                    if (slide.active) {
                        slide.active = false;
                        _this.currentSlide = _this.get(slide.index < _this.total ? slide.index : _this.total - 1);
                    }
                });
                this.updateSlidesSelection();
            }
        };
        IgxCarouselComponent.prototype.updateSlidesSelection = function () {
            var _this = this;
            requestAnimationFrame(function () {
                if (_this.currentSlide) {
                    _this.currentSlide.active = true;
                    var activeSlides = _this.slides.filter(function (slide) { return slide.active && slide.index !== _this.currentSlide.index; });
                    activeSlides.forEach(function (slide) { slide.active = false; });
                }
                else if (_this.total) {
                    _this.slides.first.active = true;
                }
                _this.play();
            });
        };
        Object.defineProperty(IgxCarouselComponent.prototype, "getIndicatorTemplate", {
            /** @hidden */
            get: function () {
                if (this.indicatorTemplate) {
                    return this.indicatorTemplate;
                }
                return this.defaultIndicator;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "getNextButtonTemplate", {
            /** @hidden */
            get: function () {
                if (this.nextButtonTemplate) {
                    return this.nextButtonTemplate;
                }
                return this.defaultNextButton;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "getPrevButtonTemplate", {
            /** @hidden */
            get: function () {
                if (this.prevButtonTemplate) {
                    return this.prevButtonTemplate;
                }
                return this.defaultPrevButton;
            },
            enumerable: true,
            configurable: true
        });
        /** @hidden */
        IgxCarouselComponent.prototype.setAriaLabel = function (slide) {
            return "Item " + (slide.index + 1) + " of " + this.total;
        };
        Object.defineProperty(IgxCarouselComponent.prototype, "indicatorsOrientationClass", {
            /** @hidden */
            get: function () {
                return "igx-carousel-indicators--" + this.indicatorsOrientation;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "showIndicators", {
            /** @hidden */
            get: function () {
                return this.total <= this.maximumIndicatorsCount && this.total > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "showIndicatorsLabel", {
            /** @hidden */
            get: function () {
                return this.total > this.maximumIndicatorsCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "getCarouselLabel", {
            /** @hidden */
            get: function () {
                return this.current + 1 + " " + this.resourceStrings.igx_carousel_of + " " + this.total;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "total", {
            /**
             * Returns the total number of `slides` in the carousel.
             * ```typescript
             * let slideCount =  this.carousel.total;
             * ```
             * @memberOf IgxCarouselComponent
             */
            get: function () {
                return this.slides.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "current", {
            /**
             * The index of the slide being currently shown.
             * ```typescript
             * let currentSlideNumber =  this.carousel.current;
             * ```
             * @memberOf IgxCarouselComponent
             */
            get: function () {
                return !this.currentSlide ? 0 : this.currentSlide.index;
            },
            enumerable: true,
            configurable: true
        });
        IgxCarouselComponent.prototype.getNextIndex = function () {
            return (this.current + 1) % this.total;
        };
        IgxCarouselComponent.prototype.getPrevIndex = function () {
            return this.current - 1 < 0 ? this.total - 1 : this.current - 1;
        };
        Object.defineProperty(IgxCarouselComponent.prototype, "isPlaying", {
            /**
             * Returns a boolean indicating if the carousel is playing.
             * ```typescript
             * let isPlaying =  this.carousel.isPlaying;
             * ```
             * @memberOf IgxCarouselComponent
             */
            get: function () {
                return this.playing;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "isDestroyed", {
            /**
             * Returns а boolean indicating if the carousel is destroyed.
             * ```typescript
             * let isDestroyed =  this.carousel.isDestroyed;
             * ```
             * @memberOf IgxCarouselComponent
             */
            get: function () {
                return this.destroyed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "nativeElement", {
            /**
             * Returns a reference to the carousel element in the DOM.
             * ```typescript
             * let nativeElement =  this.carousel.nativeElement;
             * ```
             * @memberof IgxCarouselComponent
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the slide corresponding to the provided `index` or null.
         * ```typescript
         * let slide1 =  this.carousel.get(1);
         * ```
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.get = function (index) {
            return this.slides.find(function (slide) { return slide.index === index; });
        };
        /**
         * Adds a new slide to the carousel.
         * ```typescript
         * this.carousel.add(newSlide);
         * ```
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.add = function (slide) {
            var newSlides = this.slides.toArray();
            newSlides.push(slide);
            this.slides.reset(newSlides);
            this.slides.notifyOnChanges();
        };
        /**
         * Removes a slide from the carousel.
         * ```typescript
         * this.carousel.remove(slide);
         * ```
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.remove = function (slide) {
            if (slide && slide === this.get(slide.index)) { // check if the requested slide for delete is present in the carousel
                var newSlides = this.slides.toArray();
                newSlides.splice(slide.index, 1);
                this.slides.reset(newSlides);
                this.slides.notifyOnChanges();
            }
        };
        /**
         * Kicks in a transition for a given slide with a given `direction`.
         * ```typescript
         * this.carousel.select(this.carousel.get(2), Direction.NEXT);
         * ```
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.select = function (slide, direction) {
            if (direction === void 0) { direction = Direction$1.NONE; }
            if (slide && slide !== this.currentSlide) {
                slide.direction = direction;
                slide.active = true;
            }
        };
        /**
         * Transitions to the next slide in the carousel.
         * ```typescript
         * this.carousel.next();
         * ```
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.next = function () {
            var index = this.getNextIndex();
            if (index === 0 && !this.loop) {
                this.stop();
                return;
            }
            return this.select(this.get(index), Direction$1.NEXT);
        };
        /**
         * Transitions to the previous slide in the carousel.
         * ```typescript
         * this.carousel.prev();
         * ```
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.prev = function () {
            var index = this.getPrevIndex();
            if (!this.loop && index === this.total - 1) {
                this.stop();
                return;
            }
            return this.select(this.get(index), Direction$1.PREV);
        };
        /**
         * Resumes playing of the carousel if in paused state.
         * No operation otherwise.
         * ```typescript
         * this.carousel.play();
         * }
         * ```
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.play = function () {
            if (!this.playing) {
                this.playing = true;
                this.onCarouselPlaying.emit(this);
                this.restartInterval();
                this.stoppedByInteraction = false;
            }
        };
        /**
         * Stops slide transitions if the `pause` option is set to `true`.
         * No operation otherwise.
         * ```typescript
         *  this.carousel.stop();
         * }
         * ```
         * @memberOf IgxCarouselComponent
         */
        IgxCarouselComponent.prototype.stop = function () {
            if (this.pause) {
                this.playing = false;
                this.onCarouselPaused.emit(this);
                this.resetInterval();
            }
        };
        IgxCarouselComponent.prototype.resetInterval = function () {
            if (this.lastInterval) {
                clearInterval(this.lastInterval);
                this.lastInterval = null;
            }
        };
        IgxCarouselComponent.prototype.restartInterval = function () {
            var _this = this;
            this.resetInterval();
            if (!isNaN(this.interval) && this.interval > 0 && this.platformUtil.isBrowser) {
                this.lastInterval = setInterval(function () {
                    var tick = +_this.interval;
                    if (_this.playing && _this.total && !isNaN(tick) && tick > 0) {
                        _this.next();
                    }
                    else {
                        _this.stop();
                    }
                }, this.interval);
            }
        };
        Object.defineProperty(IgxCarouselComponent.prototype, "nextButtonDisabled", {
            /** @hidden */
            get: function () {
                return !this.loop && this.current === (this.total - 1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCarouselComponent.prototype, "prevButtonDisabled", {
            /** @hidden */
            get: function () {
                return !this.loop && this.current === 0;
            },
            enumerable: true,
            configurable: true
        });
        /** @hidden */
        IgxCarouselComponent.prototype.onKeydownArrowRight = function (event) {
            var _this = this;
            if (this.keyboardSupport) {
                event.preventDefault();
                this.next();
                requestAnimationFrame(function () { return _this.nativeElement.focus(); });
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onKeydownArrowLeft = function (event) {
            var _this = this;
            if (this.keyboardSupport) {
                event.preventDefault();
                this.prev();
                requestAnimationFrame(function () { return _this.nativeElement.focus(); });
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onTap = function (event) {
            // play pause only when tap on slide
            if (event.target && event.target.classList.contains('igx-slide')) {
                if (this.isPlaying) {
                    if (this.pause) {
                        this.stoppedByInteraction = true;
                    }
                    this.stop();
                }
                else if (this.stoppedByInteraction) {
                    this.play();
                }
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onKeydownHome = function (event) {
            var _this = this;
            if (this.keyboardSupport && this.slides.length > 0) {
                event.preventDefault();
                this.slides.first.active = true;
                requestAnimationFrame(function () { return _this.nativeElement.focus(); });
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onKeydownEnd = function (event) {
            var _this = this;
            if (this.keyboardSupport && this.slides.length > 0) {
                event.preventDefault();
                this.slides.last.active = true;
                requestAnimationFrame(function () { return _this.nativeElement.focus(); });
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onMouseEnter = function () {
            if (this.pause && this.isPlaying) {
                this.stoppedByInteraction = true;
            }
            this.stop();
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onMouseLeave = function () {
            if (this.stoppedByInteraction) {
                this.play();
            }
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onPanLeft = function (event) {
            this.pan(event);
        };
        /** @hidden */
        IgxCarouselComponent.prototype.onPanRight = function (event) {
            this.pan(event);
        };
        IgxCarouselComponent.prototype.resetSlideStyles = function (slide) {
            slide.nativeElement.style.transform = '';
            slide.nativeElement.style.opacity = '';
        };
        IgxCarouselComponent.prototype.pan = function (event) {
            var slideWidth = this.currentSlide.nativeElement.offsetWidth;
            var panOffset = (slideWidth / 1000);
            var deltaX = event.deltaX;
            var index = deltaX < 0 ? this.getNextIndex() : this.getPrevIndex();
            var offset = deltaX < 0 ? slideWidth + deltaX : -slideWidth + deltaX;
            if (!this.gesturesSupport || event.isFinal || Math.abs(deltaX) + panOffset >= slideWidth) {
                return;
            }
            if (!this.loop && ((this.current === 0 && deltaX > 0) || (this.current === this.total - 1 && deltaX < 0))) {
                this.incomingSlide = null;
                return;
            }
            event.preventDefault();
            if (this.isPlaying) {
                this.stoppedByInteraction = true;
                this.stop();
            }
            this.finishAnimations();
            if (this.incomingSlide) {
                if (index !== this.incomingSlide.index) {
                    this.resetSlideStyles(this.incomingSlide);
                    this.incomingSlide.previous = false;
                    this.incomingSlide = this.get(index);
                }
            }
            else {
                this.incomingSlide = this.get(index);
            }
            this.incomingSlide.previous = true;
            if (this.animationType === exports.CarouselAnimationType.fade) {
                this.currentSlide.nativeElement.style.opacity = "" + Math.abs(offset) / slideWidth;
            }
            else {
                this.currentSlide.nativeElement.style.transform = "translateX(" + deltaX + "px)";
                this.incomingSlide.nativeElement.style.transform = "translateX(" + offset + "px)";
            }
        };
        /**
        * @hidden
        */
        IgxCarouselComponent.prototype.onPanEnd = function (event) {
            if (!this.gesturesSupport) {
                return;
            }
            event.preventDefault();
            var slideWidth = this.currentSlide.nativeElement.offsetWidth;
            var panOffset = (slideWidth / 1000);
            var deltaX = Math.abs(event.deltaX) + panOffset < slideWidth ? Math.abs(event.deltaX) : slideWidth - panOffset;
            var velocity = Math.abs(event.velocity);
            this.resetSlideStyles(this.currentSlide);
            if (this.incomingSlide) {
                this.resetSlideStyles(this.incomingSlide);
                if (slideWidth / 2 < deltaX || velocity > 1) {
                    this.incomingSlide.direction = event.deltaX < 0 ? Direction$1.NEXT : Direction$1.PREV;
                    this.incomingSlide.previous = false;
                    this.animationPosition = this.animationType === exports.CarouselAnimationType.fade ?
                        deltaX / slideWidth : (slideWidth - deltaX) / slideWidth;
                    if (velocity > 1) {
                        this.newDuration = this.animationDuration / velocity;
                    }
                    this.incomingSlide.active = true;
                }
                else {
                    this.currentSlide.direction = event.deltaX > 0 ? Direction$1.NEXT : Direction$1.PREV;
                    this.previousSlide = this.incomingSlide;
                    this.previousSlide.previous = true;
                    this.animationPosition = this.animationType === exports.CarouselAnimationType.fade ?
                        Math.abs((slideWidth - deltaX) / slideWidth) : deltaX / slideWidth;
                    this.playAnimations();
                }
            }
            if (this.stoppedByInteraction) {
                this.play();
            }
        };
        IgxCarouselComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.IterableDiffers },
            { type: animations.AnimationBuilder },
            { type: PlatformUtil }
        ]; };
        __decorate([
            core.HostBinding('attr.role')
        ], IgxCarouselComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxCarouselComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('attr.aria-label')
        ], IgxCarouselComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxCarouselComponent.prototype, "tabIndex", null);
        __decorate([
            core.HostBinding('class.igx-carousel')
        ], IgxCarouselComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('style.touch-action')
        ], IgxCarouselComponent.prototype, "touchAction", null);
        __decorate([
            core.Input()
        ], IgxCarouselComponent.prototype, "loop", void 0);
        __decorate([
            core.Input()
        ], IgxCarouselComponent.prototype, "pause", void 0);
        __decorate([
            core.Input()
        ], IgxCarouselComponent.prototype, "interval", null);
        __decorate([
            core.Input()
        ], IgxCarouselComponent.prototype, "navigation", void 0);
        __decorate([
            core.Input()
        ], IgxCarouselComponent.prototype, "keyboardSupport", void 0);
        __decorate([
            core.Input()
        ], IgxCarouselComponent.prototype, "gesturesSupport", void 0);
        __decorate([
            core.Input()
        ], IgxCarouselComponent.prototype, "maximumIndicatorsCount", void 0);
        __decorate([
            core.Input()
        ], IgxCarouselComponent.prototype, "indicatorsOrientation", void 0);
        __decorate([
            core.Input()
        ], IgxCarouselComponent.prototype, "animationType", void 0);
        __decorate([
            core.Input()
        ], IgxCarouselComponent.prototype, "resourceStrings", null);
        __decorate([
            core.ViewChild('defaultIndicator', { read: core.TemplateRef, static: true })
        ], IgxCarouselComponent.prototype, "defaultIndicator", void 0);
        __decorate([
            core.ViewChild('defaultNextButton', { read: core.TemplateRef, static: true })
        ], IgxCarouselComponent.prototype, "defaultNextButton", void 0);
        __decorate([
            core.ViewChild('defaultPrevButton', { read: core.TemplateRef, static: true })
        ], IgxCarouselComponent.prototype, "defaultPrevButton", void 0);
        __decorate([
            core.ContentChild(IgxCarouselIndicatorDirective, { read: core.TemplateRef, static: false })
        ], IgxCarouselComponent.prototype, "indicatorTemplate", void 0);
        __decorate([
            core.ContentChild(IgxCarouselNextButtonDirective, { read: core.TemplateRef, static: false })
        ], IgxCarouselComponent.prototype, "nextButtonTemplate", void 0);
        __decorate([
            core.ContentChild(IgxCarouselPrevButtonDirective, { read: core.TemplateRef, static: false })
        ], IgxCarouselComponent.prototype, "prevButtonTemplate", void 0);
        __decorate([
            core.ContentChildren(IgxSlideComponent)
        ], IgxCarouselComponent.prototype, "slides", void 0);
        __decorate([
            core.Output()
        ], IgxCarouselComponent.prototype, "onSlideChanged", void 0);
        __decorate([
            core.Output()
        ], IgxCarouselComponent.prototype, "onSlideAdded", void 0);
        __decorate([
            core.Output()
        ], IgxCarouselComponent.prototype, "onSlideRemoved", void 0);
        __decorate([
            core.Output()
        ], IgxCarouselComponent.prototype, "onCarouselPaused", void 0);
        __decorate([
            core.Output()
        ], IgxCarouselComponent.prototype, "onCarouselPlaying", void 0);
        __decorate([
            core.HostListener('keydown.arrowright', ['$event'])
        ], IgxCarouselComponent.prototype, "onKeydownArrowRight", null);
        __decorate([
            core.HostListener('keydown.arrowleft', ['$event'])
        ], IgxCarouselComponent.prototype, "onKeydownArrowLeft", null);
        __decorate([
            core.HostListener('tap', ['$event'])
        ], IgxCarouselComponent.prototype, "onTap", null);
        __decorate([
            core.HostListener('keydown.home', ['$event'])
        ], IgxCarouselComponent.prototype, "onKeydownHome", null);
        __decorate([
            core.HostListener('keydown.end', ['$event'])
        ], IgxCarouselComponent.prototype, "onKeydownEnd", null);
        __decorate([
            core.HostListener('mouseenter')
        ], IgxCarouselComponent.prototype, "onMouseEnter", null);
        __decorate([
            core.HostListener('mouseleave')
        ], IgxCarouselComponent.prototype, "onMouseLeave", null);
        __decorate([
            core.HostListener('panleft', ['$event'])
        ], IgxCarouselComponent.prototype, "onPanLeft", null);
        __decorate([
            core.HostListener('panright', ['$event'])
        ], IgxCarouselComponent.prototype, "onPanRight", null);
        __decorate([
            core.HostListener('panend', ['$event'])
        ], IgxCarouselComponent.prototype, "onPanEnd", null);
        IgxCarouselComponent = __decorate([
            core.Component({
                providers: [
                    {
                        provide: platformBrowser.HAMMER_GESTURE_CONFIG,
                        useClass: CarouselHammerConfig
                    }
                ],
                selector: 'igx-carousel',
                template: "<ng-template #defaultIndicator let-slide>\n    <div class=\"igx-nav-dot\"\n        [class.igx-nav-dot--active]=\"slide.active\"\n    >\n    </div>\n</ng-template>\n\n<ng-template #defaultNextButton let-disabled>\n    <a class=\"igx-nav-arrow\"\n        [class.igx-nav-arrow--disabled]=\"disabled\"\n    >\n        <igx-icon fontSet=\"material\">arrow_forward</igx-icon>\n    </a>\n</ng-template>\n\n<ng-template #defaultPrevButton let-disabled>\n    <a class=\"igx-nav-arrow\"\n        [class.igx-nav-arrow--disabled]=\"disabled\"\n    >\n        <igx-icon fontSet=\"material\">arrow_back</igx-icon>\n    </a>\n</ng-template>\n\n\n<div *ngIf=\"showIndicators\" [ngClass]=\"indicatorsOrientationClass\">\n    <div *ngFor=\"let slide of slides\"\n        class=\"igx-carousel-indicators__indicator\"\n        (click)=\"select(slide)\"\n        [attr.aria-label]=\"setAriaLabel(slide)\"\n        [attr.aria-selected]=\"slide.active\">\n        <ng-container *ngTemplateOutlet=\"getIndicatorTemplate; context: {$implicit: slide};\"></ng-container>\n    </div>\n</div>\n\n<div *ngIf=\"showIndicatorsLabel\" [ngClass]=\"indicatorsOrientationClass\">\n    <span class=\"igx-carousel__label\">{{getCarouselLabel}}</span>\n</div>\n\n<div class=\"igx-carousel__inner\" role=\"list\">\n    <ng-content></ng-content>\n</div>\n\n<div *ngIf=\"navigation && slides.length\" role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--prev\" (click)=\"prev()\">\n    <ng-container *ngTemplateOutlet=\"getPrevButtonTemplate; context: {$implicit: prevButtonDisabled};\"></ng-container>\n</div>\n\n<div *ngIf=\"navigation && slides.length\" role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--next\" (click)=\"next()\">\n    <ng-container *ngTemplateOutlet=\"getNextButtonTemplate; context: {$implicit: nextButtonDisabled};\"></ng-container>\n</div>\n\n\n\n",
                styles: ["\n    :host {\n        display: block;\n        outline-style: none;\n    }"]
            })
        ], IgxCarouselComponent);
        return IgxCarouselComponent;
    }());
    /**
     * @hidden
     */
    var IgxCarouselModule = /** @class */ (function () {
        function IgxCarouselModule() {
        }
        IgxCarouselModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxCarouselComponent,
                    IgxSlideComponent,
                    IgxCarouselIndicatorDirective,
                    IgxCarouselNextButtonDirective,
                    IgxCarouselPrevButtonDirective
                ],
                exports: [
                    IgxCarouselComponent,
                    IgxSlideComponent,
                    IgxCarouselIndicatorDirective,
                    IgxCarouselNextButtonDirective,
                    IgxCarouselPrevButtonDirective
                ],
                imports: [common.CommonModule, IgxIconModule]
            })
        ], IgxCarouselModule);
        return IgxCarouselModule;
    }());


    (function (LabelPosition) {
        LabelPosition["BEFORE"] = "before";
        LabelPosition["AFTER"] = "after";
    })(exports.LabelPosition || (exports.LabelPosition = {}));
    var noop$3 = function () { };
    var ɵ0$3 = noop$3;
    var nextId$2 = 0;
    /**
     * Allows users to make a binary choice for a certain condition.
     *
     * @igxModule IgxCheckboxModule
     *
     * @igxTheme igx-checkbox-theme
     *
     * @igxKeywords checkbox, label
     *
     * @igxGroup Data entry and display
     *
     * @remarks
     * The Ignite UI Checkbox is a selection control that allows users to make a binary choice for a certain condition.It behaves similarly
     * to the native browser checkbox.
     *
     * @example
     * ```html
     * <igx-checkbox checked="true">
     *   simple checkbox
     * </igx-checkbox>
     * ```
     */
    var IgxCheckboxComponent = /** @class */ (function () {
        function IgxCheckboxComponent() {
            /**
             * Sets/gets the `id` of the checkbox component.
             * If not set, the `id` of the first checkbox component will be `"igx-checkbox-0"`.
             *
             * @example
             * ```html
             * <igx-checkbox id="my-first-checkbox"></igx-checkbox>
             * ```
             * ```typescript
             * let checkboxId =  this.checkbox.id;
             * ```
             */
            this.id = "igx-checkbox-" + nextId$2++;
            /**
             * Sets/gets the id of the `label` element.
             * If not set, the id of the `label` in the first checkbox component will be `"igx-checkbox-0-label"`.
             *
             * @example
             * ```html
             * <igx-checkbox labelId = "Label1"></igx-checkbox>
             * ```
             * ```typescript
             * let labelId =  this.checkbox.labelId;
             * ```
             */
            this.labelId = this.id + "-label";
            /**
             * Sets/gets the value of the `tabindex` attribute.
             *
             * @example
             * ```html
             * <igx-checkbox [tabindex] = "1"></igx-checkbox>
             * ```
             * ```typescript
             * let tabIndex =  this.checkbox.tabindex;
             * ```
             */
            this.tabindex = null;
            /**
             *  Sets/gets the position of the `label`.
             *  If not set, the `labelPosition` will have value `"after"`.
             *
             * @example
             * ```html
             * <igx-checkbox labelPosition = "before"></igx-checkbox>
             * ```
             * ```typescript
             * let labelPosition =  this.checkbox.labelPosition;
             * ```
             */
            this.labelPosition = exports.LabelPosition.AFTER;
            /**
             * Enables/Disables the ripple effect.
             * If not set, `disableRipple` will have value `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [disableRipple] = "true"></igx-checkbox>
             * ```
             * ```typescript
             * let isRippleDisabled = this.checkbox.desableRipple;
             * ```
             */
            this.disableRipple = false;
            /**
             * Sets/gets whether the checkbox is required.
             * If not set, `required` will have value `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [required] = "true"></igx-checkbox>
             * ```
             * ```typescript
             * let isRequired =  this.checkbox.required;
             * ```
             */
            this.required = false;
            /**
             * Sets/gets the `aria-labelledby` attribute.
             * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
             *
             * @example
             * ```html
             * <igx-checkbox aria-labelledby = "Checkbox1"></igx-checkbox>
             * ```
             * ```typescript
             * let ariaLabelledBy =  this.checkbox.ariaLabelledBy;
             * ```
             */
            this.ariaLabelledBy = this.labelId;
            /**
             * Sets/gets the value of the `aria-label` attribute.
             *
             * @example
             * ```html
             * <igx-checkbox aria-label = "Checkbox1"></igx-checkbox>
             * ```
             * ```typescript
             * let ariaLabel = this.checkbox.ariaLabel;
             * ```
             */
            this.ariaLabel = null;
            /**
             * An event that is emitted after the checkbox state is changed.
             * Provides references to the `IgxCheckboxComponent` and the `checked` property as event arguments.
             */
            this.change = new core.EventEmitter();
            /**
             * Returns the class of the checkbox component.
             *
             * @example
             * ```typescript
             * let class =  this.checkbox.cssClass;
             * ```
             */
            this.cssClass = 'igx-checkbox';
            /**
             * Sets/gets whether the checkbox component is on focus.
             * Default value is `false`.
             *
             * @example
             * ```typescript
             * this.checkbox.focused =  true;
             * ```
             * ```typescript
             * let isFocused =  this.checkbox.focused;
             * ```
             */
            this.focused = false;
            /**
             * Sets/gets the checkbox indeterminate visual state.
             * Default value is `false`;
             *
             * @example
             * ```html
             * <igx-checkbox [indeterminate] = "true"></igx-checkbox>
             * ```
             * ```typescript
             * let isIndeterminate = this.checkbox.indeterminate;
             * ```
             */
            this.indeterminate = false;
            /**
             * Sets/gets whether the checkbox is checked.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [checked] = "true"></igx-checkbox>
             * ```
             * ```typescript
             * let isChecked =  this.checkbox.checked;
             * ```
             */
            this.checked = false;
            /**
             * Sets/gets whether the checkbox is disabled.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [disabled] = "true"></igx-checkbox>
             * ```
             * ```typescript
             * let isDisabled = this.checkbox.disabled;
             * ```
             */
            this.disabled = false;
            /**
             * Sets/gets whether the checkbox is readonly.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [readonly]="true"></igx-checkbox>
             * ```
             * ```typescript
             * let readonly = this.checkbox.readonly;
             * ```
             */
            this.readonly = false;
            /**
             * Sets/gets whether the checkbox should disable all css transitions.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-checkbox [disableTransitions]="true"></igx-checkbox>
             * ```
             * ```typescript
             * let disableTransitions = this.checkbox.disableTransitions;
             * ```
             */
            this.disableTransitions = false;
            /** @hidden @internal */
            this.inputId = this.id + "-input";
            /**
             *@hidden
             */
            this._onTouchedCallback = noop$3;
            /**
             * @hidden
             */
            this._onChangeCallback = noop$3;
        }
        IgxCheckboxComponent_1 = IgxCheckboxComponent;
        /**
         * If `disabled` is `false`, switches the `checked` state.
         *
         * @example
         * ```typescript
         * this.checkbox.toggle();
         * ```
         */
        IgxCheckboxComponent.prototype.toggle = function () {
            if (this.disabled || this.readonly) {
                return;
            }
            this.indeterminate = false;
            this.focused = false;
            this.checked = !this.checked;
            this.change.emit({ checked: this.checked, checkbox: this });
            this._onChangeCallback(this.checked);
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype._onCheckboxChange = function (event) {
            // We have to stop the original checkbox change event
            // from bubbling up since we emit our own change event
            event.stopPropagation();
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype._onCheckboxClick = function (event) {
            // Since the original checkbox is hidden and the label
            // is used for styling and to change the checked state of the checkbox,
            // we need to prevent the checkbox click event from bubbling up
            // as it gets triggered on label click
            event.stopPropagation();
            if (this.readonly) {
                // readonly prevents the component from changing state (see toggle() method).
                // However, the native checkbox can still be activated through user interaction (focus + space, label click)
                // Prevent the native change so the input remains in sync
                event.preventDefault();
            }
            if (isIE()) {
                this.nativeCheckbox.nativeElement.blur();
            }
            this.toggle();
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype._onLabelClick = function (event) {
            // We use a span element as a placeholder label
            // in place of the native label, we need to emit
            // the change event separately here alongside
            // the click event emitted on click
            this.toggle();
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.onFocus = function (event) {
            this.focused = true;
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.onBlur = function (event) {
            this.focused = false;
            this._onTouchedCallback();
        };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.writeValue = function (value) {
            this._value = value;
            this.checked = !!this._value;
        };
        Object.defineProperty(IgxCheckboxComponent.prototype, "labelClass", {
            /** @hidden @internal */
            get: function () {
                switch (this.labelPosition) {
                    case exports.LabelPosition.BEFORE:
                        return this.cssClass + "__label--before";
                    case exports.LabelPosition.AFTER:
                    default:
                        return this.cssClass + "__label";
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.registerOnChange = function (fn) { this._onChangeCallback = fn; };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.registerOnTouched = function (fn) { this._onTouchedCallback = fn; };
        /** @hidden @internal */
        IgxCheckboxComponent.prototype.getEditElement = function () {
            return this.nativeCheckbox.nativeElement;
        };
        var IgxCheckboxComponent_1;
        __decorate([
            core.ViewChild('checkbox', { static: true })
        ], IgxCheckboxComponent.prototype, "nativeCheckbox", void 0);
        __decorate([
            core.ViewChild('label', { static: true })
        ], IgxCheckboxComponent.prototype, "nativeLabel", void 0);
        __decorate([
            core.ViewChild('placeholderLabel', { static: true })
        ], IgxCheckboxComponent.prototype, "placeholderLabel", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxCheckboxComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxCheckboxComponent.prototype, "labelId", void 0);
        __decorate([
            core.Input()
        ], IgxCheckboxComponent.prototype, "value", void 0);
        __decorate([
            core.Input()
        ], IgxCheckboxComponent.prototype, "name", void 0);
        __decorate([
            core.Input()
        ], IgxCheckboxComponent.prototype, "tabindex", void 0);
        __decorate([
            core.Input()
        ], IgxCheckboxComponent.prototype, "labelPosition", void 0);
        __decorate([
            core.Input()
        ], IgxCheckboxComponent.prototype, "disableRipple", void 0);
        __decorate([
            core.Input()
        ], IgxCheckboxComponent.prototype, "required", void 0);
        __decorate([
            core.Input('aria-labelledby')
        ], IgxCheckboxComponent.prototype, "ariaLabelledBy", void 0);
        __decorate([
            core.Input('aria-label')
        ], IgxCheckboxComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Output()
        ], IgxCheckboxComponent.prototype, "change", void 0);
        __decorate([
            core.HostBinding('class.igx-checkbox')
        ], IgxCheckboxComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('class.igx-checkbox--focused')
        ], IgxCheckboxComponent.prototype, "focused", void 0);
        __decorate([
            core.HostBinding('class.igx-checkbox--indeterminate'),
            core.Input()
        ], IgxCheckboxComponent.prototype, "indeterminate", void 0);
        __decorate([
            core.HostBinding('class.igx-checkbox--checked'),
            core.Input()
        ], IgxCheckboxComponent.prototype, "checked", void 0);
        __decorate([
            core.HostBinding('class.igx-checkbox--disabled'),
            core.Input()
        ], IgxCheckboxComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input()
        ], IgxCheckboxComponent.prototype, "readonly", void 0);
        __decorate([
            core.HostBinding('class.igx-checkbox--plain'),
            core.Input()
        ], IgxCheckboxComponent.prototype, "disableTransitions", void 0);
        IgxCheckboxComponent = IgxCheckboxComponent_1 = __decorate([
            core.Component({
                providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxCheckboxComponent_1, multi: true }],
                selector: 'igx-checkbox',
                preserveWhitespaces: false,
                template: "<input #checkbox class=\"igx-checkbox__input\"\n    type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [indeterminate]=\"indeterminate\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onCheckboxChange($event)\"\n    (click)=\"_onCheckboxClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<div\n    igxRipple\n    igxRippleTarget=\".igx-checkbox__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    class=\"igx-checkbox__composite-wrapper\"\n>\n    <label #label class=\"igx-checkbox__composite\"\n        [attr.for]=\"inputId\">\n        <svg class=\"igx-checkbox__composite-mark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n            <path d=\"M4.1,12.7 9,17.6 20.3,6.3\" />\n        </svg>\n    </label>\n\n    <div class=\"igx-checkbox__ripple\"></div>\n</div>\n\n<span #placeholderLabel role=\"label\"\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
            })
        ], IgxCheckboxComponent);
        return IgxCheckboxComponent;
    }());
    var IGX_CHECKBOX_REQUIRED_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return IgxCheckboxRequiredDirective; }),
        multi: true
    };
    /* tslint:disable directive-selector */
    var IgxCheckboxRequiredDirective = /** @class */ (function (_super) {
        __extends(IgxCheckboxRequiredDirective, _super);
        function IgxCheckboxRequiredDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxCheckboxRequiredDirective = __decorate([
            core.Directive({
                selector: "igx-checkbox[required][formControlName],\n    igx-checkbox[required][formControl],\n    igx-checkbox[required][ngModel]",
                providers: [IGX_CHECKBOX_REQUIRED_VALIDATOR]
            })
        ], IgxCheckboxRequiredDirective);
        return IgxCheckboxRequiredDirective;
    }(forms.CheckboxRequiredValidator));
    /**
     * @hidden
     */
    var IgxCheckboxModule = /** @class */ (function () {
        function IgxCheckboxModule() {
        }
        IgxCheckboxModule = __decorate([
            core.NgModule({
                declarations: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                exports: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                imports: [IgxRippleModule]
            })
        ], IgxCheckboxModule);
        return IgxCheckboxModule;
    }());

    var CHIP_ID = 0;
    /**
     * Chip is compact visual component that displays information in an obround.
     *
     * @igxModule IgxChipsModule
     *
     * @igxTheme igx-chip-theme
     *
     * @igxKeywords chip
     *
     * @igxGroup display
     *
     * @remarks
     * The Ignite UI Chip can be templated, deleted, and selected.
     * Multiple chips can be reordered and visually connected to each other.
     * Chips reside in a container called chips area which is responsible for managing the interactions between the chips.
     *
     * @example
     * ```html
     * <igx-chip class="chipStyle" [id]="901" [draggable]="true" [removable]="true" (onRemove)="chipRemoved($event)">
     *    <igx-avatar class="chip-avatar-resized" igxPrefix fontSet="material" roundShape="true"></igx-avatar>
     * </igx-chip>
     * ```
     */
    var IgxChipComponent = /** @class */ (function (_super) {
        __extends(IgxChipComponent, _super);
        function IgxChipComponent(cdr, elementRef, renderer, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.cdr = cdr;
            _this.elementRef = elementRef;
            _this.renderer = renderer;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
             * @example
             * ```html
             * <igx-chip [id]="'igx-chip-1'"></igx-chip>
             * ```
             */
            _this.id = "igx-chip-" + CHIP_ID++;
            /**
             * An @Input property that defines if the `IgxChipComponent` can be dragged in order to change it's position.
             * By default it is set to false.
             * @example
             * ```html
             * <igx-chip [id]="'igx-chip-1'" [draggable]="true"></igx-chip>
             * ```
             */
            _this.draggable = false;
            /**
         * An @Input property that enables/disables the draggable element animation when the element is released.
         * By default it's set to true.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [animateOnRelease]="false"></igx-chip>
         * ```
         */
            _this.animateOnRelease = true;
            /**
             * An @Input property that enables/disables the hiding of the base element that has been dragged.
             * By default it's set to true.
             * @example
             * ```html
             * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [hideBaseOnDrag]="false"></igx-chip>
             * ```
             */
            _this.hideBaseOnDrag = true;
            /**
             * An @Input property that defines if the `IgxChipComponent` should render remove button and throw remove events.
             * By default it is set to false.
             * @example
             * ```html
             * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [removable]="true"></igx-chip>
             * ```
             */
            _this.removable = false;
            /**
             * An @Input property that defines if the `IgxChipComponent` can be selected on click or through navigation,
             * By default it is set to false.
             * @example
             * ```html
             * <igx-chip [id]="chip.id" [draggable]="true" [removable]="true" [selectable]="true"></igx-chip>
             * ```
             */
            _this.selectable = false;
            /**
             * @hidden
             * @internal
             */
            _this.class = '';
            /**
             * An @Input property that defines if the `IgxChipComponent` is disabled. When disabled it restricts user interactions
             * like focusing on click or tab, selection on click or Space, dragging.
             * By default it is set to false.
             * @example
             * ```html
             * <igx-chip [id]="chip.id" [disabled]="true"></igx-chip>
             * ```
             */
            _this.disabled = false;
            /**
             * @hidden
             * @internal
             */
            _this.selectedChange = new core.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` moving starts.
             * Returns the moving `IgxChipComponent`.
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveStart)="moveStarted($event)">
             * ```
             */
            _this.onMoveStart = new core.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` moving ends.
             * Returns the moved `IgxChipComponent`.
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveEnd)="moveEnded($event)">
             * ```
             */
            _this.onMoveEnd = new core.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` is removed.
             * Returns the removed `IgxChipComponent`.
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onRemove)="remove($event)">
             * ```
             */
            _this.onRemove = new core.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` is clicked.
             * Returns the clicked `IgxChipComponent`, whether the event should be canceled.
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onClick)="chipClick($event)">
             * ```
             */
            _this.onClick = new core.EventEmitter();
            /**
             * Emits event when the `IgxChipComponent` is selected/deselected.
             * Returns the selected chip reference, whether the event should be canceled, what is the next selection state and
             * when the event is triggered by interaction `originalEvent` is provided, otherwise `originalEvent` is `null`.
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (onSelection)="chipSelect($event)">
             * ```
             */
            _this.onSelection = new core.EventEmitter();
            /**
             * Emits event when the `IgxChipComponent` is selected/deselected and any related animations and transitions also end.
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (onSelectionDone)="chipSelectEnd($event)">
             * ```
             */
            _this.onSelectionDone = new core.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` keyboard navigation is being used.
             * Returns the focused/selected `IgxChipComponent`, whether the event should be canceled,
             * if the `alt`, `shift` or `control` key is pressed and the pressed key name.
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onKeyDown)="chipKeyDown($event)">
             * ```
             */
            _this.onKeyDown = new core.EventEmitter();
            /**
             * Emits an event when the `IgxChipComponent` has entered the `IgxChipsAreaComponent`.
             * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as
             * the original drop event arguments.
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onDragEnter)="chipEnter($event)">
             * ```
             */
            _this.onDragEnter = new core.EventEmitter();
            _this._selected = false;
            _this._selectedItemClass = 'igx-chip__item--selected';
            _this._movedWhileRemoving = false;
            return _this;
        }
        Object.defineProperty(IgxChipComponent.prototype, "selected", {
            /**
             * Returns if the `IgxChipComponent` is selected.
             * @example
             * ```typescript
             * @ViewChild('myChip')
             * public chip: IgxChipComponent;
             * selectedChip(){
             *     let selectedChip = this.chip.selected;
             * }
             * ```
             */
            get: function () {
                return this._selected;
            },
            /**
             * Sets the `IgxChipComponent` selected state.
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [selected]="true">
             * ```
             *
             * Two-way data binding:
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [(selected)]="model.isSelected">
             * ```
             */
            set: function (newValue) {
                this.changeSelection(newValue);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "color", {
            /**
             * Returns the background color of the `IgxChipComponent`.
             * @example
             * ```typescript
             * @ViewChild('myChip')
             * public chip: IgxChipComponent;
             * ngAfterViewInit(){
             *     let chipColor = this.chip.color;
             * }
             * ```
             */
            get: function () {
                return this.chipArea.nativeElement.style.backgroundColor;
            },
            /**
             * An @Input property that sets the `IgxChipComponent` background color.
             * The `color` property supports string, rgb, hex.
             * @example
             * ```html
             * <igx-chip #myChip [id]="'igx-chip-1'" [color]="'#ff0000'"></igx-chip>
             * ```
             */
            set: function (newColor) {
                this.chipArea.nativeElement.style.backgroundColor = newColor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "hostClass", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                var classes = [this.getComponentDensityClass('igx-chip')];
                classes.push(this.disabled ? 'igx-chip--disabled' : '');
                // The custom classes should be at the end.
                classes.push(this.class);
                return classes.join(' ');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "removeButtonTemplate", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.removeIcon || this.defaultRemoveIcon;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "selectIconTemplate", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.selectIcon || this.defaultSelectIcon;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "ghostClass", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.getComponentDensityClass('igx-chip__ghost');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxChipComponent.prototype, "chipTabindex", {
            get: function () {
                return !this.disabled ? 0 : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.selectClass = function (condition) {
            var _a;
            var SELECT_CLASS = 'igx-chip__select';
            return _a = {},
                _a[SELECT_CLASS] = condition,
                _a[SELECT_CLASS + "--hidden"] = !condition,
                _a;
        };
        IgxChipComponent.prototype.changeSelection = function (newValue, srcEvent) {
            var _this = this;
            if (srcEvent === void 0) { srcEvent = null; }
            var onSelectArgs = {
                originalEvent: srcEvent,
                owner: this,
                selected: false,
                cancel: false
            };
            rxjs.fromEvent(this.selectContainer.nativeElement, 'transitionend')
                .pipe(operators.filter(function (event) { return event.propertyName === 'width'; }), operators.take(1))
                .subscribe(function (event) { return _this.onSelectTransitionDone(event); });
            if (newValue && !this._selected) {
                onSelectArgs.selected = true;
                this.onSelection.emit(onSelectArgs);
                if (!onSelectArgs.cancel) {
                    this.renderer.addClass(this.chipArea.nativeElement, this._selectedItemClass);
                    this._selected = newValue;
                    this.selectedChange.emit(this._selected);
                }
            }
            else if (!newValue && this._selected) {
                this.onSelection.emit(onSelectArgs);
                if (!onSelectArgs.cancel) {
                    this.renderer.removeClass(this.chipArea.nativeElement, this._selectedItemClass);
                    this._selected = newValue;
                    this.selectedChange.emit(this._selected);
                }
            }
        };
        IgxChipComponent.prototype.onSelectTransitionDone = function (event) {
            if (!!event.target.tagName) {
                // Trigger onSelectionDone on when `width` property is changed and the target is valid element(not comment).
                this.onSelectionDone.emit({
                    owner: this,
                    originalEvent: event
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipKeyDown = function (event) {
            var keyDownArgs = {
                originalEvent: event,
                owner: this,
                cancel: false
            };
            this.onKeyDown.emit(keyDownArgs);
            if (keyDownArgs.cancel) {
                return;
            }
            if ((event.key === 'Delete' || event.key === 'Del') && this.removable) {
                this.onRemove.emit({
                    originalEvent: event,
                    owner: this
                });
            }
            if ((event.key === ' ' || event.key === 'Spacebar') && this.selectable && !this.disabled) {
                this.changeSelection(!this.selected, event);
            }
            if (event.key !== 'Tab') {
                event.preventDefault();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onRemoveBtnKeyDown = function (event) {
            if (event.key === ' ' || event.key === 'Spacebar' || event.key === 'Enter') {
                this.onRemove.emit({
                    originalEvent: event,
                    owner: this
                });
                event.preventDefault();
                event.stopPropagation();
            }
        };
        IgxChipComponent.prototype.onRemoveMouseDown = function (event) {
            event.stopPropagation();
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onRemoveClick = function (event) {
            this.onRemove.emit({
                originalEvent: event,
                owner: this
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onRemoveTouchMove = function () {
            // We don't remove chip if user starting touch interacting on the remove button moves the chip
            this._movedWhileRemoving = true;
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onRemoveTouchEnd = function (event) {
            if (!this._movedWhileRemoving) {
                this.onRemoveClick(event);
            }
            this._movedWhileRemoving = false;
        };
        /**
         * @hidden
         * @internal
         */
        // -----------------------------
        // Start chip igxDrag behavior
        IgxChipComponent.prototype.onChipDragStart = function (event) {
            this.onMoveStart.emit({
                originalEvent: event,
                owner: this
            });
            event.cancel = !this.draggable || this.disabled;
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipDragEnd = function () {
            if (this.animateOnRelease) {
                this.dragDirective.transitionToOrigin();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipMoveEnd = function (event) {
            // moveEnd is triggered after return animation has finished. This happen when we drag and release the chip.
            this.onMoveEnd.emit({
                originalEvent: event,
                owner: this
            });
            if (this.selected) {
                this.chipArea.nativeElement.focus();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipDragClicked = function (event) {
            var clickEventArgs = {
                originalEvent: event,
                owner: this,
                cancel: false
            };
            this.onClick.emit(clickEventArgs);
            if (!clickEventArgs.cancel && this.selectable && !this.disabled) {
                this.changeSelection(!this.selected, event);
            }
        };
        // End chip igxDrag behavior
        /**
         * @hidden
         * @internal
         */
        // -----------------------------
        // Start chip igxDrop behavior
        IgxChipComponent.prototype.onChipDragEnterHandler = function (event) {
            if (this.dragDirective === event.drag || !event.drag.data || !event.drag.data.chip) {
                return;
            }
            var eventArgs = {
                owner: this,
                dragChip: event.drag.data.chip,
                originalEvent: event
            };
            this.onDragEnter.emit(eventArgs);
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipComponent.prototype.onChipDrop = function (event) {
            // Cancel the default drop logic
            event.cancel = true;
        };
        IgxChipComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxChipComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "data", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "draggable", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "animateOnRelease", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "hideBaseOnDrag", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "removable", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "removeIcon", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "selectable", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "selectIcon", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "class", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "selected", null);
        __decorate([
            core.Output()
        ], IgxChipComponent.prototype, "selectedChange", void 0);
        __decorate([
            core.Input()
        ], IgxChipComponent.prototype, "color", null);
        __decorate([
            core.Output()
        ], IgxChipComponent.prototype, "onMoveStart", void 0);
        __decorate([
            core.Output()
        ], IgxChipComponent.prototype, "onMoveEnd", void 0);
        __decorate([
            core.Output()
        ], IgxChipComponent.prototype, "onRemove", void 0);
        __decorate([
            core.Output()
        ], IgxChipComponent.prototype, "onClick", void 0);
        __decorate([
            core.Output()
        ], IgxChipComponent.prototype, "onSelection", void 0);
        __decorate([
            core.Output()
        ], IgxChipComponent.prototype, "onSelectionDone", void 0);
        __decorate([
            core.Output()
        ], IgxChipComponent.prototype, "onKeyDown", void 0);
        __decorate([
            core.Output()
        ], IgxChipComponent.prototype, "onDragEnter", void 0);
        __decorate([
            core.HostBinding('attr.class')
        ], IgxChipComponent.prototype, "hostClass", null);
        __decorate([
            core.ViewChild('chipArea', { read: IgxDragDirective, static: true })
        ], IgxChipComponent.prototype, "dragDirective", void 0);
        __decorate([
            core.ViewChild('chipArea', { read: core.ElementRef, static: true })
        ], IgxChipComponent.prototype, "chipArea", void 0);
        __decorate([
            core.ViewChild('selectContainer', { read: core.ElementRef, static: true })
        ], IgxChipComponent.prototype, "selectContainer", void 0);
        __decorate([
            core.ViewChild('defaultRemoveIcon', { read: core.TemplateRef, static: true })
        ], IgxChipComponent.prototype, "defaultRemoveIcon", void 0);
        __decorate([
            core.ViewChild('defaultSelectIcon', { read: core.TemplateRef, static: true })
        ], IgxChipComponent.prototype, "defaultSelectIcon", void 0);
        IgxChipComponent = __decorate([
            core.Component({
                selector: 'igx-chip',
                template: "<div #chipArea class=\"igx-chip__item\"\n    [attr.tabindex]=\"chipTabindex\"\n    (keydown)=\"onChipKeyDown($event)\"\n    [igxDrag]=\"{chip: this}\"\n    [hideBaseOnDrag]=\"hideBaseOnDrag\"\n    [ghostClass]=\"ghostClass\"\n    (dragStart)=\"onChipDragStart($event)\"\n    (dragEnd)=\"onChipDragEnd()\"\n    (transitioned)=\"onChipMoveEnd($event)\"\n    (dragClick)=\"onChipDragClicked($event)\"\n    igxDrop\n    (enter)=\"onChipDragEnterHandler($event)\"\n    (dropped)=\"onChipDrop($event)\">\n\n    <div #selectContainer [ngClass]=\"selectClass(selected)\">\n        <ng-container *ngTemplateOutlet=\"selectIconTemplate\"></ng-container>\n    </div>\n\n    <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n    <div class=\"igx-chip__content\">\n        <ng-content></ng-content>\n    </div>\n\n    <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n\n    <div class=\"igx-chip__remove\" *ngIf=\"removable\"\n        tabindex=\"0\"\n        (keydown)=\"onRemoveBtnKeyDown($event)\"\n        (pointerdown)=\"onRemoveMouseDown($event)\"\n        (mousedown)=\"onRemoveMouseDown($event)\"\n        (click)=\"onRemoveClick($event)\"\n        (touchmove)=\"onRemoveTouchMove()\"\n        (touchend)=\"onRemoveTouchEnd($event)\">\n        <ng-container *ngTemplateOutlet=\"removeButtonTemplate\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultSelectIcon>\n    <igx-icon>done</igx-icon>\n</ng-template>\n\n<ng-template #defaultRemoveIcon>\n    <igx-icon>cancel</igx-icon>\n</ng-template>\n"
            }),
            __param(3, core.Optional()), __param(3, core.Inject(DisplayDensityToken))
        ], IgxChipComponent);
        return IgxChipComponent;
    }(DisplayDensityBase));

    /**
     * The chip area allows you to perform more complex scenarios with chips that require interaction,
     * like dragging, selection, navigation, etc.
     *
     * @igxModule IgxChipsModule
     *
     * @igxTheme igx-chip-theme
     *
     * @igxKeywords chip area, chip
     *
     * @igxGroup display
     *
     * @example
     * ```html
     * <igx-chips-area>
     *    <igx-chip *ngFor="let chip of chipList" [id]="chip.id">
     *        <span>{{chip.text}}</span>
     *    </igx-chip>
     * </igx-chips-area>
     * ```
     */
    var IgxChipsAreaComponent = /** @class */ (function () {
        function IgxChipsAreaComponent(cdr, element, _iterableDiffers) {
            this.cdr = cdr;
            this.element = element;
            this._iterableDiffers = _iterableDiffers;
            /**
             * @hidden
             * @internal
             */
            this.class = '';
            /**
             * Emits an event when `IgxChipComponent`s in the `IgxChipsAreaComponent` should be reordered.
             * Returns an array of `IgxChipComponent`s.
             * @example
             * ```html
             * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onReorder)="changedOrder($event)"></igx-chips-area>
             * ```
             */
            this.onReorder = new core.EventEmitter();
            /**
             * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is selected/deselected.
             * Fired after the chips area is initialized if there are initially selected chips as well.
             * Returns an array of selected `IgxChipComponent`s and the `IgxChipAreaComponent`.
             * @example
             * ```html
             * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onSelection)="selection($event)"></igx-chips-area>
             * ```
             */
            this.onSelection = new core.EventEmitter();
            /**
             * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
             * @example
             * ```html
             * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveStart)="moveStart($event)"></igx-chips-area>
             * ```
             */
            this.onMoveStart = new core.EventEmitter();
            /**
             * Emits an event after an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
             * @example
             * ```html
             * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveEnd)="moveEnd($event)"></igx-chips-area>
             * ```
             */
            this.onMoveEnd = new core.EventEmitter();
            this._differ = null;
            this.destroy$ = new rxjs.Subject();
            this._differ = this._iterableDiffers.find([]).create(null);
        }
        Object.defineProperty(IgxChipsAreaComponent.prototype, "hostClass", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                var classes = ['igx-chip-area'];
                classes.push(this.class);
                return classes.join(' ');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.ngAfterViewInit = function () {
            // If we have initially selected chips through their inputs, we need to get them, because we cannot listen to their events yet.
            if (this.chipsList.length) {
                var selectedChips = this.chipsList.filter(function (item) { return item.selected; });
                if (selectedChips.length) {
                    this.onSelection.emit({
                        originalEvent: null,
                        newSelection: selectedChips,
                        owner: this
                    });
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.ngDoCheck = function () {
            var _this = this;
            if (this.chipsList) {
                var changes = this._differ.diff(this.chipsList.toArray());
                if (changes) {
                    changes.forEachAddedItem(function (addedChip) {
                        addedChip.item.onMoveStart.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (args) {
                            _this.onChipMoveStart(args);
                        });
                        addedChip.item.onMoveEnd.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (args) {
                            _this.onChipMoveEnd(args);
                        });
                        addedChip.item.onDragEnter.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (args) {
                            _this.onChipDragEnter(args);
                        });
                        addedChip.item.onKeyDown.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (args) {
                            _this.onChipKeyDown(args);
                        });
                        if (addedChip.item.selectable) {
                            addedChip.item.onSelection.pipe(operators.takeUntil(_this.destroy$)).subscribe(function (args) {
                                _this.onChipSelectionChange(args);
                            });
                        }
                    });
                    this.modifiedChipsArray = this.chipsList.toArray();
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.onChipKeyDown = function (event) {
            var _this = this;
            var orderChanged = false;
            var chipsArray = this.chipsList.toArray();
            var dragChipIndex = chipsArray.findIndex(function (el) { return el === event.owner; });
            if (event.originalEvent.shiftKey === true) {
                if (event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') {
                    orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex - 1, false, event.originalEvent);
                    if (orderChanged) {
                        setTimeout(function () {
                            _this.chipsList.toArray()[dragChipIndex - 1].chipArea.nativeElement.focus();
                        });
                    }
                }
                else if (event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') {
                    orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex + 1, true, event.originalEvent);
                }
            }
            else {
                if ((event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') && dragChipIndex > 0) {
                    chipsArray[dragChipIndex - 1].chipArea.nativeElement.focus();
                }
                else if ((event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') &&
                    dragChipIndex < chipsArray.length - 1) {
                    chipsArray[dragChipIndex + 1].chipArea.nativeElement.focus();
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.onChipMoveStart = function (event) {
            this.onMoveStart.emit({
                originalEvent: event.originalEvent,
                owner: this
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.onChipMoveEnd = function (event) {
            this.onMoveEnd.emit({
                originalEvent: event.originalEvent,
                owner: this
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.onChipDragEnter = function (event) {
            var dropChipIndex = this.chipsList.toArray().findIndex(function (el) { return el === event.owner; });
            var dragChipIndex = this.chipsList.toArray().findIndex(function (el) { return el === event.dragChip; });
            if (dragChipIndex < dropChipIndex) {
                // from the left to right
                this.positionChipAtIndex(dragChipIndex, dropChipIndex, true, event.originalEvent);
            }
            else {
                // from the right to left
                this.positionChipAtIndex(dragChipIndex, dropChipIndex, false, event.originalEvent);
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.positionChipAtIndex = function (chipIndex, targetIndex, shiftRestLeft, originalEvent) {
            if (chipIndex < 0 || this.chipsList.length <= chipIndex ||
                targetIndex < 0 || this.chipsList.length <= targetIndex) {
                return false;
            }
            var chipsArray = this.chipsList.toArray();
            var result = [];
            for (var i = 0; i < chipsArray.length; i++) {
                if (shiftRestLeft) {
                    if (chipIndex <= i && i < targetIndex) {
                        result.push(chipsArray[i + 1]);
                    }
                    else if (i === targetIndex) {
                        result.push(chipsArray[chipIndex]);
                    }
                    else {
                        result.push(chipsArray[i]);
                    }
                }
                else {
                    if (targetIndex < i && i <= chipIndex) {
                        result.push(chipsArray[i - 1]);
                    }
                    else if (i === targetIndex) {
                        result.push(chipsArray[chipIndex]);
                    }
                    else {
                        result.push(chipsArray[i]);
                    }
                }
            }
            this.modifiedChipsArray = result;
            var eventData = {
                chipsArray: this.modifiedChipsArray,
                originalEvent: originalEvent,
                owner: this
            };
            this.onReorder.emit(eventData);
            return true;
        };
        /**
         * @hidden
         * @internal
         */
        IgxChipsAreaComponent.prototype.onChipSelectionChange = function (event) {
            var selectedChips = this.chipsList.filter(function (chip) { return chip.selected; });
            if (event.selected && !selectedChips.includes(event.owner)) {
                selectedChips.push(event.owner);
            }
            else if (!event.selected && selectedChips.includes(event.owner)) {
                selectedChips = selectedChips.filter(function (chip) {
                    return chip.id !== event.owner.id;
                });
            }
            this.onSelection.emit({
                originalEvent: event.originalEvent,
                newSelection: selectedChips,
                owner: this
            });
        };
        IgxChipsAreaComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.IterableDiffers }
        ]; };
        __decorate([
            core.Input()
        ], IgxChipsAreaComponent.prototype, "class", void 0);
        __decorate([
            core.HostBinding('attr.class')
        ], IgxChipsAreaComponent.prototype, "hostClass", null);
        __decorate([
            core.HostBinding('style.width.px'),
            core.Input()
        ], IgxChipsAreaComponent.prototype, "width", void 0);
        __decorate([
            core.HostBinding('style.height.px'),
            core.Input()
        ], IgxChipsAreaComponent.prototype, "height", void 0);
        __decorate([
            core.Output()
        ], IgxChipsAreaComponent.prototype, "onReorder", void 0);
        __decorate([
            core.Output()
        ], IgxChipsAreaComponent.prototype, "onSelection", void 0);
        __decorate([
            core.Output()
        ], IgxChipsAreaComponent.prototype, "onMoveStart", void 0);
        __decorate([
            core.Output()
        ], IgxChipsAreaComponent.prototype, "onMoveEnd", void 0);
        __decorate([
            core.ContentChildren(IgxChipComponent, { descendants: true })
        ], IgxChipsAreaComponent.prototype, "chipsList", void 0);
        IgxChipsAreaComponent = __decorate([
            core.Component({
                selector: 'igx-chips-area',
                template: "<ng-content></ng-content>\n"
            })
        ], IgxChipsAreaComponent);
        return IgxChipsAreaComponent;
    }());

    /**
     * @hidden
     */
    var IgxChipsModule = /** @class */ (function () {
        function IgxChipsModule() {
        }
        IgxChipsModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxChipsAreaComponent,
                    IgxChipComponent
                ],
                exports: [
                    IgxChipsAreaComponent,
                    IgxChipComponent,
                    IgxPrefixDirective,
                    IgxSuffixDirective
                ],
                imports: [
                    common.CommonModule,
                    IgxRippleModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxAvatarModule,
                    IgxDragDropModule,
                    IgxPrefixModule,
                    IgxSuffixModule
                ]
            })
        ], IgxChipsModule);
        return IgxChipsModule;
    }());

    /**
     * @hidden
     */
    var IgxComboHeaderDirective = /** @class */ (function () {
        function IgxComboHeaderDirective() {
        }
        IgxComboHeaderDirective = __decorate([
            core.Directive({
                selector: '[igxComboHeader]'
            })
        ], IgxComboHeaderDirective);
        return IgxComboHeaderDirective;
    }());
    /**
     * @hidden
     */
    var IgxComboFooterDirective = /** @class */ (function () {
        function IgxComboFooterDirective() {
        }
        IgxComboFooterDirective = __decorate([
            core.Directive({
                selector: '[igxComboFooter]'
            })
        ], IgxComboFooterDirective);
        return IgxComboFooterDirective;
    }());
    /**
     * @hidden
     */
    var IgxComboItemDirective = /** @class */ (function () {
        function IgxComboItemDirective() {
        }
        IgxComboItemDirective = __decorate([
            core.Directive({
                selector: '[igxComboItem]'
            })
        ], IgxComboItemDirective);
        return IgxComboItemDirective;
    }());
    /**
     * @hidden
     */
    var IgxComboEmptyDirective = /** @class */ (function () {
        function IgxComboEmptyDirective() {
        }
        IgxComboEmptyDirective = __decorate([
            core.Directive({
                selector: '[igxComboEmpty]'
            })
        ], IgxComboEmptyDirective);
        return IgxComboEmptyDirective;
    }());
    /**
     * @hidden
     */
    var IgxComboHeaderItemDirective = /** @class */ (function () {
        function IgxComboHeaderItemDirective() {
        }
        IgxComboHeaderItemDirective = __decorate([
            core.Directive({
                selector: '[igxComboHeaderItem]'
            })
        ], IgxComboHeaderItemDirective);
        return IgxComboHeaderItemDirective;
    }());
    /**
     * @hidden
     */
    var IgxComboAddItemDirective = /** @class */ (function () {
        function IgxComboAddItemDirective() {
        }
        IgxComboAddItemDirective = __decorate([
            core.Directive({
                selector: '[igxComboAddItem]'
            })
        ], IgxComboAddItemDirective);
        return IgxComboAddItemDirective;
    }());
    /**
     * @hidden
     */
    var IgxComboToggleIconDirective = /** @class */ (function () {
        function IgxComboToggleIconDirective() {
        }
        IgxComboToggleIconDirective = __decorate([
            core.Directive({
                selector: '[igxComboToggleIcon]'
            })
        ], IgxComboToggleIconDirective);
        return IgxComboToggleIconDirective;
    }());
    /**
     * @hidden
     */
    var IgxComboClearIconDirective = /** @class */ (function () {
        function IgxComboClearIconDirective() {
        }
        IgxComboClearIconDirective = __decorate([
            core.Directive({
                selector: '[igxComboClearIcon]'
            })
        ], IgxComboClearIconDirective);
        return IgxComboClearIconDirective;
    }());

    /**
     * @hidden
     */
    var IgxComboAPIService = /** @class */ (function () {
        function IgxComboAPIService() {
            this.disableTransitions = false;
        }
        IgxComboAPIService.prototype.register = function (combo) {
            this.combo = combo;
        };
        IgxComboAPIService.prototype.clear = function () {
            this.combo = null;
        };
        Object.defineProperty(IgxComboAPIService.prototype, "valueKey", {
            get: function () {
                return this.combo.valueKey !== null && this.combo.valueKey !== undefined ? this.combo.valueKey : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboAPIService.prototype, "item_focusable", {
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboAPIService.prototype, "isRemote", {
            get: function () {
                return this.combo.isRemote;
            },
            enumerable: true,
            configurable: true
        });
        IgxComboAPIService.prototype.add_custom_item = function () {
            if (!this.combo) {
                return;
            }
            this.combo.addItemToCollection();
        };
        Object.defineProperty(IgxComboAPIService.prototype, "comboID", {
            get: function () {
                return this.combo.id;
            },
            enumerable: true,
            configurable: true
        });
        IgxComboAPIService.prototype.set_selected_item = function (itemID, event) {
            var selected = this.combo.isItemSelected(itemID);
            if (itemID === null || itemID === undefined) {
                return;
            }
            if (!selected) {
                this.combo.selectItems([itemID], false, event);
            }
            else {
                this.combo.deselectItems([itemID], event);
            }
        };
        IgxComboAPIService.prototype.is_item_selected = function (itemID) {
            return this.combo.isItemSelected(itemID);
        };
        IgxComboAPIService = __decorate([
            core.Injectable()
        ], IgxComboAPIService);
        return IgxComboAPIService;
    }());

    /** @hidden */
    var IgxComboItemComponent = /** @class */ (function (_super) {
        __extends(IgxComboItemComponent, _super);
        function IgxComboItemComponent(comboAPI, dropDown, elementRef, selection) {
            var _this = _super.call(this, dropDown, elementRef, null, selection) || this;
            _this.comboAPI = comboAPI;
            _this.dropDown = dropDown;
            _this.elementRef = elementRef;
            _this.selection = selection;
            /**
             * Gets the height of a list item
             * @hidden
             */
            _this.itemHeight = '';
            return _this;
        }
        Object.defineProperty(IgxComboItemComponent.prototype, "itemID", {
            /**
             * @hidden
             */
            get: function () {
                var valueKey = this.comboAPI.valueKey;
                return valueKey !== null ? this.value[valueKey] : this.value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboItemComponent.prototype, "comboID", {
            /**
             * @hidden
             */
            get: function () {
                return this.comboAPI.comboID;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboItemComponent.prototype, "disableTransitions", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.comboAPI.disableTransitions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboItemComponent.prototype, "selected", {
            /**
             * @hidden
             */
            get: function () {
                return this.comboAPI.is_item_selected(this.itemID);
            },
            set: function (value) {
                if (this.isHeader) {
                    return;
                }
                this._selected = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxComboItemComponent.prototype.isVisible = function (direction) {
            var rect = this.element.nativeElement.getBoundingClientRect();
            var parentDiv = this.element.nativeElement.parentElement.parentElement.getBoundingClientRect();
            if (direction === Navigate.Down) {
                return rect.y + rect.height <= parentDiv.y + parentDiv.height;
            }
            return rect.y >= parentDiv.y;
        };
        /**
         * @inheritdoc
         */
        IgxComboItemComponent.prototype.clicked = function (event) {
            this.comboAPI.disableTransitions = false;
            if (!this.isSelectable) {
                return;
            }
            this.dropDown.navigateItem(this.index);
            this.comboAPI.set_selected_item(this.itemID, event);
        };
        /**
         * @hidden
         * @internal
         * The event that is prevented is the click on the checkbox label element.
         * That is the only visible element that a user can interact with.
         * The click propagates to the host and the preventDefault is to stop it from
         * switching focus to the input it's base on.
         * The toggle happens in an internal handler in the drop-down on the next task queue cycle.
         */
        IgxComboItemComponent.prototype.disableCheck = function (event) {
            event.preventDefault();
        };
        IgxComboItemComponent.prototype.ngDoCheck = function () {
        };
        IgxComboItemComponent.ctorParameters = function () { return [
            { type: IgxComboAPIService },
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_DROPDOWN_BASE,] }] },
            { type: core.ElementRef },
            { type: IgxSelectionAPIService, decorators: [{ type: core.Inject, args: [IgxSelectionAPIService,] }] }
        ]; };
        __decorate([
            core.Input(),
            core.HostBinding('style.height.px')
        ], IgxComboItemComponent.prototype, "itemHeight", void 0);
        IgxComboItemComponent = __decorate([
            core.Component({
                selector: 'igx-combo-item',
                template: "<ng-container *ngIf=\"!isHeader\">\n    <igx-checkbox [checked]=\"selected\" disableRipple=\"true\" [disableTransitions]=\"disableTransitions\" [tabindex]=\"-1\" (click)=\"disableCheck($event)\" class=\"igx-combo__checkbox\"></igx-checkbox>\n</ng-container>\n<ng-content></ng-content>\n"
            }),
            __param(1, core.Inject(IGX_DROPDOWN_BASE)),
            __param(3, core.Inject(IgxSelectionAPIService))
        ], IgxComboItemComponent);
        return IgxComboItemComponent;
    }(IgxDropDownItemComponent));

    var IGX_COMBO_COMPONENT = new core.InjectionToken('IgxComboComponentToken');

    /**
     * @hidden
     */
    var IgxComboAddItemComponent = /** @class */ (function (_super) {
        __extends(IgxComboAddItemComponent, _super);
        function IgxComboAddItemComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxComboAddItemComponent_1 = IgxComboAddItemComponent;
        Object.defineProperty(IgxComboAddItemComponent.prototype, "selected", {
            get: function () {
                return false;
            },
            set: function (value) {
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritdoc
         */
        IgxComboAddItemComponent.prototype.clicked = function (event) {
            this.comboAPI.disableTransitions = false;
            this.comboAPI.add_custom_item();
        };
        var IgxComboAddItemComponent_1;
        IgxComboAddItemComponent = IgxComboAddItemComponent_1 = __decorate([
            core.Component({
                selector: 'igx-combo-add-item',
                template: '<ng-content></ng-content>',
                providers: [{ provide: IgxComboItemComponent, useExisting: IgxComboAddItemComponent_1 }]
            })
        ], IgxComboAddItemComponent);
        return IgxComboAddItemComponent;
    }(IgxComboItemComponent));

    /** @hidden */
    var IgxComboDropDownComponent = /** @class */ (function (_super) {
        __extends(IgxComboDropDownComponent, _super);
        function IgxComboDropDownComponent(elementRef, cdr, selection, combo, comboAPI, _displayDensityOptions) {
            var _this = _super.call(this, elementRef, cdr, selection, _displayDensityOptions) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.selection = selection;
            _this.combo = combo;
            _this.comboAPI = comboAPI;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * @hidden
             * @internal
             */
            _this.children = null;
            _this.scrollHandler = function () {
                _this.comboAPI.disableTransitions = true;
            };
            return _this;
        }
        IgxComboDropDownComponent_1 = IgxComboDropDownComponent;
        Object.defineProperty(IgxComboDropDownComponent.prototype, "scrollContainer", {
            /** @hidden @internal */
            get: function () {
                return this.virtDir.dc.location.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboDropDownComponent.prototype, "isScrolledToLast", {
            get: function () {
                var scrollTop = this.virtDir.scrollPosition;
                var scrollHeight = this.virtDir.getScroll().scrollHeight;
                return Math.floor(scrollTop + this.virtDir.igxForContainerSize) === scrollHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboDropDownComponent.prototype, "lastVisibleIndex", {
            get: function () {
                return this.combo.totalItemCount ?
                    Math.floor(this.combo.itemsMaxHeight / this.combo.itemHeight) :
                    this.items.length - 1;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.onFocus = function () {
            this.focusedItem = this._focusedItem || this.items[0];
        };
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.onBlur = function (evt) {
            this.focusedItem = null;
        };
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.onToggleOpened = function () {
            this.onOpened.emit();
        };
        /**
         * @hidden
         */
        IgxComboDropDownComponent.prototype.navigateFirst = function () {
            this.navigateItem(this.virtDir.igxForOf.findIndex(function (e) { return !e.isHeader; }));
        };
        /**
         * @hidden
         */
        IgxComboDropDownComponent.prototype.navigatePrev = function () {
            if (this._focusedItem && this._focusedItem.index === 0 && this.virtDir.state.startIndex === 0) {
                this.combo.focusSearchInput(false);
            }
            else {
                _super.prototype.navigatePrev.call(this);
            }
        };
        /**
         * @hidden
         */
        IgxComboDropDownComponent.prototype.navigateNext = function () {
            var lastIndex = this.combo.totalItemCount ? this.combo.totalItemCount - 1 : this.virtDir.igxForOf.length - 1;
            if (this._focusedItem && this._focusedItem.index === lastIndex) {
                this.focusAddItemButton();
            }
            else {
                _super.prototype.navigateNext.call(this);
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.selectItem = function (item) {
            if (item === null || item === undefined) {
                return;
            }
            this.comboAPI.set_selected_item(item.itemID);
            this._focusedItem = item;
        };
        IgxComboDropDownComponent.prototype.focusAddItemButton = function () {
            if (this.combo.isAddButtonVisible()) {
                this.focusedItem = this.items[this.items.length - 1];
            }
        };
        IgxComboDropDownComponent.prototype.scrollToHiddenItem = function (newItem) { };
        Object.defineProperty(IgxComboDropDownComponent.prototype, "sortedChildren", {
            get: function () {
                if (this.children !== undefined) {
                    return this.children.toArray()
                        .sort(function (a, b) {
                        return a.index - b.index;
                    });
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboDropDownComponent.prototype, "items", {
            /**
             * Get all non-header items
             *
             * ```typescript
             * let myDropDownItems = this.dropdown.items;
             * ```
             */
            get: function () {
                var e_1, _a;
                var items = [];
                if (this.children !== undefined) {
                    var sortedChildren = this.sortedChildren;
                    try {
                        for (var sortedChildren_1 = __values(sortedChildren), sortedChildren_1_1 = sortedChildren_1.next(); !sortedChildren_1_1.done; sortedChildren_1_1 = sortedChildren_1.next()) {
                            var child = sortedChildren_1_1.value;
                            if (!child.isHeader) {
                                items.push(child);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (sortedChildren_1_1 && !sortedChildren_1_1.done && (_a = sortedChildren_1.return)) _a.call(sortedChildren_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                return items;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.updateScrollPosition = function () {
            this.virtDir.getScroll().scrollTop = this._scrollPosition;
        };
        /**
         * @hidden @internal
         */
        IgxComboDropDownComponent.prototype.onItemActionKey = function (key) {
            switch (key) {
                case DropDownActionKey.ENTER:
                    this.handleEnter();
                    break;
                case DropDownActionKey.SPACE:
                    this.handleSpace();
                    break;
                case DropDownActionKey.ESCAPE:
                    this.close();
            }
        };
        IgxComboDropDownComponent.prototype.handleEnter = function () {
            if (this.isAddItemFocused()) {
                this.combo.addItemToCollection();
            }
            else {
                this.close();
            }
        };
        IgxComboDropDownComponent.prototype.handleSpace = function () {
            if (this.isAddItemFocused()) {
                return;
            }
            else {
                this.selectItem(this.focusedItem);
            }
        };
        IgxComboDropDownComponent.prototype.isAddItemFocused = function () {
            return this.focusedItem instanceof IgxComboAddItemComponent;
        };
        IgxComboDropDownComponent.prototype.ngAfterViewInit = function () {
            this.virtDir.getScroll().addEventListener('scroll', this.scrollHandler);
        };
        /**
         *@hidden @internal
         */
        IgxComboDropDownComponent.prototype.ngOnDestroy = function () {
            this.virtDir.getScroll().removeEventListener('scroll', this.scrollHandler);
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        var IgxComboDropDownComponent_1;
        IgxComboDropDownComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: IgxSelectionAPIService },
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_COMBO_COMPONENT,] }] },
            { type: IgxComboAPIService },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.ContentChildren(IgxComboItemComponent, { descendants: true })
        ], IgxComboDropDownComponent.prototype, "children", void 0);
        IgxComboDropDownComponent = IgxComboDropDownComponent_1 = __decorate([
            core.Component({
                selector: 'igx-combo-drop-down',
                template: "<div class=\"igx-drop-down__list\" igxToggle [style.width]=\"width\"\n(onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\" (onAppended)=\"onToggleContentAppended()\"\n(onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <div class=\"igx-drop-down__list-scroll\" #scrollContainer [attr.id]=\"this.listId\" role=\"listbox\"\n    [style.height]=\"height\"\n    [style.maxHeight]=\"maxHeight\">\n        <ng-container *ngIf=\"!collapsed\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</div>\n",
                providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxComboDropDownComponent_1 }]
            }),
            __param(3, core.Inject(IGX_COMBO_COMPONENT)),
            __param(5, core.Optional()), __param(5, core.Inject(DisplayDensityToken))
        ], IgxComboDropDownComponent);
        return IgxComboDropDownComponent;
    }(IgxDropDownComponent));

    /**
     * @hidden
     */
    var IgxComboFilteringPipe = /** @class */ (function () {
        function IgxComboFilteringPipe() {
        }
        IgxComboFilteringPipe.prototype.transform = function (collection, searchValue, displayKey, shouldFilter) {
            if (!collection) {
                return [];
            }
            if (!searchValue || !shouldFilter) {
                return collection;
            }
            else {
                var searchTerm_1 = searchValue.toLowerCase().trim();
                if (displayKey != null) {
                    return collection.filter(function (e) { return e[displayKey].toLowerCase().includes(searchTerm_1); });
                }
                else {
                    return collection.filter(function (e) { return e.toLowerCase().includes(searchTerm_1); });
                }
            }
        };
        IgxComboFilteringPipe = __decorate([
            core.Pipe({
                name: 'comboFiltering'
            })
        ], IgxComboFilteringPipe);
        return IgxComboFilteringPipe;
    }());
    /**
     * @hidden
     */
    var IgxComboGroupingPipe = /** @class */ (function () {
        function IgxComboGroupingPipe(combo) {
            this.combo = combo;
        }
        IgxComboGroupingPipe.prototype.transform = function (collection, groupKey, valueKey) {
            var _a;
            this.combo.filteredData = collection;
            if ((!groupKey && groupKey !== 0) || !collection.length) {
                return collection;
            }
            var sorted = DataUtil.sort(cloneArray(collection), [{
                    fieldName: groupKey,
                    dir: exports.SortingDirection.Asc,
                    ignoreCase: true,
                    strategy: DefaultSortingStrategy.instance()
                }]);
            var data = cloneArray(sorted);
            var inserts = 0;
            var currentHeader = null;
            for (var i = 0; i < sorted.length; i++) {
                var insertFlag = 0;
                if (currentHeader !== sorted[i][groupKey]) {
                    currentHeader = sorted[i][groupKey];
                    insertFlag = 1;
                }
                if (insertFlag) {
                    data.splice(i + inserts, 0, (_a = {},
                        _a[valueKey] = currentHeader,
                        _a[groupKey] = currentHeader,
                        _a.isHeader = true,
                        _a));
                    inserts++;
                }
            }
            return data;
        };
        IgxComboGroupingPipe.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_COMBO_COMPONENT,] }] }
        ]; };
        IgxComboGroupingPipe = __decorate([
            core.Pipe({
                name: 'comboGrouping'
            }),
            __param(0, core.Inject(IGX_COMBO_COMPONENT))
        ], IgxComboGroupingPipe);
        return IgxComboGroupingPipe;
    }());

    /**
     * @hidden
     */
    var DataTypes;
    (function (DataTypes) {
        DataTypes["EMPTY"] = "empty";
        DataTypes["PRIMITIVE"] = "primitive";
        DataTypes["COMPLEX"] = "complex";
        DataTypes["PRIMARYKEY"] = "valueKey";
    })(DataTypes || (DataTypes = {}));
    /**
     * @hidden
     */
    var ItemHeights = {
        'comfortable': 40,
        'cosy': 32,
        'compact': 28,
    };
    /**
     * @hidden
     * The default number of items that should be in the combo's
     * drop-down list if no `[itemsMaxHeight]` is specified
     */
    var itemsInContainer = 10;

    (function (IgxComboState) {
        /**
         * Combo with initial state.
         */
        IgxComboState[IgxComboState["INITIAL"] = 0] = "INITIAL";
        /**
         * Combo with valid state.
         */
        IgxComboState[IgxComboState["VALID"] = 1] = "VALID";
        /**
         * Combo with invalid state.
         */
        IgxComboState[IgxComboState["INVALID"] = 2] = "INVALID";
    })(exports.IgxComboState || (exports.IgxComboState = {}));
    /**
     * When called with sets A & B, returns A - B (as array);
     * @hidden
     */
    function diffInSets(set1, set2) {
        var results = [];
        set1.forEach(function (entry) {
            if (!set2.has(entry)) {
                results.push(entry);
            }
        });
        return results;
    }
    var NEXT_ID$j = 0;
    var noop$4 = function () { };
    var ɵ0$4 = noop$4;
    var IgxComboComponent = /** @class */ (function (_super) {
        __extends(IgxComboComponent, _super);
        function IgxComboComponent(elementRef, cdr, selection, comboAPI, _displayDensityOptions, _injector) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.selection = selection;
            _this.comboAPI = comboAPI;
            _this._displayDensityOptions = _displayDensityOptions;
            _this._injector = _injector;
            /**
             * @hidden @internal
             */
            _this.customValueFlag = true;
            /**
             * @hidden @internal
             */
            _this.defaultFallbackGroup = 'Other';
            _this.stringFilters = IgxStringFilteringOperand;
            _this.booleanFilters = IgxBooleanFilteringOperand;
            _this._groupKey = '';
            _this._prevInputValue = '';
            _this._dataType = '';
            _this.ngControl = null;
            _this.destroy$ = new rxjs.Subject();
            _this._data = [];
            _this._filteredData = [];
            _this._itemHeight = null;
            _this._itemsMaxHeight = null;
            _this._remoteSelection = {};
            _this._onChangeCallback = noop$4;
            _this._onTouchedCallback = noop$4;
            _this._overlaySettings = {
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new ConnectedPositioningStrategy(),
                modal: false,
                closeOnOutsideClick: true,
                excludePositionTarget: true
            };
            _this._value = '';
            _this._valid = exports.IgxComboState.INITIAL;
            /**
             * Set custom overlay settings that control how the combo's list of items is displayed.
             * Set:
             * ```html
             * <igx-combo [overlaySettings] = "customOverlaySettings"></igx-combo>
             * ```
             *
             * ```typescript
             *  const customSettings = { positionStrategy: { settings: { target: myTarget } } };
             *  combo.overlaySettings = customSettings;
             * ```
             * Get any custom overlay settings used by the combo:
             * ```typescript
             *  const comboOverlaySettings: OverlaySettings = myCombo.overlaySettings;
             * ```
             */
            _this.overlaySettings = null;
            /**
             * @hidden @internal
             */
            _this.searchInput = null;
            /**
             * The custom template, if any, that should be used when rendering ITEMS in the combo list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.itemTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboItem>
             *          <div class="custom-item" let-item let-key="valueKey">
             *              <div class="custom-item__name">{{ item[key] }}</div>
             *              <div class="custom-item__cost">{{ item.cost }}</div>
             *          </div>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.itemTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the HEADER for the combo items list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.headerTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboHeader>
             *          <div class="combo__header">
             *              This is a custom header
             *          </div>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.headerTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the FOOTER for the combo items list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.footerTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboFooter>
             *          <div class="combo__footer">
             *              This is a custom footer
             *          </div>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.footerTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering HEADER ITEMS for groups in the combo list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.headerItemTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboHeaderItem let-item let-key="groupKey">
             *          <div class="custom-item--group">Group header for {{ item[key] }}</div>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.headerItemTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.addItemTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboAddItem>
             *          <button class="combo__add-button">
             *              Click to add item
             *          </button>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.addItemTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.emptyTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboEmpty>
             *          <div class="combo--empty">
             *              There are no items to display
             *          </div>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.emptyTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the combo TOGGLE(open/close) button
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.toggleIconTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboToggleIcon let-collapsed>
             *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.toggleIconTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the combo CLEAR button
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.combo.clearIconTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-combo #combo>
             *      ...
             *      <ng-template igxComboClearIcon>
             *          <igx-icon>clear</igx-icon>
             *      </ng-template>
             *  </igx-combo>
             * ```
             */
            _this.clearIconTemplate = null;
            _this.dropdownContainer = null;
            /**
             * Emitted when item selection is changing, before the selection completes
             *
             * ```html
             * <igx-combo (onSelectionChange)='handleSelection()'></igx-combo>
             * ```
             */
            _this.onSelectionChange = new core.EventEmitter();
            /**
             * Emitted before the dropdown is opened
             *
             * ```html
             * <igx-combo onOpening='handleOpening($event)'></igx-combo>
             * ```
             */
            _this.onOpening = new core.EventEmitter();
            /**
             * Emitted after the dropdown is opened
             *
             * ```html
             * <igx-combo (onOpened)='handleOpened()'></igx-combo>
             * ```
             */
            _this.onOpened = new core.EventEmitter();
            /**
             * Emitted before the dropdown is closed
             *
             * ```html
             * <igx-combo (onClosing)='handleClosing($event)'></igx-combo>
             * ```
             */
            _this.onClosing = new core.EventEmitter();
            /**
             * Emitted after the dropdown is closed
             *
             * ```html
             * <igx-combo (onClosed)='handleClosed()'></igx-combo>
             * ```
             */
            _this.onClosed = new core.EventEmitter();
            /**
             * Emitted when an item is being added to the data collection
             *
             * ```html
             * <igx-combo (onAddition)='handleAdditionEvent()'></igx-combo>
             * ```
             */
            _this.onAddition = new core.EventEmitter();
            /**
             * Emitted when the value of the search input changes (e.g. typing, pasting, clear, etc.)
             *
             * ```html
             * <igx-combo (onSearchInput)='handleSearchInputEvent()'></igx-combo>
             * ```
             */
            _this.onSearchInput = new core.EventEmitter();
            /**
             * Emitted when new chunk of data is loaded from the virtualization
             *
             * ```html
             * <igx-combo (onDataPreLoad)='handleDataPreloadEvent()'></igx-combo>
             * ```
             */
            _this.onDataPreLoad = new core.EventEmitter();
            /**
             * Gets/gets combo id.
             *
             * ```typescript
             * // get
             * let id = this.combo.id;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [id]='combo1'></igx-combo>
             * ```
            */
            _this.id = "igx-combo-" + NEXT_ID$j++;
            /**
             * @hidden @internal
             */
            _this.cssClass = 'igx-combo'; // Independent of display density, at the time being
            /**
             * @hidden @internal
             */
            _this.role = 'combobox';
            /**
             * Controls whether custom values can be added to the collection
             *
             * ```typescript
             * // get
             * let comboAllowsCustomValues = this.combo.allowCustomValues;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [allowCustomValues]='true'></igx-combo>
             * ```
             */
            _this.allowCustomValues = false;
            /**
             * @hidden @internal
             */
            _this.filteringLogic = exports.FilteringLogic.Or;
            /**
             * Defines the placeholder value for the combo dropdown search field
             *
             * ```typescript
             * // get
             * let myComboSearchPlaceholder = this.combo.searchPlaceholder;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [searchPlaceholder]='newPlaceHolder'></igx-combo>
             * ```
             */
            _this.searchPlaceholder = 'Enter a Search Term';
            /**
             * Combo value data source property.
             *
             * ```typescript
             * // get
             * let myComboValueKey = this.combo.valueKey;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [valueKey]='myKey'></igx-combo>
             * ```
             */
            _this.valueKey = null;
            /**
             * An @Input property that enabled/disables filtering in the list. The default is `true`.
             * ```html
             *<igx-combo [filterable]="false">
             * ```
             */
            _this.filterable = true;
            /**
             * An @Input property that enabled/disables combo. The default is `false`.
             * ```html
             *<igx-combo [disabled]="'true'">
             * ```
             */
            _this.disabled = false;
            /**
             * An @Input property that sets how the combo will be styled.
             * The allowed values are `line`, `box`, `border` and `search`. The default is `box`.
             * ```html
             *<igx-combo [type]="'line'">
             * ```
             */
            _this.type = 'box';
            /**
             * @hidden @internal
             */
            _this.searchValue = '';
            _this.onStatusChanged = function () {
                if ((_this.ngControl.control.touched || _this.ngControl.control.dirty) &&
                    (_this.ngControl.control.validator || _this.ngControl.control.asyncValidator)) {
                    _this.valid = _this.ngControl.valid ? exports.IgxComboState.VALID : exports.IgxComboState.INVALID;
                }
                _this.manageRequiredAsterisk();
            };
            _this.comboAPI.register(_this);
            return _this;
        }
        IgxComboComponent_1 = IgxComboComponent;
        Object.defineProperty(IgxComboComponent.prototype, "displaySearchInput", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.filterable || this.allowCustomValues;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "ariaExpanded", {
            /**
             * @hidden @internal
             */
            get: function () {
                return !this.dropdown.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "hasPopUp", {
            /**
             * @hidden @internal
             */
            get: function () {
                return 'listbox';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "ariaOwns", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.dropdown.id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "itemsMaxHeight", {
            /**
             * Configures the drop down list height
             *
             * ```typescript
             * // get
             * let myComboItemsMaxHeight = this.combo.itemsMaxHeight;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [itemsMaxHeight]='320'></igx-combo>
             * ```
            */
            get: function () {
                if (this._itemsMaxHeight === null || this._itemsMaxHeight === undefined) {
                    return this.itemHeight * itemsInContainer;
                }
                return this._itemsMaxHeight;
            },
            set: function (val) {
                this._itemsMaxHeight = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "itemHeight", {
            /**
             * Configures the drop down list item height
             *
             * ```typescript
             * // get
             * let myComboItemHeight = this.combo.itemHeight;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [itemHeight]='32'></igx-combo>
             * ```
             */
            get: function () {
                if (this._itemHeight === null || this._itemHeight === undefined) {
                    return ItemHeights[this.displayDensity];
                }
                return this._itemHeight;
            },
            set: function (val) {
                this._itemHeight = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "inputEmpty", {
            /**
             * @hidden @internal
             */
            get: function () {
                return !this.value && !this.placeholder;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "data", {
            /**
             * Combo data source.
             *
             * ```html
             * <!--set-->
             * <igx-combo [data]='items'></igx-combo>
             * ```
             */
            get: function () {
                return this._data;
            },
            set: function (val) {
                this._data = (val) ? val : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "displayKey", {
            /**
             * Combo text data source property.
             *
             * ```typescript
             * // get
             * let myComboDisplayKey = this.combo.displayKey;
             *
             * // set
             * this.combo.displayKey = 'val';
             *
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-combo [displayKey]='myDisplayKey'></igx-combo>
             * ```
             */
            get: function () {
                return this._displayKey ? this._displayKey : this.valueKey;
            },
            set: function (val) {
                this._displayKey = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "groupKey", {
            /**
             * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
             *
             * ```typescript
             * // get
             * let currentGroupKey = this.combo.groupKey;
             * ```
             */
            get: function () {
                return this._groupKey;
            },
            /**
             * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
             *
             * ```html
             * <!--set-->
             * <igx-combo [groupKey]='newGroupKey'></igx-combo>
             * ```
             */
            set: function (val) {
                this._groupKey = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "valid", {
            /**
             * Gets if control is valid, when used in a form
             *
             * ```typescript
             * // get
             * let valid = this.combo.valid;
             * ```
             * */
            get: function () {
                return this._valid;
            },
            /**
            * Sets if control is valid, when used in a form
            *
            * ```typescript
            * // set
            * this.combo.valid = IgxComboState.INVALID;
            * ```
           */
            set: function (valid) {
                this._valid = valid;
                this.comboInput.valid = exports.IgxInputState[exports.IgxComboState[valid]];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.onArrowDown = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.open();
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.onInputClick = function (event) {
            event.stopPropagation();
            event.preventDefault();
            this.toggle();
        };
        Object.defineProperty(IgxComboComponent.prototype, "virtualizationState", {
            /**
             * Defines the current state of the virtualized data. It contains `startIndex` and `chunkSize`
             *
             * ```typescript
             * // get
             * let state = this.combo.virtualizationState;
             * ```
            */
            get: function () {
                return this.virtDir.state;
            },
            /**
             * Sets the current state of the virtualized data.
             *
             * ```typescript
             * // set
             * this.combo.virtualizationState(state);
             * ```
             */
            set: function (state) {
                this.virtDir.state = state;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "totalItemCount", {
            /**
             * Gets total count of the virtual data items, when using remote service.
             *
             * ```typescript
             * // get
             * let count = this.combo.totalItemCount;
             * ```
            */
            get: function () {
                return this.virtDir.totalItemCount;
            },
            /**
             * Sets total count of the virtual data items, when using remote service.
             *
             * ```typescript
             * // set
             * this.combo.totalItemCount(remoteService.count);
             * ```
             */
            set: function (count) {
                this.virtDir.totalItemCount = count;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "value", {
            /**
             * The text displayed in the combo input
             *
             * ```typescript
             * // get
             * let comboValue = this.combo.value;
             * ```
             */
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "filteredData", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.filterable ? this._filteredData : this.data;
            },
            /**
             * @hidden @internal
             */
            set: function (val) {
                this._filteredData = this.groupKey ? (val || []).filter(function (e) { return e.isHeader !== true; }) : val;
                this.checkMatch();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleKeyUp = function (event) {
            if (event.key === 'ArrowDown' || event.key === 'Down') {
                this.dropdown.focusedItem = this.dropdown.items[0];
                this.dropdownContainer.nativeElement.focus();
            }
            else if (event.key === 'Escape' || event.key === 'Esc') {
                this.toggle();
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleKeyDown = function (event) {
            if (event.key === 'ArrowUp' || event.key === 'Up') {
                event.preventDefault();
                event.stopPropagation();
                this.close();
            }
        };
        IgxComboComponent.prototype.checkMatch = function () {
            var _this = this;
            var displayKey = this.displayKey;
            var matchFn = function (e) {
                var value = displayKey ? e[displayKey] : e;
                return value.toString().toLowerCase() === _this.searchValue.trim().toLowerCase();
            };
            var itemMatch = this.filteredData.some(matchFn);
            this.customValueFlag = this.allowCustomValues && !itemMatch;
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleInputChange = function (event) {
            if (event !== undefined) {
                this.onSearchInput.emit(event);
            }
            this.checkMatch();
        };
        Object.defineProperty(IgxComboComponent.prototype, "dataType", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.displayKey) {
                    return DataTypes.COMPLEX;
                }
                return DataTypes.PRIMITIVE;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "isRemote", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.totalItemCount > 0 &&
                    this.valueKey &&
                    this.dataType === DataTypes.COMPLEX;
            },
            enumerable: true,
            configurable: true
        });
        /** Contains key-value pairs of the selected valueKeys and their resp. displayKeys */
        IgxComboComponent.prototype.registerRemoteEntries = function (ids, add) {
            var e_1, _a, e_2, _b;
            if (add === void 0) { add = true; }
            if (add) {
                var selection = this.getValueDisplayPairs(ids);
                try {
                    for (var selection_1 = __values(selection), selection_1_1 = selection_1.next(); !selection_1_1.done; selection_1_1 = selection_1.next()) {
                        var entry = selection_1_1.value;
                        this._remoteSelection[entry[this.valueKey]] = entry[this.displayKey];
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (selection_1_1 && !selection_1_1.done && (_a = selection_1.return)) _a.call(selection_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                try {
                    for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
                        var entry = ids_1_1.value;
                        delete this._remoteSelection[entry];
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (ids_1_1 && !ids_1_1.done && (_b = ids_1.return)) _b.call(ids_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        };
        /** For `id: any[]` returns a mapped `{ [combo.valueKey]: any, [combo.displayKey]: any }[]`*/
        IgxComboComponent.prototype.getValueDisplayPairs = function (ids) {
            var _this = this;
            return this.data.filter(function (entry) { return ids.indexOf(entry[_this.valueKey]) > -1; }).map(function (e) {
                var _a;
                return _a = {},
                    _a[_this.valueKey] = e[_this.valueKey],
                    _a[_this.displayKey] = e[_this.displayKey],
                    _a;
            });
        };
        /**
         * Returns if the specified itemID is selected
         * @hidden
         * @internal
         */
        IgxComboComponent.prototype.isItemSelected = function (item) {
            return this.selection.is_item_selected(this.id, item);
        };
        /**
         * Triggers change detection on the combo view
         */
        IgxComboComponent.prototype.triggerCheck = function () {
            this.cdr.detectChanges();
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.isAddButtonVisible = function () {
            // This should always return a boolean value. If this.searchValue was '', it returns '' instead of false;
            return this.searchValue !== '' && this.customValueFlag;
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleSelectAll = function (evt) {
            if (evt.checked) {
                this.selectAllItems();
            }
            else {
                this.deselectAllItems();
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.addItemToCollection = function () {
            var _a, _b;
            if (!this.searchValue) {
                return;
            }
            var newValue = this.searchValue.trim();
            var addedItem = this.displayKey ? (_a = {},
                _a[this.valueKey] = newValue,
                _a[this.displayKey] = newValue,
                _a) : newValue;
            if (this.groupKey) {
                Object.assign(addedItem, (_b = {}, _b[this.groupKey] = this.defaultFallbackGroup, _b));
            }
            var oldCollection = this.data;
            var newCollection = __spread(this.data);
            newCollection.push(addedItem);
            var args = {
                oldCollection: oldCollection, addedItem: addedItem, newCollection: newCollection
            };
            this.onAddition.emit(args);
            this.data.push(addedItem);
            // If you mutate the array, no pipe is invoked and the display isn't updated;
            // if you replace the array, the pipe executes and the display is updated.
            this.data = cloneArray(this.data);
            this.selectItems(this.comboAPI.valueKey !== null ? [addedItem[this.valueKey]] : [addedItem], false);
            this.customValueFlag = false;
            this.searchInput.nativeElement.focus();
            this.dropdown.focusedItem = null;
            this.virtDir.scrollTo(0);
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.focusSearchInput = function (opening) {
            if (this.displaySearchInput && this.searchInput) {
                this.searchInput.nativeElement.focus();
            }
            else {
                if (opening) {
                    this.dropdownContainer.nativeElement.focus();
                }
                else {
                    this.comboInput.nativeElement.focus();
                    this.toggle();
                }
            }
        };
        IgxComboComponent.prototype.manageRequiredAsterisk = function () {
            if (this.ngControl && this.ngControl.control.validator) {
                // Run the validation with empty object to check if required is enabled.
                var error = this.ngControl.control.validator({});
                this.inputGroup.isRequired = error && error.required;
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.onBlur = function () {
            if (this.collapsed) {
                this._onTouchedCallback();
                if (this.ngControl && !this.ngControl.valid) {
                    this.valid = exports.IgxComboState.INVALID;
                }
                else {
                    this.valid = exports.IgxComboState.INITIAL;
                }
            }
        };
        /** @hidden @internal */
        IgxComboComponent.prototype.onFocus = function () {
            if (this.collapsed) {
                this._onTouchedCallback();
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.ngOnInit = function () {
            this.ngControl = this._injector.get(forms.NgControl, null);
            this._overlaySettings.positionStrategy.settings.target = this.elementRef.nativeElement;
            this.selection.set(this.id, new Set());
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.filteredData = __spread(this.data);
            if (this.ngControl) {
                this.ngControl.statusChanges.pipe(operators.takeUntil(this.destroy$)).subscribe(this.onStatusChanged);
                this.manageRequiredAsterisk();
                this.cdr.detectChanges();
            }
            this.virtDir.onChunkPreload.pipe(operators.takeUntil(this.destroy$)).subscribe(function (e) {
                _this.onDataPreLoad.emit(e);
            });
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next();
            this.destroy$.complete();
            this.comboAPI.clear();
            this.selection.clear(this.id);
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.writeValue = function (value) {
            this.selectItems(value, true);
            this.cdr.markForCheck();
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        /**
         * @hidden
         */
        IgxComboComponent.prototype.getEditElement = function () {
            return this.comboInput.nativeElement;
        };
        Object.defineProperty(IgxComboComponent.prototype, "template", {
            /**
             * @hidden @internal
             */
            get: function () {
                this._dataType = this.dataType;
                if (this.itemTemplate) {
                    return this.itemTemplate;
                }
                if (this._dataType === DataTypes.COMPLEX) {
                    return this.complexTemplate;
                }
                return this.primitiveTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxComboComponent.prototype, "context", {
            /**
             * @hidden @internal
             */
            get: function () {
                return {
                    $implicit: this
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleClearItems = function (event) {
            this.deselectAllItems(true, event);
            if (this.collapsed) {
                this.getEditElement().focus();
            }
            else {
                this.focusSearchInput(true);
            }
            event.stopPropagation();
        };
        /**
         * A method that opens/closes the combo.
         *
         *```html
         *<button (click)="combo.toggle()">Toggle Combo</button>
         *<igx-combo #combo></igx-combo>
         *```
         */
        IgxComboComponent.prototype.toggle = function () {
            var overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
            this.dropdown.toggle(overlaySettings);
        };
        /**
         * A method that opens the combo.
         *
         *```html
         *<button (click)="combo.open()">Open Combo</button>
         *<igx-combo #combo></igx-combo>
         *```
         */
        IgxComboComponent.prototype.open = function () {
            var overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
            this.dropdown.open(overlaySettings);
        };
        /**
         * A method that closes the combo.
         *
         *```html
         *<button (click)="combo.close()">Close Combo</button>
         *<igx-combo #combo></igx-combo>
         *```
         */
        IgxComboComponent.prototype.close = function () {
            this.dropdown.close();
        };
        Object.defineProperty(IgxComboComponent.prototype, "collapsed", {
            /**
             * Gets drop down state.
             *
             * ```typescript
             * let state = this.combo.collapsed;
             * ```
            */
            get: function () {
                return this.dropdown.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Get current selection state
         * @returns Array of selected items
         * ```typescript
         * let selectedItems = this.combo.selectedItems();
         * ```
         */
        IgxComboComponent.prototype.selectedItems = function () {
            var items = Array.from(this.selection.get(this.id));
            return items;
        };
        /**
         * Select defined items
         * @param newItems new items to be selected
         * @param clearCurrentSelection if true clear previous selected items
         * ```typescript
         * this.combo.selectItems(["New York", "New Jersey"]);
         * ```
         */
        IgxComboComponent.prototype.selectItems = function (newItems, clearCurrentSelection, event) {
            if (newItems) {
                var newSelection = this.selection.add_items(this.id, newItems, clearCurrentSelection);
                this.setSelection(newSelection, event);
            }
        };
        /**
         * Deselect defined items
         * @param items items to deselected
         * ```typescript
         * this.combo.deselectItems(["New York", "New Jersey"]);
         * ```
         */
        IgxComboComponent.prototype.deselectItems = function (items, event) {
            if (items) {
                var newSelection = this.selection.delete_items(this.id, items);
                this.setSelection(newSelection, event);
            }
        };
        /**
         * Select all (filtered) items
         * @param ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.
         * ```typescript
         * this.combo.selectAllItems();
         * ```
         */
        IgxComboComponent.prototype.selectAllItems = function (ignoreFilter, event) {
            var allVisible = this.selection.get_all_ids(ignoreFilter ? this.data : this.filteredData, this.valueKey);
            var newSelection = this.selection.add_items(this.id, allVisible);
            this.setSelection(newSelection, event);
        };
        /**
         * Deselect all (filtered) items
         * @param ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.
         * ```typescript
         * this.combo.deselectAllItems();
         * ```
         */
        IgxComboComponent.prototype.deselectAllItems = function (ignoreFilter, event) {
            var newSelection = this.selection.get_empty();
            if (this.filteredData.length !== this.data.length && !ignoreFilter) {
                newSelection = this.selection.delete_items(this.id, this.selection.get_all_ids(this.filteredData, this.valueKey));
            }
            this.setSelection(newSelection, event);
        };
        /**
         * Selects/Deselects a single item
         * @param itemID the itemID of the specific item
         * @param select If the item should be selected (true) or deselected (false)
         *
         * Without specified valueKey;
         * ```typescript
         * this.combo.valueKey = null;
         * const items: { field: string, region: string}[] = data;
         * this.combo.setSelectedItem(items[0], true);
         * ```
         * With specified valueKey;
         * ```typescript
         * this.combo.valueKey = 'field';
         * const items: { field: string, region: string}[] = data;
         * this.combo.setSelectedItem('Connecticut', true);
         * ```
         */
        IgxComboComponent.prototype.setSelectedItem = function (itemID, select, event) {
            if (select === void 0) { select = true; }
            if (itemID === null || itemID === undefined) {
                return;
            }
            if (select) {
                this.selectItems([itemID], false, event);
            }
            else {
                this.deselectItems([itemID], event);
            }
        };
        IgxComboComponent.prototype.setSelection = function (newSelection, event) {
            var removed = diffInSets(this.selection.get(this.id), newSelection);
            var added = diffInSets(newSelection, this.selection.get(this.id));
            var newSelectionAsArray = Array.from(newSelection);
            var oldSelectionAsArray = Array.from(this.selection.get(this.id) || []);
            var displayText = this.createDisplayText(newSelectionAsArray, oldSelectionAsArray);
            var args = {
                newSelection: newSelectionAsArray,
                oldSelection: oldSelectionAsArray,
                added: added,
                removed: removed,
                event: event,
                displayText: displayText,
                cancel: false
            };
            this.onSelectionChange.emit(args);
            if (!args.cancel) {
                this.selection.select_items(this.id, args.newSelection, true);
                if (displayText !== args.displayText) {
                    this._value = args.displayText;
                }
                else {
                    this._value = this.createDisplayText(args.newSelection, args.oldSelection);
                }
                this._onChangeCallback(args.newSelection);
            }
        };
        /** Returns a string that should be populated in the combo's text box */
        IgxComboComponent.prototype.concatDisplayText = function (selection) {
            var _this = this;
            var value = this.displayKey !== null && this.displayKey !== undefined ?
                this.convertKeysToItems(selection).map(function (entry) { return entry[_this.displayKey]; }).join(', ') :
                selection.join(', ');
            return value;
        };
        /** Constructs the combo display value
         * If remote, caches the key displayText
         * If not, just combine the object.displayKeys
         */
        IgxComboComponent.prototype.createDisplayText = function (newSelection, oldSelection) {
            var _this = this;
            var value = '';
            if (this.isRemote) {
                if (newSelection.length) {
                    var removedItems = oldSelection.filter(function (e) { return newSelection.indexOf(e) < 0; });
                    var addedItems = newSelection.filter(function (e) { return oldSelection.indexOf(e) < 0; });
                    this.registerRemoteEntries(addedItems);
                    this.registerRemoteEntries(removedItems, false);
                    value = Object.keys(this._remoteSelection).map(function (e) { return _this._remoteSelection[e]; }).join(', ');
                }
                else {
                    // If new selection is empty, clear all items
                    this.registerRemoteEntries(oldSelection, false);
                }
            }
            else {
                value = this.concatDisplayText(newSelection);
            }
            return value;
        };
        /** if there is a valueKey - map the keys to data items, else - just return the keys */
        IgxComboComponent.prototype.convertKeysToItems = function (keys) {
            var _this = this;
            if (this.comboAPI.valueKey === null) {
                return keys;
            }
            // map keys vs. filter data to retain the order of the selected items
            return keys.map(function (key) { return _this.data.find(function (entry) { return entry[_this.valueKey] === key; }); }).filter(function (e) { return e !== undefined; });
        };
        /**
         * Event handlers
         * @hidden
         * @internal
         */
        IgxComboComponent.prototype.handleOpening = function (event) {
            this.onOpening.emit(event);
            if (event.cancel) {
                return;
            }
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleOpened = function () {
            this.triggerCheck();
            this.focusSearchInput(true);
            this.onOpened.emit();
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleClosing = function (event) {
            this.onClosing.emit(event);
            if (event.cancel) {
                return;
            }
            this.searchValue = '';
            this.comboInput.nativeElement.focus();
        };
        /**
         * @hidden @internal
         */
        IgxComboComponent.prototype.handleClosed = function () {
            this.onClosed.emit();
        };
        var IgxComboComponent_1;
        IgxComboComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: IgxSelectionAPIService },
            { type: IgxComboAPIService },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] },
            { type: core.Injector, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.ViewChild(IgxForOfDirective, { read: IgxForOfDirective, static: true })
        ], IgxComboComponent.prototype, "virtDir", void 0);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "overlaySettings", void 0);
        __decorate([
            core.ViewChild('inputGroup', { read: IgxInputGroupComponent, static: true })
        ], IgxComboComponent.prototype, "inputGroup", void 0);
        __decorate([
            core.ViewChild('comboInput', { read: IgxInputDirective, static: true })
        ], IgxComboComponent.prototype, "comboInput", void 0);
        __decorate([
            core.ViewChild(IgxComboDropDownComponent, { read: IgxComboDropDownComponent, static: true })
        ], IgxComboComponent.prototype, "dropdown", void 0);
        __decorate([
            core.ViewChild('searchInput')
        ], IgxComboComponent.prototype, "searchInput", void 0);
        __decorate([
            core.ContentChild(IgxComboItemDirective, { read: core.TemplateRef })
        ], IgxComboComponent.prototype, "itemTemplate", void 0);
        __decorate([
            core.ContentChild(IgxComboHeaderDirective, { read: core.TemplateRef })
        ], IgxComboComponent.prototype, "headerTemplate", void 0);
        __decorate([
            core.ContentChild(IgxComboFooterDirective, { read: core.TemplateRef })
        ], IgxComboComponent.prototype, "footerTemplate", void 0);
        __decorate([
            core.ContentChild(IgxComboHeaderItemDirective, { read: core.TemplateRef })
        ], IgxComboComponent.prototype, "headerItemTemplate", void 0);
        __decorate([
            core.ContentChild(IgxComboAddItemDirective, { read: core.TemplateRef })
        ], IgxComboComponent.prototype, "addItemTemplate", void 0);
        __decorate([
            core.ContentChild(IgxComboEmptyDirective, { read: core.TemplateRef })
        ], IgxComboComponent.prototype, "emptyTemplate", void 0);
        __decorate([
            core.ContentChild(IgxComboToggleIconDirective, { read: core.TemplateRef })
        ], IgxComboComponent.prototype, "toggleIconTemplate", void 0);
        __decorate([
            core.ContentChild(IgxComboClearIconDirective, { read: core.TemplateRef })
        ], IgxComboComponent.prototype, "clearIconTemplate", void 0);
        __decorate([
            core.ViewChild('primitive', { read: core.TemplateRef, static: true })
        ], IgxComboComponent.prototype, "primitiveTemplate", void 0);
        __decorate([
            core.ViewChild('complex', { read: core.TemplateRef, static: true })
        ], IgxComboComponent.prototype, "complexTemplate", void 0);
        __decorate([
            core.ViewChild(IgxForOfDirective, { static: true })
        ], IgxComboComponent.prototype, "virtualScrollContainer", void 0);
        __decorate([
            core.ViewChild('dropdownItemContainer', { static: true })
        ], IgxComboComponent.prototype, "dropdownContainer", void 0);
        __decorate([
            core.Output()
        ], IgxComboComponent.prototype, "onSelectionChange", void 0);
        __decorate([
            core.Output()
        ], IgxComboComponent.prototype, "onOpening", void 0);
        __decorate([
            core.Output()
        ], IgxComboComponent.prototype, "onOpened", void 0);
        __decorate([
            core.Output()
        ], IgxComboComponent.prototype, "onClosing", void 0);
        __decorate([
            core.Output()
        ], IgxComboComponent.prototype, "onClosed", void 0);
        __decorate([
            core.Output()
        ], IgxComboComponent.prototype, "onAddition", void 0);
        __decorate([
            core.Output()
        ], IgxComboComponent.prototype, "onSearchInput", void 0);
        __decorate([
            core.Output()
        ], IgxComboComponent.prototype, "onDataPreLoad", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxComboComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('style.width'),
            core.Input()
        ], IgxComboComponent.prototype, "width", void 0);
        __decorate([
            core.HostBinding('class.igx-combo')
        ], IgxComboComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding("attr.role")
        ], IgxComboComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.aria-expanded')
        ], IgxComboComponent.prototype, "ariaExpanded", null);
        __decorate([
            core.HostBinding('attr.aria-haspopup')
        ], IgxComboComponent.prototype, "hasPopUp", null);
        __decorate([
            core.HostBinding('attr.aria-owns')
        ], IgxComboComponent.prototype, "ariaOwns", null);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "allowCustomValues", void 0);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "itemsMaxHeight", null);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "itemsWidth", void 0);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "itemHeight", null);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "placeholder", void 0);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "searchPlaceholder", void 0);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "data", null);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "valueKey", void 0);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "displayKey", null);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "groupKey", null);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "filterable", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('attr.aria-labelledby')
        ], IgxComboComponent.prototype, "ariaLabelledBy", void 0);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input()
        ], IgxComboComponent.prototype, "type", void 0);
        __decorate([
            core.HostListener('keydown.ArrowDown', ['$event']),
            core.HostListener('keydown.Alt.ArrowDown', ['$event'])
        ], IgxComboComponent.prototype, "onArrowDown", null);
        IgxComboComponent = IgxComboComponent_1 = __decorate([
            core.Component({
                selector: 'igx-combo',
                template: "<igx-input-group #inputGroup [displayDensity]=\"displayDensity\" [type]=\"type\" (click)=\"onInputClick($event)\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\">\n        <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n    </ng-container>\n    <input igxInput #comboInput name=\"comboInput\" type=\"text\" [value]=\"value\" readonly [attr.placeholder]=\"placeholder\"\n        [disabled]=\"disabled\" (blur)=\"onBlur()\" (focus)=\"onFocus()\"/>\n    <ng-container ngProjectAs=\"igx-suffix\">\n        <ng-content select=\"igx-suffix\"></ng-content>\n    </ng-container>\n    <igx-suffix *ngIf=\"value.length\" aria-label=\"Clear Selection\" class=\"igx-combo__clear-button\"\n        (click)=\"handleClearItems($event)\">\n        <ng-container *ngIf=\"clearIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"clearIconTemplate\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!clearIconTemplate\" fontSet=\"material\">\n            clear\n        </igx-icon>\n    </igx-suffix>\n    <igx-suffix igxButton=\"icon\" class=\"igx-combo__toggle-button\" igxRipple>\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">\n            {{ dropdown.collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}\n        </igx-icon>\n    </igx-suffix>\n</igx-input-group>\n<igx-combo-drop-down #igxComboDropDown class=\"igx-combo__drop-down\" [displayDensity]=\"displayDensity\"\n    [width]=\"itemsWidth || '100%'\" (onOpening)=\"handleOpening($event)\" (onClosing)=\"handleClosing($event)\"\n    (onOpened)=\"handleOpened()\" (onClosed)=\"handleClosed()\">\n    <igx-input-group *ngIf=\"displaySearchInput\" [displayDensity]=\"displayDensity\" class=\"igx-combo__search\">\n        <input class=\"igx-combo-input\" igxInput #searchInput name=\"searchInput\" autocomplete=\"off\" type=\"text\"\n            [(ngModel)]=\"searchValue\" (ngModelChange)=\"handleInputChange($event)\" (keyup)=\"handleKeyUp($event)\"\n            (keydown)=\"handleKeyDown($event)\" (focus)=\"dropdown.onBlur($event)\" [attr.placeholder]=\"searchPlaceholder\"\n            aria-autocomplete=\"both\" [attr.aria-owns]=\"dropdown.id\" [attr.aria-labelledby]=\"ariaLabelledBy\" />\n    </igx-input-group>\n    <ng-container *ngTemplateOutlet=\"headerTemplate\">\n    </ng-container>\n    <div #dropdownItemContainer class=\"igx-combo__content\" [style.overflow]=\"'hidden'\"\n        [style.maxHeight.px]=\"itemsMaxHeight\" [igxDropDownItemNavigation]=\"dropdown\" (focus)=\"dropdown.onFocus()\"\n        [tabindex]=\"dropdown.collapsed ? -1 : 0\" role=\"listbox\" [attr.id]=\"dropdown.id\">\n        <igx-combo-item role=\"option\" [itemHeight]='itemHeight'\n            *igxFor=\"let item of data\n            | comboFiltering:searchValue:displayKey:filterable\n            | comboGrouping:groupKey:valueKey;\n            index as rowIndex; containerSize: itemsMaxHeight; scrollOrientation: 'vertical'; itemSize: itemHeight\"\n            [value]=\"item\" [isHeader]=\"item.isHeader\" [index]=\"rowIndex\">\n            <ng-container *ngIf=\"item.isHeader\">\n                <ng-container\n                    *ngTemplateOutlet=\"headerItemTemplate ? headerItemTemplate : headerItemBase;\n                    context: {$implicit: item, data: data, valueKey: valueKey, groupKey: groupKey, displayKey: displayKey}\">\n                </ng-container>\n            </ng-container>\n            <ng-container *ngIf=\"!item.isHeader\">\n                <ng-container #listItem\n                    *ngTemplateOutlet=\"template; context: {$implicit: item, data: data, valueKey: valueKey, displayKey: displayKey};\">\n                </ng-container>\n            </ng-container>\n        </igx-combo-item>\n    </div>\n    <div class=\"igx-combo__add\" *ngIf=\"filteredData.length === 0 || isAddButtonVisible()\">\n        <div class=\"igx-combo__empty\" *ngIf=\"filteredData.length === 0\">\n            <ng-container *ngTemplateOutlet=\"emptyTemplate ? emptyTemplate : empty\">\n            </ng-container>\n        </div>\n        <igx-combo-add-item [itemHeight]='itemHeight' *ngIf=\"isAddButtonVisible()\"\n            [tabindex]=\"dropdown.collapsed ? -1 : customValueFlag ? 1 : -1\" class=\"igx-combo__add-item\" role=\"button\"\n            aria-label=\"Add Item\" [index]=\"virtualScrollContainer.igxForOf.length\">\n            <ng-container *ngTemplateOutlet=\"addItemTemplate ? addItemTemplate : addItemDefault\">\n            </ng-container>\n        </igx-combo-add-item>\n    </div>\n    <ng-container *ngTemplateOutlet=\"footerTemplate\">\n    </ng-container>\n</igx-combo-drop-down>\n<ng-template #complex let-display let-data=\"data\" let-key=\"displayKey\">\n    {{display[key]}}\n</ng-template>\n<ng-template #primitive let-display>\n    {{display}}\n</ng-template>\n<ng-template #empty>\n    <span>The list is empty</span>\n</ng-template>\n<ng-template #addItemDefault let-control>\n    <button igxButton=\"flat\" igxRipple>Add item</button>\n</ng-template>\n<ng-template #headerItemBase let-item let-key=\"valueKey\" let-groupKey=\"groupKey\">\n    {{ item[key] }}\n</ng-template>",
                providers: [
                    IgxComboAPIService,
                    { provide: IGX_COMBO_COMPONENT, useExisting: IgxComboComponent_1 },
                    { provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxComboComponent_1, multi: true }
                ]
            }),
            __param(4, core.Optional()), __param(4, core.Inject(DisplayDensityToken)),
            __param(5, core.Optional())
        ], IgxComboComponent);
        return IgxComboComponent;
    }(DisplayDensityBase));
    /**
     * @hidden
     */
    var IgxComboModule = /** @class */ (function () {
        function IgxComboModule() {
        }
        IgxComboModule = __decorate([
            core.NgModule({
                declarations: [IgxComboComponent, IgxComboItemComponent, IgxComboGroupingPipe,
                    IgxComboFilteringPipe, IgxComboDropDownComponent, IgxComboAddItemComponent,
                    IgxComboItemDirective,
                    IgxComboEmptyDirective,
                    IgxComboHeaderItemDirective,
                    IgxComboHeaderDirective,
                    IgxComboFooterDirective,
                    IgxComboAddItemDirective,
                    IgxComboToggleIconDirective,
                    IgxComboClearIconDirective],
                exports: [IgxComboComponent, IgxComboItemComponent, IgxComboDropDownComponent, IgxComboAddItemComponent,
                    IgxComboItemDirective,
                    IgxComboEmptyDirective,
                    IgxComboHeaderItemDirective,
                    IgxComboHeaderDirective,
                    IgxComboFooterDirective,
                    IgxComboAddItemDirective,
                    IgxComboToggleIconDirective,
                    IgxComboClearIconDirective],
                imports: [IgxRippleModule, common.CommonModule, IgxInputGroupModule, forms.FormsModule, forms.ReactiveFormsModule,
                    IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule]
            })
        ], IgxComboModule);
        return IgxComboModule;
    }());

    /**
     *@hidden
     */
    var DatePickerUtil = /** @class */ (function () {
        function DatePickerUtil() {
        }
        /**
         * This method generates date parts structure based on editor mask and locale.
         * @param maskValue: string
         * @param locale: string
         * @returns array containing information about date parts - type, position, format
         */
        DatePickerUtil.parseDateFormat = function (maskValue, locale) {
            if (locale === void 0) { locale = DatePickerUtil.DEFAULT_LOCALE; }
            var dateStruct = [];
            if (maskValue === undefined && !isIE()) {
                dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
            }
            else {
                var mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
                var maskArray = Array.from(mask);
                var monthInitPosition = mask.indexOf("M" /* MonthChar */);
                var dayInitPosition = mask.indexOf("d" /* DayChar */);
                var yearInitPosition = mask.indexOf("y" /* YearChar */);
                if (yearInitPosition !== -1) {
                    dateStruct.push({
                        type: "year" /* Year */,
                        initialPosition: yearInitPosition,
                        formatType: DatePickerUtil.getYearFormatType(mask)
                    });
                }
                if (monthInitPosition !== -1) {
                    dateStruct.push({
                        type: "month" /* Month */,
                        initialPosition: monthInitPosition,
                        formatType: DatePickerUtil.getMonthFormatType(mask)
                    });
                }
                if (dayInitPosition !== -1) {
                    dateStruct.push({
                        type: "day" /* Day */,
                        initialPosition: dayInitPosition,
                        formatType: DatePickerUtil.getDayFormatType(mask)
                    });
                }
                for (var i = 0; i < maskArray.length; i++) {
                    if (!DatePickerUtil.isDateChar(maskArray[i])) {
                        dateStruct.push({
                            type: DatePickerUtil.SEPARATOR,
                            initialPosition: i,
                            value: maskArray[i]
                        });
                    }
                }
                dateStruct.sort(function (a, b) { return a.initialPosition - b.initialPosition; });
                DatePickerUtil.fillDatePartsPositions(dateStruct);
            }
            return dateStruct;
        };
        /**
         * This method generates input mask based on date parts.
         * @param dateStruct array
         * @returns input mask
         */
        DatePickerUtil.getInputMask = function (dateStruct) {
            var inputMask = [];
            for (var i = 0; i < dateStruct.length; i++) {
                if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                    inputMask.push(dateStruct[i].value);
                }
                else if (dateStruct[i].type === "day" /* Day */ || dateStruct[i].type === "month" /* Month */) {
                    inputMask.push('00');
                }
                else if (dateStruct[i].type === "year" /* Year */) {
                    switch (dateStruct[i].formatType) {
                        case "numeric" /* Numeric */: {
                            inputMask.push('0000');
                            break;
                        }
                        case "2-digit" /* TwoDigits */: {
                            inputMask.push('00');
                            break;
                        }
                    }
                }
            }
            return inputMask.join('');
        };
        /**
         * This method generates editor mask.
         * @param dateStruct
         * @returns editor mask
         */
        DatePickerUtil.getMask = function (dateStruct) {
            var mask = [];
            for (var i = 0; i < dateStruct.length; i++) {
                switch (dateStruct[i].formatType) {
                    case "numeric" /* Numeric */: {
                        if (dateStruct[i].type === "day" /* Day */) {
                            mask.push('d');
                        }
                        else if (dateStruct[i].type === "month" /* Month */) {
                            mask.push('M');
                        }
                        else {
                            mask.push('yyyy');
                        }
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        if (dateStruct[i].type === "day" /* Day */) {
                            mask.push('dd');
                        }
                        else if (dateStruct[i].type === "month" /* Month */) {
                            mask.push('MM');
                        }
                        else {
                            mask.push('yy');
                        }
                    }
                }
                if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                    mask.push(dateStruct[i].value);
                }
            }
            return mask.join('');
        };
        /**
         * This method parses an input string base on date parts and returns a date and its validation state.
         * @param dateFormatParts
         * @param prevDateValue
         * @param inputValue
         * @returns object containing a date and its validation state
         */
        DatePickerUtil.parseDateArray = function (dateFormatParts, prevDateValue, inputValue) {
            var dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
            var monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
            var yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
            var yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
            var day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
            var month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
            var year;
            if (yearStr === '') {
                year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
            }
            else {
                year = yearStr;
            }
            var yearPrefix;
            if (prevDateValue) {
                var originalYear = prevDateValue.getFullYear().toString();
                if (originalYear.length === 4) {
                    yearPrefix = originalYear.substring(0, 2);
                }
            }
            else {
                yearPrefix = '20';
            }
            var fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
            if ((month < 0) || (month > 11) || (month === NaN)) {
                return { state: "invalid" /* Invalid */, value: inputValue };
            }
            if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month + 1)) || (day === NaN)) {
                return { state: "invalid" /* Invalid */, value: inputValue };
            }
            return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
        };
        DatePickerUtil.maskToPromptChars = function (mask) {
            var result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
            return result;
        };
        /**
         * This method replaces prompt chars with empty string.
         * @param value
         */
        DatePickerUtil.trimUnderlines = function (value) {
            var result = value.replace(/_/g, '');
            return result;
        };
        /**
         * This method is used for spinning date parts.
         * @param dateFormatParts
         * @param inputValue
         * @param position
         * @param delta
         * @param isSpinLoop
         * @return modified text input
         */
        DatePickerUtil.getModifiedDateInput = function (dateFormatParts, inputValue, position, delta, isSpinLoop) {
            var datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
            var datePartType = datePart.type;
            var datePartFormatType = datePart.formatType;
            var newValue;
            var datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
            newValue = parseInt(datePartValue, 10);
            var maxValue, minValue;
            var minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
            minValue = minMax.min;
            maxValue = minMax.max;
            if (isNaN(newValue)) {
                if (minValue === 'infinite') {
                    newValue = 2000;
                }
                else {
                    newValue = minValue;
                }
            }
            var tempValue = newValue;
            tempValue += delta;
            // Infinite loop for full years
            if (maxValue === 'infinite' && minValue === 'infinite') {
                newValue = tempValue;
            }
            if (isSpinLoop) {
                if (tempValue > maxValue) {
                    tempValue = minValue;
                }
                if (tempValue < minValue) {
                    tempValue = maxValue;
                }
                newValue = tempValue;
            }
            else {
                if (tempValue <= maxValue && tempValue >= minValue) {
                    newValue = tempValue;
                }
            }
            var startIdx = datePart.position[0];
            var endIdx = datePart.position[1];
            var start = inputValue.slice(0, startIdx);
            var end = inputValue.slice(endIdx, inputValue.length);
            var changedPart;
            var prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
            changedPart = (newValue < 10) ? "" + prefix + newValue : "" + newValue;
            return "" + start + changedPart + end;
        };
        /**
         * This method returns date input with prompt chars.
         * @param dateFormatParts
         * @param date
         * @param inputValue
         * @returns date input including prompt chars
         */
        DatePickerUtil.addPromptCharsEditMode = function (dateFormatParts, date, inputValue) {
            var dateArray = Array.from(inputValue);
            for (var i = 0; i < dateFormatParts.length; i++) {
                if (dateFormatParts[i].formatType === "numeric" /* Numeric */) {
                    if ((dateFormatParts[i].type === "day" /* Day */ && date.getDate() < 10)
                        || (dateFormatParts[i].type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                        dateArray.splice(dateFormatParts[i].position[0], 0, DatePickerUtil.PROMPT_CHAR);
                        dateArray.join('');
                    }
                }
            }
            return dateArray.join('');
        };
        /**
         * This method checks if date input is done.
         * @param dateFormatParts
         * @param input
         * @returns input completeness
         */
        DatePickerUtil.checkForCompleteDateInput = function (dateFormatParts, input) {
            var dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
            var monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
            var yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
            var dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
            var monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
            if (DatePickerUtil.isFullInput(dayValue, dayStr)
                && DatePickerUtil.isFullInput(monthValue, monthStr)
                && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
                return 'complete';
            }
            else if (dayValue === '' && monthValue === '' && yearValue === '') {
                return 'empty';
            }
            else if (dayValue === '' || monthValue === '' || yearValue === '') {
                return 'partial';
            }
            return '';
        };
        DatePickerUtil.getYearFormatType = function (format) {
            switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
                case 1: {
                    // y (2020)
                    return "numeric" /* Numeric */;
                }
                case 4: {
                    // yyyy (2020)
                    return "numeric" /* Numeric */;
                }
                case 2: {
                    // yy (20)
                    return "2-digit" /* TwoDigits */;
                }
            }
        };
        DatePickerUtil.getMonthFormatType = function (format) {
            switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
                case 1: {
                    // M (8)
                    return "numeric" /* Numeric */;
                }
                case 2: {
                    // MM (08)
                    return "2-digit" /* TwoDigits */;
                }
            }
        };
        DatePickerUtil.getDayFormatType = function (format) {
            switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
                case 1: {
                    // d (6)
                    return "numeric" /* Numeric */;
                }
                case 2: {
                    // dd (06)
                    return "2-digit" /* TwoDigits */;
                }
            }
        };
        DatePickerUtil.getDefaultLocaleMask = function (locale) {
            var dateStruct = [];
            var formatter = new Intl.DateTimeFormat(locale);
            var formatToParts = formatter.formatToParts(new Date());
            for (var i = 0; i < formatToParts.length; i++) {
                if (formatToParts[i].type === DatePickerUtil.SEPARATOR) {
                    dateStruct.push({
                        type: DatePickerUtil.SEPARATOR,
                        value: formatToParts[i].value
                    });
                }
                else {
                    dateStruct.push({
                        type: formatToParts[i].type,
                    });
                }
            }
            var formatterOptions = formatter.resolvedOptions();
            for (var i = 0; i < dateStruct.length; i++) {
                switch (dateStruct[i].type) {
                    case "day" /* Day */: {
                        dateStruct[i].formatType = formatterOptions.day;
                        break;
                    }
                    case "month" /* Month */: {
                        dateStruct[i].formatType = formatterOptions.month;
                        break;
                    }
                    case "year" /* Year */: {
                        dateStruct[i].formatType = formatterOptions.month;
                        break;
                    }
                }
            }
            DatePickerUtil.fillDatePartsPositions(dateStruct);
            return dateStruct;
        };
        DatePickerUtil.isDateChar = function (char) {
            return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
        };
        DatePickerUtil.getNumericFormatPrefix = function (formatType) {
            switch (formatType) {
                case "2-digit" /* TwoDigits */: {
                    return '0';
                }
                case "numeric" /* Numeric */: {
                    return DatePickerUtil.PROMPT_CHAR;
                }
            }
        };
        DatePickerUtil.getMinMaxValue = function (dateFormatParts, datePart, inputValue) {
            var maxValue, minValue;
            switch (datePart.type) {
                case "month" /* Month */: {
                    minValue = 1;
                    maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                    break;
                }
                case "day" /* Day */: {
                    minValue = 1;
                    maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                    break;
                }
                case "year" /* Year */: {
                    if (datePart.formatType === "2-digit" /* TwoDigits */) {
                        minValue = 0;
                        maxValue = 99;
                    }
                    else {
                        // Infinite loop
                        minValue = 'infinite';
                        maxValue = 'infinite';
                    }
                    break;
                }
            }
            return { min: minValue, max: maxValue };
        };
        DatePickerUtil.daysInMonth = function (fullYear, month) {
            return new Date(fullYear, month, 0).getDate();
        };
        DatePickerUtil.getDateValueFromInput = function (dateFormatParts, type, inputValue, trim) {
            if (trim === void 0) { trim = true; }
            var partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
            var result = inputValue.substring(partPosition[0], partPosition[1]);
            return (trim) ? DatePickerUtil.trimUnderlines(result) : result;
        };
        DatePickerUtil.getDayValueFromInput = function (dateFormatParts, inputValue, trim) {
            if (trim === void 0) { trim = true; }
            return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
        };
        DatePickerUtil.getMonthValueFromInput = function (dateFormatParts, inputValue, trim) {
            if (trim === void 0) { trim = true; }
            return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
        };
        DatePickerUtil.getYearValueFromInput = function (dateFormatParts, inputValue, trim) {
            if (trim === void 0) { trim = true; }
            return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
        };
        DatePickerUtil.getDateFormatPart = function (dateFormatParts, type) {
            var result = dateFormatParts.filter(function (datePart) { return (datePart.type === type); })[0];
            return result;
        };
        DatePickerUtil.isFullInput = function (value, input) {
            return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
        };
        DatePickerUtil.isFullYearInput = function (dateFormatParts, value) {
            switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
                case "numeric" /* Numeric */: {
                    return (value !== '' && value.length === 4);
                }
                case "2-digit" /* TwoDigits */: {
                    return (value !== '' && value.length === 2);
                }
                default: {
                    return false;
                }
            }
        };
        DatePickerUtil.getDatePartOnPosition = function (dateFormatParts, position) {
            var result = dateFormatParts.filter(function (element) {
                return element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR;
            })[0];
            return result;
        };
        DatePickerUtil.getFullYearFromString = function (yearPart, inputValue) {
            return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
        };
        DatePickerUtil.fillDatePartsPositions = function (dateArray) {
            var currentPos = 0;
            for (var i = 0; i < dateArray.length; i++) {
                // Day|Month part positions
                if (dateArray[i].type === "day" /* Day */ || dateArray[i].type === "month" /* Month */) {
                    // Offset 2 positions for number
                    dateArray[i].position = [currentPos, currentPos + 2];
                    currentPos += 2;
                }
                else if (dateArray[i].type === "year" /* Year */) {
                    // Year part positions
                    switch (dateArray[i].formatType) {
                        case "numeric" /* Numeric */: {
                            // Offset 4 positions for full year
                            dateArray[i].position = [currentPos, currentPos + 4];
                            currentPos += 4;
                            break;
                        }
                        case "2-digit" /* TwoDigits */: {
                            // Offset 2 positions for short year
                            dateArray[i].position = [currentPos, currentPos + 2];
                            currentPos += 2;
                            break;
                        }
                    }
                }
                else if (dateArray[i].type === DatePickerUtil.SEPARATOR) {
                    // Separator positions
                    dateArray[i].position = [currentPos, currentPos + 1];
                    currentPos++;
                }
            }
        };
        DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
        DatePickerUtil.SEPARATOR = 'literal';
        DatePickerUtil.NUMBER_OF_MONTHS = 12;
        DatePickerUtil.PROMPT_CHAR = '_';
        DatePickerUtil.DEFAULT_LOCALE = 'en';
        return DatePickerUtil;
    }());

    /** @hidden */
    var IGX_DATE_PICKER_COMPONENT = 'IgxDatePickerComponentToken';

    /**
     * @hidden
     */
    var DatePickerDisplayValuePipe = /** @class */ (function () {
        function DatePickerDisplayValuePipe(_datePicker) {
            this._datePicker = _datePicker;
        }
        DatePickerDisplayValuePipe.prototype.transform = function (value, args) {
            if (value !== '') {
                if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
                    return '';
                }
                this._datePicker.rawDateString = value;
                return DatePickerUtil.trimUnderlines(value);
            }
            return '';
        };
        DatePickerDisplayValuePipe.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
        ]; };
        DatePickerDisplayValuePipe = __decorate([
            core.Pipe({
                name: 'displayValue'
            }),
            __param(0, core.Inject(IGX_DATE_PICKER_COMPONENT))
        ], DatePickerDisplayValuePipe);
        return DatePickerDisplayValuePipe;
    }());
    /**
     * @hidden
     */
    var DatePickerInputValuePipe = /** @class */ (function () {
        function DatePickerInputValuePipe(_datePicker) {
            this._datePicker = _datePicker;
        }
        DatePickerInputValuePipe.prototype.transform = function (value, args) {
            if (this._datePicker.invalidDate !== '') {
                return this._datePicker.invalidDate;
            }
            else {
                if (this._datePicker.value === null || this._datePicker.value === undefined) {
                    return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
                }
                else {
                    return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
                }
            }
        };
        DatePickerInputValuePipe.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
        ]; };
        DatePickerInputValuePipe = __decorate([
            core.Pipe({
                name: 'inputValue'
            }),
            __param(0, core.Inject(IGX_DATE_PICKER_COMPONENT))
        ], DatePickerInputValuePipe);
        return DatePickerInputValuePipe;
    }());

    var IgxDatePickerTemplateDirective = /** @class */ (function () {
        function IgxDatePickerTemplateDirective(template) {
            this.template = template;
        }
        IgxDatePickerTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxDatePickerTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxDatePickerTemplate]'
            })
            /**
             * IgxDatePickerTemplateDirective can be used to re-template the date-picker input-group.
             *
             * @hidden
             */
        ], IgxDatePickerTemplateDirective);
        return IgxDatePickerTemplateDirective;
    }());
    /**
     * IgxDatePickerActionsDirective can be used to re-template the dropdown/dialog action buttons.
     */
    var IgxDatePickerActionsDirective = /** @class */ (function () {
        function IgxDatePickerActionsDirective(template) {
            this.template = template;
        }
        IgxDatePickerActionsDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxDatePickerActionsDirective = __decorate([
            core.Directive({
                selector: '[igxDatePickerActions]'
            })
        ], IgxDatePickerActionsDirective);
        return IgxDatePickerActionsDirective;
    }());

    /**
     * This enumeration is used to configure whether the date/time picker has an editable input with drop down
     * or is readonly - the date/time is selected only through a dialog.
     */

    (function (InteractionMode) {
        InteractionMode["DropDown"] = "dropdown";
        InteractionMode["Dialog"] = "dialog";
    })(exports.InteractionMode || (exports.InteractionMode = {}));

    /**
     * @hidden
     */
    var IgxCalendarContainerComponent = /** @class */ (function () {
        function IgxCalendarContainerComponent() {
            this.mode = exports.InteractionMode.Dialog;
            this.vertical = false;
            this.onClose = new core.EventEmitter();
            this.onTodaySelection = new core.EventEmitter();
            this.styleClass = 'igx-date-picker';
        }
        Object.defineProperty(IgxCalendarContainerComponent.prototype, "dropdownCSS", {
            get: function () {
                return this.mode === exports.InteractionMode.DropDown;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCalendarContainerComponent.prototype, "verticalCSS", {
            get: function () {
                return this.vertical && this.mode === exports.InteractionMode.Dialog;
            },
            enumerable: true,
            configurable: true
        });
        IgxCalendarContainerComponent.prototype.onEscape = function (event) {
            event.preventDefault();
            this.onClose.emit();
        };
        Object.defineProperty(IgxCalendarContainerComponent.prototype, "isReadonly", {
            /**
             * Returns whether the date-picker is in readonly dialog mode.
             *
             * @hidden
            */
            get: function () {
                return this.mode === exports.InteractionMode.Dialog;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Emits close event for the calendar.
         */
        IgxCalendarContainerComponent.prototype.closeCalendar = function () {
            this.onClose.emit();
        };
        /**
        * Emits today selection event for the calendar.
        */
        IgxCalendarContainerComponent.prototype.triggerTodaySelection = function () {
            this.onTodaySelection.emit();
        };
        __decorate([
            core.ViewChild('calendar', { static: true })
        ], IgxCalendarContainerComponent.prototype, "calendar", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarContainerComponent.prototype, "mode", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarContainerComponent.prototype, "vertical", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarContainerComponent.prototype, "cancelButtonLabel", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarContainerComponent.prototype, "todayButtonLabel", void 0);
        __decorate([
            core.Input()
        ], IgxCalendarContainerComponent.prototype, "datePickerActions", void 0);
        __decorate([
            core.Output()
        ], IgxCalendarContainerComponent.prototype, "onClose", void 0);
        __decorate([
            core.Output()
        ], IgxCalendarContainerComponent.prototype, "onTodaySelection", void 0);
        __decorate([
            core.HostBinding('class.igx-date-picker')
        ], IgxCalendarContainerComponent.prototype, "styleClass", void 0);
        __decorate([
            core.HostBinding('class.igx-date-picker--dropdown')
        ], IgxCalendarContainerComponent.prototype, "dropdownCSS", null);
        __decorate([
            core.HostBinding('class.igx-date-picker--vertical')
        ], IgxCalendarContainerComponent.prototype, "verticalCSS", null);
        __decorate([
            core.HostListener('keydown.esc', ['$event']),
            core.HostListener('keydown.alt.arrowup', ['$event'])
        ], IgxCalendarContainerComponent.prototype, "onEscape", null);
        IgxCalendarContainerComponent = __decorate([
            core.Component({
                selector: 'igx-calendar-container',
                template: "<ng-template #defaultDatePickerActions>\n    <div *ngIf=\"cancelButtonLabel || todayButtonLabel\" class=\"igx-date-picker__buttons\">\n        <button #closeButton *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"closeCalendar()\">\n            {{ cancelButtonLabel }}\n        </button>\n        <button #todayButton *ngIf=\"todayButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"triggerTodaySelection()\">\n            {{ todayButtonLabel }}\n        </button>\n    </div>\n</ng-template>\n<igx-calendar #calendar></igx-calendar>\n<ng-container *ngTemplateOutlet=\"datePickerActions ? datePickerActions.template : defaultDatePickerActions\"></ng-container>\n",
                styles: [':host {display: block;}']
            })
        ], IgxCalendarContainerComponent);
        return IgxCalendarContainerComponent;
    }());

    var NEXT_ID$k = 0;
    /**
     * This enumeration is used to configure the date picker to operate with pre-defined format option used in Angular DatePipe.
     * 'https://angular.io/api/common/DatePipe'
     * 'shortDate': equivalent to 'M/d/yy' (6/15/15).
     * 'mediumDate': equivalent to 'MMM d, y' (Jun 15, 2015).
     * 'longDate': equivalent to 'MMMM d, y' (June 15, 2015).
     * 'fullDate': equivalent to 'EEEE, MMMM d, y' (Monday, June 15, 2015).
     */

    (function (PredefinedFormatOptions) {
        PredefinedFormatOptions["ShortDate"] = "shortDate";
        PredefinedFormatOptions["MediumDate"] = "mediumDate";
        PredefinedFormatOptions["LongDate"] = "longDate";
        PredefinedFormatOptions["FullDate"] = "fullDate";
    })(exports.PredefinedFormatOptions || (exports.PredefinedFormatOptions = {}));
    var noop$5 = function () { };
    var ɵ0$5 = noop$5;
    /**
     * Date Picker displays a popup calendar that lets users select a single date.
     *@igxModule IgxDatePickerModule
     *@igxTheme igx-calendar-theme, igx-icon-theme
     *@igxGroup Scheduling
     *@igxKeywords  datepicker, calendar, schedule, date
     *@example
     * ```html
     * <igx-date-picker [(ngModel)]="selectedDate"></igx-date-picker>
     * ```
     */
    var IgxDatePickerComponent = /** @class */ (function () {
        function IgxDatePickerComponent(_overlayService, element, _cdr, _moduleRef, _injector) {
            this._overlayService = _overlayService;
            this.element = element;
            this._cdr = _cdr;
            this._moduleRef = _moduleRef;
            this._injector = _injector;
            /**
             * Gets/Sets the `IgxDatePickerComponent` label.
             * @remarks
             * The default label is 'Date'.
             * @example
             * ```html
             * <igx-date-picker [label]="Calendar"></igx-date-picker>
             * ```
             */
            this.label = 'Date';
            /**
             * Gets/Sets the `IgxDatePickerComponent` label visibility.
             * @remarks
             * By default the visibility is set to true.
             * @example
             * <igx-date-picker [labelVisibility]="false"></igx-date-picker>
             */
            this.labelVisibility = true;
            /**
             *Gets/Sets on which day the week starts.
             @example
             *```html
             *<igx-date-picker [weekStart]="WEEKDAYS.FRIDAY" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
             *```
             */
            this.weekStart = exports.WEEKDAYS.SUNDAY;
            /**
             * Gets/Sets the number of month views displayed.
             * @remarks
             * Default value is `1`.
             * @example
             * ```html
             * <igx-date-picker [monthsViewNumber]="2"></igx-date-picker>
             * ```
             * @example
             * ```typescript
             * let monthViewsDisplayed = this.datePicker.monthsViewNumber;
             * ```
             */
            this.monthsViewNumber = 1;
            /**
             *Gets/Sets the value of `id` attribute.
             *@remarks If not provided it will be automatically generated.
             *@example
             *```html
             *<igx-date-picker [id]="'igx-date-picker-3'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
             *```
             */
            this.id = "igx-date-picker-" + NEXT_ID$k++;
            /**
             *Gets/Sets the orientation of the `IgxDatePickerComponent` header.
             *@example
             *```html
             *<igx-date-picker [vertical]="'true'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
             *```
             */
            this.vertical = false;
            /**
             *Gets/Sets the interaction mode - dialog or drop down.
             *@example
             *```html
             *<igx-date-picker mode="dropdown"></igx-date-picker>
             *```
             */
            this.mode = exports.InteractionMode.Dialog;
            /**
             *Gets/Sets whether date should spin continuously or stop when min/max is reached.
             *@example
             *```html
             *<igx-date-picker [isSpinLoop]="false"></igx-date-picker>
             *```
             */
            this.isSpinLoop = true;
            /**
             *Emitted when the `IgxDatePickerComponent` calendar is opened.
            */
            this.onOpened = new core.EventEmitter();
            /**
             *Emitted after the `IgxDatePickerComponent` is closed.
            */
            this.onClosed = new core.EventEmitter();
            /**
             *Emitted when the `IgxDatePickerComponent` is being closed.
             */
            this.onClosing = new core.EventEmitter();
            /**
             *Emitted when selection is made in the calendar.
             *@example
             *```html
             *<igx-date-picker (onSelection)="selection($event)"></igx-date-picker>
             *```
             */
            this.onSelection = new core.EventEmitter();
            /**
             *Emitted when date picker value is changed.
             *@example
            *```html
            *<igx-date-picker (valueChange)="valueChanged($event)" mode="dropdown"></igx-date-picker>
            *```
            */
            this.valueChange = new core.EventEmitter();
            /**
            *Emitted when the user types/spins to a disabled date in the date-picker editor.
            *@example
            *```html
            *<igx-date-picker (onDisabledDate)="onDisabledDate($event)"></igx-date-picker>
            *```
            */
            this.onDisabledDate = new core.EventEmitter();
            /**
            *Emitted when the user types/spins invalid date in the date-picker editor.
            *@example
            *```html
            *<igx-date-picker (onValidationFailed)="onValidationFailed($event)"></igx-date-picker>
            *```
            */
            this.onValidationFailed = new core.EventEmitter();
            /**@hidden @internal*/
            this.hasHeader = true;
            /**@hidden @internal*/
            this.collapsed = true;
            /**@hidden @internal*/
            this.displayValuePipe = new DatePickerDisplayValuePipe(this);
            /**@hidden @internal*/
            this.inputValuePipe = new DatePickerInputValuePipe(this);
            /**@hidden @internal*/
            this.dateFormatParts = [];
            /**@hidden @internal*/
            this.isEmpty = true;
            /**@hidden @internal*/
            this.invalidDate = '';
            this.spinDelta = 1;
            this.defaultLocale = 'en';
            this._formatOptions = {
                day: 'numeric',
                month: 'short',
                weekday: 'short',
                year: 'numeric'
            };
            this._formatViews = {
                day: false,
                month: true,
                year: false
            };
            this._destroy$ = new rxjs.Subject();
            this._disabledDates = null;
            this._specialDates = null;
            this._onOpen = new core.EventEmitter();
            this._onClose = new core.EventEmitter();
            this._ngControl = null;
            //#region ControlValueAccessor
            this._onChangeCallback = noop$5;
            this._onTouchedCallback = noop$5;
        }
        IgxDatePickerComponent_1 = IgxDatePickerComponent;
        Object.defineProperty(IgxDatePickerComponent.prototype, "formatOptions", {
            /**
             *Gets the format options of the `IgxDatePickerComponent`.
             @example
             *```typescript
                let formatOptions = this.datePicker.formatOptions;
             *```
             */
            get: function () {
                return this._formatOptions;
            },
            /**
             *Sets the format options of the `IgxDatePickerComponent`.
             *@example
             *```typescript
             * this.datePicker.formatOptions = {  day: "numeric",  month: "long", weekday: "long", year: "numeric"};
             *```
             */
            set: function (formatOptions) {
                this._formatOptions = Object.assign(this._formatOptions, formatOptions);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "format", {
            /**
             *Gets/Sets the date display format of the `IgxDatePickerComponent` in dropdown mode.
             @example
             *```typescript
             * let format = this.datePicker.format;
             * this.datePicker.format = 'yyyy-M-d';
             *```
             */
            get: function () {
                return (this._format === undefined) ? exports.PredefinedFormatOptions.ShortDate : this._format;
            },
            set: function (format) {
                this._format = format;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "formatViews", {
            /**
             *Gets/Sets the format views of the `IgxDatePickerComponent`.
             *@example
             *```typescript
             * let formatViews = this.datePicker.formatViews;
             *  this.datePicker.formatViews = {day:false, month: false, year:false};
             *```
             */
            get: function () {
                return this._formatViews;
            },
            set: function (formatViews) {
                this._formatViews = Object.assign(this._formatViews, formatViews);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "disabledDates", {
            /**
             * Gets/Sets the disabled dates descriptors.
             * @example
             * ```typescript
             * let disabledDates = this.datepicker.disabledDates;
             * this.datePicker.disabledDates = [ {type: DateRangeType.Weekends}, ...];
             * ```
             */
            get: function () {
                return this._disabledDates;
            },
            set: function (value) {
                this._disabledDates = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "specialDates", {
            /**
             * Gets/Sets the special dates descriptors.
             * @example
             * ```typescript
             * let specialDates = this.datepicker.specialDates;
             * this.datePicker.specialDates = [ {type: DateRangeType.Weekends}, ... ];
             * ```
             */
            get: function () {
                return this._specialDates;
            },
            set: function (value) {
                this._specialDates = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "modalOverlaySettings", {
            /**
            * Gets/Sets the modal overlay settings.
            */
            get: function () {
                return this._modalOverlay;
            },
            set: function (value) {
                this._modalOverlay = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "dropDownOverlaySettings", {
            /**
            * Gets/Sets the drop-down overlay settings.
            */
            get: function () {
                return this._dropDownOverlaySettings || this._defaultDropDownOverlaySettings;
            },
            set: function (value) {
                this._dropDownOverlaySettings = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "displayData", {
            /**
             *Gets the formatted date when `IgxDatePickerComponent` is in dialog mode.
             *@example
             *```typescript
             *let selectedDate = this.datePicker.displayData;
             *```
             */
            get: function () {
                if (this.value) {
                    return this._customFormatChecker(this.formatter, this.value);
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "transformedDate", {
            /**
             @hidden @internal
             */
            get: function () {
                if (this._value) {
                    this._transformedDate = (this._isInEditMode) ? this._getEditorDate(this._value) : this._getDisplayDate(this._value);
                    this.isEmpty = false;
                }
                else {
                    this._transformedDate = (this._isInEditMode) ? DatePickerUtil.maskToPromptChars(this.inputMask) : '';
                }
                return this._transformedDate;
            },
            /**
             @hidden @internal
             */
            set: function (value) {
                this._transformedDate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "template", {
            /**
             * Gets the input group template.
             * @example
             * ```typescript
             * let template = this.template();
             * ```
             */
            get: function () {
                if (this.datePickerTemplateDirective) {
                    return this.datePickerTemplateDirective.template;
                }
                return (this.mode === exports.InteractionMode.Dialog) ? this.readOnlyDatePickerTemplate : this.editableDatePickerTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "context", {
            /**
             * Gets the context passed to the input group template.
             */
            get: function () {
                var _this = this;
                return {
                    disabled: this.disabled,
                    disabledDates: this.disabledDates,
                    displayData: this.displayData,
                    format: this.format,
                    isSpinLoop: this.isSpinLoop,
                    label: this.label,
                    labelVisibility: this.labelVisibility,
                    locale: this.locale,
                    mask: this.mask,
                    mode: this.mode,
                    specialDates: this.specialDates,
                    value: this.value,
                    openDialog: function (target) { return _this.openDialog(target); }
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "required", {
            get: function () {
                if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
                    // Run the validation with empty object to check if required is enabled.
                    var error = this._ngControl.control.validator({});
                    return error && error.required;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "value", {
            /**
             *Gets/Sets the selected date.
             *@example
             *```html
             *<igx-date-picker [value]="date"></igx-date-picker>
             *```
             */
            get: function () {
                return this._value;
            },
            set: function (date) {
                this._value = date;
                this._onChangeCallback(date);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "onOpen", {
            /**
             * @deprecated Use 'onOpened' instead.
             *An event that is emitted when the `IgxDatePickerComponent` calendar is opened.
             *@example
             *```typescript
             *public open(event){
             *    alert("The date-picker calendar has been opened!");
             *}
             *```
             *```html
             *<igx-date-picker (onOpen)="open($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
             *```
             */
            get: function () {
                return this._onOpen;
            },
            set: function (val) {
                this._onOpen = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDatePickerComponent.prototype, "onClose", {
            /**
             * @deprecated Use 'onClosed' instead.
             *"An event that is emitted when the `IgxDatePickerComponent` is closed.
             *@example
             *```typescript
             *public close(event){
             *    alert("The date-picker has been closed!");
             *}
             *```
             *```html
             *<igx-date-picker (onClose)="close($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
             *```
             */
            get: function () {
                return this._onClose;
            },
            set: function (val) {
                this._onClose = val;
            },
            enumerable: true,
            configurable: true
        });
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.writeValue = function (value) {
            this._value = value;
            // TODO: do we need next call
            this._cdr.markForCheck();
        };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.registerOnChange = function (fn) { this._onChangeCallback = fn; };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.registerOnTouched = function (fn) { this._onTouchedCallback = fn; };
        /** @hidden @internal */
        IgxDatePickerComponent.prototype.setDisabledState = function (isDisabled) { this.disabled = isDisabled; };
        //#endregion
        /**
        * @hidden
        */
        IgxDatePickerComponent.prototype.onSpaceClick = function (event) {
            this.openDialog(this.getInputGroupElement());
            event.preventDefault();
        };
        /** @hidden */
        IgxDatePickerComponent.prototype.getEditElement = function () {
            var inputDirectiveElementRef = this._inputElementRef || this._inputUserTemplateElementRef;
            return (inputDirectiveElementRef) ? inputDirectiveElementRef.nativeElement : null;
        };
        /**
         *@hidden @internal
         */
        IgxDatePickerComponent.prototype.getInputGroupElement = function () {
            return this.inputGroup ? this.inputGroup.element.nativeElement : null;
        };
        /**
         *@hidden @internal
         */
        IgxDatePickerComponent.prototype.ngOnInit = function () {
            var _this = this;
            this._positionSettings = {
                openAnimation: fadeIn,
                closeAnimation: fadeOut
            };
            this._defaultDropDownOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new AutoPositionStrategy(this._positionSettings),
                outlet: this.outlet
            };
            this._modalOverlaySettings = {
                closeOnOutsideClick: true,
                modal: true,
                outlet: this.outlet
            };
            this._overlayService.onOpening.pipe(operators.filter(function (overlay) { return overlay.id === _this._componentID; }), operators.takeUntil(this._destroy$)).subscribe(function (eventArgs) {
                _this._onOpening(eventArgs);
            });
            this._overlayService.onOpened.pipe(operators.filter(function (overlay) { return overlay.id === _this._componentID; }), operators.takeUntil(this._destroy$)).subscribe(function () {
                _this._onOpened();
            });
            this._overlayService.onClosed.pipe(operators.filter(function (overlay) { return overlay.id === _this._componentID; }), operators.takeUntil(this._destroy$)).subscribe(function () {
                _this._onClosed();
            });
            this._overlayService.onClosing.pipe(operators.filter(function (overlay) { return overlay.id === _this._componentID; }), operators.takeUntil(this._destroy$)).subscribe(function (event) {
                _this.onClosing.emit(event);
                // If canceled in a user onClosing handler
                if (event.cancel) {
                    return;
                }
                // Do not focus the input if clicking outside in dropdown mode
                var input = _this.getEditElement();
                if (input && !(event.event && _this.mode === exports.InteractionMode.DropDown)) {
                    input.focus();
                }
                else {
                    // outside click
                    _this._updateValidityOnBlur();
                }
            });
            if (this.mode === exports.InteractionMode.DropDown) {
                this.dateFormatParts = DatePickerUtil.parseDateFormat(this.mask, this.locale);
                if (this.mask === undefined) {
                    this.mask = DatePickerUtil.getMask(this.dateFormatParts);
                }
                this.inputMask = DatePickerUtil.getInputMask(this.dateFormatParts);
            }
            this._ngControl = this._injector.get(forms.NgControl, null);
        };
        /**
         *@hidden @internal
        */
        IgxDatePickerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.mode === exports.InteractionMode.DropDown && this._inputElementRef) {
                rxjs.fromEvent(this._inputElementRef.nativeElement, 'keydown').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(this._destroy$)).subscribe(function (res) { return _this.onKeyDown(res); });
            }
            if (this._ngControl) {
                this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            }
        };
        IgxDatePickerComponent.prototype.ngAfterViewChecked = function () {
            // if one sets mode at run time this forces initialization of new igxInputGroup
            // As a result a new igxInputDirective is initialized too. In ngAfterViewInit of
            // the new directive isRequired of the igxInputGroup is set again. However
            // ngAfterViewInit of date picker is not called again and we may finish with wrong
            // isRequired in igxInputGroup. This is why we should set it her, only when needed
            if (this.inputGroup && this.inputGroup.isRequired !== this.required) {
                this.inputGroup.isRequired = this.required;
                this._cdr.detectChanges();
            }
        };
        IgxDatePickerComponent.prototype.onStatusChanged = function () {
            if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
                (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
                if (this.inputGroup.isFocused) {
                    this._inputDirective.valid = this._ngControl.valid ? exports.IgxInputState.VALID : exports.IgxInputState.INVALID;
                }
                else {
                    this._inputDirective.valid = this._ngControl.valid ? exports.IgxInputState.INITIAL : exports.IgxInputState.INVALID;
                }
            }
            if (this.inputGroup && this.inputGroup.isRequired !== this.required) {
                this.inputGroup.isRequired = this.required;
            }
        };
        /**
         *@hidden @internal
        */
        IgxDatePickerComponent.prototype.ngOnDestroy = function () {
            if (this._componentID) {
                this._overlayService.hide(this._componentID);
            }
            this._destroy$.next(true);
            this._destroy$.complete();
        };
        /**
         *Selects today's date from calendar.
         *@remarks
         *Changes the input field value, @calendar.viewDate and @calendar.value.
         *@example
         *```typescript
         *this.datePicker.triggerTodaySelection();
         *```
         */
        IgxDatePickerComponent.prototype.triggerTodaySelection = function () {
            var today = new Date(Date.now());
            this.handleSelection(today);
        };
        /**
         * Change the calendar selection.
         * @remarks
         * Calling this method will emit the @calendar.onSelection event,
         * which will fire @handleSelection method.
         * @example
         *```typescript
         *this.datePicker.selectDate(this.date);
         * ```
         * @param date passed date that has to be set to the calendar.
         */
        IgxDatePickerComponent.prototype.selectDate = function (date) {
            var oldValue = this.value;
            this.value = date;
            this.emitValueChangeEvent(oldValue, this.value);
            this.onSelection.emit(date);
        };
        /**
         * Deselects the calendar date.
         * @example
         *```typescript
         *this.datePicker.deselectDate();
         * ```
         */
        IgxDatePickerComponent.prototype.deselectDate = function () {
            var oldValue = this.value;
            this.value = null;
            this.emitValueChangeEvent(oldValue, this.value);
            if (this.calendar) {
                this.calendar.deselectDate();
            }
        };
        /**
         * Opens the date picker drop down or dialog.
         * @param target HTMLElement - the target element to use for positioning the drop down container according to
         * @example
         * ```typescript
         * this.datePicker.openDialog(target);
         * ```
         */
        IgxDatePickerComponent.prototype.openDialog = function (target) {
            if (!this.collapsed) {
                return;
            }
            switch (this.mode) {
                case exports.InteractionMode.Dialog: {
                    this.hasHeader = true;
                    var modalOverlay = (this.modalOverlaySettings !== undefined) ? this._modalOverlay : this._modalOverlaySettings;
                    this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, modalOverlay, this._moduleRef);
                    this._overlayService.show(this._componentID);
                    break;
                }
                case exports.InteractionMode.DropDown: {
                    this.hasHeader = false;
                    if (target) {
                        this.dropDownOverlaySettings.positionStrategy.settings.target = target;
                    }
                    this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, this.dropDownOverlaySettings, this._moduleRef);
                    this._overlayService.show(this._componentID);
                    break;
                }
            }
        };
        IgxDatePickerComponent.prototype.mouseDown = function (e) {
            // if the click is not on the input but in input group
            // e.g. on prefix or sufix, prevent default and this way prevent blur
            if (e.target !== this.getEditElement()) {
                e.preventDefault();
            }
        };
        /**
         * Close the calendar.
         *
         * @hidden @internal
         */
        IgxDatePickerComponent.prototype.closeCalendar = function () {
            this._overlayService.hide(this._componentID);
        };
        /**
         * Clear the input field, date picker value and calendar selection.
         *
         * @hidden @internal
         */
        IgxDatePickerComponent.prototype.clear = function () {
            this.isEmpty = true;
            this.invalidDate = '';
            this.deselectDate();
            this._setCursorPosition(0);
        };
        /**
         * Evaluates when @calendar.onSelection event was fired
         * and update the input value.
         *
         * @param event selected value from calendar.
         *
         * @hidden @internal
         */
        IgxDatePickerComponent.prototype.handleSelection = function (date) {
            if (this.value) {
                date.setHours(this.value.getHours());
                date.setMinutes(this.value.getMinutes());
                date.setSeconds(this.value.getSeconds());
                date.setMilliseconds(this.value.getMilliseconds());
            }
            var oldValue = this.value;
            this.value = date;
            this.emitValueChangeEvent(oldValue, this.value);
            this.calendar.viewDate = date;
            this.closeCalendar();
            this.onSelection.emit(date);
        };
        /**
        * @hidden @internal
        */
        IgxDatePickerComponent.prototype.onBlur = function (event) {
            this._isInEditMode = false;
            if (this.mode === exports.InteractionMode.DropDown) {
                this.calculateDate(event.target.value, event.type);
            }
            if (this.collapsed) {
                this._updateValidityOnBlur();
            }
        };
        /**
        * @hidden @internal
        */
        IgxDatePickerComponent.prototype.onFocus = function () {
            this._isInEditMode = true;
            if (this.value && this.invalidDate === '') {
                this._transformedDate = this._getEditorDate(this.value);
            }
        };
        /**
        * @hidden @internal
        */
        IgxDatePickerComponent.prototype.onKeyDown = function (event) {
            switch (event.key) {
                case "ArrowUp" /* UP_ARROW */:
                case "Up" /* UP_ARROW_IE */:
                    event.preventDefault();
                    event.stopPropagation();
                    this.spinValue(event.target.value, 1, event.type);
                    break;
                case "ArrowDown" /* DOWN_ARROW */:
                case "Down" /* DOWN_ARROW_IE */:
                    if (event.altKey) {
                        this.openDialog(this.getInputGroupElement());
                    }
                    else {
                        event.preventDefault();
                        event.stopPropagation();
                        this.spinValue(event.target.value, -1, event.type);
                    }
                    break;
                default:
                    break;
            }
        };
        /**
        * @hidden @internal
        */
        IgxDatePickerComponent.prototype.onWheel = function (event) {
            if (this._isInEditMode) {
                event.preventDefault();
                event.stopPropagation();
                var sign = (event.deltaY > 0) ? -1 : 1;
                this.spinValue(event.target.value, sign, event.type);
            }
        };
        /**
        * @hidden @internal
        */
        IgxDatePickerComponent.prototype.onInput = function (event) {
            var _this = this;
            var targetValue = event.target.value;
            var cursorPosition = this._getCursorPosition();
            var checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, targetValue);
            this._isInEditMode = true;
            if (targetValue !== DatePickerUtil.maskToPromptChars(this.inputMask)) {
                this.isEmpty = false;
            }
            // If all date parts are completed, change the date-picker value, stay in edit mode
            if (checkInput === 'complete' && event.inputType !== 'deleteContentBackward') {
                this._transformedDate = targetValue;
                this.calculateDate(targetValue, event.type);
                this._setCursorPosition(cursorPosition);
            }
            else if (checkInput === 'partial') {
                // While editing, if one date part is deleted, date-picker value is set to null, the remaining input stays intact.
                this.deselectDate();
                requestAnimationFrame(function () {
                    _this.getEditElement().value = targetValue;
                    _this._setCursorPosition(cursorPosition);
                });
            }
            else if (checkInput === 'empty') {
                // Total clean-up as input is deleted.
                this.isEmpty = true;
                this.deselectDate();
            }
        };
        IgxDatePickerComponent.prototype.emitValueChangeEvent = function (oldValue, newValue) {
            if (!isEqual(oldValue, newValue)) {
                this.valueChange.emit(newValue);
            }
        };
        IgxDatePickerComponent.prototype.calculateDate = function (dateString, invokedByEvent) {
            if (dateString !== '') {
                var prevDateValue = this.value;
                var inputValue = (invokedByEvent === 'blur') ? this.rawDateString : dateString;
                var newDateArray = DatePickerUtil.parseDateArray(this.dateFormatParts, prevDateValue, inputValue);
                if (newDateArray.state === "valid" /* Valid */) {
                    var newValue = newDateArray.date;
                    // Restore the time part if any
                    if (prevDateValue) {
                        newValue.setHours(prevDateValue.getHours());
                        newValue.setMinutes(prevDateValue.getMinutes());
                        newValue.setSeconds(prevDateValue.getSeconds());
                        newValue.setMilliseconds(prevDateValue.getMilliseconds());
                    }
                    if (this.disabledDates === null
                        || (this.disabledDates !== null && !isDateInRanges(newValue, this.disabledDates))) {
                        var oldValue = this.value;
                        this.value = newValue;
                        this.emitValueChangeEvent(oldValue, this.value);
                        this.invalidDate = '';
                    }
                    else {
                        var args = {
                            datePicker: this,
                            currentValue: newValue,
                        };
                        this.onDisabledDate.emit(args);
                    }
                }
                else {
                    var args = {
                        datePicker: this,
                        prevValue: prevDateValue
                    };
                    this.invalidDate = dateString;
                    this.onValidationFailed.emit(args);
                }
            }
        };
        IgxDatePickerComponent.prototype.spinValue = function (inputValue, sign, eventType) {
            this._isInEditMode = true;
            this.isEmpty = false;
            var cursorPosition = this._getCursorPosition();
            var modifiedInputValue = DatePickerUtil.getModifiedDateInput(this.dateFormatParts, inputValue, cursorPosition, this.spinDelta * sign, this.isSpinLoop);
            this.getEditElement().value = modifiedInputValue;
            this._setCursorPosition(cursorPosition);
            var checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, modifiedInputValue);
            if (checkInput === 'complete') {
                this._isInEditMode = true;
                this.calculateDate(modifiedInputValue, eventType);
                this._setCursorPosition(cursorPosition);
            }
        };
        IgxDatePickerComponent.prototype._onOpening = function (event) {
            this._initializeCalendarContainer(event.componentRef.instance);
            this.collapsed = false;
        };
        IgxDatePickerComponent.prototype._onOpened = function () {
            this.onOpened.emit(this);
            // TODO: remove this line after deprecating 'onOpen'
            this._onOpen.emit(this);
            if (this.calendar) {
                this._focusCalendarDate();
            }
        };
        IgxDatePickerComponent.prototype._onClosed = function () {
            this.collapsed = true;
            this._componentID = null;
            this.onClosed.emit(this);
        };
        IgxDatePickerComponent.prototype._initializeCalendarContainer = function (componentInstance) {
            var _this = this;
            this.calendar = componentInstance.calendar;
            var isVertical = (this.vertical && this.mode === exports.InteractionMode.Dialog);
            this.calendar.hasHeader = this.hasHeader;
            this.calendar.formatOptions = this.formatOptions;
            this.calendar.formatViews = this.formatViews;
            this.calendar.locale = this.locale;
            this.calendar.vertical = isVertical;
            this.calendar.weekStart = this.weekStart;
            this.calendar.specialDates = this.specialDates;
            this.calendar.disabledDates = this.disabledDates;
            this.calendar.headerTemplate = this.headerTemplate;
            this.calendar.subheaderTemplate = this.subheaderTemplate;
            this.calendar.hideOutsideDays = this.hideOutsideDays;
            this.calendar.monthsViewNumber = this.monthsViewNumber;
            this.calendar.onSelection.pipe(operators.takeUntil(this._destroy$)).subscribe(function (ev) { return _this.handleSelection(ev); });
            if (this.value) {
                this.calendar.value = this.value;
                this.calendar.viewDate = this.value;
            }
            componentInstance.mode = this.mode;
            componentInstance.vertical = isVertical;
            componentInstance.cancelButtonLabel = this.cancelButtonLabel;
            componentInstance.todayButtonLabel = this.todayButtonLabel;
            componentInstance.datePickerActions = this.datePickerActionsDirective;
            componentInstance.onClose.pipe(operators.takeUntil(this._destroy$)).subscribe(function () { return _this.closeCalendar(); });
            componentInstance.onTodaySelection.pipe(operators.takeUntil(this._destroy$)).subscribe(function () { return _this.triggerTodaySelection(); });
        };
        // Focus a date, after the calendar appearance into DOM.
        IgxDatePickerComponent.prototype._focusCalendarDate = function () {
            var _this = this;
            requestAnimationFrame(function () {
                _this.calendar.daysView.focusActiveDate();
            });
        };
        IgxDatePickerComponent.prototype._setLocaleToDate = function (value) {
            if (isIE()) {
                // this is a workaround fixing the following IE11 issue:
                // IE11 has added character code 8206 (mark for RTL) to the output of toLocaleDateString() that
                // precedes each portion that comprises the total date... For more information read this article:
                // tslint:disable-next-line: max-line-length
                // https://www.csgpro.com/blog/2016/08/a-bad-date-with-internet-explorer-11-trouble-with-new-unicode-characters-in-javascript-date-strings/
                var localeDateStrIE = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
                return localeDateStrIE.toLocaleDateString(this.locale);
            }
            return value.toLocaleDateString(this.locale);
        };
        IgxDatePickerComponent.prototype._getCursorPosition = function () {
            return this.getEditElement().selectionStart;
        };
        IgxDatePickerComponent.prototype._setCursorPosition = function (start, end) {
            var _this = this;
            if (end === void 0) { end = start; }
            requestAnimationFrame(function () {
                _this.getEditElement().setSelectionRange(start, end);
            });
        };
        /**
         * Apply custom user formatter upon date.
         * @param formatter custom formatter function.
         * @param date passed date
         */
        IgxDatePickerComponent.prototype._customFormatChecker = function (formatter, date) {
            return this.formatter ? this.formatter(date) : this._setLocaleToDate(date);
        };
        /*
        * Transforms the date according to the specified format when `IgxDatePickerComponent` is in edit mode
        * using @angular/common formatDate method: https://angular.io/api/common/formatDate
        * @param  value: string | number | Date
        * @returns formatted string
        */
        IgxDatePickerComponent.prototype._getDisplayDate = function (value) {
            if (this.format && !this.formatter) {
                var locale = this.locale || this.defaultLocale;
                return common.formatDate(value, this.format, locale);
            }
            else {
                return this._customFormatChecker(this.formatter, value);
            }
        };
        IgxDatePickerComponent.prototype._getEditorDate = function (value) {
            var locale = this.locale || this.defaultLocale;
            var changedValue = (value) ? common.formatDate(value, this.mask, locale) : '';
            return DatePickerUtil.addPromptCharsEditMode(this.dateFormatParts, this.value, changedValue);
        };
        IgxDatePickerComponent.prototype._updateValidityOnBlur = function () {
            this._onTouchedCallback();
            var input = this._inputDirective || this._inputDirectiveUserTemplate;
            if (input && this._ngControl && !this._ngControl.valid) {
                input.valid = exports.IgxInputState.INVALID;
            }
            else {
                input.valid = exports.IgxInputState.INITIAL;
            }
        };
        var IgxDatePickerComponent_1;
        IgxDatePickerComponent.ctorParameters = function () { return [
            { type: IgxOverlayService, decorators: [{ type: core.Inject, args: [IgxOverlayService,] }] },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: core.NgModuleRef },
            { type: core.Injector }
        ]; };
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "label", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "labelVisibility", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "locale", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "weekStart", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "formatOptions", null);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "hideOutsideDays", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "monthsViewNumber", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "format", null);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "mask", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "formatViews", null);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "disabledDates", null);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "specialDates", null);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "modalOverlaySettings", null);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "dropDownOverlaySettings", null);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "value", null);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxDatePickerComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "formatter", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "vertical", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "todayButtonLabel", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "cancelButtonLabel", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "mode", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "isSpinLoop", void 0);
        __decorate([
            core.Input()
        ], IgxDatePickerComponent.prototype, "outlet", void 0);
        __decorate([
            DeprecateProperty("'onOpen' @Output property is deprecated. Use 'onOpened' instead."),
            core.Output()
        ], IgxDatePickerComponent.prototype, "onOpen", null);
        __decorate([
            core.Output()
        ], IgxDatePickerComponent.prototype, "onOpened", void 0);
        __decorate([
            DeprecateProperty("'onClose' @Output property is deprecated. Use 'onClosed' instead."),
            core.Output()
        ], IgxDatePickerComponent.prototype, "onClose", null);
        __decorate([
            core.Output()
        ], IgxDatePickerComponent.prototype, "onClosed", void 0);
        __decorate([
            core.Output()
        ], IgxDatePickerComponent.prototype, "onClosing", void 0);
        __decorate([
            core.Output()
        ], IgxDatePickerComponent.prototype, "onSelection", void 0);
        __decorate([
            core.Output()
        ], IgxDatePickerComponent.prototype, "valueChange", void 0);
        __decorate([
            core.Output()
        ], IgxDatePickerComponent.prototype, "onDisabledDate", void 0);
        __decorate([
            core.Output()
        ], IgxDatePickerComponent.prototype, "onValidationFailed", void 0);
        __decorate([
            core.ViewChild('readOnlyDatePickerTemplate', { read: core.TemplateRef, static: true })
        ], IgxDatePickerComponent.prototype, "readOnlyDatePickerTemplate", void 0);
        __decorate([
            core.ViewChild('editableDatePickerTemplate', { read: core.TemplateRef, static: true })
        ], IgxDatePickerComponent.prototype, "editableDatePickerTemplate", void 0);
        __decorate([
            core.ViewChild(IgxInputGroupComponent)
        ], IgxDatePickerComponent.prototype, "inputGroup", void 0);
        __decorate([
            core.ViewChild(IgxInputDirective, { read: core.ElementRef })
        ], IgxDatePickerComponent.prototype, "_inputElementRef", void 0);
        __decorate([
            core.ContentChild(IgxInputDirective, { read: core.ElementRef })
        ], IgxDatePickerComponent.prototype, "_inputUserTemplateElementRef", void 0);
        __decorate([
            core.ViewChild(IgxInputDirective)
        ], IgxDatePickerComponent.prototype, "_inputDirective", void 0);
        __decorate([
            core.ContentChild(IgxInputDirective)
        ], IgxDatePickerComponent.prototype, "_inputDirectiveUserTemplate", void 0);
        __decorate([
            core.ContentChild(IgxDatePickerTemplateDirective, { read: IgxDatePickerTemplateDirective })
        ], IgxDatePickerComponent.prototype, "datePickerTemplateDirective", void 0);
        __decorate([
            core.ContentChild(IgxCalendarHeaderTemplateDirective, { read: IgxCalendarHeaderTemplateDirective })
        ], IgxDatePickerComponent.prototype, "headerTemplate", void 0);
        __decorate([
            core.ContentChild(IgxCalendarSubheaderTemplateDirective, { read: IgxCalendarSubheaderTemplateDirective })
        ], IgxDatePickerComponent.prototype, "subheaderTemplate", void 0);
        __decorate([
            core.ContentChild(IgxDatePickerActionsDirective, { read: IgxDatePickerActionsDirective })
        ], IgxDatePickerComponent.prototype, "datePickerActionsDirective", void 0);
        __decorate([
            core.HostListener('keydown.spacebar', ['$event']),
            core.HostListener('keydown.space', ['$event'])
        ], IgxDatePickerComponent.prototype, "onSpaceClick", null);
        IgxDatePickerComponent = IgxDatePickerComponent_1 = __decorate([
            core.Component({
                providers: [{
                        provide: forms.NG_VALUE_ACCESSOR,
                        useExisting: IgxDatePickerComponent_1,
                        multi: true
                    }],
                // tslint:disable-next-line:component-selector
                selector: 'igx-date-picker',
                template: "<ng-template #readOnlyDatePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\" (mousedown)=\"mouseDown($event)\">\n        <igx-prefix>\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility\" igxLabel>{{label}}</label>\n        <input\n            class=\"igx-date-picker__input-date\"\n            igxInput\n            [value]=\"displayData || ''\"\n            [disabled]=\"disabled\"\n            (blur)=\"onBlur($event)\"\n            readonly\n        />\n    </igx-input-group>\n</ng-template>\n\n<ng-template #editableDatePickerTemplate>\n    <igx-input-group #editableInputGroup [supressInputAutofocus]=\"true\" (mousedown)=\"mouseDown($event)\">\n        <igx-prefix (click)=\"openDialog(editableInputGroup.element.nativeElement)\">\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility\" igxLabel>{{label}}</label>\n        <input\n            class=\"igx-date-picker__input-date\"\n            igxInput\n            [igxTextSelection]=\"true\"\n            type=\"text\"\n            [value]=\"transformedDate\"\n            [igxMask]=\"inputMask\"\n            [placeholder]=\"mask\"\n            [disabled]=\"disabled\"\n            [displayValuePipe]=\"displayValuePipe\"\n            [focusedValuePipe]=\"inputValuePipe\"\n            (blur)=\"onBlur($event)\"\n            (wheel)=\"onWheel($event)\"\n            (input)=\"onInput($event)\"\n            (focus)=\"onFocus()\"\n        />\n        <igx-suffix *ngIf=\"!isEmpty\" (click)=\"clear()\">\n            <igx-icon>clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                styles: ["\n        :host {\n            display: block;\n        }\n    "]
            }),
            __param(0, core.Inject(IgxOverlayService))
        ], IgxDatePickerComponent);
        return IgxDatePickerComponent;
    }());
    /**
     * @hidden
     */
    var IgxDatePickerModule = /** @class */ (function () {
        function IgxDatePickerModule() {
        }
        IgxDatePickerModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxDatePickerComponent,
                    IgxCalendarContainerComponent,
                    IgxDatePickerActionsDirective,
                    IgxDatePickerTemplateDirective,
                    DatePickerDisplayValuePipe,
                    DatePickerInputValuePipe
                ],
                entryComponents: [
                    IgxCalendarContainerComponent
                ],
                exports: [
                    IgxDatePickerComponent,
                    IgxDatePickerTemplateDirective,
                    IgxDatePickerActionsDirective,
                    DatePickerDisplayValuePipe,
                    DatePickerInputValuePipe
                ],
                imports: [
                    common.CommonModule,
                    IgxIconModule,
                    IgxInputGroupModule,
                    IgxCalendarModule,
                    IgxButtonModule,
                    IgxRippleModule,
                    IgxMaskModule,
                    IgxTextSelectionModule
                ]
            })
        ], IgxDatePickerModule);
        return IgxDatePickerModule;
    }());

    /**
     * @hidden
     */
    var IgxDialogTitleDirective = /** @class */ (function () {
        function IgxDialogTitleDirective() {
            this.defaultStyle = true;
        }
        __decorate([
            core.HostBinding('class.igx-dialog__window-title')
        ], IgxDialogTitleDirective.prototype, "defaultStyle", void 0);
        IgxDialogTitleDirective = __decorate([
            core.Directive({
                selector: 'igx-dialog-title,[igxDialogTitle]'
            })
        ], IgxDialogTitleDirective);
        return IgxDialogTitleDirective;
    }());
    /**
     * @hidden
     */
    var IgxDialogActionsDirective = /** @class */ (function () {
        function IgxDialogActionsDirective() {
            this.defaultClass = true;
        }
        __decorate([
            core.HostBinding('class.igx-dialog__window-actions')
        ], IgxDialogActionsDirective.prototype, "defaultClass", void 0);
        IgxDialogActionsDirective = __decorate([
            core.Directive({
                selector: 'igx-dialog-actions,[igxDialogActions]'
            })
        ], IgxDialogActionsDirective);
        return IgxDialogActionsDirective;
    }());

    var DIALOG_ID = 0;
    /**
     * **Ignite UI for Angular Dialog Window** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/dialog.html)
     *
     * The Ignite UI Dialog Window presents a dialog window to the user which can simply display messages or display
     * more complicated visuals such as a user sign-in form.  It also provides a right and left button
     * which can be used for custom actions.
     *
     * Example:
     * ```html
     * <button (click)="form.open()">Show Dialog</button>
     * <igx-dialog #form title="Sign In" rightButtonLabel="OK">
     *   <div>
     *     <input type="text" igxInput/>
     *     <label igxLabel>Username</label>
     *   </div>
     *   <div>
     *     <input type="password" igxInput/>
     *     <label igxLabel>Password</label>
     *   </div>
     * </igx-dialog>
     * ```
     */
    var IgxDialogComponent = /** @class */ (function () {
        function IgxDialogComponent(elementRef, navService) {
            this.elementRef = elementRef;
            this.navService = navService;
            /**
            * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
            *```html
            *<igx-dialog [id]="'igx-dialog-56'" #alert title="Notification" leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
            *```
            */
            this.id = "igx-dialog-" + DIALOG_ID++;
            /**
            * An @Input property controlling the `title` of the dialog.
            *```html
            *<igx-dialog title="Notification" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
            *```
            */
            this.title = '';
            /**
             *  An @Input property controlling the `message` of the dialog.
             *```html
             *<igx-dialog message="Your email was sent!" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.message = '';
            /**
             * An @Input property to set the `label` of the left button of the dialog.
             *```html
             *<igx-dialog leftButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.leftButtonLabel = '';
            /**
             * An @Input property to set the left button `type`. The types are `flat`, `raised` and `fab`.
             * The `flat` type button is a rectangle and doesn't have a shadow. <br>
             * The `raised` type button is also a rectangle but has a shadow. <br>
             * The `fab` type button is a circle with a shadow. <br>
             * The default value is `flat`.
             *```html
             *<igx-dialog leftButtonType="raised" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.leftButtonType = 'flat';
            /**
             * An @Input property to set the left button color. The property accepts all valid CSS color property values.
             *```html
             *<igx-dialog leftButtonColor="yellow" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.leftButtonColor = '';
            /**
             * An @Input property to set the left button `background-color`. The property accepts all valid CSS color property values.
             *```html
             *<igx-dialog leftButtonBackgroundColor="black" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.leftButtonBackgroundColor = '';
            /**
             * An @Input property to set the left button `ripple`. The `ripple` animates a click/tap to a component as a series of fading waves.
             * The property accepts all valid CSS color property values.
             *```html
             *<igx-dialog leftButtonRipple="green" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.leftButtonRipple = '';
            /**
             * An @Input property to set the `label` of the right button of the dialog.
             *```html
             *<igx-dialog rightButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.rightButtonLabel = '';
            /**
             * An @Input property to set the right button `type`. The types are `flat`, `raised` and `fab`.
             * The `flat` type button is a rectangle and doesn't have a shadow. <br>
             * The `raised` type button is also a rectangle but has a shadow. <br>
             * The `fab` type button is a circle with a shadow. <br>
             * The default value is `flat`.
             *```html
             *<igx-dialog rightButtonType="fab" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.rightButtonType = 'flat';
            /**
             * An @Input property to set the right button `color`. The property accepts all valid CSS color property values.
             *```html
             *<igx-dialog rightButtonColor="yellow" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.rightButtonColor = '';
            /**
             * An @Input property to set the right button `background-color`. The property accepts all valid CSS color property values.
             *```html
             *<igx-dialog rightButtonBackgroundColor="black" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.rightButtonBackgroundColor = '';
            /**
             * An @Input property to set the right button `ripple`.
             *```html
             *<igx-dialog rightButtonRipple="green" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
             *```
             */
            this.rightButtonRipple = '';
            /**
             * An event that is emitted when the dialog is opened.
             *```html
             *<igx-dialog (onOpen)="onDialogOpenHandler($event)" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK">
             *</igx-dialog>
             *```
             */
            this.onOpen = new core.EventEmitter();
            /**
             * An event that is emitted when the dialog is closed.
             *```html
             *<igx-dialog (onClose)="onDialogCloseHandler($event)" title="Confirmation" leftButtonLabel="Cancel" rightButtonLabel="OK">
             *</igx-dialog>
             *```
             */
            this.onClose = new core.EventEmitter();
            /**
             * An event that is emitted when the left button is clicked.
             *```html
             *<igx-dialog (onLeftButtonSelect)="onDialogOKSelected($event)" #dialog leftButtonLabel="OK" rightButtonLabel="Cancel">
             *</igx-dialog>
             *```
             */
            this.onLeftButtonSelect = new core.EventEmitter();
            /**
             * An event that is emitted when the right button is clicked.
             * ```html
             *<igx-dialog (onRightButtonSelect)="onDialogOKSelected($event)"
             *#dialog title="Confirmation" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK"
             *rightButtonRipple="#4CAF50" closeOnOutsideSelect="true">
             *</igx-dialog>
             *```
             */
            this.onRightButtonSelect = new core.EventEmitter();
            this._positionSettings = {
                openAnimation: animations.useAnimation(slideInBottom, { params: { fromPosition: 'translateY(100%)' } }),
                closeAnimation: animations.useAnimation(slideOutTop, { params: { toPosition: 'translateY(-100%)' } })
            };
            this._closeOnOutsideSelect = false;
            this._isModal = true;
            this.destroy$ = new rxjs.Subject();
            /**
             * The default `tabindex` attribute for the component
             *
             * @hidden
             */
            this.tabindex = -1;
            this._titleId = IgxDialogComponent_1.NEXT_ID++ + '_title';
            this._overlayDefaultSettings = {
                positionStrategy: new GlobalPositionStrategy(this._positionSettings),
                scrollStrategy: new NoOpScrollStrategy(),
                modal: this.isModal,
                closeOnOutsideClick: this.closeOnOutsideSelect
            };
        }
        IgxDialogComponent_1 = IgxDialogComponent;
        Object.defineProperty(IgxDialogComponent.prototype, "isModal", {
            get: function () {
                return this._isModal;
            },
            set: function (val) {
                this._overlayDefaultSettings.modal = val;
                this._isModal = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "closeOnOutsideSelect", {
            /**
             * An @Input property that allows you to enable the "close on click outside the dialog". By default it's disabled.
             *```html
             *<igx-dialog closeOnOutsideSelect="true" leftButtonLabel="Cancel" (onLeftButtonSelect)="dialog.close()"
             *rightButtonLabel="OK" rightButtonRipple="#4CAF50" (onRightButtonSelect)="onDialogOKSelected($event)">
             *</igx-dialog>
             *```
             */
            get: function () {
                return this._closeOnOutsideSelect;
            },
            set: function (val) {
                this._overlayDefaultSettings.closeOnOutsideClick = val;
                this._closeOnOutsideSelect = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "positionSettings", {
            /**
             * Get the position and animation settings used by the dialog.
             * ```typescript
             * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
             * let currentPosition: PositionSettings = this.alert.positionSettings
             * ```
             */
            get: function () {
                return this._positionSettings;
            },
            /**
             * Set the position and animation settings used by the dialog.
             * ```typescript
             * import { slideInLeft, slideOutRight } from 'igniteui-angular';
             * ...
             * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
             *  public newPositionSettings: PositionSettings = {
             *      openAnimation: useAnimation(slideInTop, { params: { duration: '2000ms' } }),
             *      closeAnimation: useAnimation(slideOutBottom, { params: { duration: '2000ms'} }),
             *      horizontalDirection: HorizontalAlignment.Left,
             *      verticalDirection: VerticalAlignment.Middle,
             *      horizontalStartPoint: HorizontalAlignment.Left,
             *      verticalStartPoint: VerticalAlignment.Middle,
             *      minSize: { height: 100, width: 100 }
             *  };
             * this.alert.positionSettings = this.newPositionSettings;
             * ```
             */
            set: function (settings) {
                this._positionSettings = settings;
                this._overlayDefaultSettings.positionStrategy = new GlobalPositionStrategy(this._positionSettings);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "element", {
            /**
             * @hidden
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "state", {
            /**
             * Returns the value of state. Possible state values are "open" or "close".
             *```typescript
             *@ViewChild("MyDialog")
             *public dialog: IgxDialogComponent;
             *ngAfterViewInit() {
             *    let dialogState = this.dialog.state;
             *}
             *```
             */
            get: function () {
                return this.isOpen ? 'open' : 'close';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "isOpen", {
            /**
             * Returns whether the dialog is visible to the end user.
             *```typescript
             *@ViewChild("MyDialog")
             *public dialog: IgxDialogComponent;
             *ngAfterViewInit() {
             *    let dialogOpen = this.dialog.isOpen;
             *}
             * ```
             */
            get: function () {
                return !this.toggleRef.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "isCollapsed", {
            get: function () {
                return this.toggleRef.collapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "role", {
            /**
             *Returns the value of the role of the dialog. The valid values are `dialog`, `alertdialog`, `alert`.
             *```typescript
             *@ViewChild("MyDialog")
             *public dialog: IgxDialogComponent;
             *ngAfterViewInit() {
             *    let dialogRole = this.dialog.role;
             *}
             * ```
             */
            get: function () {
                if (this.leftButtonLabel !== '' && this.rightButtonLabel !== '') {
                    return 'dialog';
                }
                else if (this.leftButtonLabel !== '' ||
                    this.rightButtonLabel !== '') {
                    return 'alertdialog';
                }
                else {
                    return 'alert';
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDialogComponent.prototype, "titleId", {
            /**
             *Returns the value of the title id.
             *```typescript
             *@ViewChild("MyDialog")
             *public dialog: IgxDialogComponent;
             *ngAfterViewInit() {
             *    let dialogTitle = this.dialog.titleId;
             *}
             * ```
             */
            get: function () {
                return this._titleId;
            },
            enumerable: true,
            configurable: true
        });
        IgxDialogComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.toggleRef.onClosing.pipe(operators.takeUntil(this.destroy$)).subscribe(function () { return _this.emitCloseFromDialog(); });
        };
        IgxDialogComponent.prototype.emitCloseFromDialog = function () {
            this.onClose.emit({ dialog: this, event: null });
        };
        /**
         * A method that opens the dialog.
         * @memberOf {@link IgxDialogComponent}
         *```html
         *<button (click)="dialog.open() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
         *<igx-dialog #dialog></igx-dialog>
         *```
         */
        IgxDialogComponent.prototype.open = function (overlaySettings) {
            if (overlaySettings === void 0) { overlaySettings = this._overlayDefaultSettings; }
            this.toggleRef.open(overlaySettings);
            this.onOpen.emit({ dialog: this, event: null });
            if (!this.leftButtonLabel && !this.rightButtonLabel) {
                this.toggleRef.element.focus();
            }
        };
        /**
         *A method that that closes the dialog.
         *@memberOf {@link IgxDialogComponent}
         *```html
         *<button (click)="dialog.close() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
         *<igx-dialog #dialog></igx-dialog>
         *```
         */
        IgxDialogComponent.prototype.close = function () {
            // `onClose` will emit from `toggleRef.onClosing` subscription
            this.toggleRef.close();
        };
        /**
         * A method that opens/closes the dialog.
         *@memberOf {@link IgxDialogComponent}
         *```html
         *<button (click)="dialog.toggle() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
         *<igx-dialog #dialog></igx-dialog>
         *```
         */
        IgxDialogComponent.prototype.toggle = function () {
            this.isOpen ? this.close() : this.open();
        };
        /**
         * @hidden
         */
        IgxDialogComponent.prototype.onDialogSelected = function (event) {
            event.stopPropagation();
            if (this.isOpen &&
                this.closeOnOutsideSelect &&
                event.target.classList.contains(IgxDialogComponent_1.DIALOG_CLASS)) {
                this.close();
            }
        };
        /**
         * @hidden
         */
        IgxDialogComponent.prototype.onInternalLeftButtonSelect = function (event) {
            this.onLeftButtonSelect.emit({ dialog: this, event: event });
        };
        /**
         * @hidden
         */
        IgxDialogComponent.prototype.onInternalRightButtonSelect = function (event) {
            this.onRightButtonSelect.emit({ dialog: this, event: event });
        };
        /**
         * @hidden
         */
        IgxDialogComponent.prototype.ngOnInit = function () {
            if (this.navService && this.id) {
                this.navService.add(this.id, this);
            }
        };
        /**
         * @hidden
         */
        IgxDialogComponent.prototype.ngOnDestroy = function () {
            if (this.navService && this.id) {
                this.navService.remove(this.id);
            }
        };
        var IgxDialogComponent_1;
        IgxDialogComponent.NEXT_ID = 1;
        IgxDialogComponent.DIALOG_CLASS = 'igx-dialog';
        IgxDialogComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: IgxNavigationService, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.ViewChild(IgxToggleDirective, { static: true })
        ], IgxDialogComponent.prototype, "toggleRef", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxDialogComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "isModal", null);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "title", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "message", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "leftButtonLabel", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "leftButtonType", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "leftButtonColor", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "leftButtonBackgroundColor", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "leftButtonRipple", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "rightButtonLabel", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "rightButtonType", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "rightButtonColor", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "rightButtonBackgroundColor", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "rightButtonRipple", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "closeOnOutsideSelect", null);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "positionSettings", null);
        __decorate([
            core.Output()
        ], IgxDialogComponent.prototype, "onOpen", void 0);
        __decorate([
            core.Output()
        ], IgxDialogComponent.prototype, "onClose", void 0);
        __decorate([
            core.Output()
        ], IgxDialogComponent.prototype, "onLeftButtonSelect", void 0);
        __decorate([
            core.Output()
        ], IgxDialogComponent.prototype, "onRightButtonSelect", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxDialogComponent.prototype, "tabindex", void 0);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "isOpen", null);
        __decorate([
            core.HostBinding('class.igx-dialog--hidden')
        ], IgxDialogComponent.prototype, "isCollapsed", null);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "role", null);
        __decorate([
            core.Input()
        ], IgxDialogComponent.prototype, "titleId", null);
        IgxDialogComponent = IgxDialogComponent_1 = __decorate([
            core.Component({
                selector: 'igx-dialog',
                template: "<div tabindex=\"0\" #dialog class=\"igx-dialog\" igxToggle (click)=\"onDialogSelected($event)\">\n    <div #dialogWindow class=\"igx-dialog__window\"  [attr.role]=\"role\" [attr.aria-labelledby]=\"titleId\">\n\n        <div *ngIf=\"title\" [attr.id]=\"titleId\" class=\"igx-dialog__window-title\">\n            {{ title }}\n        </div>\n        <ng-content *ngIf=\"!title\" select=\"igx-dialog-title,[igxDialogTitle]\"></ng-content>\n\n        <div class=\"igx-dialog__window-content\" *ngIf=\"message\">{{ message }}</div>\n        <ng-content *ngIf=\"!message\"></ng-content>\n\n        <div *ngIf=\"leftButtonLabel || rightButtonLabel\" class=\"igx-dialog__window-actions\">\n            <button *ngIf=\"leftButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ leftButtonType }}\" igxButtonColor=\"{{ leftButtonColor }}\" igxButtonBackground=\"{{ leftButtonBackgroundColor }}\"\n                igxRipple=\"{{ leftButtonRipple }}\" (click)=\"onInternalLeftButtonSelect($event)\">\n                {{ leftButtonLabel }}\n            </button>\n            <button *ngIf=\"rightButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ rightButtonType }}\" igxButtonColor=\"{{ rightButtonColor }}\" igxButtonBackground=\"{{ rightButtonBackgroundColor }}\"\n                igxRipple=\"{{ rightButtonRipple }}\" (click)=\"onInternalRightButtonSelect($event)\">\n                {{ rightButtonLabel }}\n            </button>\n        </div>\n        <ng-content *ngIf=\"!leftButtonLabel && !rightButtonLabel\" select=\"igx-dialog-actions,[igxDialogActions]\"></ng-content>\n\n    </div>\n</div>\n"
            }),
            __param(1, core.Optional())
        ], IgxDialogComponent);
        return IgxDialogComponent;
    }());
    /**
     * @hidden
     */
    var IgxDialogModule = /** @class */ (function () {
        function IgxDialogModule() {
        }
        IgxDialogModule = __decorate([
            core.NgModule({
                declarations: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                exports: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                imports: [common.CommonModule, IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]
            })
        ], IgxDialogModule);
        return IgxDialogModule;
    }());

    /**
     * @hidden
     */
    var IgxTemplateOutletDirective = /** @class */ (function () {
        function IgxTemplateOutletDirective(_viewContainerRef, _zone, cdr) {
            this._viewContainerRef = _viewContainerRef;
            this._zone = _zone;
            this.cdr = cdr;
            /**
            * The embedded views cache. Collection is key-value paired.
            * Key is the template id, value is the embedded view for the related template.
            */
            this._embeddedViewsMap = new Map();
            this.onViewCreated = new core.EventEmitter();
            this.onViewMoved = new core.EventEmitter();
            this.onCachedViewLoaded = new core.EventEmitter();
            this.onBeforeViewDetach = new core.EventEmitter();
        }
        IgxTemplateOutletDirective.prototype.ngOnChanges = function (changes) {
            var actionType = this._getActionType(changes);
            switch (actionType) {
                case TemplateOutletAction.CreateView:
                    this._recreateView();
                    break;
                case TemplateOutletAction.MoveView:
                    this._moveView();
                    break;
                case TemplateOutletAction.UseCachedView:
                    this._useCachedView();
                    break;
                case TemplateOutletAction.UpdateViewContext:
                    this._updateExistingContext(this.igxTemplateOutletContext);
                    break;
            }
        };
        IgxTemplateOutletDirective.prototype.cleanCache = function () {
            this._embeddedViewsMap.forEach(function (item) {
                if (!item.destroyed) {
                    item.destroy();
                }
            });
            this._embeddedViewsMap.clear();
        };
        IgxTemplateOutletDirective.prototype.cleanView = function (tmplID) {
            var embView = this._embeddedViewsMap.get(tmplID);
            if (embView) {
                embView.destroy();
                this._embeddedViewsMap.delete(tmplID);
            }
        };
        IgxTemplateOutletDirective.prototype._recreateView = function () {
            var prevIndex = this._viewRef ? this._viewContainerRef.indexOf(this._viewRef) : -1;
            // detach old and create new
            if (prevIndex !== -1) {
                this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                this._viewContainerRef.detach(prevIndex);
            }
            if (this.igxTemplateOutlet) {
                this._viewRef = this._viewContainerRef.createEmbeddedView(this.igxTemplateOutlet, this.igxTemplateOutletContext);
                this.onViewCreated.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                var tmplId = this.igxTemplateOutletContext['templateID'];
                if (tmplId) {
                    // if context contains a template id, check if we have a view for that template already stored in the cache
                    // if not create a copy and add it to the cache in detached state.
                    // Note: Views in detached state do not appear in the DOM, however they remain stored in memory.
                    var res = this._embeddedViewsMap.get(this.igxTemplateOutletContext['templateID']);
                    if (!res) {
                        this._embeddedViewsMap.set(this.igxTemplateOutletContext['templateID'], this._viewRef);
                    }
                }
            }
        };
        IgxTemplateOutletDirective.prototype._moveView = function () {
            // using external view and inserting it in current view.
            var view = this.igxTemplateOutletContext['moveView'];
            var owner = this.igxTemplateOutletContext['owner'];
            if (view !== this._viewRef) {
                if (owner._viewContainerRef.indexOf(view) !== -1) {
                    // detach in case view it is attached somewhere else at the moment.
                    this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                    owner._viewContainerRef.detach(owner._viewContainerRef.indexOf(view));
                }
                if (this._viewRef && this._viewContainerRef.indexOf(this._viewRef) !== -1) {
                    this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                    this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
                }
                this._viewRef = view;
                this._viewContainerRef.insert(view, 0);
                this._updateExistingContext(this.igxTemplateOutletContext);
                this.onViewMoved.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            }
            else {
                this._updateExistingContext(this.igxTemplateOutletContext);
            }
        };
        IgxTemplateOutletDirective.prototype._useCachedView = function () {
            // use view for specific template cached in the current template outlet
            var tmplID = this.igxTemplateOutletContext['templateID'];
            var cachedView = tmplID ?
                this._embeddedViewsMap.get(tmplID) :
                null;
            // if view exists, but template has been changed and there is a view in the cache with the related template
            // then detach old view and insert the stored one with the matching template
            // after that update its context.
            if (this._viewContainerRef.length > 0) {
                this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
            }
            this._viewRef = cachedView;
            var oldContext = this._cloneContext(cachedView.context);
            this._viewContainerRef.insert(this._viewRef, 0);
            this._updateExistingContext(this.igxTemplateOutletContext);
            this.onCachedViewLoaded.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext, oldContext: oldContext });
        };
        IgxTemplateOutletDirective.prototype._shouldRecreateView = function (changes) {
            var ctxChange = changes['igxTemplateOutletContext'];
            return !!changes['igxTemplateOutlet'] || (ctxChange && this._hasContextShapeChanged(ctxChange));
        };
        IgxTemplateOutletDirective.prototype._hasContextShapeChanged = function (ctxChange) {
            var e_1, _a;
            var prevCtxKeys = Object.keys(ctxChange.previousValue || {});
            var currCtxKeys = Object.keys(ctxChange.currentValue || {});
            if (prevCtxKeys.length === currCtxKeys.length) {
                try {
                    for (var currCtxKeys_1 = __values(currCtxKeys), currCtxKeys_1_1 = currCtxKeys_1.next(); !currCtxKeys_1_1.done; currCtxKeys_1_1 = currCtxKeys_1.next()) {
                        var propName = currCtxKeys_1_1.value;
                        if (prevCtxKeys.indexOf(propName) === -1) {
                            return true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (currCtxKeys_1_1 && !currCtxKeys_1_1.done && (_a = currCtxKeys_1.return)) _a.call(currCtxKeys_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return false;
            }
            else {
                return true;
            }
        };
        IgxTemplateOutletDirective.prototype._updateExistingContext = function (ctx) {
            var e_2, _a;
            try {
                for (var _b = __values(Object.keys(ctx)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var propName = _c.value;
                    this._viewRef.context[propName] = this.igxTemplateOutletContext[propName];
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        IgxTemplateOutletDirective.prototype._cloneContext = function (ctx) {
            var e_3, _a;
            var clone = {};
            try {
                for (var _b = __values(Object.keys(ctx)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var propName = _c.value;
                    clone[propName] = ctx[propName];
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return clone;
        };
        IgxTemplateOutletDirective.prototype._getActionType = function (changes) {
            var movedView = this.igxTemplateOutletContext['moveView'];
            var tmplID = this.igxTemplateOutletContext['templateID'];
            var cachedView = tmplID ?
                this._embeddedViewsMap.get(tmplID) :
                null;
            var shouldRecreate = this._shouldRecreateView(changes);
            if (movedView) {
                // view is moved from external source
                return TemplateOutletAction.MoveView;
            }
            else if (shouldRecreate && cachedView) {
                // should recreate (template or context change) and there is a matching template in cache
                return TemplateOutletAction.UseCachedView;
            }
            else if (!this._viewRef || shouldRecreate) {
                // no view or should recreate
                return TemplateOutletAction.CreateView;
            }
            else if (this.igxTemplateOutletContext) {
                // has context, update context
                return TemplateOutletAction.UpdateViewContext;
            }
        };
        IgxTemplateOutletDirective.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.NgZone },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxTemplateOutletDirective.prototype, "igxTemplateOutletContext", void 0);
        __decorate([
            core.Input()
        ], IgxTemplateOutletDirective.prototype, "igxTemplateOutlet", void 0);
        __decorate([
            core.Output()
        ], IgxTemplateOutletDirective.prototype, "onViewCreated", void 0);
        __decorate([
            core.Output()
        ], IgxTemplateOutletDirective.prototype, "onViewMoved", void 0);
        __decorate([
            core.Output()
        ], IgxTemplateOutletDirective.prototype, "onCachedViewLoaded", void 0);
        __decorate([
            core.Output()
        ], IgxTemplateOutletDirective.prototype, "onBeforeViewDetach", void 0);
        IgxTemplateOutletDirective = __decorate([
            core.Directive({ selector: '[igxTemplateOutlet]' })
        ], IgxTemplateOutletDirective);
        return IgxTemplateOutletDirective;
    }());
    var TemplateOutletAction;
    (function (TemplateOutletAction) {
        TemplateOutletAction[TemplateOutletAction["CreateView"] = 0] = "CreateView";
        TemplateOutletAction[TemplateOutletAction["MoveView"] = 1] = "MoveView";
        TemplateOutletAction[TemplateOutletAction["UseCachedView"] = 2] = "UseCachedView";
        TemplateOutletAction[TemplateOutletAction["UpdateViewContext"] = 3] = "UpdateViewContext";
    })(TemplateOutletAction || (TemplateOutletAction = {}));
    /**
     * @hidden
     */
    var IgxTemplateOutletModule = /** @class */ (function () {
        function IgxTemplateOutletModule() {
        }
        IgxTemplateOutletModule = __decorate([
            core.NgModule({
                declarations: [IgxTemplateOutletDirective],
                entryComponents: [],
                exports: [IgxTemplateOutletDirective],
                imports: [common.CommonModule]
            })
        ], IgxTemplateOutletModule);
        return IgxTemplateOutletModule;
    }());

    var IgxProcessBarTextTemplateDirective = /** @class */ (function () {
        function IgxProcessBarTextTemplateDirective(template) {
            this.template = template;
        }
        IgxProcessBarTextTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxProcessBarTextTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxProcessBarText]'
            })
        ], IgxProcessBarTextTemplateDirective);
        return IgxProcessBarTextTemplateDirective;
    }());
    var IgxProgressBarGradientDirective = /** @class */ (function () {
        function IgxProgressBarGradientDirective(template) {
            this.template = template;
        }
        IgxProgressBarGradientDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxProgressBarGradientDirective = __decorate([
            core.Directive({
                selector: '[igxProgressBarGradient]'
            })
        ], IgxProgressBarGradientDirective);
        return IgxProgressBarGradientDirective;
    }());

    /**
     * Injection token is used to inject the document into Directionality
     * which factory could be faked for testing purposes.
     *
     * We can't provide and mock the DOCUMENT token from platform-browser because configureTestingModule
     * allows override of the default providers, directive, pipes, modules of the test injector
     * which causes errors.
     *
     * @hidden
     */
    var DIR_DOCUMENT = new core.InjectionToken('dir-doc', {
        providedIn: 'root',
        factory: DIR_DOCUMENT_FACTORY
    });
    /**
     * @hidden
     */
    function DIR_DOCUMENT_FACTORY() {
        return core.inject(common.DOCUMENT);
    }
    /**
     * @hidden
     *
     * Bidirectional service that extracts the value of the direction attribute on the body or html elements.
     *
     * The dir attribute over the body element takes precedence.
     */
    var IgxDirectionality = /** @class */ (function () {
        function IgxDirectionality(document) {
            this._document = document;
            var bodyDir = this._document.body ? this._document.body.dir : null;
            var htmlDir = this._document.documentElement ? this._document.documentElement.dir : null;
            var extractedDir = bodyDir || htmlDir;
            this._dir = (extractedDir === 'ltr' || extractedDir === 'rtl') ? extractedDir : 'ltr';
        }
        Object.defineProperty(IgxDirectionality.prototype, "value", {
            get: function () {
                return this._dir;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDirectionality.prototype, "document", {
            get: function () {
                return this._document;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxDirectionality.prototype, "rtl", {
            get: function () {
                return this._dir === 'rtl';
            },
            enumerable: true,
            configurable: true
        });
        IgxDirectionality.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [DIR_DOCUMENT,] }] }
        ]; };
        IgxDirectionality.ɵprov = core["ɵɵdefineInjectable"]({ factory: function IgxDirectionality_Factory() { return new IgxDirectionality(core["ɵɵinject"](DIR_DOCUMENT)); }, token: IgxDirectionality, providedIn: "root" });
        IgxDirectionality = __decorate([
            core.Injectable({
                providedIn: 'root'
            }),
            __param(0, core.Inject(DIR_DOCUMENT))
        ], IgxDirectionality);
        return IgxDirectionality;
    }());

    var ONE_PERCENT = 0.01;
    var MIN_VALUE = 0;

    (function (IgxTextAlign) {
        IgxTextAlign["START"] = "start";
        IgxTextAlign["CENTER"] = "center";
        IgxTextAlign["END"] = "end";
    })(exports.IgxTextAlign || (exports.IgxTextAlign = {}));

    (function (IgxProgressType) {
        IgxProgressType["ERROR"] = "error";
        IgxProgressType["INFO"] = "info";
        IgxProgressType["WARNING"] = "warning";
        IgxProgressType["SUCCESS"] = "success";
    })(exports.IgxProgressType || (exports.IgxProgressType = {}));
    var BaseProgress = /** @class */ (function () {
        function BaseProgress() {
            /**
             * @hidden
             */
            this.requestAnimationId = undefined;
            /**
             * @hidden
             */
            this._valueInPercent = MIN_VALUE;
            /**
             * @hidden
             */
            this._max = 100;
            /**
             * @hidden
             */
            this._value = MIN_VALUE;
            /**
             * @hidden
             */
            this._animate = true;
        }
        Object.defineProperty(BaseProgress.prototype, "valueInPercent", {
            /**
             *Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
             *```typescript
             *@ViewChild("MyProgressBar")
             *public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
             *public valuePercent(event){
             *    let percentValue = this.progressBar.valueInPercent;
             *    alert(percentValue);
             *}
             *```
             */
            get: function () {
                return this._valueInPercent;
            },
            /**
             *Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
             *```typescript
             *@ViewChild("MyProgressBar")
             *public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
             *    public setValue(event){
             *    this.progressBar.valueInPercent = 56;
             *}
             * //...
             *```
             *```html
             *<button igxButton="fab" igxRipple="" (click)="setValue()">setValue</button>
             *```
             */
            set: function (value) {
                this._valueInPercent = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        BaseProgress.prototype.runAnimation = function (val, step) {
            var _this = this;
            this.requestAnimationId = requestAnimationFrame(function () { return _this.updateProgressSmoothly.call(_this, val, step); });
        };
        /**
         * @hidden
         */
        BaseProgress.prototype.updateProgressSmoothly = function (val, step) {
            var _this = this;
            this._value += step;
            var passedValue = convertInPercentage(val, this._max);
            var progressValue = convertInPercentage(this._value, this._max);
            if (this.valueInPercent === passedValue) {
                this.updateProgress(val);
                cancelAnimationFrame(this.requestAnimationId);
            }
            else if (this.isInLimitRange(progressValue, passedValue, step)) {
                this.updateProgress(val);
                cancelAnimationFrame(this.requestAnimationId);
            }
            else {
                this.valueInPercent = progressValue;
                this.requestAnimationId = requestAnimationFrame(function () { return _this.updateProgressSmoothly.call(_this, val, step); });
            }
        };
        /**
         * @hidden
         */
        BaseProgress.prototype.updateProgressDirectly = function (val) {
            this._value = val;
            this.valueInPercent = convertInPercentage(this._value, this._max);
        };
        /**
         * @hidden
         */
        BaseProgress.prototype.directionFlow = function (currentValue, prevValue, step) {
            if (currentValue < prevValue) {
                return step;
            }
            return -step;
        };
        /**
         * @hidden
         */
        BaseProgress.prototype.isInLimitRange = function (val, comparator, step) {
            return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
        };
        /**
         * @hidden
         *
         *
         * @param val
         * @param comparator
         * @param step
         */
        BaseProgress.prototype.isExceedingUpperLimit = function (val, comparator, step) {
            return val > comparator && step > 0;
        };
        /**
         * @hidden
         *
         * @param val
         * @param comparator
         * @param step
         */
        BaseProgress.prototype.isExceedingLowerLimit = function (val, comparator, step) {
            return val < comparator && step < 0;
        };
        /**
         * @hidden
         * @param step
         */
        BaseProgress.prototype.updateProgress = function (val) {
            this._value = val;
            this.valueInPercent = convertInPercentage(this._value, this._max);
        };
        return BaseProgress;
    }());
    var NEXT_LINEAR_ID = 0;
    var NEXT_CIRCULAR_ID = 0;
    var NEXT_GRADIENT_ID = 0;
    var IgxLinearProgressBarComponent = /** @class */ (function (_super) {
        __extends(IgxLinearProgressBarComponent, _super);
        function IgxLinearProgressBarComponent() {
            var _this = _super.call(this) || this;
            _this.valueMin = 0;
            _this.cssClass = 'igx-linear-bar';
            /**
             *Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
             *```html
             *<igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
             *```
             */
            _this.striped = false;
            /**
             *Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
             *```html
             *<igx-linear-bar [indeterminate]="true"></igx-linear-bar>
             *```
             */
            _this.indeterminate = false;
            /**An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
             * ```html
             *<igx-linear-bar role="progressbar"></igx-linear-bar>
             * ```
             */
            _this.role = 'progressbar';
            /**An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
             * ```html
             *<igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
             * ```
             */
            _this.id = "igx-linear-bar-" + NEXT_LINEAR_ID++;
            /**
             *Set the position that defines where the text is aligned.
             Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
             *```typescript
             *public positionCenter: IgxTextAlign;
             *public ngOnInit() {
             *    this.positionCenter = IgxTextAlign.CENTER;
             *}
             * //...
             *```
             * ```html
             *<igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
             *```
             */
            _this.textAlign = exports.IgxTextAlign.START;
            /**
             *Set the text to be visible. By default it is set to true.
             * ```html
             *<igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
             *```
             */
            _this.textVisibility = true;
            /**
             *Set the position that defines if the text should be aligned above the progress line. By default is set to false.
             *```html
             *<igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
             *```
             */
            _this.textTop = false;
            /**
             *Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
             *```html
             *<igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
             *```
             */
            _this.type = 'default';
            /**
             *An event, which is triggered after a progress is changed.
             *```typescript
             *public progressChange(event) {
             *    alert("Progress made!");
             *}
             * //...
             *```
             *```html
             *<igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
             *```
             */
            _this.onProgressChanged = new core.EventEmitter();
            return _this;
        }
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "animate", {
            /**
             *Returns whether the `IgxLinearProgressBarComponent` has animation true/false.
             *```typescript
             *@ViewChild("MyProgressBar")
             *public progressBar: IgxLinearProgressBarComponent;
             *public animationStatus(event) {
             *    let animationStatus = this.progressBar.animate;
             *    alert(animationStatus);
             *}
             *```
             */
            get: function () {
                return this._animate;
            },
            /**
             *Animation on progress `IgxLinearProgressBarComponent`. By default it is set to true.
             *```html
             *<igx-linear-bar [animate]="false" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
             *```
             */
            set: function (animate) {
                this._animate = animate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "max", {
            /**
             *Returns the the maximum progress value of the `IgxLinearProgressBarComponent`.
             *```typescript
             *@ViewChild("MyProgressBar")
             *public progressBar: IgxLinearProgressBarComponent;
             *public maxValue(event) {
             *    let max = this.progressBar.max;
             *    alert(max);
             *}
             *```
             */
            get: function () {
                return this._max;
            },
            /**
             *Set maximum value that can be passed. By default it is set to 100.
             *```html
             *<igx-linear-bar [striped]="false" [max]="200" [value]="0"></igx-linear-bar>
             *```
             */
            set: function (maxNum) {
                this._max = maxNum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "step", {
            /**
             *Returns the value which update the progress indicator of the `IgxLinearProgressBarComponent`.
             *```typescript
             *@ViewChild("MyProgressBar")
             *public progressBar: IgxLinearProgressBarComponent;
             *public stepValue(event) {
             *    let step = this.progressBar.step;
             *    alert(step);
             *}
             *```
             */
            get: function () {
                if (this._step) {
                    return this._step;
                }
                return this._max * ONE_PERCENT;
            },
            /**
             *Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
             *```html
             *<igx-linear-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-linear-bar>
             *```
             */
            set: function (val) {
                this._step = Number(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "value", {
            /**
            *Returns value that indicates the current `IgxLinearProgressBarComponent` position.
            *```typescript
            *@ViewChild("MyProgressBar")
            *public progressBar: IgxLinearProgressBarComponent;
            *public getValue(event) {
            *    let value = this.progressBar.value;
            *    alert(value);
            *}
            *```
            */
            get: function () {
                return this._value;
            },
            /**
             *Set value that indicates the current `IgxLinearProgressBarComponent` position.
             *```html
             *<igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
             *```
             */
            set: function (val) {
                val = Number(val);
                if (this._value === val || this.indeterminate) {
                    return;
                }
                var valueInRange = getValueInProperRange(val, this.max);
                if (isNaN(valueInRange)) {
                    return;
                }
                var changedValues = {
                    currentValue: valueInRange,
                    previousValue: this._value
                };
                var updateValue = _super.prototype.directionFlow.call(this, this._value, val, this.step);
                if (this._animate && val >= this.step) {
                    _super.prototype.runAnimation.call(this, valueInRange, updateValue);
                }
                else {
                    _super.prototype.updateProgressDirectly.call(this, valueInRange);
                }
                this.onProgressChanged.emit(changedValues);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "error", {
            /**
             * @hidden
             */
            get: function () {
                return this.type === exports.IgxProgressType.ERROR;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "info", {
            /**
             * @hidden
             */
            get: function () {
                return this.type === exports.IgxProgressType.INFO;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "warning", {
            /**
             * @hidden
             */
            get: function () {
                return this.type === exports.IgxProgressType.WARNING;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLinearProgressBarComponent.prototype, "success", {
            /**
             * @hidden
             */
            get: function () {
                return this.type === exports.IgxProgressType.SUCCESS;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "animate", null);
        __decorate([
            core.HostBinding('attr.aria-valuemax'),
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "max", null);
        __decorate([
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "step", null);
        __decorate([
            core.HostBinding('attr.aria-valuemin')
        ], IgxLinearProgressBarComponent.prototype, "valueMin", void 0);
        __decorate([
            core.HostBinding('class.igx-linear-bar')
        ], IgxLinearProgressBarComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('class.igx-linear-bar--striped'),
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "striped", void 0);
        __decorate([
            core.HostBinding('class.igx-linear-bar--indeterminate'),
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "indeterminate", void 0);
        __decorate([
            core.HostBinding('attr.role'),
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "textAlign", void 0);
        __decorate([
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "textVisibility", void 0);
        __decorate([
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "textTop", void 0);
        __decorate([
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "text", void 0);
        __decorate([
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "type", void 0);
        __decorate([
            core.HostBinding('attr.aria-valuenow'),
            core.Input()
        ], IgxLinearProgressBarComponent.prototype, "value", null);
        __decorate([
            core.Output()
        ], IgxLinearProgressBarComponent.prototype, "onProgressChanged", void 0);
        __decorate([
            core.HostBinding('class.igx-linear-bar--danger')
        ], IgxLinearProgressBarComponent.prototype, "error", null);
        __decorate([
            core.HostBinding('class.igx-linear-bar--info')
        ], IgxLinearProgressBarComponent.prototype, "info", null);
        __decorate([
            core.HostBinding('class.igx-linear-bar--warning')
        ], IgxLinearProgressBarComponent.prototype, "warning", null);
        __decorate([
            core.HostBinding('class.igx-linear-bar--success')
        ], IgxLinearProgressBarComponent.prototype, "success", null);
        IgxLinearProgressBarComponent = __decorate([
            core.Component({
                selector: 'igx-linear-bar',
                template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\" [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
            })
        ], IgxLinearProgressBarComponent);
        return IgxLinearProgressBarComponent;
    }(BaseProgress));
    var IgxCircularProgressBarComponent = /** @class */ (function (_super) {
        __extends(IgxCircularProgressBarComponent, _super);
        function IgxCircularProgressBarComponent(renderer, _directionality) {
            var _this = _super.call(this) || this;
            _this.renderer = renderer;
            _this._directionality = _directionality;
            _this.STROKE_OPACITY_DVIDER = 100;
            _this.STROKE_OPACITY_ADDITION = .2;
            /** @hidden */
            _this.cssClass = 'igx-circular-bar';
            /**
             *An event, which is triggered after a progress is changed.
             *```typescript
             *public progressChange(event) {
             *    alert("Progress made!");
             *}
             * //...
             *```
             *```html
             *<igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
             *```
             */
            _this.onProgressChanged = new core.EventEmitter();
            /**
             *An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
             *```html
             *<igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
             *```
             */
            _this.id = "igx-circular-bar-" + NEXT_CIRCULAR_ID++;
            /**
             * @hidden
             */
            _this.gradientId = "igx-circular-gradient-" + NEXT_GRADIENT_ID++;
            /**
             *An @Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
             *```html
             *<igx-circular-bar [indeterminate]="true"></igx-circular-bar>
             *```
             */
            _this.indeterminate = false;
            /**
             *Sets the text visibility. By default it is set to true.
             *```html
             *<igx-circular-bar [textVisibility]="false"></igx-circular-bar>
             *```
             */
            _this.textVisibility = true;
            _this._circleRadius = 46;
            _this._circumference = 2 * Math.PI * _this._circleRadius;
            return _this;
        }
        Object.defineProperty(IgxCircularProgressBarComponent.prototype, "context", {
            /**
             * @hidden
            */
            get: function () {
                return {
                    $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCircularProgressBarComponent.prototype, "animate", {
            /**
             *Returns whether the `IgxCircularProgressBarComponent` has animation true/false.
             *```typescript
             *@ViewChild("MyProgressBar")
             *public progressBar: IgxCircularProgressBarComponent;
             *public animationStatus(event) {
             *    let animationStatus = this.progressBar.animate;
             *    alert(animationStatus);
             *}
             *```
             */
            get: function () {
                return this._animate;
            },
            /**
            *Animation on progress `IgxCircularProgressBarComponent`. By default it is set to true.
             *```html
             *<igx-circular-bar [animate]="false" [value]="50"></igx-circular-bar>
             *```
             */
            set: function (animate) {
                this._animate = animate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCircularProgressBarComponent.prototype, "max", {
            /**
             *Returns the the maximum progress value of the `IgxCircularProgressBarComponent`.
             *```typescript
             *@ViewChild("MyProgressBar")
             *public progressBar: IgxCircularProgressBarComponent;
             *public maxValue(event) {
             *    let max = this.progressBar.max;
             *    alert(max);
             *}
             *```
             *```html
             *<igx-circular-bar [max]="245" [animate]="false" [value]="currentValue"></igx-circular-bar>
             *```
             */
            get: function () {
                return this._max;
            },
            /**
             *Set maximum value that can be passed. By default it is set to 100.
             *```html
             *<igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
             *```
             */
            set: function (maxNum) {
                this._max = maxNum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCircularProgressBarComponent.prototype, "step", {
            /**
             *Returns the value which update the progress indicator of the `IgxCircularProgressBarComponent`.
             *```typescript
             *@ViewChild("MyProgressBar")
             *public progressBar: IgxCircularProgressBarComponent;
             *public stepValue(event) {
             *    let step = this.progressBar.step;
             *    alert(step);
             *}
             *```
             */
            get: function () {
                if (this._step) {
                    return this._step;
                }
                return this._max * ONE_PERCENT;
            },
            /**
             *Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
             *```html
             *<igx-circular-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-circular-bar>
             *```
            */
            set: function (val) {
                this._step = Number(val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxCircularProgressBarComponent.prototype, "value", {
            /**
             *Returns value that indicates the current `IgxCircularProgressBarComponent` position.
             *```typescript
             *@ViewChild("MyProgressBar")
             *public progressBar: IgxCircularProgressBarComponent;
             *public getValue(event) {
             *    let value = this.progressBar.value;
             *    alert(value);
             *}
             *```
             *```html
             *<button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
             *```
             */
            get: function () {
                return this._value;
            },
            /**
             *Set value that indicates the current `IgxCircularProgressBarComponent` position.
             *```html
             *<igx-circular-bar [value]="50"></igx-circular-bar>
             *```
             */
            set: function (val) {
                val = Number(val);
                if (this._value === val || this.indeterminate) {
                    return;
                }
                var valueInProperRange = getValueInProperRange(val, this.max);
                if (isNaN(valueInProperRange)) {
                    return;
                }
                var changedValues = {
                    currentValue: valueInProperRange,
                    previousValue: this._value
                };
                var updateValue = _super.prototype.directionFlow.call(this, this._value, val, this.step);
                if (this.animate && val >= this.step) {
                    _super.prototype.runAnimation.call(this, valueInProperRange, updateValue);
                }
                else {
                    this.updateProgressDirectly(valueInProperRange);
                }
                this.onProgressChanged.emit(changedValues);
            },
            enumerable: true,
            configurable: true
        });
        IgxCircularProgressBarComponent.prototype.ngAfterViewInit = function () {
            this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', "url(#" + this.gradientId + ")");
        };
        /**
         * @hidden
         */
        IgxCircularProgressBarComponent.prototype.updateProgressSmoothly = function (val, step) {
            // Set frames for the animation
            var FRAMES = [{
                    strokeDashoffset: this.getProgress(this._value),
                    strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
                }, {
                    strokeDashoffset: this.getProgress(this.valueInPercent),
                    strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
                }];
            this._svgCircle.nativeElement.animate(FRAMES, {
                easing: 'ease-out',
                fill: 'forwards'
            });
            _super.prototype.updateProgressSmoothly.call(this, val, step);
        };
        Object.defineProperty(IgxCircularProgressBarComponent.prototype, "textContent", {
            /**
             * @hidden
            */
            get: function () {
                return this.text;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
        */
        IgxCircularProgressBarComponent.prototype.updateProgressDirectly = function (val) {
            _super.prototype.updateProgressDirectly.call(this, val);
            this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
            this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
        };
        IgxCircularProgressBarComponent.prototype.getProgress = function (percentage) {
            return this._directionality.rtl ?
                this._circumference + (percentage * this._circumference / 100) :
                this._circumference - (percentage * this._circumference / 100);
        };
        IgxCircularProgressBarComponent.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: IgxDirectionality }
        ]; };
        __decorate([
            core.HostBinding('class.igx-circular-bar')
        ], IgxCircularProgressBarComponent.prototype, "cssClass", void 0);
        __decorate([
            core.Output()
        ], IgxCircularProgressBarComponent.prototype, "onProgressChanged", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxCircularProgressBarComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('class.igx-circular-bar--indeterminate'),
            core.Input()
        ], IgxCircularProgressBarComponent.prototype, "indeterminate", void 0);
        __decorate([
            core.Input()
        ], IgxCircularProgressBarComponent.prototype, "textVisibility", void 0);
        __decorate([
            core.Input()
        ], IgxCircularProgressBarComponent.prototype, "text", void 0);
        __decorate([
            core.ContentChild(IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective })
        ], IgxCircularProgressBarComponent.prototype, "textTemplate", void 0);
        __decorate([
            core.ContentChild(IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective })
        ], IgxCircularProgressBarComponent.prototype, "gradientTemplate", void 0);
        __decorate([
            core.Input()
        ], IgxCircularProgressBarComponent.prototype, "animate", null);
        __decorate([
            core.Input()
        ], IgxCircularProgressBarComponent.prototype, "max", null);
        __decorate([
            core.Input()
        ], IgxCircularProgressBarComponent.prototype, "step", null);
        __decorate([
            core.Input()
        ], IgxCircularProgressBarComponent.prototype, "value", null);
        __decorate([
            core.ViewChild('circle', { static: true })
        ], IgxCircularProgressBarComponent.prototype, "_svgCircle", void 0);
        IgxCircularProgressBarComponent = __decorate([
            core.Component({
                selector: 'igx-circular-bar',
                template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n        </ng-container>\n    </svg:text>\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultTextTemplate>\n        <svg:tspan class=\"igx-circular-bar__text\">\n            {{textContent ? textContent: valueInPercent + '%'}}\n        </svg:tspan>\n    </ng-template>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n"
            })
        ], IgxCircularProgressBarComponent);
        return IgxCircularProgressBarComponent;
    }(BaseProgress));
    function getValueInProperRange(value, max, min) {
        if (min === void 0) { min = 0; }
        return Math.max(Math.min(value, max), min);
    }
    function convertInPercentage(value, max) {
        return Math.floor(100 * value / max);
    }
    /**
     * @hidden
     */
    var IgxProgressBarModule = /** @class */ (function () {
        function IgxProgressBarModule() {
        }
        IgxProgressBarModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxLinearProgressBarComponent,
                    IgxCircularProgressBarComponent,
                    IgxProcessBarTextTemplateDirective,
                    IgxProgressBarGradientDirective,
                ],
                exports: [
                    IgxLinearProgressBarComponent,
                    IgxCircularProgressBarComponent,
                    IgxProcessBarTextTemplateDirective,
                    IgxProgressBarGradientDirective,
                ],
                imports: [common.CommonModule]
            })
        ], IgxProgressBarModule);
        return IgxProgressBarModule;
    }());

    var IgxSelectItemComponent = /** @class */ (function (_super) {
        __extends(IgxSelectItemComponent, _super);
        function IgxSelectItemComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxSelectItemComponent.prototype, "text", {
            /**
             * An @Input property that gets/sets the item's text to be displayed in the select component's input when the item is selected.
             *
             * ```typescript
             *  //get
             *  let mySelectedItem = this.dropDown.selectedItem;
             *  let selectedItemText = mySelectedItem.text;
             * ```
        
             * ```html
             * // set
             * <igx-select-item [text]="'London'"></igx-select-item>
             * ```
             */
            get: function () {
                return this._text;
            },
            set: function (text) {
                this._text = text;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSelectItemComponent.prototype, "itemText", {
            /** @hidden @internal */
            get: function () {
                if (this._text !== undefined) {
                    return this._text;
                }
                // If text @Input is undefined, try extract a meaningful item text out of the item template
                return this.elementRef.nativeElement.textContent.trim();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSelectItemComponent.prototype, "selected", {
            /**
             * Sets/Gets if the item is the currently selected one in the select
             *
             * ```typescript
             *  let mySelectedItem = this.select.selectedItem;
             *  let isMyItemSelected = mySelectedItem.selected; // true
             * ```
             */
            get: function () {
                return !this.isHeader && !this.disabled && this.selection.is_item_selected(this.dropDown.id, this);
            },
            set: function (value) {
                if (value && !this.isHeader && !this.disabled) {
                    this.dropDown.selectItem(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxSelectItemComponent.prototype.ngDoCheck = function () {
        };
        __decorate([
            core.Input()
        ], IgxSelectItemComponent.prototype, "text", null);
        IgxSelectItemComponent = __decorate([
            core.Component({
                selector: 'igx-select-item',
                template: '<ng-content></ng-content>'
            })
        ], IgxSelectItemComponent);
        return IgxSelectItemComponent;
    }(IgxDropDownItemComponent));

    /** @hidden @internal */
    var SelectPositioningStrategy = /** @class */ (function (_super) {
        __extends(SelectPositioningStrategy, _super);
        function SelectPositioningStrategy(select, settings) {
            var _this = _super.call(this) || this;
            _this.select = select;
            _this._selectDefaultSettings = {
                horizontalDirection: exports.HorizontalAlignment.Right,
                verticalDirection: exports.VerticalAlignment.Bottom,
                horizontalStartPoint: exports.HorizontalAlignment.Left,
                verticalStartPoint: exports.VerticalAlignment.Top,
                openAnimation: fadeIn,
                closeAnimation: fadeOut
            };
            // Global variables required for cases of !initialCall (page scroll/overlay repositionAll)
            _this.global_yOffset = 0;
            _this.global_xOffset = 0;
            _this.global_styles = {};
            _this.settings = Object.assign({}, _this._selectDefaultSettings, settings);
            return _this;
        }
        /** @inheritdoc */
        SelectPositioningStrategy.prototype.position = function (contentElement, size, document, initialCall) {
            var rects = _super.prototype.calculateElementRectangles.call(this, contentElement);
            // selectFit obj, to be used for both cases of initialCall and !initialCall(page scroll/overlay repositionAll)
            var selectFit = {
                verticalOffset: this.global_yOffset,
                horizontalOffset: this.global_xOffset,
                targetRect: rects.targetRect,
                contentElementRect: rects.elementRect,
                styles: this.global_styles,
                scrollContainer: this.select.scrollContainer,
                scrollContainerRect: this.select.scrollContainer.getBoundingClientRect()
            };
            if (initialCall) {
                // Fill in the required selectFit object properties.
                selectFit.viewPortRect = Util.getViewportRect(document);
                selectFit.itemElement = this.getInteractionItemElement();
                selectFit.itemRect = selectFit.itemElement.getBoundingClientRect();
                // Calculate input and selected item elements style related variables
                selectFit.styles = this.calculateStyles(selectFit);
                selectFit.scrollAmount = this.calculateScrollAmount(selectFit);
                // Calculate how much to offset the overlay container.
                this.calculateYoffset(selectFit);
                this.calculateXoffset(selectFit);
                _super.prototype.updateViewPortFit.call(this, selectFit);
                // container does not fit in viewPort and is out on Top or Bottom
                if (selectFit.fitVertical.back < 0 || selectFit.fitVertical.forward < 0) {
                    this.fitInViewport(contentElement, selectFit);
                }
                this.select.scrollContainer.scrollTop = selectFit.scrollAmount;
            }
            this.setStyles(contentElement, selectFit);
        };
        /**
         * Calculate selected item scroll position.
         */
        SelectPositioningStrategy.prototype.calculateScrollAmount = function (selectFit) {
            var itemElementRect = selectFit.itemRect;
            var scrollContainer = selectFit.scrollContainer;
            var scrollContainerRect = selectFit.scrollContainerRect;
            var scrollDelta = scrollContainerRect.top - itemElementRect.top;
            var scrollPosition = scrollContainer.scrollTop - scrollDelta;
            var dropDownHeight = scrollContainer.clientHeight;
            scrollPosition -= dropDownHeight / 2;
            scrollPosition += itemElementRect.height / 2;
            return Math.round(Math.min(Math.max(0, scrollPosition), scrollContainer.scrollHeight - scrollContainerRect.height));
        };
        /**
         * Position the items outer container so selected item text is positioned over input text and if header
         * And/OR footer - both header/footer are visible
         * @param selectFit selectFit to use for computation.
         */
        SelectPositioningStrategy.prototype.fitInViewport = function (contentElement, selectFit) {
            var footer = selectFit.scrollContainerRect.bottom - selectFit.contentElementRect.bottom;
            var header = selectFit.scrollContainerRect.top - selectFit.contentElementRect.top;
            var lastItemFitSize = selectFit.targetRect.bottom + selectFit.styles.itemTextToInputTextDiff - footer;
            var firstItemFitSize = selectFit.targetRect.top - selectFit.styles.itemTextToInputTextDiff - header;
            // out of viewPort on Top
            if (selectFit.fitVertical.back < 0) {
                var possibleScrollAmount = selectFit.scrollContainer.scrollHeight -
                    selectFit.scrollContainerRect.height - selectFit.scrollAmount;
                if (possibleScrollAmount + selectFit.fitVertical.back > 0 && firstItemFitSize > selectFit.viewPortRect.top) {
                    selectFit.scrollAmount -= selectFit.fitVertical.back;
                    selectFit.verticalOffset -= selectFit.fitVertical.back;
                    this.global_yOffset = selectFit.verticalOffset;
                }
                else {
                    selectFit.verticalOffset = 0;
                    this.global_yOffset = 0;
                }
                // out of viewPort on Bottom
            }
            else if (selectFit.fitVertical.forward < 0) {
                if (selectFit.scrollAmount + selectFit.fitVertical.forward > 0 && lastItemFitSize < selectFit.viewPortRect.bottom) {
                    selectFit.scrollAmount += selectFit.fitVertical.forward;
                    selectFit.verticalOffset += selectFit.fitVertical.forward;
                    this.global_yOffset = selectFit.verticalOffset;
                }
                else {
                    selectFit.verticalOffset = -selectFit.contentElementRect.height + selectFit.targetRect.height;
                    this.global_yOffset = selectFit.verticalOffset;
                }
            }
        };
        /**
         * Sets element's style which effectively positions the provided element
         * @param element Element to position
         * @param selectFit selectFit to use for computation.
         * @param initialCall should be true if this is the initial call to the position method calling setStyles
         */
        SelectPositioningStrategy.prototype.setStyles = function (contentElement, selectFit) {
            _super.prototype.setStyle.call(this, contentElement, selectFit.targetRect, selectFit.contentElementRect, selectFit);
            contentElement.style.width = selectFit.styles.contentElementNewWidth + "px"; // manage container based on paddings?
            this.global_styles.contentElementNewWidth = selectFit.styles.contentElementNewWidth;
        };
        /**
         * Calculate the necessary input and selected item styles to be used for positioning item text over input text.
         * Calculate & Set default items container width.
         * @param selectFit selectFit to use for computation.
         */
        SelectPositioningStrategy.prototype.calculateStyles = function (selectFit) {
            var styles = {};
            var inputElementStyles = window.getComputedStyle(this.settings.target);
            var itemElementStyles = window.getComputedStyle(selectFit.itemElement);
            var numericInputFontSize = parseFloat(inputElementStyles.fontSize);
            var numericItemFontSize = parseFloat(itemElementStyles.fontSize);
            var inputTextToInputTop = (selectFit.targetRect.bottom - selectFit.targetRect.top - numericInputFontSize) / 2;
            var itemTextToItemTop = (selectFit.itemRect.height - numericItemFontSize) / 2;
            // Adjust for input top padding
            var negateInputPaddings = (parseFloat(inputElementStyles.paddingTop) -
                parseFloat(inputElementStyles.paddingBottom)) / 2;
            styles.itemTextToInputTextDiff = Math.round(itemTextToItemTop - inputTextToInputTop + negateInputPaddings);
            var numericLeftPadding = parseFloat(itemElementStyles.paddingLeft);
            var numericTextIndent = parseFloat(itemElementStyles.textIndent);
            styles.itemTextPadding = numericLeftPadding;
            styles.itemTextIndent = numericTextIndent;
            // 24 is the input's toggle ddl icon width
            styles.contentElementNewWidth = selectFit.targetRect.width + 24 + numericLeftPadding * 2;
            return styles;
        };
        /**
         * Obtain the selected item if there is such one or otherwise use the first one
         */
        SelectPositioningStrategy.prototype.getInteractionItemElement = function () {
            var itemElement;
            if (this.select.selectedItem) {
                itemElement = this.select.selectedItem.element.nativeElement;
                // D.P. Feb 22 2019, #3921 Force item scroll before measuring in IE11, due to base scrollToItem delay
                if (isIE()) {
                    this.select.scrollContainer.scrollTop = this.select.calculateScrollPosition(this.select.selectedItem);
                }
            }
            else {
                itemElement = this.select.getFirstItemElement();
            }
            return itemElement;
        };
        /**
         * Calculate how much to offset the overlay container for Y-axis.
         */
        SelectPositioningStrategy.prototype.calculateYoffset = function (selectFit) {
            selectFit.verticalOffset = -(selectFit.itemRect.top - selectFit.contentElementRect.top +
                selectFit.styles.itemTextToInputTextDiff - selectFit.scrollAmount);
            this.global_yOffset = selectFit.verticalOffset;
        };
        /**
         * Calculate how much to offset the overlay container for X-axis.
         */
        SelectPositioningStrategy.prototype.calculateXoffset = function (selectFit) {
            selectFit.horizontalOffset = selectFit.styles.itemTextIndent - selectFit.styles.itemTextPadding;
            this.global_xOffset = selectFit.horizontalOffset;
        };
        return SelectPositioningStrategy;
    }(BaseFitPositionStrategy));

    /** @hidden @internal */
    var IgxSelectToggleIconDirective = /** @class */ (function () {
        function IgxSelectToggleIconDirective() {
        }
        IgxSelectToggleIconDirective = __decorate([
            core.Directive({
                selector: '[igxSelectToggleIcon]'
            })
        ], IgxSelectToggleIconDirective);
        return IgxSelectToggleIconDirective;
    }());
    /** @hidden @internal */
    var IgxSelectHeaderDirective = /** @class */ (function () {
        function IgxSelectHeaderDirective() {
        }
        IgxSelectHeaderDirective = __decorate([
            core.Directive({
                selector: '[igxSelectHeader]'
            })
        ], IgxSelectHeaderDirective);
        return IgxSelectHeaderDirective;
    }());
    /** @hidden @internal */
    var IgxSelectFooterDirective = /** @class */ (function () {
        function IgxSelectFooterDirective() {
        }
        IgxSelectFooterDirective = __decorate([
            core.Directive({
                selector: '[igxSelectFooter]'
            })
        ], IgxSelectFooterDirective);
        return IgxSelectFooterDirective;
    }());
    var noop$6 = function () { };
    var ɵ0$6 = noop$6;
    /**
     * **Ignite UI for Angular Select** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/select.html)
     *
     * The `igxSelect` provides an input with dropdown list allowing selection of a single item.
     *
     * Example:
     * ```html
     * <igx-select #select1 [placeholder]="'Pick One'">
     *   <label igxLabel>Select Label</label>
     *   <igx-select-item *ngFor="let item of items" [value]="item.field">
     *     {{ item.field }}
     *   </igx-select-item>
     * </igx-select>
     * ```
     */
    var IgxSelectComponent = /** @class */ (function (_super) {
        __extends(IgxSelectComponent, _super);
        function IgxSelectComponent(elementRef, cdr, selection, _displayDensityOptions, _injector) {
            var _this = _super.call(this, elementRef, cdr, selection, _displayDensityOptions) || this;
            _this.elementRef = elementRef;
            _this.cdr = cdr;
            _this.selection = selection;
            _this._displayDensityOptions = _displayDensityOptions;
            _this._injector = _injector;
            _this.ngControl = null;
            /** @hidden @internal do not use the drop-down container class */
            _this.cssClass = false;
            /** @hidden @internal */
            _this.allowItemsFocus = false;
            /**
             * An @Input property that disables the `IgxSelectComponent`.
             * ```html
             * <igx-select [disabled]="'true'"></igx-select>
             * ```
             */
            _this.disabled = false;
            /** @hidden @internal */
            _this.maxHeight = '256px';
            /**
             * An @Input property that sets how the select will be styled.
             * The allowed values are `line`, `box` and `border`. The default is `line`.
             * ```html
             *<igx-select [type]="'box'"></igx-select>
             * ```
             */
            _this.type = 'line';
            /**
             * The custom template, if any, that should be used when rendering the select TOGGLE(open/close) button
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.select.toggleIconTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-select #select>
             *      ...
             *      <ng-template igxSelectToggleIcon let-collapsed>
             *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
             *      </ng-template>
             *  </igx-select>
             * ```
             */
            _this.toggleIconTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the HEADER for the select items list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.select.headerTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-select #select>
             *      ...
             *      <ng-template igxSelectHeader>
             *          <div class="select__header">
             *              This is a custom header
             *          </div>
             *      </ng-template>
             *  </igx-select>
             * ```
             */
            _this.headerTemplate = null;
            /**
             * The custom template, if any, that should be used when rendering the FOOTER for the select items list
             *
             * ```typescript
             * // Set in typescript
             * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
             * myComponent.select.footerTemplate = myCustomTemplate;
             * ```
             * ```html
             * <!-- Set in markup -->
             *  <igx-select #select>
             *      ...
             *      <ng-template igxSelectFooter>
             *          <div class="select__footer">
             *              This is a custom footer
             *          </div>
             *      </ng-template>
             *  </igx-select>
             * ```
             */
            _this.footerTemplate = null;
            //#region ControlValueAccessor
            /** @hidden @internal */
            _this._onChangeCallback = noop$6;
            /** @hidden @internal */
            _this._onTouchedCallback = noop$6;
            /** @hidden @internal */
            _this.writeValue = function (value) {
                _this.value = value;
            };
            return _this;
        }
        IgxSelectComponent_1 = IgxSelectComponent;
        Object.defineProperty(IgxSelectComponent.prototype, "value", {
            /**
             * An @Input property that gets/sets the component value.
             *
             * ```typescript
             * // get
             * let selectValue = this.select.value;
             * ```
             *
             * ```typescript
             * // set
             * this.select.value = 'London';
             * ```
             * ```html
             * <igx-select [value]="value"></igx-select>
             * ```
             */
            get: function () {
                return this._value;
            },
            set: function (v) {
                var _this = this;
                if (this._value === v) {
                    return;
                }
                this._value = v;
                this.setSelection(this.items.find(function (x) { return x.value === _this.value; }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSelectComponent.prototype, "selectionValue", {
            /** @hidden @internal */
            get: function () {
                var selectedItem = this.selectedItem;
                return selectedItem ? selectedItem.itemText : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSelectComponent.prototype, "selectedItem", {
            /** @hidden @internal */
            get: function () {
                return this.selection.first_item(this.id);
            },
            enumerable: true,
            configurable: true
        });
        /** @hidden @internal */
        IgxSelectComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.setDisabledState = function (isDisabled) {
            this.disabled = isDisabled;
        };
        //#endregion
        /** @hidden @internal */
        IgxSelectComponent.prototype.getEditElement = function () {
            return this.input.nativeElement;
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.selectItem = function (newSelection, event) {
            var oldSelection = this.selectedItem;
            if (event) {
                this.toggleDirective.close();
            }
            if (newSelection === null || newSelection === oldSelection || newSelection.disabled || newSelection.isHeader) {
                return;
            }
            var args = { oldSelection: oldSelection, newSelection: newSelection, cancel: false };
            this.onSelection.emit(args);
            if (args.cancel) {
                return;
            }
            this.setSelection(newSelection);
            this._value = newSelection.value;
            this.cdr.detectChanges();
            this._onChangeCallback(this.value);
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.getFirstItemElement = function () {
            return this.children.first.element.nativeElement;
        };
        /**
         * Opens the select
         *
         * ```typescript
         * this.select.open();
         * ```
         */
        IgxSelectComponent.prototype.open = function (overlaySettings) {
            if (this.disabled || this.items.length === 0) {
                return;
            }
            if (!this.selectedItem) {
                this.navigateFirst();
            }
            _super.prototype.open.call(this, Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this._overlayDefaults = {
                modal: false,
                closeOnOutsideClick: false,
                positionStrategy: new SelectPositioningStrategy(this, { target: this.getEditElement() }),
                scrollStrategy: new AbsoluteScrollStrategy(),
                excludePositionTarget: true
            };
            this.children.changes.subscribe(function () {
                _this.setSelection(_this.items.find(function (x) { return x.value === _this.value; }));
                _this.cdr.detectChanges();
            });
            Promise.resolve().then(function () { return _this.children.notifyOnChanges(); });
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.onToggleOpening = function (event) {
            this.onOpening.emit(event);
            if (event.cancel) {
                return;
            }
            this.scrollToItem(this.selectedItem);
        };
        IgxSelectComponent.prototype.navigate = function (direction, currentIndex) {
            if (this.collapsed && this.selectedItem) {
                this.navigateItem(this.selectedItem.itemIndex);
            }
            _super.prototype.navigate.call(this, direction, currentIndex);
        };
        IgxSelectComponent.prototype.manageRequiredAsterisk = function () {
            if (this.ngControl && this.ngControl.control.validator) {
                // Run the validation with empty object to check if required is enabled.
                var error = this.ngControl.control.validator({});
                this.inputGroup.isRequired = error && error.required;
                this.cdr.markForCheck();
            }
        };
        IgxSelectComponent.prototype.setSelection = function (item) {
            if (item && item.value !== undefined && item.value !== null) {
                this.selection.set(this.id, new Set([item]));
            }
            else {
                this.selection.clear(this.id);
            }
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.onBlur = function () {
            this._onTouchedCallback();
            if (this.ngControl && !this.ngControl.valid) {
                this.input.valid = exports.IgxInputState.INVALID;
            }
            else {
                this.input.valid = exports.IgxInputState.INITIAL;
            }
            if (!this.collapsed) {
                this.toggleDirective.close();
            }
        };
        /** @hidden @internal */
        IgxSelectComponent.prototype.onFocus = function () {
            this._onTouchedCallback();
        };
        IgxSelectComponent.prototype.onStatusChanged = function () {
            if ((this.ngControl.control.touched || this.ngControl.control.dirty) &&
                (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
                if (this.inputGroup.isFocused) {
                    this.input.valid = this.ngControl.valid ? exports.IgxInputState.VALID : exports.IgxInputState.INVALID;
                }
                else {
                    this.input.valid = this.ngControl.valid ? exports.IgxInputState.INITIAL : exports.IgxInputState.INVALID;
                }
            }
            this.manageRequiredAsterisk();
        };
        /**
         * @hidden @internal
         */
        IgxSelectComponent.prototype.ngOnInit = function () {
            this.ngControl = this._injector.get(forms.NgControl, null);
        };
        /**
         * @hidden @internal
         */
        IgxSelectComponent.prototype.ngAfterViewInit = function () {
            if (this.ngControl) {
                this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
                this.manageRequiredAsterisk();
            }
            this.cdr.detectChanges();
        };
        /**
         * @hidden @internal
         */
        IgxSelectComponent.prototype.ngOnDestroy = function () {
            this.selection.clear(this.id);
            if (this._statusChanges$) {
                this._statusChanges$.unsubscribe();
            }
        };
        /**
         * @hidden @internal
         * Prevent input blur - closing the items container on Header/Footer Template click.
         */
        IgxSelectComponent.prototype.mousedownHandler = function (event) {
            event.preventDefault();
        };
        var IgxSelectComponent_1;
        IgxSelectComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: IgxSelectionAPIService },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] },
            { type: core.Injector }
        ]; };
        __decorate([
            core.ViewChild('inputGroup', { read: IgxInputGroupComponent, static: true })
        ], IgxSelectComponent.prototype, "inputGroup", void 0);
        __decorate([
            core.ViewChild('input', { read: IgxInputDirective, static: true })
        ], IgxSelectComponent.prototype, "input", void 0);
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return IgxSelectItemComponent; }), { descendants: true })
        ], IgxSelectComponent.prototype, "children", void 0);
        __decorate([
            core.ContentChild(core.forwardRef(function () { return IgxLabelDirective; }), { static: true })
        ], IgxSelectComponent.prototype, "label", void 0);
        __decorate([
            core.Input()
        ], IgxSelectComponent.prototype, "value", null);
        __decorate([
            core.Input()
        ], IgxSelectComponent.prototype, "placeholder", void 0);
        __decorate([
            core.Input()
        ], IgxSelectComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input()
        ], IgxSelectComponent.prototype, "overlaySettings", void 0);
        __decorate([
            core.HostBinding('style.maxHeight')
        ], IgxSelectComponent.prototype, "maxHeight", void 0);
        __decorate([
            core.Input()
        ], IgxSelectComponent.prototype, "type", void 0);
        __decorate([
            core.ContentChild(IgxSelectToggleIconDirective, { read: core.TemplateRef })
        ], IgxSelectComponent.prototype, "toggleIconTemplate", void 0);
        __decorate([
            core.ContentChild(IgxSelectHeaderDirective, { read: core.TemplateRef, static: false })
        ], IgxSelectComponent.prototype, "headerTemplate", void 0);
        __decorate([
            core.ContentChild(IgxSelectFooterDirective, { read: core.TemplateRef, static: false })
        ], IgxSelectComponent.prototype, "footerTemplate", void 0);
        IgxSelectComponent = IgxSelectComponent_1 = __decorate([
            core.Component({
                selector: 'igx-select',
                template: "<igx-input-group #inputGroup class=\"input-group\" [disabled]=\"disabled\" (click)=\"toggle()\" [type]=\"type\" [displayDensity]=\"displayDensity\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n    </ng-container>\n    <input #input class=\"input\" type=\"text\" igxInput [igxSelectItemNavigation]=\"this\"\n        readonly=\"true\"\n        [attr.placeholder]=\"this.placeholder\"\n        [value]=\"this.selectionValue\"\n        role=\"combobox\"\n        aria-haspopup=\"listbox\"\n        [attr.aria-labelledby]=\"this.label ? this.label.id : ''\"\n        [attr.aria-expanded]=\"!this.collapsed\"\n        [attr.aria-owns]=\"this.listId\"\n        [attr.aria-activedescendant]=\"!this.collapsed ? this.focusedItem?.id : null\"\n        (blur)=\"onBlur()\"\n        (focus)=\"onFocus()\"\n    />\n    <ng-container ngProjectAs=\"igx-suffix\">\n            <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </ng-container>\n    <igx-suffix>\n            <ng-container *ngIf=\"toggleIconTemplate\">\n                <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n                </ng-container>\n            <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">{{ collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n    </igx-suffix>\n</igx-input-group>\n<div igxToggle class=\"igx-drop-down__list\" (mousedown)=\"mousedownHandler($event);\" (onOpening)=\"onToggleOpening($event)\"\n    (onOpened)=\"onToggleOpened()\" (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n\n    <div *ngIf=\"headerTemplate\" class=\"igx-drop-down__select-header\">\n        <ng-content *ngTemplateOutlet=\"headerTemplate\"></ng-content>\n    </div>\n\n    <div #scrollContainer class=\"igx-drop-down__list-scroll\" [style.maxHeight]=\"maxHeight\" [attr.id]=\"this.listId\" role=\"listbox\">\n        <ng-content select=\"igx-select-item, igx-select-item-group\"></ng-content>\n    </div>\n\n    <div *ngIf=\"footerTemplate\" class=\"igx-drop-down__select-footer\">\n        <ng-container *ngTemplateOutlet=\"footerTemplate\"></ng-container>\n    </div>\n</div>\n",
                providers: [
                    { provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxSelectComponent_1, multi: true },
                    { provide: IGX_DROPDOWN_BASE, useExisting: IgxSelectComponent_1 }
                ],
                styles: ["\n        :host {\n            display: block;\n        }\n    "]
            }),
            __param(3, core.Optional()), __param(3, core.Inject(DisplayDensityToken))
        ], IgxSelectComponent);
        return IgxSelectComponent;
    }(IgxDropDownComponent));

    /** @hidden @internal */
    var IgxSelectItemNavigationDirective = /** @class */ (function (_super) {
        __extends(IgxSelectItemNavigationDirective, _super);
        function IgxSelectItemNavigationDirective() {
            var _this = _super.call(this, null) || this;
            // tslint:disable:member-ordering
            _this.inputStream = '';
            _this.clearStream$ = rxjs.Subscription.EMPTY;
            return _this;
        }
        /** Captures keydown events and calls the appropriate handlers on the target component */
        IgxSelectItemNavigationDirective.prototype.handleKeyDown = function (event) {
            if (!event || event.shiftKey) {
                return;
            }
            var key = event.key.toLowerCase();
            if (event.altKey && (key === 'arrowdown' || key === 'arrowup' || key === 'down' || key === 'up')) {
                this.target.toggle();
                return;
            }
            if (this.target.collapsed) {
                switch (key) {
                    case 'space':
                    case 'spacebar':
                    case ' ':
                    case 'enter':
                        event.preventDefault();
                        this.target.open();
                        return;
                    case 'arrowdown':
                    case 'down':
                        this.target.navigateNext();
                        this.target.selectItem(this.target.focusedItem);
                        event.preventDefault();
                        return;
                    case 'arrowup':
                    case 'up':
                        this.target.navigatePrev();
                        this.target.selectItem(this.target.focusedItem);
                        event.preventDefault();
                        return;
                    default:
                        break;
                }
            }
            _super.prototype.handleKeyDown.call(this, event);
        };
        /** Handle continuous letter typing navigation */
        IgxSelectItemNavigationDirective.prototype.captureKey = function (event) {
            var _this = this;
            // relying only on key, available on all major browsers:
            // https://caniuse.com/#feat=keyboardevent-key (IE/Edge quirk doesn't affect letter typing)
            if (!event || !event.key || event.key.length > 1) {
                // ignore longer keys ('Alt', 'ArrowDown', etc)
                return;
            }
            this.clearStream$.unsubscribe();
            this.clearStream$ = rxjs.timer(500).subscribe(function () {
                _this.inputStream = '';
            });
            this.inputStream += event.key;
            var focusedItem = this.target.focusedItem;
            // select the item
            if (focusedItem && this.inputStream.length > 1 && focusedItem.itemText.toLowerCase().startsWith(this.inputStream.toLowerCase())) {
                return;
            }
            this.activateItemByText(this.inputStream);
        };
        IgxSelectItemNavigationDirective.prototype.activateItemByText = function (text) {
            var items = this.target.items;
            var activeItemIndex = items.indexOf(this.target.focusedItem) || 0;
            // ^ this is focused OR selected if the dd is closed
            var nextItem = items.slice(activeItemIndex + 1).find(function (x) { return !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())); });
            if (!nextItem) {
                nextItem = items.slice(0, activeItemIndex).find(function (x) { return !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())); });
            }
            if (!nextItem) {
                return;
            }
            if (this.target.collapsed) {
                this.target.selectItem(nextItem);
            }
            this.target.navigateItem(items.indexOf(nextItem));
        };
        IgxSelectItemNavigationDirective.prototype.ngOnDestroy = function () {
            this.clearStream$.unsubscribe();
        };
        __decorate([
            core.Input('igxSelectItemNavigation')
        ], IgxSelectItemNavigationDirective.prototype, "target", void 0);
        __decorate([
            core.HostListener('keyup', ['$event'])
        ], IgxSelectItemNavigationDirective.prototype, "captureKey", null);
        IgxSelectItemNavigationDirective = __decorate([
            core.Directive({
                selector: '[igxSelectItemNavigation]'
            })
        ], IgxSelectItemNavigationDirective);
        return IgxSelectItemNavigationDirective;
    }(IgxDropDownItemNavigationDirective));

    /**
     * The `<igx-select-item>` is a container intended for row items in
     * a `<igx-select>` container.
     */
    var IgxSelectGroupComponent = /** @class */ (function (_super) {
        __extends(IgxSelectGroupComponent, _super);
        function IgxSelectGroupComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxSelectGroupComponent = __decorate([
            core.Component({
                selector: 'igx-select-item-group',
                template: "\n        <label id=\"{{labelId}}\">{{ label }}</label>\n        <ng-content select=\"igx-select-item\"></ng-content>\n    "
            })
        ], IgxSelectGroupComponent);
        return IgxSelectGroupComponent;
    }(IgxDropDownGroupComponent));

    /** @hidden */
    var IgxSelectModule = /** @class */ (function () {
        function IgxSelectModule() {
        }
        IgxSelectModule = __decorate([
            core.NgModule({
                declarations: [IgxSelectComponent, IgxSelectItemComponent, IgxSelectItemNavigationDirective,
                    IgxSelectToggleIconDirective, IgxSelectGroupComponent, IgxSelectHeaderDirective,
                    IgxSelectFooterDirective],
                exports: [IgxSelectComponent, IgxSelectItemComponent, IgxSelectItemNavigationDirective,
                    IgxSelectToggleIconDirective, IgxSelectGroupComponent, IgxSelectHeaderDirective,
                    IgxSelectFooterDirective],
                imports: [IgxRippleModule, common.CommonModule, IgxInputGroupModule, forms.FormsModule, forms.ReactiveFormsModule,
                    IgxToggleModule, IgxDropDownModule, IgxButtonModule, IgxIconModule],
                providers: []
            })
        ], IgxSelectModule);
        return IgxSelectModule;
    }());

    /**
    * @hidden
    */
    function WatchChanges() {
        return function (target, key, propDesc) {
            var privateKey = '_' + key.toString();
            propDesc = propDesc || {
                configurable: true,
                enumerable: true,
            };
            propDesc.get = propDesc.get || (function () { return this[privateKey]; });
            var originalSetter = propDesc.set || (function (val) { this[privateKey] = val; });
            propDesc.set = function (val) {
                var _a;
                var init = this._init;
                var oldValue = this[key];
                if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                    originalSetter.call(this, val);
                    if (this.ngOnChanges && !init) {
                        // in case wacthed prop changes trigger ngOnChanges manually
                        var changes = (_a = {},
                            _a[key] = new core.SimpleChange(oldValue, val, false),
                            _a);
                        this.ngOnChanges(changes);
                    }
                }
            };
            return propDesc;
        };
    }
    function WatchColumnChanges() {
        return function (target, key, propDesc) {
            var privateKey = '_' + key.toString();
            propDesc = propDesc || {
                configurable: true,
                enumerable: true,
            };
            propDesc.get = propDesc.get || (function () { return this[privateKey]; });
            var originalSetter = propDesc.set || (function (val) { this[privateKey] = val; });
            propDesc.set = function (val) {
                var init = this._init;
                var oldValue = this[key];
                originalSetter.call(this, val);
                if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                    if (this.rowIslandAPI.rowIsland) {
                        this.rowIslandAPI.rowIsland.updateColumnList();
                    }
                }
            };
            return propDesc;
        };
    }
    function notifyChanges(repaint) {
        if (repaint === void 0) { repaint = false; }
        return function (_, key, propDesc) {
            var privateKey = "__" + key;
            propDesc = propDesc || {
                enumerable: true,
                configurable: true
            };
            var originalSetter = propDesc ? propDesc.set : null;
            propDesc.get = propDesc.get || (function () { return this[privateKey]; });
            propDesc.set = function (newValue) {
                if (originalSetter) {
                    originalSetter.call(this, newValue);
                    if (this.grid) {
                        this.grid.notifyChanges(repaint);
                    }
                }
                else {
                    if (newValue === this[key]) {
                        return;
                    }
                    this[privateKey] = newValue;
                    if (this.grid) {
                        this.grid.notifyChanges(repaint);
                    }
                }
            };
            return propDesc;
        };
    }

    var IgxRowIslandAPIService = /** @class */ (function () {
        function IgxRowIslandAPIService() {
            this.change = new rxjs.Subject();
            this.state = new Map();
            this.destroyMap = new Map();
            this.childRowIslands = new Map();
            this.childGrids = new Map();
        }
        IgxRowIslandAPIService.prototype.register = function (rowIsland) {
            this.state.set(rowIsland.id, rowIsland);
            this.destroyMap.set(rowIsland.id, new rxjs.Subject());
        };
        IgxRowIslandAPIService.prototype.unsubscribe = function (rowIsland) {
            this.state.delete(rowIsland.id);
        };
        IgxRowIslandAPIService.prototype.get = function (id) {
            return this.state.get(id);
        };
        IgxRowIslandAPIService.prototype.unset = function (id) {
            this.state.delete(id);
            this.destroyMap.delete(id);
        };
        IgxRowIslandAPIService.prototype.reset = function (oldId, newId) {
            var destroy = this.destroyMap.get(oldId);
            var rowIsland = this.get(oldId);
            this.unset(oldId);
            if (rowIsland) {
                this.state.set(newId, rowIsland);
            }
            if (destroy) {
                this.destroyMap.set(newId, destroy);
            }
        };
        IgxRowIslandAPIService.prototype.registerChildRowIsland = function (rowIsland) {
            this.childRowIslands.set(rowIsland.key, rowIsland);
            this.destroyMap.set(rowIsland.key, new rxjs.Subject());
        };
        IgxRowIslandAPIService.prototype.unsetChildRowIsland = function (rowIsland) {
            this.childRowIslands.delete(rowIsland.key);
            this.destroyMap.delete(rowIsland.key);
        };
        IgxRowIslandAPIService.prototype.getChildRowIsland = function (rowIslandKey) {
            return this.childRowIslands.get(rowIslandKey);
        };
        IgxRowIslandAPIService.prototype.registerChildGrid = function (parentRowID, grid) {
            this.childGrids.set(parentRowID, grid);
        };
        IgxRowIslandAPIService.prototype.getChildGrids = function (inDepth) {
            var allChildren = [];
            this.childGrids.forEach(function (grid) {
                allChildren.push(grid);
            });
            if (inDepth) {
                this.childRowIslands.forEach(function (layout) {
                    allChildren = allChildren.concat(layout.rowIslandAPI.getChildGrids(inDepth));
                });
            }
            return allChildren;
        };
        IgxRowIslandAPIService.prototype.getChildGridByID = function (rowID) {
            return this.childGrids.get(rowID);
        };
        IgxRowIslandAPIService = __decorate([
            core.Injectable()
        ], IgxRowIslandAPIService);
        return IgxRowIslandAPIService;
    }());

    // TODO: Refactor - export in a separate file
    var IgxRow = /** @class */ (function () {
        function IgxRow(id, index, data) {
            this.id = id;
            this.index = index;
            this.data = data;
        }
        IgxRow.prototype.createEditEventArgs = function () {
            return {
                rowID: this.id,
                oldValue: __assign({}, this.data),
                newValue: this.newData,
                cancel: false
            };
        };
        return IgxRow;
    }());
    var IgxCell = /** @class */ (function () {
        function IgxCell(id, rowIndex, column, value, editValue, rowData) {
            this.id = id;
            this.rowIndex = rowIndex;
            this.column = column;
            this.value = value;
            this.editValue = editValue;
            this.rowData = rowData;
        }
        IgxCell.prototype.castToNumber = function (value) {
            if (this.column.dataType === 'number' && !this.column.inlineEditorTemplate) {
                var v = parseFloat(value);
                return !isNaN(v) && isFinite(v) ? v : 0;
            }
            return value;
        };
        IgxCell.prototype.createEditEventArgs = function () {
            return {
                rowID: this.id.rowID,
                cellID: this.id,
                oldValue: this.value,
                newValue: this.editValue,
                cancel: false
            };
        };
        return IgxCell;
    }());
    var IgxGridCRUDService = /** @class */ (function () {
        function IgxGridCRUDService() {
            this.cell = null;
            this.row = null;
        }
        IgxGridCRUDService.prototype.createCell = function (cell) {
            return new IgxCell(cell.cellID, cell.rowIndex, cell.column, cell.value, cell.value, cell.row.rowData);
        };
        IgxGridCRUDService.prototype.createRow = function (cell) {
            return new IgxRow(cell.id.rowID, cell.rowIndex, cell.rowData);
        };
        IgxGridCRUDService.prototype.sameRow = function (rowID) {
            return this.row && this.row.id === rowID;
        };
        IgxGridCRUDService.prototype.sameCell = function (cell) {
            return (this.cell.id.rowID === cell.id.rowID &&
                this.cell.id.columnID === cell.id.columnID);
        };
        Object.defineProperty(IgxGridCRUDService.prototype, "inEditMode", {
            get: function () {
                return !!this.cell;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCRUDService.prototype, "rowEditing", {
            get: function () {
                return this.grid.rowEditable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCRUDService.prototype, "primaryKey", {
            get: function () {
                return this.grid.primaryKey;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridCRUDService.prototype.beginRowEdit = function () {
            if (this.grid.rowEditable && (this.grid.primaryKey === undefined || this.grid.primaryKey === null)) {
                console.warn('The grid must have a `primaryKey` specified when using `rowEditable`!');
            }
            this.row = this.createRow(this.cell);
            var args = {
                rowID: this.row.id,
                oldValue: this.row.data,
                cancel: false
            };
            this.grid.onRowEditEnter.emit(args);
            if (args.cancel) {
                this.endRowEdit();
                return;
            }
            this.row.transactionState = this.grid.transactions.getAggregatedValue(this.row.id, true);
            this.grid.transactions.startPending();
            this.grid.openRowOverlay(this.row.id);
        };
        IgxGridCRUDService.prototype.endRowEdit = function () {
            this.row = null;
        };
        IgxGridCRUDService.prototype.begin = function (cell) {
            var newCell = this.createCell(cell);
            newCell.primaryKey = this.primaryKey;
            var args = {
                cellID: newCell.id,
                rowID: newCell.id.rowID,
                oldValue: newCell.value,
                cancel: false
            };
            this.grid.onCellEditEnter.emit(args);
            if (args.cancel) {
                this.end();
                return;
            }
            if (this.rowEditing) {
                if (this.row && !this.sameRow(newCell.id.rowID)) {
                    this.grid.endEdit(true);
                    this.cell = newCell;
                    this.beginRowEdit();
                    return;
                }
                this.cell = newCell;
                if (!this.row) {
                    this.beginRowEdit();
                    return;
                }
            }
            else {
                this.cell = newCell;
                this.endRowEdit();
            }
        };
        IgxGridCRUDService.prototype.end = function () {
            this.cell = null;
        };
        IgxGridCRUDService.prototype.isInEditMode = function (rowIndex, columnIndex) {
            if (!this.cell) {
                return false;
            }
            return this.cell.column.index === columnIndex && this.cell.rowIndex === rowIndex;
        };
        IgxGridCRUDService = __decorate([
            core.Injectable()
        ], IgxGridCRUDService);
        return IgxGridCRUDService;
    }());
    var IgxGridSelectionService = /** @class */ (function () {
        function IgxGridSelectionService(zone) {
            this.zone = zone;
            this.dragMode = false;
            this.keyboardState = {};
            this.pointerState = {};
            this.selection = new Map();
            this.temp = new Map();
            this._ranges = new Set();
            this.rowSelection = new Set();
            this.initPointerState();
            this.initKeyboardState();
        }
        Object.defineProperty(IgxGridSelectionService.prototype, "ranges", {
            /**
             * Returns the current selected ranges in the grid from both
             * keyboard and pointer interactions
             */
            get: function () {
                // The last action was keyboard + shift selection -> add it
                this.addKeyboardRange();
                var ranges = Array.from(this._ranges).map(function (range) { return JSON.parse(range); });
                // No ranges but we have a focused cell -> add it
                if (!ranges.length && this.activeElement && this.grid.isCellSelectable) {
                    ranges.push(this.generateRange(this.activeElement));
                }
                return ranges;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridSelectionService.prototype, "primaryButton", {
            get: function () {
                return this.pointerState.primaryButton;
            },
            set: function (value) {
                this.pointerState.primaryButton = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Resets the keyboard state
         */
        IgxGridSelectionService.prototype.initKeyboardState = function () {
            this.keyboardState.node = null;
            this.keyboardState.shift = false;
            this.keyboardState.range = null;
            this.keyboardState.active = false;
        };
        /**
         * Resets the pointer state
         */
        IgxGridSelectionService.prototype.initPointerState = function () {
            this.pointerState.node = null;
            this.pointerState.ctrl = false;
            this.pointerState.shift = false;
            this.pointerState.range = null;
            this.pointerState.primaryButton = true;
        };
        /**
         * Adds a single node.
         * Single clicks | Ctrl + single clicks on cells is the usual case.
         */
        IgxGridSelectionService.prototype.add = function (node, addToRange) {
            if (addToRange === void 0) { addToRange = true; }
            this.selection.has(node.row) ? this.selection.get(node.row).add(node.column) :
                this.selection.set(node.row, new Set()).get(node.row).add(node.column);
            if (addToRange) {
                this._ranges.add(JSON.stringify(this.generateRange(node)));
            }
        };
        /**
         * Adds the active keyboard range selection (if any) to the `ranges` meta.
         */
        IgxGridSelectionService.prototype.addKeyboardRange = function () {
            if (this.keyboardState.range) {
                this._ranges.add(JSON.stringify(this.keyboardState.range));
            }
        };
        IgxGridSelectionService.prototype.remove = function (node) {
            if (this.selection.has(node.row)) {
                this.selection.get(node.row).delete(node.column);
            }
            if (this.isActiveNode(node)) {
                this.activeElement = null;
            }
            this._ranges.delete(JSON.stringify(this.generateRange(node)));
        };
        IgxGridSelectionService.prototype.isInMap = function (node) {
            return (this.selection.has(node.row) && this.selection.get(node.row).has(node.column)) ||
                (this.temp.has(node.row) && this.temp.get(node.row).has(node.column));
        };
        IgxGridSelectionService.prototype.selected = function (node) {
            return (this.isActiveNode(node) && this.grid.isCellSelectable) || this.isInMap(node);
        };
        IgxGridSelectionService.prototype.isActiveNode = function (node) {
            if (this.activeElement) {
                var isActive = this.activeElement.column === node.column && this.activeElement.row === node.row;
                if (this.grid.hasColumnLayouts) {
                    var layout = this.activeElement.layout;
                    return isActive && this.isActiveLayout(layout, node.layout);
                }
                return isActive;
            }
            return false;
        };
        IgxGridSelectionService.prototype.isActiveLayout = function (current, target) {
            return current.columnVisibleIndex === target.columnVisibleIndex;
        };
        IgxGridSelectionService.prototype.addRangeMeta = function (node, state) {
            this._ranges.add(JSON.stringify(this.generateRange(node, state)));
        };
        IgxGridSelectionService.prototype.removeRangeMeta = function (node, state) {
            this._ranges.delete(JSON.stringify(this.generateRange(node, state)));
        };
        /**
         * Generates a new selection range from the given `node`.
         * If `state` is passed instead it will generate the range based on the passed `node`
         * and the start node of the `state`.
         */
        IgxGridSelectionService.prototype.generateRange = function (node, state) {
            if (!state) {
                return {
                    rowStart: node.row,
                    rowEnd: node.row,
                    columnStart: node.column,
                    columnEnd: node.column
                };
            }
            var _a = state.node, row = _a.row, column = _a.column;
            var rowStart = Math.min(node.row, row);
            var rowEnd = Math.max(node.row, row);
            var columnStart = Math.min(node.column, column);
            var columnEnd = Math.max(node.column, column);
            return { rowStart: rowStart, rowEnd: rowEnd, columnStart: columnStart, columnEnd: columnEnd };
        };
        /**
         *
         */
        IgxGridSelectionService.prototype.keyboardStateOnKeydown = function (node, shift, shiftTab) {
            this.keyboardState.active = true;
            this.initPointerState();
            this.keyboardState.shift = shift && !shiftTab;
            // Kb navigation with shift and no previous node.
            // Clear the current selection init the start node.
            if (this.keyboardState.shift && !this.keyboardState.node) {
                this.clear();
                this.keyboardState.node = node;
            }
        };
        IgxGridSelectionService.prototype.keyboardStateOnFocus = function (node, emitter, dom) {
            var kbState = this.keyboardState;
            // Focus triggered by keyboard navigation
            if (kbState.active) {
                if (isChromium()) {
                    this._moveSelectionChrome(dom);
                }
                // Start generating a range if shift is hold
                if (kbState.shift) {
                    this.dragSelect(node, kbState);
                    kbState.range = this.generateRange(node, kbState);
                    emitter.emit(this.generateRange(node, kbState));
                    return;
                }
                this.initKeyboardState();
                this.clear();
                this.add(node);
            }
        };
        IgxGridSelectionService.prototype.pointerDown = function (node, shift, ctrl) {
            this.addKeyboardRange();
            this.initKeyboardState();
            this.pointerState.ctrl = ctrl;
            this.pointerState.shift = shift;
            // No ctrl key pressed - no multiple selection
            if (!ctrl) {
                this.clear();
            }
            if (shift) {
                // No previously 'clicked' node. Use the last active node.
                if (!this.pointerState.node) {
                    this.pointerState.node = this.activeElement || node;
                }
                this.pointerDownShiftKey(node);
                this.clearTextSelection();
                return;
            }
            this.removeRangeMeta(node);
            this.pointerState.node = node;
        };
        IgxGridSelectionService.prototype.pointerDownShiftKey = function (node) {
            this.clear();
            this.selectRange(node, this.pointerState);
        };
        IgxGridSelectionService.prototype.mergeMap = function (target, source) {
            var iterator = source.entries();
            var pair = iterator.next();
            var key;
            var value;
            var _loop_1 = function () {
                var _a;
                _a = __read(pair.value, 2), key = _a[0], value = _a[1];
                if (target.has(key)) {
                    var newValue_1 = target.get(key);
                    value.forEach(function (record) { return newValue_1.add(record); });
                    target.set(key, newValue_1);
                }
                else {
                    target.set(key, value);
                }
                pair = iterator.next();
            };
            while (!pair.done) {
                _loop_1();
            }
        };
        IgxGridSelectionService.prototype.pointerEnter = function (node, event) {
            // https://www.w3.org/TR/pointerevents/#the-button-property
            this.dragMode = event.buttons === 1 && event.button === -1;
            if (!this.dragMode) {
                return false;
            }
            this.clearTextSelection();
            // If the users triggers a drag-like event by first clicking outside the grid cells
            // and then enters in the grid body we may not have a initial pointer starting node.
            // Assume the first pointerenter node is where we start.
            if (!this.pointerState.node) {
                this.pointerState.node = node;
            }
            this.pointerState.ctrl ? this.selectRange(node, this.pointerState, this.temp) :
                this.dragSelect(node, this.pointerState);
            return true;
        };
        IgxGridSelectionService.prototype.pointerUp = function (node, emitter) {
            var _this = this;
            if (this.dragMode) {
                this.restoreTextSelection();
                this.addRangeMeta(node, this.pointerState);
                this.mergeMap(this.selection, this.temp);
                this.zone.runTask(function () { return emitter.emit(_this.generateRange(node, _this.pointerState)); });
                this.temp.clear();
                this.dragMode = false;
                return true;
            }
            if (this.pointerState.shift) {
                this.clearTextSelection();
                this.restoreTextSelection();
                this.addRangeMeta(node, this.pointerState);
                emitter.emit(this.generateRange(node, this.pointerState));
                return true;
            }
            this.add(node);
            return false;
        };
        IgxGridSelectionService.prototype.selectRange = function (node, state, collection) {
            if (collection === void 0) { collection = this.selection; }
            if (collection === this.temp) {
                collection.clear();
            }
            var _a = this.generateRange(node, state), rowStart = _a.rowStart, rowEnd = _a.rowEnd, columnStart = _a.columnStart, columnEnd = _a.columnEnd;
            for (var i = rowStart; i <= rowEnd; i++) {
                for (var j = columnStart; j <= columnEnd; j++) {
                    collection.has(i) ? collection.get(i).add(j) :
                        collection.set(i, new Set()).get(i).add(j);
                }
            }
        };
        IgxGridSelectionService.prototype.dragSelect = function (node, state) {
            if (!this.pointerState.ctrl) {
                this.selection.clear();
            }
            this.selectRange(node, state);
        };
        IgxGridSelectionService.prototype.clear = function (clearAcriveEl) {
            if (clearAcriveEl === void 0) { clearAcriveEl = false; }
            if (clearAcriveEl) {
                this.activeElement = null;
            }
            this.selection.clear();
            this.temp.clear();
            this._ranges.clear();
        };
        IgxGridSelectionService.prototype.clearTextSelection = function () {
            var selection = window.getSelection();
            if (selection.rangeCount) {
                this._selectionRange = selection.getRangeAt(0);
                this._selectionRange.collapse(true);
                selection.removeAllRanges();
            }
        };
        IgxGridSelectionService.prototype.restoreTextSelection = function () {
            var selection = window.getSelection();
            if (!selection.rangeCount) {
                selection.addRange(this._selectionRange || document.createRange());
            }
        };
        /**
         * (╯°□°）╯︵ ┻━┻
         * Chrome and Chromium don't care about the active
         * range after keyboard navigation, thus this.
         */
        IgxGridSelectionService.prototype._moveSelectionChrome = function (node) {
            var selection = window.getSelection();
            selection.removeAllRanges();
            var range = new Range();
            range.selectNode(node);
            range.collapse(true);
            selection.addRange(range);
        };
        /** Returns array of the selected row id's. */
        IgxGridSelectionService.prototype.getSelectedRows = function () {
            return this.rowSelection.size ? Array.from(this.rowSelection.keys()) : [];
        };
        /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */
        IgxGridSelectionService.prototype.clearRowSelection = function (event) {
            var _this = this;
            var removedRec = this.isFilteringApplied() ?
                this.getRowIDs(this.allData).filter(function (rID) { return _this.isRowSelected(rID); }) : this.getSelectedRows();
            var newSelection = this.isFilteringApplied() ? this.getSelectedRows().filter(function (x) { return !removedRec.includes(x); }) : [];
            this.emitRowSelectionEvent(newSelection, [], removedRec, event);
        };
        /** Select all rows, if filtering is applied select only from filtered data. */
        IgxGridSelectionService.prototype.selectAllRows = function (event) {
            var _this = this;
            var allRowIDs = this.getRowIDs(this.allData);
            var addedRows = allRowIDs.filter(function (rID) { return !_this.isRowSelected(rID); });
            var newSelection = this.rowSelection.size ? this.getSelectedRows().concat(addedRows) : addedRows;
            this.emitRowSelectionEvent(newSelection, addedRows, [], event);
        };
        /** Select the specified row and emit event. */
        IgxGridSelectionService.prototype.selectRowById = function (rowID, clearPrevSelection, event) {
            if (!this.grid.isRowSelectable || this.isRowDeleted(rowID)) {
                return;
            }
            clearPrevSelection = !this.grid.isMultiRowSelectionEnabled || clearPrevSelection;
            var newSelection = clearPrevSelection ? [rowID] : this.getSelectedRows().indexOf(rowID) !== -1 ?
                this.getSelectedRows() : __spread(this.getSelectedRows(), [rowID]);
            var removed = clearPrevSelection ? this.getSelectedRows() : [];
            this.emitRowSelectionEvent(newSelection, [rowID], removed, event);
        };
        /** Deselect the specified row and emit event. */
        IgxGridSelectionService.prototype.deselectRow = function (rowID, event) {
            if (!this.isRowSelected(rowID)) {
                return;
            }
            var newSelection = this.getSelectedRows().filter(function (r) { return r !== rowID; });
            if (this.rowSelection.size && this.rowSelection.has(rowID)) {
                this.emitRowSelectionEvent(newSelection, [], [rowID], event);
            }
        };
        /** Select specified rows. No event is emitted. */
        IgxGridSelectionService.prototype.selectRowsWithNoEvent = function (rowIDs, clearPrevSelection) {
            var _this = this;
            if (clearPrevSelection) {
                this.rowSelection.clear();
            }
            rowIDs.forEach(function (rowID) { _this.rowSelection.add(rowID); });
            this.allRowsSelected = undefined;
        };
        /** Deselect specified rows. No event is emitted. */
        IgxGridSelectionService.prototype.deselectRowsWithNoEvent = function (rowIDs) {
            var _this = this;
            rowIDs.forEach(function (rowID) { return _this.rowSelection.delete(rowID); });
            this.allRowsSelected = undefined;
        };
        IgxGridSelectionService.prototype.isRowSelected = function (rowID) {
            return this.rowSelection.size > 0 && this.rowSelection.has(rowID);
        };
        /** Select range from last selected row to the current specified row.*/
        IgxGridSelectionService.prototype.selectMultipleRows = function (rowID, rowData, event) {
            var _this = this;
            this.allRowsSelected = undefined;
            if (!this.rowSelection.size || this.isRowDeleted(rowID)) {
                this.selectRowById(rowID);
                return;
            }
            var gridData = this.allData;
            var lastRowID = this.getSelectedRows()[this.rowSelection.size - 1];
            var currIndex = gridData.indexOf(this.getRowDataById(lastRowID));
            var newIndex = gridData.indexOf(rowData);
            var rows = gridData.slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1);
            var added = this.getRowIDs(rows).filter(function (rID) { return !_this.isRowSelected(rID); });
            var newSelection = this.getSelectedRows().concat(added);
            this.emitRowSelectionEvent(newSelection, added, [], event);
        };
        IgxGridSelectionService.prototype.areAllRowSelected = function () {
            if (!this.grid.data) {
                return false;
            }
            if (this.allRowsSelected !== undefined) {
                return this.allRowsSelected;
            }
            var dataItemsID = this.getRowIDs(this.allData);
            return this.allRowsSelected = Math.min(this.rowSelection.size, dataItemsID.length) > 0 &&
                new Set(Array.from(this.rowSelection.values()).concat(dataItemsID)).size === this.rowSelection.size;
        };
        IgxGridSelectionService.prototype.hasSomeRowSelected = function () {
            var _this = this;
            var filteredData = this.isFilteringApplied() ?
                this.getRowIDs(this.grid.filteredData).some(function (rID) { return _this.isRowSelected(rID); }) : true;
            return this.rowSelection.size > 0 && filteredData && !this.areAllRowSelected();
        };
        Object.defineProperty(IgxGridSelectionService.prototype, "filteredSelectedRowIds", {
            get: function () {
                var _this = this;
                return this.isFilteringApplied() ?
                    this.getRowIDs(this.allData).filter(function (rowID) { return _this.isRowSelected(rowID); }) :
                    this.getSelectedRows().filter(function (rowID) { return !_this.isRowDeleted(rowID); });
            },
            enumerable: true,
            configurable: true
        });
        IgxGridSelectionService.prototype.emitRowSelectionEvent = function (newSelection, added, removed, event) {
            var currSelection = this.getSelectedRows();
            if (this.areEqualCollections(currSelection, newSelection)) {
                return;
            }
            var args = {
                oldSelection: currSelection, newSelection: newSelection,
                added: added, removed: removed, event: event, cancel: false
            };
            this.grid.onRowSelectionChange.emit(args);
            if (args.cancel) {
                return;
            }
            this.selectRowsWithNoEvent(args.newSelection, true);
        };
        IgxGridSelectionService.prototype.getRowDataById = function (rowID) {
            if (!this.grid.primaryKey) {
                return rowID;
            }
            var rowIndex = this.getRowIDs(this.grid.gridAPI.get_all_data(true)).indexOf(rowID);
            return rowIndex < 0 ? {} : this.grid.gridAPI.get_all_data(true)[rowIndex];
        };
        IgxGridSelectionService.prototype.getRowIDs = function (data) {
            var _this = this;
            return this.grid.primaryKey && data.length ? data.map(function (rec) { return rec[_this.grid.primaryKey]; }) : data;
        };
        IgxGridSelectionService.prototype.clearHeaderCBState = function () {
            this.allRowsSelected = undefined;
        };
        /**Clear rowSelection and update checkbox state*/
        IgxGridSelectionService.prototype.clearAllSelectedRows = function () {
            this.rowSelection.clear();
            this.clearHeaderCBState();
        };
        Object.defineProperty(IgxGridSelectionService.prototype, "allData", {
            /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */
            get: function () {
                var _this = this;
                var allData = this.isFilteringApplied() || this.grid.sortingExpressions.length ?
                    this.grid.filteredSortedData : this.grid.gridAPI.get_all_data(true);
                return allData.filter(function (rData) { return !_this.isRowDeleted(_this.grid.gridAPI.get_row_id(rData)); });
            },
            enumerable: true,
            configurable: true
        });
        IgxGridSelectionService.prototype.areEqualCollections = function (first, second) {
            return first.length === second.length && new Set(first.concat(second)).size === first.length;
        };
        IgxGridSelectionService.prototype.isFilteringApplied = function () {
            var grid = this.grid;
            return !FilteringExpressionsTree.empty(grid.filteringExpressionsTree) ||
                !FilteringExpressionsTree.empty(grid.advancedFilteringExpressionsTree);
        };
        IgxGridSelectionService.prototype.isRowDeleted = function (rowID) {
            return this.grid.gridAPI.row_deleted_transaction(rowID);
        };
        IgxGridSelectionService.ctorParameters = function () { return [
            { type: core.NgZone }
        ]; };
        IgxGridSelectionService = __decorate([
            core.Injectable()
        ], IgxGridSelectionService);
        return IgxGridSelectionService;
    }());
    function isChromium() {
        return (/Chrom|e?ium/g.test(navigator.userAgent) || /Google Inc/g.test(navigator.vendor)) && !/Edge/g.test(navigator.userAgent);
    }

    var EVENT_SUFFIX = 'precise';
    /**
     * Touch gestures manager based on Hammer.js
     * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
     * @hidden
     */
    var HammerGesturesManager = /** @class */ (function () {
        function HammerGesturesManager(_zone, doc, platformUtil) {
            this._zone = _zone;
            this.doc = doc;
            this.platformUtil = platformUtil;
            /**
             * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
             */
            this.hammerOptions = {};
            this._hammerManagers = [];
            this.platformBrowser = this.platformUtil.isBrowser;
            if (this.platformBrowser) {
                this.hammerOptions = {
                    // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)
                    // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803
                    inputClass: Hammer.TouchInput,
                    recognizers: [
                        [Hammer.Pan, { threshold: 0 }],
                        [Hammer.Swipe, {
                                direction: Hammer.DIRECTION_HORIZONTAL
                            }],
                        [Hammer.Tap],
                        [Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]
                    ]
                };
            }
        }
        HammerGesturesManager.prototype.supports = function (eventName) {
            return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);
        };
        /**
         * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
         * Modeling after other event plugins for easy future modifications.
         */
        HammerGesturesManager.prototype.addEventListener = function (element, eventName, eventHandler, options) {
            var _this = this;
            if (options === void 0) { options = null; }
            if (!this.platformBrowser) {
                return;
            }
            // Creating the manager bind events, must be done outside of angular
            return this._zone.runOutsideAngular(function () {
                var mc = _this.getManagerForElement(element);
                if (mc === null) {
                    // new Hammer is a shortcut for Manager with defaults
                    mc = new Hammer(element, Object.assign(_this.hammerOptions, options));
                    _this.addManagerForElement(element, mc);
                }
                var handler = function (eventObj) { _this._zone.run(function () { eventHandler(eventObj); }); };
                mc.on(eventName, handler);
                return function () { mc.off(eventName, handler); };
            });
        };
        /**
         * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
         * Modeling after other event plugins for easy future modifications.
         *
         * @param target Can be one of either window, body or document(fallback default).
         */
        HammerGesturesManager.prototype.addGlobalEventListener = function (target, eventName, eventHandler) {
            if (!this.platformBrowser) {
                return;
            }
            var element = this.getGlobalEventTarget(target);
            // Creating the manager bind events, must be done outside of angular
            return this.addEventListener(element, eventName, eventHandler);
        };
        /**
         * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
         * Supported: window, document, body. Defaults to document for invalid args.
         * @param target Target name
         */
        HammerGesturesManager.prototype.getGlobalEventTarget = function (target) {
            return platformBrowser["ɵgetDOM"]().getGlobalEventTarget(this.doc, target);
        };
        /**
         * Set HammerManager options.
         *
         * @param element The DOM element used to create the manager on.
         *
         * ### Example
         *
         * ```ts
         * manager.setManagerOption(myElem, "pan", { pointers: 1 });
         * ```
         */
        HammerGesturesManager.prototype.setManagerOption = function (element, event, options) {
            var manager = this.getManagerForElement(element);
            manager.get(event).set(options);
        };
        /**
         * Add an element and manager map to the internal collection.
         *
         * @param element The DOM element used to create the manager on.
         */
        HammerGesturesManager.prototype.addManagerForElement = function (element, manager) {
            this._hammerManagers.push({ element: element, manager: manager });
        };
        /**
         * Get HammerManager for the element or null
         *
         * @param element The DOM element used to create the manager on.
         */
        HammerGesturesManager.prototype.getManagerForElement = function (element) {
            var result = this._hammerManagers.filter(function (value, index, array) {
                return value.element === element;
            });
            return result.length ? result[0].manager : null;
        };
        /**
         * Destroys the HammerManager for the element, removing event listeners in the process.
         *
         * @param element The DOM element used to create the manager on.
         */
        HammerGesturesManager.prototype.removeManagerForElement = function (element) {
            var index = null;
            for (var i = 0; i < this._hammerManagers.length; i++) {
                if (element === this._hammerManagers[i].element) {
                    index = i;
                    break;
                }
            }
            if (index !== null) {
                var item = this._hammerManagers.splice(index, 1)[0];
                // destroy also
                item.manager.destroy();
            }
        };
        /** Destroys all internally tracked HammerManagers, removing event listeners in the process. */
        HammerGesturesManager.prototype.destroy = function () {
            var e_1, _a;
            try {
                for (var _b = __values(this._hammerManagers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    item.manager.destroy();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this._hammerManagers = [];
        };
        HammerGesturesManager.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: PlatformUtil }
        ]; };
        HammerGesturesManager = __decorate([
            core.Injectable(),
            __param(1, core.Inject(common.DOCUMENT))
        ], HammerGesturesManager);
        return HammerGesturesManager;
    }());


    (function (FilterMode) {
        FilterMode["quickFilter"] = "quickFilter";
        FilterMode["excelStyleFilter"] = "excelStyleFilter";
    })(exports.FilterMode || (exports.FilterMode = {}));

    (function (GridSummaryPosition) {
        GridSummaryPosition["top"] = "top";
        GridSummaryPosition["bottom"] = "bottom";
    })(exports.GridSummaryPosition || (exports.GridSummaryPosition = {}));

    (function (GridSummaryCalculationMode) {
        GridSummaryCalculationMode["rootLevelOnly"] = "rootLevelOnly";
        GridSummaryCalculationMode["childLevelsOnly"] = "childLevelsOnly";
        GridSummaryCalculationMode["rootAndChildLevels"] = "rootAndChildLevels";
    })(exports.GridSummaryCalculationMode || (exports.GridSummaryCalculationMode = {}));

    (function (GridKeydownTargetType) {
        GridKeydownTargetType["dataCell"] = "dataCell";
        GridKeydownTargetType["summaryCell"] = "summaryCell";
        GridKeydownTargetType["groupRow"] = "groupRow";
        GridKeydownTargetType["hierarchicalRow"] = "hierarchicalRow";
    })(exports.GridKeydownTargetType || (exports.GridKeydownTargetType = {}));

    (function (GridSelectionMode) {
        GridSelectionMode["none"] = "none";
        GridSelectionMode["single"] = "single";
        GridSelectionMode["multiple"] = "multiple";
    })(exports.GridSelectionMode || (exports.GridSelectionMode = {}));

    (function (ColumnDisplayOrder) {
        ColumnDisplayOrder["Alphabetical"] = "Alphabetical";
        ColumnDisplayOrder["DisplayOrder"] = "DisplayOrder";
    })(exports.ColumnDisplayOrder || (exports.ColumnDisplayOrder = {}));

    /**
     * Providing reference to `IgxGridCellComponent`:
     * ```typescript
     * @ViewChild('grid', { read: IgxGridComponent })
     *  public grid: IgxGridComponent;
     * ```
     * ```typescript
     *  let column = this.grid.columnList.first;
     * ```
     * ```typescript
     *  let cell = column.cells[0];
     * ```
     */
    var IgxGridCellComponent = /** @class */ (function () {
        function IgxGridCellComponent(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil) {
            var _this = this;
            this.selectionService = selectionService;
            this.crudService = crudService;
            this.gridAPI = gridAPI;
            this.cdr = cdr;
            this.element = element;
            this.zone = zone;
            this.touchManager = touchManager;
            this.platformUtil = platformUtil;
            this._vIndex = -1;
            /**
             * Sets/gets the highlight class of the cell.
             * Default value is `"igx-highlight"`.
             * ```typescript
             * let highlightClass = this.cell.highlightClass;
             * ```
             * ```typescript
             * this.cell.highlightClass = 'igx-cell-highlight';
             * ```
             * @memberof IgxGridCellComponent
             */
            this.highlightClass = 'igx-highlight';
            /**
             * Sets/gets the active highlight class class of the cell.
             * Default value is `"igx-highlight__active"`.
             * ```typescript
             * let activeHighlightClass = this.cell.activeHighlightClass;
             * ```
             * ```typescript
             * this.cell.activeHighlightClass = 'igx-cell-highlight_active';
             * ```
             * @memberof IgxGridCellComponent
             */
            this.activeHighlightClass = 'igx-highlight__active';
            /**
             * @hidden
             * @internal
             */
            this.lastPinned = false;
            /**
             * Returns whether the cell is in edit mode.
             */
            this.editMode = false;
            /**
             * Sets/get the `tabindex` property of the cell.
             * Default value is `0`.
             * ```typescript
             * this.cell.tabindex = 1;
             * ```
             * ```typescript
             * let cellTabIndex = this.cell.tabindex;
             * ```
             * @memberof IgxGridCellComponent
             */
            this.tabindex = 0;
            /**
             * Sets/get the `role` property of the cell.
             * Default value is `"gridcell"`.
             * ```typescript
             * this.cell.role = 'grid-cell';
             * ```
             * ```typescript
             * let cellRole = this.cell.role;
             * ```
             * @memberof IgxGridCellComponent
             */
            this.role = 'gridcell';
            /**
             * Gets the width of the cell.
             * ```typescript
             * let cellWidth = this.cell.width;
             * ```
             * @memberof IgxGridCellComponent
             */
            this.width = '';
            /**
             * @hidden
             * @internal
             */
            this.focused = false;
            this.isInCompositionMode = false;
            this._cellSelection = exports.GridSelectionMode.multiple;
            /**
             *
             * @hidden
             * @internal
             */
            this.pointerdown = function (event) {
                if (!isLeftClick(event)) {
                    _this.selectionService.addKeyboardRange();
                    _this.selectionService.initKeyboardState();
                    _this.selectionService.primaryButton = false;
                    return;
                }
                _this.selectionService.pointerDown(_this.selectionNode, event.shiftKey, event.ctrlKey);
            };
            /**
             *
             * @hidden
             * @internal
             */
            this.pointerenter = function (event) {
                var dragMode = _this.selectionService.pointerEnter(_this.selectionNode, event);
                if (dragMode) {
                    _this.grid.cdr.detectChanges();
                }
            };
            /**
             * @hidden
             * @internal
             */
            this.pointerup = function (event) {
                if (_this.grid.hasColumnLayouts) {
                    _this.grid.navigation.setStartNavigationCell(_this.colStart, _this.rowStart, null);
                }
                if (!isLeftClick(event)) {
                    return;
                }
                if (_this.selectionService.pointerUp(_this.selectionNode, _this.grid.onRangeSelection)) {
                    _this.grid.cdr.detectChanges();
                }
                _this._updateCRUDStatus();
            };
            /**
             * @hidden
             * @internal
             */
            this.onDoubleClick = function (event) {
                if (event.type === 'doubletap') {
                    // prevent double-tap to zoom on iOS
                    event.preventDefault();
                }
                if (_this.editable && !_this.editMode && !_this.row.deleted) {
                    _this.crudService.begin(_this);
                }
                _this.grid.onDoubleClick.emit({
                    cell: _this,
                    event: event
                });
            };
        }
        Object.defineProperty(IgxGridCellComponent.prototype, "context", {
            /**
             * Gets the cell template context object.
             * ```typescript
             *  let context = this.cell.context();
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return {
                    $implicit: this.value,
                    cell: this
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "template", {
            /**
             * Gets the cell template.
             * ```typescript
             * let template = this.cell.template;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                if (this.editMode) {
                    var inlineEditorTemplate = this.column.inlineEditorTemplate;
                    return inlineEditorTemplate ? inlineEditorTemplate : this.inlineEditorTemplate;
                }
                if (this.cellTemplate) {
                    return this.cellTemplate;
                }
                return this.defaultCellTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "gridID", {
            /**
             * Gets the `id` of the grid in which the cell is stored.
             * ```typescript
             * let gridId = this.cell.gridID;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.row.gridID;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "grid", {
            /**
             * Gets the grid of the cell.
             * ```typescript
             * let grid = this.cell.grid;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "rowIndex", {
            /**
             * Gets the `index` of the row where the cell is stored.
             * ```typescript
             * let rowIndex = this.cell.rowIndex;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.row.index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "columnIndex", {
            /**
             * Gets the `index` of the cell column.
             * ```typescript
             * let columnIndex = this.cell.columnIndex;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.column.index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "visibleColumnIndex", {
            /**
             * Gets the visible `index` of the in which the cell is stored.
             * ```typescript
             * let visibleColumnIndex = this.cell.visibleColumnIndex;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.column.columnLayoutChild ? this.column.visibleIndex : this._vIndex;
            },
            set: function (val) {
                this._vIndex = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "cellID", {
            /**
             * Gets the ID of the cell.
             * ```typescript
             * let cellID = this.cell.cellID;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                var primaryKey = this.grid.primaryKey;
                var rowID = primaryKey ? this.rowData[primaryKey] : this.rowData;
                return { rowID: rowID, columnID: this.columnIndex, rowIndex: this.rowIndex };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "nativeElement", {
            /**
             * Returns a reference to the nativeElement of the cell.
             * ```typescript
             * let cellNativeElement = this.cell.nativeElement;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "inEditMode", {
            /**
             * @deprecated
             * Use `cell.editMode` as a getter and
             * `cell.setEditMode(true | false)` to start/exit edit mode.
             *
             * Gets/sets whether the cell is in edit mode.
             * ```typescript
             * let isCellInEditMode = this.cell.inEditMode;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.editMode;
            },
            set: function (value) {
                this.setEditMode(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "cellSelectionMode", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this._cellSelection;
            },
            set: function (value) {
                var _this = this;
                if (this._cellSelection === value) {
                    return;
                }
                this.zone.runOutsideAngular(function () {
                    value === exports.GridSelectionMode.multiple ?
                        _this.addPointerListeners(value) : _this.removePointerListeners(_this._cellSelection);
                });
                this._cellSelection = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "lastSearchInfo", {
            /**
             * @hidden
             * @internal
             */
            set: function (value) {
                this._lastSearchInfo = value;
                this.highlightText(this._lastSearchInfo.searchText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "readonly", {
            /**
             * Gets whether the cell is editable.
             * ```typescript
             * let isCellReadonly = this.cell.readonly;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return !this.column.editable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "gridRowSpan", {
            get: function () {
                return this.column.gridRowSpan;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "gridColumnSpan", {
            get: function () {
                return this.column.gridColumnSpan;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "rowEnd", {
            get: function () {
                return this.column.rowEnd;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "colEnd", {
            get: function () {
                return this.column.colEnd;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "rowStart", {
            get: function () {
                return this.column.rowStart;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "colStart", {
            get: function () {
                return this.column.colStart;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "describedby", {
            /**
             * Returns a string containing the grid `id` and the column `field` concatenated by "_".
             * ```typescript
             * let describedBy = this.cell.describedBy;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.row.gridID + "_" + this.column.field;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "selected", {
            /**
             * Gets whether the cell is selected.
             * ```typescript
             * let isSelected = this.cell.selected;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                return this.selectionService.selected(this.selectionNode);
            },
            /**
             * Selects/deselects the cell.
             * ```typescript
             * this.cell.selected = true.
             * ```
             * @memberof IgxGridCellComponent
             */
            set: function (val) {
                var node = this.selectionNode;
                val ? this.selectionService.add(node) : this.selectionService.remove(node);
                this.grid.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "dirty", {
            get: function () {
                if (this.grid.rowEditable) {
                    var rowCurrentState = this.grid.transactions.getAggregatedValue(this.row.rowID, false);
                    if (rowCurrentState) {
                        return rowCurrentState[this.column.field] !== undefined && rowCurrentState[this.column.field] !== null;
                    }
                }
                else {
                    var rowTransaction = this.grid.transactions.getState(this.row.rowID);
                    return rowTransaction && rowTransaction.value &&
                        (rowTransaction.value[this.column.field] ||
                            rowTransaction.value[this.column.field] === 0 ||
                            rowTransaction.value[this.column.field] === false);
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "editValue", {
            /**
             * Gets the current edit value while a cell is in edit mode.
             * Only for cell editing mode.
             * ```typescript
             * let editValue = this.cell.editValue;
             * ```
             * @memberof IgxGridCellComponent
             */
            get: function () {
                if (this.crudService.inEditMode) {
                    return this.crudService.cell.editValue;
                }
            },
            /**
             * Sets the current edit value while a cell is in edit mode.
             * Only for cell editing mode.
             * ```typescript
             * this.cell.editValue = value;
             * ```
             * @memberof IgxGridCellComponent
             */
            set: function (value) {
                if (this.crudService.inEditMode) {
                    this.crudService.cell.editValue = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "editable", {
            /**
             * Returns whether the cell is editable.
             */
            get: function () {
                return this.column.editable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "highlight", {
            get: function () {
                return this._highlight;
            },
            set: function (value) {
                this._highlight = value;
                if (this._highlight && this.grid.lastSearchInfo.searchText) {
                    this._highlight.highlight(this.grid.lastSearchInfo.searchText, this.grid.lastSearchInfo.caseSensitive, this.grid.lastSearchInfo.exactMatch);
                    this._highlight.activateIfNecessary();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridCellComponent.prototype, "selectionNode", {
            get: function () {
                return {
                    row: this.rowIndex,
                    column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
                    layout: this.column.columnLayoutChild ? {
                        rowStart: this.column.rowStart,
                        colStart: this.column.colStart,
                        rowEnd: this.column.rowEnd,
                        colEnd: this.column.colEnd,
                        columnVisibleIndex: this.visibleColumnIndex
                    } : null
                };
            },
            enumerable: true,
            configurable: true
        });
        IgxGridCellComponent.prototype.addPointerListeners = function (selection) {
            if (selection !== exports.GridSelectionMode.multiple) {
                return;
            }
            this.nativeElement.addEventListener('pointerdown', this.pointerdown);
            this.nativeElement.addEventListener('pointerenter', this.pointerenter);
            this.nativeElement.addEventListener('pointerup', this.pointerup);
        };
        IgxGridCellComponent.prototype.removePointerListeners = function (selection) {
            if (selection !== exports.GridSelectionMode.multiple) {
                return;
            }
            this.nativeElement.removeEventListener('pointerdown', this.pointerdown);
            this.nativeElement.removeEventListener('pointerenter', this.pointerenter);
            this.nativeElement.removeEventListener('pointerup', this.pointerup);
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.addPointerListeners(_this.cellSelectionMode);
                // IE 11 workarounds
                if (isIE()) {
                    _this.compositionStartHandler = function () { return _this.isInCompositionMode = true; };
                    _this.compositionEndHandler = function () { return _this.isInCompositionMode = false; };
                    // Hitting Enter with IME submits and exits from edit mode instead of first closing the IME dialog
                    _this.nativeElement.addEventListener('compositionstart', _this.compositionStartHandler);
                    _this.nativeElement.addEventListener('compositionend', _this.compositionEndHandler);
                }
            });
            if (this.platformUtil.isIOS) {
                this.touchManager.addEventListener(this.nativeElement, 'doubletap', this.onDoubleClick, {
                    cssProps: {} /* don't disable user-select, etc */
                });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.removePointerListeners(_this.cellSelectionMode);
                if (isIE()) {
                    _this.nativeElement.removeEventListener('compositionstart', _this.compositionStartHandler);
                    _this.nativeElement.removeEventListener('compositionend', _this.compositionEndHandler);
                }
            });
            this.touchManager.destroy();
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype._updateCRUDStatus = function () {
            if (this.editMode) {
                return;
            }
            var crud = this.crudService;
            var editableCell = this.crudService.cell;
            var editMode = !!(crud.row || crud.cell);
            if (this.editable && editMode && !this.row.deleted) {
                if (editableCell) {
                    this.gridAPI.update_cell(editableCell, editableCell.editValue);
                    /* This check is related with the following issue #6517:
                     * when edit cell that belongs to a column which is sorted and press tab,
                     * the next cell in edit mode is with wrong value /its context is not updated/;
                     * So we reapply sorting before the next cell enters edit mode.
                     * Also we need to keep the notifyChanges below, because of the current
                     * change detection cycle when we have editing with enabled transactions
                     */
                    if (this.grid.sortingExpressions.length && this.grid.sortingExpressions.indexOf(editableCell.column.field)) {
                        this.grid.cdr.detectChanges();
                    }
                }
                crud.end();
                this.grid.notifyChanges();
                crud.begin(this);
                return;
            }
            if (editableCell && crud.sameRow(this.cellID.rowID)) {
                this.gridAPI.submit_value();
            }
            else if (editMode && !crud.sameRow(this.cellID.rowID)) {
                this.grid.endEdit(true);
            }
        };
        /**
         * @deprecated
         * Gets whether the cell is selected.
         * ```typescript
         * let isCellSelected = thid.cell.isCellSelected();
         * ```
         * @memberof IgxGridCellComponent
         */
        IgxGridCellComponent.prototype.isCellSelected = function () {
            return this.selectionService.selected(this.selectionNode);
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.ngOnChanges = function (changes) {
            if (changes.value && !changes.value.firstChange) {
                if (this.highlight) {
                    this.highlight.lastSearchInfo.searchedText = this.grid.lastSearchInfo.searchText;
                    this.highlight.lastSearchInfo.caseSensitive = this.grid.lastSearchInfo.caseSensitive;
                    this.highlight.lastSearchInfo.exactMatch = this.grid.lastSearchInfo.exactMatch;
                }
            }
        };
        /**
         * Starts/ends edit mode for the cell.
         *
         * ```typescript
         * cell.setEditMode(true);
         * ```
         */
        IgxGridCellComponent.prototype.setEditMode = function (value) {
            if (this.row.deleted) {
                return;
            }
            if (this.editable && value) {
                this.gridAPI.submit_value();
                this.crudService.begin(this);
            }
            else {
                this.gridAPI.escape_editMode();
            }
            this.grid.notifyChanges();
        };
        /**
         * Sets new value to the cell.
         * ```typescript
         * this.cell.update('New Value');
         * ```
         * @memberof IgxGridCellComponent
         */
        // TODO: Refactor
        IgxGridCellComponent.prototype.update = function (val) {
            if (this.row.deleted) {
                return;
            }
            var cell = this.crudService.createCell(this);
            var args = this.gridAPI.update_cell(cell, val);
            if (this.crudService.cell && this.crudService.sameCell(cell)) {
                if (args.cancel) {
                    return;
                }
                this.gridAPI.escape_editMode();
            }
            this.cdr.markForCheck();
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.onClick = function (event) {
            this.grid.onCellClick.emit({
                cell: this,
                event: event
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.onContextMenu = function (event) {
            this.grid.onContextMenu.emit({
                cell: this,
                event: event
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.onFocus = function (event) {
            if (this.focused) {
                return;
            }
            this.focused = true;
            this.row.focused = true;
            var node = this.selectionNode;
            var shouldEmitSelection = !this.selectionService.isActiveNode(node);
            if (this.selectionService.primaryButton) {
                this._updateCRUDStatus();
                this.selectionService.activeElement = node;
            }
            else {
                this.selectionService.activeElement = null;
                if (this.crudService.inEditMode && !this.editMode) {
                    this.gridAPI.submit_value();
                }
            }
            this.selectionService.primaryButton = true;
            if (this.cellSelectionMode === exports.GridSelectionMode.multiple && this.selectionService.activeElement) {
                this.selectionService.add(this.selectionService.activeElement, false); // pointer events handle range generation
                this.selectionService.keyboardStateOnFocus(node, this.grid.onRangeSelection, this.nativeElement);
            }
            if (this.grid.isCellSelectable && shouldEmitSelection) {
                this.grid.onSelection.emit({ cell: this, event: event });
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.onBlur = function () {
            this.focused = false;
            this.row.focused = false;
        };
        IgxGridCellComponent.prototype.handleAlt = function (key, event) {
            if (this.isToggleKey(key)) {
                var collapse = this.row.expanded && ROW_COLLAPSE_KEYS.has(key);
                var expand = !this.row.expanded && ROW_EXPAND_KEYS.has(key);
                if (expand) {
                    this.gridAPI.set_row_expansion_state(this.row.rowID, true, event);
                }
                else if (collapse) {
                    this.gridAPI.set_row_expansion_state(this.row.rowID, false, event);
                }
                this.grid.notifyChanges();
            }
        };
        IgxGridCellComponent.prototype.handleTab = function (shift) {
            if (shift) {
                this.grid.navigation.performShiftTabKey(this.row.nativeElement, this.selectionNode);
            }
            else {
                this.grid.navigation.performTab(this.row.nativeElement, this.selectionNode);
            }
        };
        IgxGridCellComponent.prototype.handleEnd = function (ctrl) {
            if (ctrl) {
                this.grid.navigation.goToLastCell();
            }
            else {
                this.grid.navigation.onKeydownEnd(this.rowIndex, false, this.rowStart);
            }
        };
        IgxGridCellComponent.prototype.handleHome = function (ctrl) {
            if (ctrl) {
                this.grid.navigation.goToFirstCell();
            }
            else {
                this.grid.navigation.onKeydownHome(this.rowIndex, false, this.rowStart);
            }
        };
        // TODO: Refactor
        /**
         *
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.dispatchEvent = function (event) {
            var key = event.key.toLowerCase();
            var shift = event.shiftKey;
            var ctrl = event.ctrlKey;
            var node = this.selectionNode;
            if (!SUPPORTED_KEYS.has(key)) {
                return;
            }
            event.stopPropagation();
            var keydownArgs = { targetType: 'dataCell', target: this, event: event, cancel: false };
            // This fixes IME editing issue(#6335) that happens only on IE
            if (isIE() && keydownArgs.event.keyCode === 229 && event.key === 'Tab') {
                return;
            }
            this.grid.onGridKeydown.emit(keydownArgs);
            if (keydownArgs.cancel) {
                this.selectionService.clear();
                this.selectionService.keyboardState.active = true;
                return;
            }
            if (event.altKey) {
                event.preventDefault();
                this.handleAlt(key, event);
                return;
            }
            this.selectionService.keyboardStateOnKeydown(node, shift, shift && key === 'tab');
            if (key === 'tab') {
                event.preventDefault();
            }
            if (this.editMode) {
                if (NAVIGATION_KEYS.has(key)) {
                    if (this.column.inlineEditorTemplate) {
                        return;
                    }
                    if (['date', 'boolean'].indexOf(this.column.dataType) > -1) {
                        return;
                    }
                    return;
                }
            }
            if (NAVIGATION_KEYS.has(key)) {
                event.preventDefault();
            }
            switch (key) {
                case 'tab':
                    this.handleTab(shift);
                    break;
                case 'end':
                    this.handleEnd(ctrl);
                    break;
                case 'home':
                    this.handleHome(ctrl);
                    break;
                case 'arrowleft':
                case 'left':
                    if (ctrl) {
                        this.grid.navigation.onKeydownHome(node.row, false, this.rowStart);
                        break;
                    }
                    this.grid.navigation.onKeydownArrowLeft(this.nativeElement, this.selectionNode);
                    break;
                case 'arrowright':
                case 'right':
                    if (ctrl) {
                        this.grid.navigation.onKeydownEnd(node.row, false, this.rowStart);
                        break;
                    }
                    this.grid.navigation.onKeydownArrowRight(this.nativeElement, this.selectionNode);
                    break;
                case 'arrowup':
                case 'up':
                    if (ctrl) {
                        this.grid.navigation.navigateTop(this.visibleColumnIndex);
                        break;
                    }
                    this.grid.navigation.navigateUp(this.row.nativeElement, this.selectionNode);
                    break;
                case 'arrowdown':
                case 'down':
                    if (ctrl) {
                        this.grid.navigation.navigateBottom(this.visibleColumnIndex);
                        break;
                    }
                    this.grid.navigation.navigateDown(this.row.nativeElement, this.selectionNode);
                    break;
                case 'enter':
                case 'f2':
                    this.onKeydownEnterEditMode();
                    break;
                case 'escape':
                case 'esc':
                    this.onKeydownExitEditMode();
                    break;
                case ' ':
                case 'spacebar':
                case 'space':
                    if (this.grid.isRowSelectable) {
                        this.row.selected ? this.selectionService.deselectRow(this.row.rowID, event) :
                            this.selectionService.selectRowById(this.row.rowID, false, event);
                    }
                    break;
                default:
                    return;
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.onKeydownEnterEditMode = function () {
            if (this.isInCompositionMode) {
                return;
            }
            if (this.column.editable && !this.row.deleted) {
                if (this.editMode) {
                    this.grid.endEdit(true);
                    this.nativeElement.focus();
                }
                else {
                    this.crudService.begin(this);
                }
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.onKeydownExitEditMode = function () {
            if (this.isInCompositionMode) {
                return;
            }
            if (this.editMode) {
                var args = this.crudService.cell.createEditEventArgs();
                this.grid.onCellEditCancel.emit(args);
                if (args.cancel) {
                    return;
                }
                this.grid.endEdit(false);
                this.nativeElement.focus();
            }
        };
        /**
         * If the provided string matches the text in the cell, the text gets highlighted.
         * ```typescript
         * this.cell.highlightText('Cell Value', true);
         * ```
         * @memberof IgxGridCellComponent
         */
        IgxGridCellComponent.prototype.highlightText = function (text, caseSensitive, exactMatch) {
            return this.highlight && this.column.searchable ? this.highlight.highlight(text, caseSensitive, exactMatch) : 0;
        };
        /**
         * Clears the highlight of the text in the cell.
         * ```typescript
         * this.cell.clearHighLight();
         * ```
         * @memberof IgxGridCellComponent
         */
        IgxGridCellComponent.prototype.clearHighlight = function () {
            if (this.highlight && this.column.searchable) {
                this.highlight.clearHighlight();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridCellComponent.prototype.calculateSizeToFit = function (range) {
            return Math.max.apply(Math, __spread(Array.from(this.nativeElement.children)
                .map(function (child) { return getNodeSizeViaRange(range, child); })));
        };
        IgxGridCellComponent.prototype.isToggleKey = function (key) {
            return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
        };
        IgxGridCellComponent.ctorParameters = function () { return [
            { type: IgxGridSelectionService },
            { type: IgxGridCRUDService },
            { type: GridBaseAPIService },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: HammerGesturesManager },
            { type: PlatformUtil }
        ]; };
        __decorate([
            core.Input()
        ], IgxGridCellComponent.prototype, "column", void 0);
        __decorate([
            core.Input()
        ], IgxGridCellComponent.prototype, "row", void 0);
        __decorate([
            core.Input()
        ], IgxGridCellComponent.prototype, "rowData", void 0);
        __decorate([
            core.Input()
        ], IgxGridCellComponent.prototype, "cellTemplate", void 0);
        __decorate([
            core.Input()
        ], IgxGridCellComponent.prototype, "value", void 0);
        __decorate([
            core.Input()
        ], IgxGridCellComponent.prototype, "formatter", void 0);
        __decorate([
            core.HostBinding('attr.data-rowIndex')
        ], IgxGridCellComponent.prototype, "rowIndex", null);
        __decorate([
            core.HostBinding('attr.data-visibleIndex'),
            core.Input()
        ], IgxGridCellComponent.prototype, "visibleColumnIndex", null);
        __decorate([
            DeprecateProperty("'inEditMode' is deprecated\nUse 'editMode' to get the current state and 'setEditMode(boolean)' as a setter")
        ], IgxGridCellComponent.prototype, "inEditMode", null);
        __decorate([
            core.Input()
        ], IgxGridCellComponent.prototype, "cellSelectionMode", null);
        __decorate([
            core.Input()
        ], IgxGridCellComponent.prototype, "lastSearchInfo", null);
        __decorate([
            core.Input(),
            core.HostBinding('class.igx-grid__td--pinned-last')
        ], IgxGridCellComponent.prototype, "lastPinned", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('class.igx-grid__td--editing')
        ], IgxGridCellComponent.prototype, "editMode", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxGridCellComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxGridCellComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.aria-readonly')
        ], IgxGridCellComponent.prototype, "readonly", null);
        __decorate([
            core.HostBinding('attr.aria-describedby')
        ], IgxGridCellComponent.prototype, "describedby", null);
        __decorate([
            core.Input()
        ], IgxGridCellComponent.prototype, "width", void 0);
        __decorate([
            core.HostBinding('attr.aria-selected'),
            core.HostBinding('class.igx-grid__td--selected')
        ], IgxGridCellComponent.prototype, "selected", null);
        __decorate([
            core.HostBinding('class.igx-grid__td--edited')
        ], IgxGridCellComponent.prototype, "dirty", null);
        __decorate([
            core.HostBinding('class.igx-grid__td--active')
        ], IgxGridCellComponent.prototype, "focused", void 0);
        __decorate([
            core.ViewChild('defaultCell', { read: core.TemplateRef, static: true })
        ], IgxGridCellComponent.prototype, "defaultCellTemplate", void 0);
        __decorate([
            core.ViewChild('inlineEditor', { read: core.TemplateRef, static: true })
        ], IgxGridCellComponent.prototype, "inlineEditorTemplate", void 0);
        __decorate([
            core.ViewChild(IgxTextHighlightDirective, { read: IgxTextHighlightDirective })
        ], IgxGridCellComponent.prototype, "highlight", null);
        __decorate([
            DeprecateMethod("'isCellSelected' is deprecated. Use 'selected' property instead.")
        ], IgxGridCellComponent.prototype, "isCellSelected", null);
        __decorate([
            core.HostListener('dblclick', ['$event'])
        ], IgxGridCellComponent.prototype, "onDoubleClick", void 0);
        __decorate([
            core.HostListener('click', ['$event'])
        ], IgxGridCellComponent.prototype, "onClick", null);
        __decorate([
            core.HostListener('contextmenu', ['$event'])
        ], IgxGridCellComponent.prototype, "onContextMenu", null);
        __decorate([
            core.HostListener('focus', ['$event'])
        ], IgxGridCellComponent.prototype, "onFocus", null);
        __decorate([
            core.HostListener('blur')
        ], IgxGridCellComponent.prototype, "onBlur", null);
        __decorate([
            core.HostListener('keydown', ['$event'])
        ], IgxGridCellComponent.prototype, "dispatchEvent", null);
        IgxGridCellComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                selector: 'igx-grid-cell',
                template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\"\n            [igxFocus]=\"focused\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n            [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n",
                providers: [HammerGesturesManager]
            })
        ], IgxGridCellComponent);
        return IgxGridCellComponent;
    }());

    var IgxRowDirective = /** @class */ (function () {
        function IgxRowDirective(gridAPI, crudService, selectionService, element, cdr) {
            this.gridAPI = gridAPI;
            this.crudService = crudService;
            this.selectionService = selectionService;
            this.element = element;
            this.cdr = cdr;
            /**
             * @hidden
             */
            this.role = 'row';
            /**
             * @hidden
             */
            this.dragging = false;
            /**
             * @hidden
             */
            this.focused = false;
            /**
             * @hidden
             * @internal
             */
            this.defaultCssClass = 'igx-grid__tr';
        }
        Object.defineProperty(IgxRowDirective.prototype, "rowData", {
            /**
             *  The data passed to the row component.
             *
             * ```typescript
             * // get the row data for the first selected row
             * let selectedRowData = this.grid.selectedRows[0].rowData;
             * ```
             */
            get: function () {
                if (this.inEditMode) {
                    return Object.assign({}, this._rowData, this.grid.transactions.getAggregatedValue(this.rowID, false));
                }
                return this._rowData;
            },
            set: function (v) {
                this._rowData = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "dataRowIndex", {
            get: function () {
                return this.index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "styleClasses", {
            /**
             * @hidden
             */
            get: function () {
                return this.resolveClasses();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "selected", {
            /**
             * @hidden
             */
            get: function () {
                return this.selectionService.isRowSelected(this.rowID);
            },
            set: function (value) {
                value ? this.selectionService.selectRowsWithNoEvent([this.rowID]) :
                    this.selectionService.deselectRowsWithNoEvent([this.rowID]);
                this.grid.cdr.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "columns", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.visibleColumns;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "viewIndex", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.grid.groupingExpressions.length) {
                    return this.grid.filteredSortedData.indexOf(this.rowData);
                }
                return this.index + this.grid.page * this.grid.perPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "pinnedColumns", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.pinnedColumns;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "unpinnedColumns", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.unpinnedColumns;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "showRowSelectors", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.showRowSelectors;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "dirty", {
            /** @hidden */
            get: function () {
                var row = this.grid.transactions.getState(this.rowID);
                if (row) {
                    return row.type === exports.TransactionType.ADD || row.type === exports.TransactionType.UPDATE;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "isSelected", {
            get: function () {
                return this.selectionService.isRowSelected(this.rowID);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "rowDraggable", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.rowDraggable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "added", {
            /** @hidden */
            get: function () {
                var row = this.grid.transactions.getState(this.rowID);
                if (row) {
                    return row.type === exports.TransactionType.ADD;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "deleted", {
            /** @hidden */
            get: function () {
                return this.gridAPI.row_deleted_transaction(this.rowID);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "inEditMode", {
            // TODO: Refactor
            get: function () {
                if (this.grid.rowEditable) {
                    var editRowState = this.crudService.row;
                    return (editRowState && editRowState.id === this.rowID) || false;
                }
                else {
                    return false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "grid", {
            /**
             * Get a reference to the grid that contains the selected row.
             *
             * ```typescript
             * handleRowSelection(event) {
             *  // the grid on which the onRowSelectionChange event was triggered
             *  const grid = event.row.grid;
             * }
             * ```
             *
             * ```html
             *  <igx-grid
             *    [data]="data"
             *    (onRowSelectionChange)="handleRowSelection($event)">
             *  </igx-grid>
             * ```
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "rowID", {
            /**
             * Gets the ID of the row.
             * A row in the grid is identified either by:
             * - primaryKey data value,
             * - the whole rowData, if the primaryKey is omitted.
             *
             * ```typescript
             * let rowID = this.grid.selectedRows[2].rowID;
             * ```
             */
            get: function () {
                var primaryKey = this.grid.primaryKey;
                return primaryKey ? this._rowData[primaryKey] : this._rowData;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowDirective.prototype, "nativeElement", {
            /**
             * The native DOM element representing the row. Could be null in certain environments.
             *
             * ```typescript
             * // get the nativeElement of the second selected row
             * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
             * ```
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxRowDirective.prototype.onClick = function (event) {
            if (this.grid.rowSelection === 'none' || this.deleted) {
                return;
            }
            if (event.shiftKey && this.grid.rowSelection === 'multiple') {
                this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
                return;
            }
            this.selectionService.selectRowById(this.rowID, !event.ctrlKey, event);
        };
        /**
         * @hidden
         */
        IgxRowDirective.prototype.onRowSelectorClick = function (event) {
            event.stopPropagation();
            if (event.shiftKey && this.grid.rowSelection === 'multiple') {
                this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
                return;
            }
            this.selected ? this.selectionService.deselectRow(this.rowID, event) :
                this.selectionService.selectRowById(this.rowID, false, event);
        };
        /**
         * Updates the specified row object and the data source record with the passed value.
         * This method emits `onEditDone` event.
         *
         * ```typescript
         * // update the second selected row's value
         * let newValue = "Apple";
         * this.grid.selectedRows[1].update(newValue);
         * ```
         */
        IgxRowDirective.prototype.update = function (value) {
            var crudService = this.crudService;
            if (crudService.inEditMode && crudService.cell.id.rowID === this.rowID) {
                this.grid.endEdit(false);
            }
            var row = new IgxRow(this.rowID, this.index, this.rowData);
            this.gridAPI.update_row(row, value);
            this.cdr.markForCheck();
        };
        /**
         * Removes the specified row from the grid's data source.
         * This method emits `onRowDeleted` event.
         *
         * ```typescript
         * // delete the third selected row from the grid
         * this.grid.selectedRows[2].delete();
         * ```
         */
        IgxRowDirective.prototype.delete = function () {
            this.grid.deleteRowById(this.rowID);
        };
        Object.defineProperty(IgxRowDirective.prototype, "rowCheckboxAriaLabel", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.primaryKey ?
                    this.selected ? 'Deselect row with key ' + this.rowID : 'Select row with key ' + this.rowID :
                    this.selected ? 'Deselect row' : 'Select row';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxRowDirective.prototype.ngDoCheck = function () {
            this.cdr.markForCheck();
        };
        /**
         * @hidden
         */
        IgxRowDirective.prototype.resolveClasses = function () {
            var indexClass = this.index % 2 ? this.grid.evenRowCSS : this.grid.oddRowCSS;
            var selectedClass = this.selected ? 'igx-grid__tr--selected' : '';
            var editClass = this.inEditMode ? 'igx-grid__tr--edit' : '';
            var dirtyClass = this.dirty ? 'igx-grid__tr--edited' : '';
            var deletedClass = this.deleted ? 'igx-grid__tr--deleted' : '';
            var mrlClass = this.grid.hasColumnLayouts ? 'igx-grid__tr--mrl' : '';
            var dragClass = this.dragging ? 'igx-grid__tr--drag' : '';
            return (this.defaultCssClass + " " + indexClass + " " + selectedClass + " " + editClass + " " + dirtyClass + "\n         " + deletedClass + " " + mrlClass + " " + dragClass).trim();
        };
        Object.defineProperty(IgxRowDirective.prototype, "resolveDragIndicatorClasses", {
            /**
             * @hidden
             */
            get: function () {
                var defaultDragIndicatorCssClass = 'igx-grid__drag-indicator';
                var dragIndicatorOff = this.grid.rowDragging && !this.dragging ? 'igx-grid__drag-indicator--off' : '';
                return defaultDragIndicatorCssClass + " " + dragIndicatorOff;
            },
            enumerable: true,
            configurable: true
        });
        IgxRowDirective.ctorParameters = function () { return [
            { type: GridBaseAPIService },
            { type: IgxGridCRUDService },
            { type: IgxGridSelectionService },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxRowDirective.prototype, "rowData", null);
        __decorate([
            core.Input()
        ], IgxRowDirective.prototype, "index", void 0);
        __decorate([
            core.Input()
        ], IgxRowDirective.prototype, "gridID", void 0);
        __decorate([
            core.ViewChild('igxDirRef', { read: IgxGridForOfDirective })
        ], IgxRowDirective.prototype, "virtDirRow", void 0);
        __decorate([
            core.ViewChild(core.forwardRef(function () { return IgxCheckboxComponent; }), { read: IgxCheckboxComponent })
        ], IgxRowDirective.prototype, "checkboxElement", void 0);
        __decorate([
            core.ViewChildren(core.forwardRef(function () { return IgxGridCellComponent; }))
        ], IgxRowDirective.prototype, "cells", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxRowDirective.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.data-rowIndex')
        ], IgxRowDirective.prototype, "dataRowIndex", null);
        __decorate([
            core.HostBinding('class')
        ], IgxRowDirective.prototype, "styleClasses", null);
        __decorate([
            core.Input(),
            core.HostBinding('attr.aria-selected')
        ], IgxRowDirective.prototype, "selected", null);
        __decorate([
            DeprecateProperty('isSelected property is deprecated. Use selected property instead.')
        ], IgxRowDirective.prototype, "isSelected", null);
        __decorate([
            core.HostListener('click', ['$event'])
        ], IgxRowDirective.prototype, "onClick", null);
        IgxRowDirective = __decorate([
            core.Directive({
                selector: '[igxRowBaseComponent]'
            })
        ], IgxRowDirective);
        return IgxRowDirective;
    }());

    var clear = function (el) { return el === 0 || Boolean(el); };
    var ɵ0$7 = clear;
    var first = function (arr) { return arr[0]; };
    var ɵ1 = first;
    var last = function (arr) { return arr[arr.length - 1]; };
    var ɵ2 = last;
    var IgxSummaryOperand = /** @class */ (function () {
        function IgxSummaryOperand() {
        }
        /**
         * Counts all the records in the data source.
         * If filtering is applied, counts only the filtered records.
         * ```typescript
         * IgxSummaryOperand.count(dataSource);
         * ```
         * @memberof IgxSummaryOperand
         */
        IgxSummaryOperand.count = function (data) {
            return data.length;
        };
        /**
         * Executes the static `count` method and returns `IgxSummaryResult[]`.
         * ```typescript
         * interface IgxSummaryResult {
         *   key: string;
         *   label: string;
         *   summaryResult: any;
         * }
         * ```
         * Can be overridden in the inherited classes to provide customization for the `summary`.
         * ```typescript
         * class CustomSummary extends IgxSummaryOperand {
         *   constructor() {
         *     super();
         *   }
         *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
         *     const result = [];
         *     result.push({
         *       key: "test",
         *       label: "Test",
         *       summaryResult: IgxSummaryOperand.count(data)
         *     });
         *     return result;
         *   }
         * }
         * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;
         * ```
         * @memberof IgxSummaryOperand
         */
        IgxSummaryOperand.prototype.operate = function (data, allData, fieldName) {
            if (data === void 0) { data = []; }
            if (allData === void 0) { allData = []; }
            return [{
                    key: 'count',
                    label: 'Count',
                    summaryResult: IgxSummaryOperand.count(data)
                }];
        };
        return IgxSummaryOperand;
    }());
    // @dynamic
    var IgxNumberSummaryOperand = /** @class */ (function (_super) {
        __extends(IgxNumberSummaryOperand, _super);
        function IgxNumberSummaryOperand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Returns the minimum numeric value in the provided data records.
         * If filtering is applied, returns the minimum value in the filtered data records.
         * ```typescript
         * IgxNumberSummaryOperand.min(data);
         * ```
         * @memberof IgxNumberSummaryOperand
         */
        IgxNumberSummaryOperand.min = function (data) {
            return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) { return Math.min(a, b); }) : 0;
        };
        /**
         * Returns the maximum numeric value in the provided data records.
         * If filtering is applied, returns the maximum value in the filtered data records.
         * ```typescript
         * IgxNumberSummaryOperand.max(data);
         * ```
         * @memberof IgxNumberSummaryOperand
         */
        IgxNumberSummaryOperand.max = function (data) {
            return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) { return Math.max(a, b); }) : 0;
        };
        /**
         * Returns the sum of the numeric values in the provided data records.
         * If filtering is applied, returns the sum of the numeric values in the data records.
         * ```typescript
         * IgxNumberSummaryOperand.sum(data);
         * ```
         * @memberof IgxNumberSummaryOperand
         */
        IgxNumberSummaryOperand.sum = function (data) {
            return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) { return +a + +b; }) : 0;
        };
        /**
         * Returns the average numeric value in the data provided data records.
         * If filtering is applied, returns the average numeric value in the filtered data records.
         * ```typescript
         * IgxSummaryOperand.average(data);
         * ```
         * @memberof IgxNumberSummaryOperand
         */
        IgxNumberSummaryOperand.average = function (data) {
            return data.length && data.filter(clear).length ? this.sum(data) / this.count(data) : 0;
        };
        /**
         * Executes the static methods and returns `IgxSummaryResult[]`.
         * ```typescript
         * interface IgxSummaryResult {
         *   key: string;
         *   label: string;
         *   summaryResult: any;
         * }
         * ```
         * Can be overridden in the inherited classes to provide customization for the `summary`.
         * ```typescript
         * class CustomNumberSummary extends IgxNumberSummaryOperand {
         *   constructor() {
         *     super();
         *   }
         *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
         *     const result = [];
         *     result.push({
         *       key: "avg",
         *       label: "Avg",
         *       summaryResult: IgxNumberSummaryOperand.average(data)
         *     });
         *     result.push({
         *       key: "max",
         *       label: "Max",
         *       summaryResult: IgxNumberSummaryOperand.max(data)
         *     });
         *     return result;
         *   }
         * }
         * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;
         * ```
         * @memberof IgxNumberSummaryOperand
         */
        IgxNumberSummaryOperand.prototype.operate = function (data, allData, fieldName) {
            if (data === void 0) { data = []; }
            if (allData === void 0) { allData = []; }
            var result = _super.prototype.operate.call(this, data, allData, fieldName);
            result.push({
                key: 'min',
                label: 'Min',
                summaryResult: IgxNumberSummaryOperand.min(data)
            });
            result.push({
                key: 'max',
                label: 'Max',
                summaryResult: IgxNumberSummaryOperand.max(data)
            });
            result.push({
                key: 'sum',
                label: 'Sum',
                summaryResult: IgxNumberSummaryOperand.sum(data)
            });
            result.push({
                key: 'average',
                label: 'Avg',
                summaryResult: IgxNumberSummaryOperand.average(data)
            });
            return result;
        };
        return IgxNumberSummaryOperand;
    }(IgxSummaryOperand));
    // @dynamic
    var IgxDateSummaryOperand = /** @class */ (function (_super) {
        __extends(IgxDateSummaryOperand, _super);
        function IgxDateSummaryOperand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Returns the latest date value in the data records.
         * If filtering is applied, returns the latest date value in the filtered data records.
         * ```typescript
         * IgxDateSummaryOperand.latest(data);
         * ```
         * @memberof IgxDateSummaryOperand
         */
        IgxDateSummaryOperand.latest = function (data) {
            return data.length && data.filter(clear).length ?
                first(data.filter(clear).sort(function (a, b) { return new Date(b).valueOf() - new Date(a).valueOf(); })) : undefined;
        };
        /**
         * Returns the earliest date value in the data records.
         * If filtering is applied, returns the latest date value in the filtered data records.
         * ```typescript
         * IgxDateSummaryOperand.earliest(data);
         * ```
         * @memberof IgxDateSummaryOperand
         */
        IgxDateSummaryOperand.earliest = function (data) {
            return data.length && data.filter(clear).length ?
                last(data.filter(clear).sort(function (a, b) { return new Date(b).valueOf() - new Date(a).valueOf(); })) : undefined;
        };
        /**
         * Executes the static methods and returns `IgxSummaryResult[]`.
         * ```typescript
         * interface IgxSummaryResult {
         *   key: string;
         *   label: string;
         *   summaryResult: any;
         * }
         * ```
         * Can be overridden in the inherited classes to provide customization for the `summary`.
         * ```typescript
         * class CustomDateSummary extends IgxDateSummaryOperand {
         *   constructor() {
         *     super();
         *   }
         *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
         *     const result = [];
         *     result.push({
         *       key: "latest",
         *       label: "Latest Date",
         *       summaryResult: IgxDateSummaryOperand.latest(data)
         *     });
         *     return result;
         *   }
         * }
         * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;
         * ```
         * @memberof IgxDateSummaryOperand
         */
        IgxDateSummaryOperand.prototype.operate = function (data, allData, fieldName) {
            if (data === void 0) { data = []; }
            if (allData === void 0) { allData = []; }
            var result = _super.prototype.operate.call(this, data, allData, fieldName);
            result.push({
                key: 'earliest',
                label: 'Earliest',
                summaryResult: IgxDateSummaryOperand.earliest(data)
            });
            result.push({
                key: 'latest',
                label: 'Latest',
                summaryResult: IgxDateSummaryOperand.latest(data)
            });
            return result;
        };
        return IgxDateSummaryOperand;
    }(IgxSummaryOperand));

    var IgxFilterCellTemplateDirective = /** @class */ (function () {
        function IgxFilterCellTemplateDirective(template) {
            this.template = template;
        }
        IgxFilterCellTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxFilterCellTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxFilterCellTemplate]'
            })
        ], IgxFilterCellTemplateDirective);
        return IgxFilterCellTemplateDirective;
    }());
    var IgxCellTemplateDirective = /** @class */ (function () {
        function IgxCellTemplateDirective(template) {
            this.template = template;
        }
        IgxCellTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxCellTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxCell]'
            })
        ], IgxCellTemplateDirective);
        return IgxCellTemplateDirective;
    }());
    var IgxCellHeaderTemplateDirective = /** @class */ (function () {
        function IgxCellHeaderTemplateDirective(template) {
            this.template = template;
        }
        IgxCellHeaderTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxCellHeaderTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxHeader]'
            })
        ], IgxCellHeaderTemplateDirective);
        return IgxCellHeaderTemplateDirective;
    }());
    /**
     * @hidden
     */
    var IgxCellFooterTemplateDirective = /** @class */ (function () {
        function IgxCellFooterTemplateDirective(template) {
            this.template = template;
        }
        IgxCellFooterTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxCellFooterTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxFooter]'
            })
        ], IgxCellFooterTemplateDirective);
        return IgxCellFooterTemplateDirective;
    }());
    var IgxCellEditorTemplateDirective = /** @class */ (function () {
        function IgxCellEditorTemplateDirective(template) {
            this.template = template;
        }
        IgxCellEditorTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxCellEditorTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxCellEditor]'
            })
        ], IgxCellEditorTemplateDirective);
        return IgxCellEditorTemplateDirective;
    }());
    var IgxCollapsibleIndicatorTemplateDirective = /** @class */ (function () {
        function IgxCollapsibleIndicatorTemplateDirective(template) {
            this.template = template;
        }
        IgxCollapsibleIndicatorTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxCollapsibleIndicatorTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxCollapsibleIndicator]'
            })
        ], IgxCollapsibleIndicatorTemplateDirective);
        return IgxCollapsibleIndicatorTemplateDirective;
    }());

    /**
     * **Ignite UI for Angular Column** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html#columns-configuration)
     *
     * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
     * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
     * the column using `ng-template` which will be used for all cells within the column.
     */
    var IgxColumnComponent = /** @class */ (function () {
        function IgxColumnComponent(gridAPI, cdr, rowIslandAPI) {
            this.gridAPI = gridAPI;
            this.cdr = cdr;
            this.rowIslandAPI = rowIslandAPI;
            /**
             * Sets/gets the `header` value.
             * ```typescript
             * let columnHeader = this.column.header;
             * ```
             * ```html
             * <igx-column [header] = "'ID'"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.header = '';
            /**
             * Sets/gets whether the column is sortable.
             * Default value is `false`.
             * ```typescript
             * let isSortable = this.column.sortable;
             * ```
             * ```html
             * <igx-column [sortable] = "true"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.sortable = false;
            /**
             * Sets/gets whether the column is groupable.
             * Default value is `false`.
             * ```typescript
             * let isGroupable = this.column.groupable;
             * ```
             * ```html
             * <igx-column [groupable] = "true"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.groupable = false;
            /**
             * Sets/gets whether the column is filterable.
             * Default value is `true`.
             * ```typescript
             * let isFilterable = this.column.filterable;
             * ```
             * ```html
             * <igx-column [filterable] = "false"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.filterable = true;
            /**
             * Sets/gets whether the column is resizable.
             * Default value is `false`.
             * ```typescript
             * let isResizable = this.column.resizable;
             * ```
             * ```html
             * <igx-column [resizable] = "true"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.resizable = false;
            /**
             *@hidden
             */
            this.hiddenChange = new core.EventEmitter();
            /** @hidden */
            this.expandedChange = new core.EventEmitter();
            /** @hidden */
            this.collapsibleChange = new core.EventEmitter();
            /** @hidden */
            this.visibleWhenCollapsedChange = new core.EventEmitter();
            /**
             * Gets whether the hiding is disabled.
             * ```typescript
             * let isHidingDisabled =  this.column.disableHiding;
             * ```
             * @memberof IgxColumnComponent
             */
            this.disableHiding = false;
            /**
             * Gets whether the pinning is disabled.
             * ```typescript
             * let isPinningDisabled =  this.column.disablePinning;
             * ```
             * @memberof IgxColumnComponent
             */
            this.disablePinning = false;
            /**
             * Sets/gets whether the column is movable.
             * Default value is `false`.
             * ```typescript
             * let isMovable = this.column.movable;
             * ```
             * ```html
             * <igx-column [movable] = "true"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.movable = false;
            /**
             *@hidden
             */
            this.widthChange = new core.EventEmitter();
            this._calcWidth = null;
            /**
             * Sets/gets the class selector of the column header.
             * ```typescript
             * let columnHeaderClass = this.column.headerClasses;
             * ```
             * ```html
             * <igx-column [headerClasses] = "'column-header'"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.headerClasses = '';
            /**
             * Sets/gets the class selector of the column group header.
             * ```typescript
             * let columnHeaderClass = this.column.headerGroupClasses;
             * ```
             * ```html
             * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.headerGroupClasses = '';
            /**
             * Sets conditional style properties on the column cells.
             * Similar to `ngStyle` it accepts an object literal where the keys are
             * the style properties and the value is the expression to be evaluated.
             * As with `cellClasses` it accepts a callback function.
             * ```typescript
             * styles = {
             *  background: 'royalblue',
             *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') : 'red': 'inherit'
             * }
             * ```
             * ```html
             * <igx-column [cellStyles]="styles"></igx-column>
             * ```
             *
             * @memberof IgxColumnComponent
             */
            this.cellStyles = null;
            /**
             * Sets/gets whether the column filtering should be case sensitive.
             * Default value is `true`.
             * ```typescript
             * let filteringIgnoreCase = this.column.filteringIgnoreCase;
             * ```
             * ```html
             * <igx-column [filteringIgnoreCase] = "false"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.filteringIgnoreCase = true;
            /**
             * Sets/gets whether the column sorting should be case sensitive.
             * Default value is `true`.
             * ```typescript
             * let sortingIgnoreCase = this.column.sortingIgnoreCase;
             * ```
             * ```html
             * <igx-column [sortingIgnoreCase] = "false"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.sortingIgnoreCase = true;
            /**
             * Sets/gets the data type of the column values.
             * Default value is `string`.
             * ```typescript
             * let columnDataType = this.column.dataType;
             * ```
             * ```html
             * <igx-column [dataType] = "'number'"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.dataType = exports.DataType.String;
            /**
             *@hidden
             */
            this.pinnedChange = new core.EventEmitter();
            /**
             * Sets/gets whether the column is `searchable`.
             * Default value is `true`.
             * ```typescript
             * let isSearchable =  this.column.searchable';
             * ```
             * ```html
             *  <igx-column [searchable] = "false"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            this.searchable = true;
            /**
             * @hidden
             * @internal
             */
            this.collapsible = false;
            /**
             * @hidden
             * @internal
             */
            this.expanded = true;
            /**
             * Sets/gets the parent column.
             * ```typescript
             * let parentColumn = this.column.parent;
             * ```
             * ```typescript
             * this.column.parent = higherLevelColumn;
             * ```
             * @memberof IgxColumnComponent
             */
            this.parent = null;
            /**
             *@hidden
             */
            this._pinned = false;
            /**
             *@hidden
             */
            this._summaries = null;
            /**
             *@hidden
             */
            this._filters = null;
            /**
             *@hidden
             */
            this._sortStrategy = DefaultSortingStrategy.instance();
            /**
             *@hidden
             */
            this._hidden = false;
            /**
             *@hidden
             */
            this._disablePinning = false;
            /**
             *@hidden
             */
            this._defaultMinWidth = '';
            /**
             *@hidden
             */
            this._hasSummary = false;
            /**
             * @hidden
             */
            this._collapsible = false;
            /**
             * @hidden
             */
            this._expanded = true;
            this._vIndex = NaN;
        }
        Object.defineProperty(IgxColumnComponent.prototype, "editable", {
            /**
             * Gets whether the column is editable.
             * Default value is `false`.
             * ```typescript
             * let isEditable = this.column.editable;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                // Updating the primary key when grid has transactions (incl. row edit)
                // should not be allowed, as that can corrupt transaction state.
                var rowEditable = this.grid && this.grid.rowEditable;
                var hasTransactions = this.grid && this.grid.transactions.enabled;
                if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
                    return false;
                }
                if (this._editable !== undefined) {
                    return this._editable;
                }
                else {
                    return rowEditable;
                }
            },
            /**
             * Sets whether the column is editable.
             * ```typescript
             * this.column.editable = true;
             * ```
             * ```html
             * <igx-column [editable] = "true"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (editable) {
                this._editable = editable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "hasSummary", {
            /**
             * Gets a value indicating whether the summary for the column is enabled.
             * ```typescript
             * let hasSummary = this.column.hasSummary;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._hasSummary;
            },
            /**
             * Sets a value indicating whether the summary for the column is enabled.
             * Default value is `false`.
             * ```html
             * <igx-column [hasSummary] = "true"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                this._hasSummary = value;
                if (this.grid) {
                    this.grid.summaryService.resetSummaryHeight();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "hidden", {
            /**
             * Gets whether the column is hidden.
             * ```typescript
             * let isHidden = this.column.hidden;
             * ```
             *@memberof IgxColumnComponent
             */
            get: function () {
                return this._hidden;
            },
            /**
             * Sets the column hidden property.
             * Default value is `false`.
             * ```html
             * <igx-column [hidden] = "true"></igx-column>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-column [(hidden)] = "model.isHidden"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                if (this._hidden !== value) {
                    this._hidden = value;
                    this.hiddenChange.emit(this._hidden);
                    if (this.columnLayoutChild && this.parent.hidden !== value) {
                        this.parent.hidden = value;
                        return;
                    }
                    if (this.grid) {
                        this.grid.endEdit(false);
                        this.grid.summaryService.resetSummaryHeight();
                        this.grid.filteringService.refreshExpressions();
                        this.grid.notifyChanges();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "width", {
            /**
             * Gets the `width` of the column.
             * ```typescript
             * let columnWidth = this.column.width;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this.widthSetByUser ? this._width : this.defaultWidth;
            },
            /**
             * Sets the `width` of the column.
             * ```html
             * <igx-column [width] = "'25%'"></igx-column>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-column [(width)]="model.columns[0].width"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                if (value) {
                    this._calcWidth = null;
                    this.calcPixelWidth = NaN;
                    this.widthSetByUser = true;
                    // width could be passed as number from the template
                    // host bindings are not px affixed so we need to ensure we affix simple number strings
                    if (typeof (value) === 'number' || value.match(/^[0-9]*$/)) {
                        value = value + 'px';
                    }
                    this._width = value;
                    if (this.grid) {
                        this.cacheCalcWidth();
                    }
                    this.widthChange.emit(this._width);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "calcWidth", {
            /**
             * @hidden
             */
            get: function () {
                return this.getCalcWidth();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "minWidth", {
            get: function () {
                return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
            },
            /**
             * Sets/gets the minimum `width` of the column.
             * Default value is `88`;
             * ```typescript
             * let columnMinWidth = this.column.minWidth;
             * ```
             * ```html
             * <igx-column [minWidth] = "'15%'"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                var minVal = parseFloat(value);
                if (Number.isNaN(minVal)) {
                    return;
                }
                this._defaultMinWidth = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "index", {
            /**
             * Gets the column index.
             * ```typescript
             * let columnIndex = this.column.index;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this.grid.columns.indexOf(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "pinned", {
            /**
             * Gets whether the column is `pinned`.
             * ```typescript
             * let isPinned = this.column.pinned;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._pinned;
            },
            /**
             * Sets whether the column is pinned.
             * Default value is `false`.
             * ```html
             * <igx-column [pinned] = "true"></igx-column>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                if (this._pinned !== value) {
                    if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                        value ? this.pin() : this.unpin();
                        return;
                    }
                    /* No grid/width available at initialization. `initPinning` in the grid
                       will re-init the group (if present)
                    */
                    this._unpinnedIndex = this.grid ? this.grid.columns.filter(function (x) { return !x.pinned; }).indexOf(this) : 0;
                    this._pinned = value;
                    this.pinnedChange.emit(this._pinned);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "summaries", {
            /**
             * Gets the column `summaries`.
             * ```typescript
             * let columnSummaries = this.column.summaries;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._summaries;
            },
            /**
             * Sets the column `summaries`.
             * ```typescript
             * this.column.summaries = IgxNumberSummaryOperand;
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (classRef) {
                this._summaries = new classRef();
                if (this.grid) {
                    this.grid.summaryService.removeSummariesCachePerColumn(this.field);
                    this.grid._summaryPipeTrigger++;
                    this.grid.summaryService.resetSummaryHeight();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "filters", {
            /**
             * Gets the column `filters`.
             * ```typescript
             * let columnFilters = this.column.filters'
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._filters;
            },
            /**
             * Sets the column `filters`.
             * ```typescript
             * this.column.filters = IgxBooleanFilteringOperand.instance().
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (instance) {
                this._filters = instance;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "sortStrategy", {
            /**
             * Gets the column `sortStrategy`.
             * ```typescript
             * let sortStrategy = this.column.sortStrategy
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._sortStrategy;
            },
            /**
             * Sets the column `sortStrategy`.
             * ```typescript
             * this.column.sortStrategy = new CustomSortingStrategy().
             * class CustomSortingStrategy extends SortingStrategy {...}
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (classRef) {
                this._sortStrategy = classRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "groupingComparer", {
            /**
            * Gets the function that compares values for grouping.
            * ```typescript
            * let groupingComparer = this.column.groupingComparer'
            * ```
            * @memberof IgxColumnComponent
            */
            get: function () {
                return this._groupingComparer;
            },
            /**
             * Sets a custom function to compare values for grouping.
             * Subsequent values in the sorted data that the function returns 0 for are grouped.
             * ```typescript
             * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (funcRef) {
                this._groupingComparer = funcRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "defaultMinWidth", {
            /**
             * Gets the default minimum `width` of the column.
             * ```typescript
             * let defaultMinWidth =  this.column.defaultMinWidth;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                if (!this.grid) {
                    return '80';
                }
                switch (this.grid.displayDensity) {
                    case exports.DisplayDensity.cosy:
                        return '64';
                    case exports.DisplayDensity.compact:
                        return '56';
                    default:
                        return '80';
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "grid", {
            /**
             * The reference to the `igx-grid` owner.
             * ```typescript
             * let gridComponent = this.column.grid;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "bodyTemplate", {
            /**
             * Returns a reference to the `bodyTemplate`.
             * ```typescript
             * let bodyTemplate = this.column.bodyTemplate;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._bodyTemplate;
            },
            /**
             * Sets the body template.
             * ```html
             * <ng-template #bodyTemplate igxCell let-val>
             *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
             *       <span> {{val}} </span>
             *    </div>
             * </ng-template>
             * ```
             * ```typescript
             * @ViewChild("'bodyTemplate'", {read: TemplateRef })
             * public bodyTemplate: TemplateRef<any>;
             * this.column.bodyTemplate = this.bodyTemplate;
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (template) {
                this._bodyTemplate = template;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "headerTemplate", {
            /**
             * Returns a reference to the header template.
             * ```typescript
             * let headerTemplate = this.column.headerTemplate;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._headerTemplate;
            },
            /**
             * Sets the header template.
             * Note that the column header height is fixed and any content bigger than it will be cut off.
             * ```html
             * <ng-template #headerTemplate>
             *   <div style = "background-color:black" (click) = "changeColor(val)">
             *       <span style="color:red" >{{column.field}}</span>
             *   </div>
             * </ng-template>
             * ```
             * ```typescript
             * @ViewChild("'headerTemplate'", {read: TemplateRef })
             * public headerTemplate: TemplateRef<any>;
             * this.column.headerTemplate = this.headerTemplate;
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (template) {
                this._headerTemplate = template;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "inlineEditorTemplate", {
            /**
             * Returns a reference to the inline editor template.
             * ```typescript
             * let inlineEditorTemplate = this.column.inlineEditorTemplate;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._inlineEditorTemplate;
            },
            /**
             * Sets the inline editor template.
             * ```html
             * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
             *     <input type="string" [(ngModel)]="cell.value"/>
             * </ng-template>
             * ```
             * ```typescript
             * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
             * public inlineEditorTemplate: TemplateRef<any>;
             * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (template) {
                this._inlineEditorTemplate = template;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "filterCellTemplate", {
            /**
             * Returns a reference to the `filterCellTemplate`.
             * ```typescript
             * let filterCellTemplate = this.column.filterCellTemplate;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this._filterCellTemplate;
            },
            /**
             * Sets the quick filter template.
             * ```html
             * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
             *    <input (input)="onInput()">
             * </ng-template>
             * ```
             * ```typescript
             * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
             * public filterCellTemplate: TemplateRef<any>;
             * this.column.filterCellTemplate = this.filterCellTemplate;
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (template) {
                this._filterCellTemplate = template;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "cells", {
            /**
             * Gets the cells of the column.
             * ```typescript
             * let columnCells =  this.column.cells;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                var _this = this;
                return this.grid.rowList.filter(function (row) { return row instanceof IgxRowDirective; })
                    .map(function (row) {
                    if (row.cells) {
                        return row.cells.filter(function (cell) { return cell.columnIndex === _this.index; });
                    }
                }).reduce(function (a, b) { return a.concat(b); }, []);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "visibleIndex", {
            /**
             * Gets the column visible index.
             * If the column is not visible, returns `-1`.
             * ```typescript
             * let visibleColumnIndex =  this.column.visibleIndex;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                var _this = this;
                if (!isNaN(this._vIndex)) {
                    return this._vIndex;
                }
                var unpinnedColumns = this.grid.unpinnedColumns.filter(function (c) { return !c.columnGroup; });
                var pinnedColumns = this.grid.pinnedColumns.filter(function (c) { return !c.columnGroup; });
                var col = this;
                var vIndex = -1;
                if (this.columnGroup) {
                    col = this.allChildren.filter(function (c) { return !c.columnGroup; })[0];
                }
                if (this.columnLayoutChild) {
                    return this.parent.childrenVisibleIndexes.find(function (x) { return x.column === _this; }).index;
                }
                if (!this.pinned) {
                    var indexInCollection = unpinnedColumns.indexOf(col);
                    vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
                }
                else {
                    vIndex = pinnedColumns.indexOf(col);
                }
                this._vIndex = vIndex;
                return vIndex;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "columnGroup", {
            /**
             * Returns a boolean indicating if the column is a `ColumnGroup`.
             * ```typescript
             * let columnGroup =  this.column.columnGroup;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "columnLayout", {
            /**
             * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
             * ```typescript
             * let columnGroup =  this.column.columnGroup;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "columnLayoutChild", {
            /**
            * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
            * ```typescript
            * let columnLayoutChild =  this.column.columnLayoutChild;
            * ```
            * @memberof IgxColumnComponent
            */
            get: function () {
                return this.parent && this.parent.columnLayout;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "allChildren", {
            /**
             * Returns the children columns collection.
             * Returns an empty array if the column does not contain children columns.
             * ```typescript
             * let childrenColumns =  this.column.allChildren;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "level", {
            /**
             * Returns the level of the column in a column group.
             * Returns `0` if the column doesn't have a `parent`.
             * ```typescript
             * let columnLevel =  this.column.level;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                var ptr = this.parent;
                var lvl = 0;
                while (ptr) {
                    lvl++;
                    ptr = ptr.parent;
                }
                return lvl;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "isLastPinned", {
            get: function () {
                return this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "gridRowSpan", {
            get: function () {
                return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "gridColumnSpan", {
            get: function () {
                return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "visibleWhenCollapsed", {
            get: function () {
                return this._visibleWhenCollapsed;
            },
            /**
             * Indicates whether the column will be visible when its parent is collapsed.
             * ```html
             * <igx-column-group>
             *   <igx-column [visibleWhenCollapsed]="true"></igx-column>
             * </igx-column-group>
             * ```
             * @memberof IgxColumnComponent
             */
            set: function (value) {
                this._visibleWhenCollapsed = value;
                this.visibleWhenCollapsedChange.emit(this._visibleWhenCollapsed);
                if (this.parent) {
                    this.parent.setExpandCollapseState();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "filteringExpressionsTree", {
            /**
             * Returns the filteringExpressionsTree of the column.
             * ```typescript
             * let tree =  this.column.filteringExpressionsTree;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return this.grid.filteringExpressionsTree.find(this.field);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "isPrimaryColumn", {
            /**
             * @hidden
             */
            get: function () {
                return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxColumnComponent.prototype.resetCaches = function () {
            this._vIndex = NaN;
            if (this.grid) {
                this.cacheCalcWidth();
            }
        };
        /**
         *@hidden
         */
        IgxColumnComponent.prototype.ngAfterContentInit = function () {
            if (this.cellTemplate) {
                this._bodyTemplate = this.cellTemplate.template;
            }
            if (this.headTemplate && this.headTemplate.length) {
                this._headerTemplate = this.headTemplate.toArray()[0].template;
            }
            if (this.editorTemplate) {
                this._inlineEditorTemplate = this.editorTemplate.template;
            }
            if (this.filterCellTemplateDirective) {
                this._filterCellTemplate = this.filterCellTemplateDirective.template;
            }
            if (!this.summaries) {
                switch (this.dataType) {
                    case exports.DataType.String:
                    case exports.DataType.Boolean:
                        this.summaries = IgxSummaryOperand;
                        break;
                    case exports.DataType.Number:
                        this.summaries = IgxNumberSummaryOperand;
                        break;
                    case exports.DataType.Date:
                        this.summaries = IgxDateSummaryOperand;
                        break;
                    default:
                        this.summaries = IgxSummaryOperand;
                        break;
                }
            }
            if (!this.filters) {
                switch (this.dataType) {
                    case exports.DataType.Boolean:
                        this.filters = IgxBooleanFilteringOperand.instance();
                        break;
                    case exports.DataType.Number:
                        this.filters = IgxNumberFilteringOperand.instance();
                        break;
                    case exports.DataType.Date:
                        this.filters = IgxDateFilteringOperand.instance();
                        break;
                    case exports.DataType.String:
                    default:
                        this.filters = IgxStringFilteringOperand.instance();
                        break;
                }
            }
        };
        /**
         * @hidden
         */
        IgxColumnComponent.prototype.getGridTemplate = function (isRow, isIE) {
            if (isRow) {
                var rowsCount = this.grid.multiRowLayoutRowSize;
                return isIE ?
                    "(1fr)[" + rowsCount + "]" :
                    "repeat(" + rowsCount + ",1fr)";
            }
            else {
                return this.getColumnSizesString(this.children);
            }
        };
        IgxColumnComponent.prototype.getInitialChildColumnSizes = function (children) {
            var _this = this;
            var columnSizes = [];
            // find the smallest col spans
            children.forEach(function (col) {
                if (!col.colStart) {
                    return;
                }
                var newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
                var newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
                var bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
                var bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
                if (columnSizes[col.colStart - 1] === undefined) {
                    // If nothing is defined yet take any column at first
                    // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                    columnSizes[col.colStart - 1] = {
                        ref: col,
                        width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                        colSpan: col.gridColumnSpan,
                        colEnd: col.colStart + col.gridColumnSpan,
                        widthSetByUser: col.widthSetByUser
                    };
                }
                else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                    // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                    /**
                     *  If replaced column has bigger span, we want to fill the remaining columns
                     *  that the replacing column does not fill with the old one.
                     **/
                    if (bothWidthsSet && newSpanSmaller) {
                        // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                        // We have not yet replaced it so we can use it directly from the columnSizes collection.
                        // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                        for (var i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                            if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                                columnSizes[i] = columnSizes[col.colStart - 1];
                            }
                            else {
                                break;
                            }
                        }
                    }
                    // Replace the old column with the new one.
                    columnSizes[col.colStart - 1] = {
                        ref: col,
                        width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                        colSpan: col.gridColumnSpan,
                        colEnd: col.colStart + col.gridColumnSpan,
                        widthSetByUser: col.widthSetByUser
                    };
                }
                else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                    // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                    // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                    // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                    for (var i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = {
                                ref: col,
                                width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                                colSpan: col.gridColumnSpan,
                                colEnd: col.colStart + col.gridColumnSpan,
                                widthSetByUser: col.widthSetByUser
                            };
                        }
                        else {
                            break;
                        }
                    }
                }
            });
            // Flatten columnSizes so there are not columns with colSpan > 1
            for (var i = 0; i < columnSizes.length; i++) {
                if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                    var j = 1;
                    // Replace all empty places depending on how much the current column spans starting from next col.
                    for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                        if (columnSizes[i + j] &&
                            ((!columnSizes[i].width && columnSizes[i + j].width) ||
                                (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                                (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                            // If we reach an already defined column that has width and the current doesn't have or
                            // if the reached column has bigger colSpan we stop.
                            break;
                        }
                        else {
                            var width = columnSizes[i].widthSetByUser ?
                                columnSizes[i].width / columnSizes[i].colSpan :
                                columnSizes[i].width;
                            columnSizes[i + j] = {
                                ref: columnSizes[i].ref,
                                width: width,
                                colSpan: 1,
                                colEnd: columnSizes[i].colEnd,
                                widthSetByUser: columnSizes[i].widthSetByUser
                            };
                        }
                    }
                    // Update the current column width so it is divided between all columns it spans and set it to 1.
                    columnSizes[i].width = columnSizes[i].widthSetByUser ?
                        columnSizes[i].width / columnSizes[i].colSpan :
                        columnSizes[i].width;
                    columnSizes[i].colSpan = 1;
                    // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                    i += j - 1;
                }
            }
            return columnSizes;
        };
        IgxColumnComponent.prototype.getFilledChildColumnSizes = function (children) {
            var columnSizes = this.getInitialChildColumnSizes(children);
            // fill the gaps if there are any
            var result = [];
            for (var i = 0; i < columnSizes.length; i++) {
                if (columnSizes[i] && !!columnSizes[i].width) {
                    result.push(columnSizes[i].width + 'px');
                }
                else {
                    result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
                }
            }
            return result;
        };
        IgxColumnComponent.prototype.getColumnSizesString = function (children) {
            var res = this.getFilledChildColumnSizes(children);
            return res.join(' ');
        };
        IgxColumnComponent.prototype.getResizableColUnderEnd = function () {
            if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
                return [{ target: this, spanUsed: 1 }];
            }
            var columnSized = this.getInitialChildColumnSizes(this.parent.children);
            var targets = [];
            var colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
            for (var i = 0; i < columnSized.length; i++) {
                if (this.colStart <= i + 1 && i + 1 < colEnd) {
                    targets.push({ target: columnSized[i].ref, spanUsed: 1 });
                }
            }
            var targetsSquashed = [];
            for (var j = 0; j < targets.length; j++) {
                if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === targets[j].target.field) {
                    targetsSquashed[targetsSquashed.length - 1].spanUsed++;
                }
                else {
                    targetsSquashed.push(targets[j]);
                }
            }
            return targetsSquashed;
        };
        /**
         * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
         * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
         * Column cannot be pinned if:
         * - Is already pinned
         * - index argument is out of range
         * - The pinned area exceeds 80% of the grid width
         * ```typescript
         * let success = this.column.pin();
         * ```
         * @memberof IgxColumnComponent
         */
        IgxColumnComponent.prototype.pin = function (index) {
            // TODO: Probably should the return type of the old functions
            // should be moved as a event parameter.
            if (this.grid) {
                this.grid.endEdit(true);
            }
            if (this._pinned) {
                return false;
            }
            if (this.parent && !this.parent.pinned) {
                return this.topLevelParent.pin(index);
            }
            var grid = this.grid;
            var hasIndex = index !== undefined;
            if (hasIndex && (index < 0 || index >= grid.pinnedColumns.length)) {
                return false;
            }
            if (!this.parent && !this.pinnable) {
                return false;
            }
            this._pinned = true;
            this.pinnedChange.emit(this._pinned);
            this._unpinnedIndex = grid._unpinnedColumns.indexOf(this);
            index = index !== undefined ? index : grid._pinnedColumns.length;
            var targetColumn = grid._pinnedColumns[index];
            var args = { column: this, insertAtIndex: index, isPinned: true };
            grid.onColumnPinning.emit(args);
            if (grid._pinnedColumns.indexOf(this) === -1) {
                grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
                if (grid._unpinnedColumns.indexOf(this) !== -1) {
                    grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1);
                }
            }
            if (hasIndex) {
                grid._moveColumns(this, targetColumn);
            }
            if (this.columnGroup) {
                this.allChildren.forEach(function (child) { return child.pin(); });
                grid.reinitPinStates();
            }
            grid.resetCaches();
            grid.notifyChanges();
            if (this.columnLayoutChild) {
                this.grid.columns.filter(function (x) { return x.columnLayout; }).forEach(function (x) { return x.populateVisibleIndexes(); });
            }
            this.grid.filteringService.refreshExpressions();
            return true;
        };
        /**
         * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
         * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
         * Column cannot be unpinned if:
         * - Is already unpinned
         * - index argument is out of range
         * ```typescript
         * let success = this.column.unpin();
         * ```
         * @memberof IgxColumnComponent
         */
        IgxColumnComponent.prototype.unpin = function (index) {
            if (this.grid) {
                this.grid.endEdit(true);
            }
            if (!this._pinned) {
                return false;
            }
            if (this.parent && this.parent.pinned) {
                return this.topLevelParent.unpin(index);
            }
            var grid = this.grid;
            var hasIndex = index !== undefined;
            if (hasIndex && (index < 0 || index >= grid._unpinnedColumns.length)) {
                return false;
            }
            index = (index !== undefined ? index :
                this._unpinnedIndex !== undefined ? this._unpinnedIndex : this.index);
            this._pinned = false;
            this.pinnedChange.emit(this._pinned);
            var targetColumn = grid._unpinnedColumns[index];
            grid._unpinnedColumns.splice(index, 0, this);
            if (grid._pinnedColumns.indexOf(this) !== -1) {
                grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
            }
            if (hasIndex) {
                grid._moveColumns(this, targetColumn);
            }
            if (this.columnGroup) {
                this.allChildren.forEach(function (child) { return child.unpin(); });
            }
            grid.reinitPinStates();
            grid.resetCaches();
            var insertAtIndex = grid._unpinnedColumns.indexOf(this);
            var args = { column: this, insertAtIndex: insertAtIndex, isPinned: false };
            grid.onColumnPinning.emit(args);
            grid.notifyChanges();
            if (this.columnLayoutChild) {
                this.grid.columns.filter(function (x) { return x.columnLayout; }).forEach(function (x) { return x.populateVisibleIndexes(); });
            }
            this.grid.filteringService.refreshExpressions();
            return true;
        };
        Object.defineProperty(IgxColumnComponent.prototype, "topLevelParent", {
            /**
             * Returns a reference to the top level parent column.
             * ```typescript
             * let topLevelParent =  this.column.topLevelParent;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                var parent = this.parent;
                while (parent && parent.parent) {
                    parent = parent.parent;
                }
                return parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "headerCell", {
            /**
             * Returns a reference to the header of the column.
             * ```typescript
             * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
             * let headerCell = column.headerCell;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                var _this = this;
                return this.grid.headerCellList.find(function (header) { return header.column === _this; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "filterCell", {
            /**
            * Returns a reference to the filter cell of the column.
            * ```typescript
            * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
            * let filterell = column.filterell;
            * ```
            * @memberof IgxColumnComponent
            */
            get: function () {
                var _this = this;
                return this.grid.filterCellList.find(function (filterCell) { return filterCell.column === _this; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnComponent.prototype, "headerGroup", {
            /**
             * Returns a reference to the header group of the column.
             * @memberof IgxColumnComponent
             */
            get: function () {
                var _this = this;
                return this.grid.headerGroupsList.find(function (headerGroup) { return headerGroup.column === _this; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Autosize the column to the longest currently visible cell value, including the header cell.
         * ```typescript
         * @ViewChild('grid') grid: IgxGridComponent;
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * column.autosize();
         * ```
         * @memberof IgxColumnComponent
         */
        IgxColumnComponent.prototype.autosize = function () {
            if (!this.columnGroup) {
                this.width = this.getLargestCellWidth();
                this.grid.reflow();
            }
        };
        /**
         * @hidden
         */
        IgxColumnComponent.prototype.getCalcWidth = function () {
            if (this._calcWidth !== null && !isNaN(this.calcPixelWidth)) {
                return this._calcWidth;
            }
            this.cacheCalcWidth();
            return this._calcWidth;
        };
        /**
         * @hidden
         * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
         * ```typescript
         * @ViewChild('grid') grid: IgxGridComponent;
         *
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let size = column.getLargestCellWidth();
         * ```
         * @memberof IgxColumnComponent
         */
        IgxColumnComponent.prototype.getLargestCellWidth = function () {
            var range = this.grid.document.createRange();
            var largest = new Map();
            if (this.cells.length > 0) {
                var cellsContentWidths_1 = [];
                if (this.cells[0].nativeElement.children.length > 0) {
                    this.cells.forEach(function (cell) { return cellsContentWidths_1.push(cell.calculateSizeToFit(range)); });
                }
                else {
                    cellsContentWidths_1 = this.cells.map(function (cell) { return getNodeSizeViaRange(range, cell.nativeElement); });
                }
                var index = cellsContentWidths_1.indexOf(Math.max.apply(Math, __spread(cellsContentWidths_1)));
                var cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
                var cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                    parseFloat(cellStyle.borderRightWidth);
                largest.set(Math.max.apply(Math, __spread(cellsContentWidths_1)), cellPadding);
            }
            if (this.headerCell) {
                var headerCell = void 0;
                if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
                    headerCell = Math.max.apply(Math, __spread(Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                        .map(function (child) { return getNodeSizeViaRange(range, child); })));
                }
                else {
                    headerCell = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
                }
                if (this.sortable || this.filterable) {
                    headerCell += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
                }
                var headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
                var headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
                    parseFloat(headerStyle.borderRightWidth);
                largest.set(headerCell, headerPadding);
            }
            var largestCell = Math.max.apply(Math, __spread(Array.from(largest.keys())));
            var width = Math.ceil(largestCell + largest.get(largestCell));
            if (Number.isNaN(width)) {
                return this.width;
            }
            else {
                return width + 'px';
            }
        };
        /**
         *@hidden
         */
        IgxColumnComponent.prototype.getCellWidth = function () {
            var colWidth = this.width;
            var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (this.columnLayoutChild) {
                return '';
            }
            if (colWidth && !isPercentageWidth) {
                var cellWidth = colWidth;
                if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                    cellWidth += 'px';
                }
                return cellWidth;
            }
            else {
                return colWidth;
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxColumnComponent.prototype.cacheCalcWidth = function () {
            var grid = this.gridAPI.grid;
            var colWidth = this.width;
            var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (isPercentageWidth) {
                this._calcWidth = parseInt(colWidth, 10) / 100 * (grid.calcWidth - grid.featureColumnsWidth());
            }
            else if (!colWidth) {
                // no width
                this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
            }
            else {
                this._calcWidth = this.width;
            }
            this.calcPixelWidth = parseInt(this._calcWidth, 10);
        };
        /**
         * @hidden
         * @internal
         */
        IgxColumnComponent.prototype.setExpandCollapseState = function () {
            var _this = this;
            this.children.filter(function (col) { return (col.visibleWhenCollapsed !== undefined); }).forEach(function (c) {
                if (!_this.collapsible) {
                    c.hidden = _this.hidden;
                    return;
                }
                c.hidden = _this._expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
            });
        };
        /**
        * @hidden
        * @internal
        */
        IgxColumnComponent.prototype.checkCollapsibleState = function () {
            if (!this.children) {
                return false;
            }
            var cols = this.children.map(function (child) { return child.visibleWhenCollapsed; });
            return (cols.some(function (c) { return c === true; }) && cols.some(function (c) { return c === false; }));
        };
        Object.defineProperty(IgxColumnComponent.prototype, "pinnable", {
            /**
             *@hidden
            */
            get: function () {
                return this.grid._init || !this.pinned;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxColumnComponent.prototype.populateVisibleIndexes = function () { };
        IgxColumnComponent.ctorParameters = function () { return [
            { type: GridBaseAPIService },
            { type: core.ChangeDetectorRef },
            { type: IgxRowIslandAPIService }
        ]; };
        __decorate([
            core.Input()
        ], IgxColumnComponent.prototype, "field", void 0);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "header", void 0);
        __decorate([
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "sortable", void 0);
        __decorate([
            notifyChanges(true),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "groupable", void 0);
        __decorate([
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "editable", null);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "filterable", void 0);
        __decorate([
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "resizable", void 0);
        __decorate([
            notifyChanges(true),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "hasSummary", null);
        __decorate([
            notifyChanges(true),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "hidden", null);
        __decorate([
            core.Output()
        ], IgxColumnComponent.prototype, "hiddenChange", void 0);
        __decorate([
            core.Output()
        ], IgxColumnComponent.prototype, "expandedChange", void 0);
        __decorate([
            core.Output()
        ], IgxColumnComponent.prototype, "collapsibleChange", void 0);
        __decorate([
            core.Output()
        ], IgxColumnComponent.prototype, "visibleWhenCollapsedChange", void 0);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "disableHiding", void 0);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "disablePinning", void 0);
        __decorate([
            WatchColumnChanges(),
            notifyChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "movable", void 0);
        __decorate([
            notifyChanges(true),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "width", null);
        __decorate([
            core.Output()
        ], IgxColumnComponent.prototype, "widthChange", void 0);
        __decorate([
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "maxWidth", void 0);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "minWidth", null);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "headerClasses", void 0);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "cellClasses", void 0);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "cellStyles", void 0);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "formatter", void 0);
        __decorate([
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
        __decorate([
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
        __decorate([
            core.Input()
        ], IgxColumnComponent.prototype, "dataType", void 0);
        __decorate([
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "pinned", null);
        __decorate([
            core.Output()
        ], IgxColumnComponent.prototype, "pinnedChange", void 0);
        __decorate([
            DeprecateProperty("The property is deprecated. Please, use `column.grid.id` instead.")
        ], IgxColumnComponent.prototype, "gridID", void 0);
        __decorate([
            notifyChanges(true),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "summaries", null);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "searchable", void 0);
        __decorate([
            core.Input()
        ], IgxColumnComponent.prototype, "filters", null);
        __decorate([
            core.Input()
        ], IgxColumnComponent.prototype, "sortStrategy", null);
        __decorate([
            core.Input()
        ], IgxColumnComponent.prototype, "groupingComparer", null);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input('cellTemplate')
        ], IgxColumnComponent.prototype, "bodyTemplate", null);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input()
        ], IgxColumnComponent.prototype, "headerTemplate", null);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input('cellEditorTemplate')
        ], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
        __decorate([
            notifyChanges(),
            WatchColumnChanges(),
            core.Input('filterCellTemplate')
        ], IgxColumnComponent.prototype, "filterCellTemplate", null);
        __decorate([
            core.Input('collapsibleIndicatorTemplate')
        ], IgxColumnComponent.prototype, "collapsibleIndicatorTemplate", void 0);
        __decorate([
            core.Input()
        ], IgxColumnComponent.prototype, "rowEnd", void 0);
        __decorate([
            core.Input()
        ], IgxColumnComponent.prototype, "colEnd", void 0);
        __decorate([
            core.Input()
        ], IgxColumnComponent.prototype, "rowStart", void 0);
        __decorate([
            core.Input()
        ], IgxColumnComponent.prototype, "colStart", void 0);
        __decorate([
            notifyChanges(true),
            core.Input()
        ], IgxColumnComponent.prototype, "visibleWhenCollapsed", null);
        __decorate([
            core.ContentChild(IgxCellTemplateDirective, { read: IgxCellTemplateDirective })
        ], IgxColumnComponent.prototype, "cellTemplate", void 0);
        __decorate([
            core.ContentChildren(IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false })
        ], IgxColumnComponent.prototype, "headTemplate", void 0);
        __decorate([
            core.ContentChild(IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective })
        ], IgxColumnComponent.prototype, "editorTemplate", void 0);
        __decorate([
            core.ContentChild(IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective })
        ], IgxColumnComponent.prototype, "filterCellTemplateDirective", void 0);
        __decorate([
            core.ContentChild(IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false })
        ], IgxColumnComponent.prototype, "collapseIndicatorTemplate", void 0);
        IgxColumnComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-column',
                template: ""
            })
        ], IgxColumnComponent);
        return IgxColumnComponent;
    }());

    var IgxGridBodyDirective = /** @class */ (function () {
        function IgxGridBodyDirective() {
        }
        IgxGridBodyDirective = __decorate([
            core.Directive({
                selector: '[igxGridBody]',
                providers: [IgxForOfSyncService]
            })
        ], IgxGridBodyDirective);
        return IgxGridBodyDirective;
    }());
    /**
     * @hidden
     */
    var RowEditPositionStrategy = /** @class */ (function (_super) {
        __extends(RowEditPositionStrategy, _super);
        function RowEditPositionStrategy() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.isTop = false;
            _this.isTopInitialPosition = null;
            return _this;
        }
        RowEditPositionStrategy.prototype.position = function (contentElement, size, document, initialCall) {
            var container = this.settings.container; // grid.tbody
            var target = this.settings.target; // current grid.row
            // Position of the overlay depends on the available space in the grid.
            // If the bottom space is not enough then the the row overlay will show at the top of the row.
            // Once shown, either top or bottom, then this position stays until the overlay is closed (isTopInitialPosition property),
            // which means that when scrolling then overlay may hide, while the row is still visible (UX requirement).
            this.isTop = this.isTopInitialPosition !== null ?
                this.isTopInitialPosition :
                container.getBoundingClientRect().bottom <
                    target.getBoundingClientRect().bottom + contentElement.getBoundingClientRect().height;
            // Set width of the row editing overlay to equal row width, otherwise it fits 100% of the grid.
            contentElement.style.width = target.clientWidth + 'px';
            this.settings.verticalStartPoint = this.settings.verticalDirection = this.isTop ? exports.VerticalAlignment.Top : exports.VerticalAlignment.Bottom;
            this.settings.openAnimation = this.isTop ? scaleInVerBottom : scaleInVerTop;
            _super.prototype.position.call(this, contentElement, { width: target.clientWidth, height: target.clientHeight }, document, initialCall);
        };
        return RowEditPositionStrategy;
    }(ConnectedPositioningStrategy));

    /**
     *@hidden
     */
    var ItemPropertyValueChangedDirective = /** @class */ (function () {
        function ItemPropertyValueChangedDirective(propName) {
            this.valueChanged = new core.EventEmitter();
            this._propName = propName;
        }
        Object.defineProperty(ItemPropertyValueChangedDirective.prototype, "object", {
            get: function () {
                return this._object;
            },
            set: function (value) {
                if (value) {
                    this._object = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemPropertyValueChangedDirective.prototype, "value", {
            get: function () {
                return (this.object) ? this.object[this._propName] : null;
            },
            set: function (value) {
                this.onValueChanged(value);
            },
            enumerable: true,
            configurable: true
        });
        ItemPropertyValueChangedDirective.prototype.onValueChanged = function (value) {
            var currentValue = this.value;
            if (value !== currentValue) {
                this.object[this._propName] = value;
                this.valueChanged.emit({ oldValue: currentValue, newValue: value });
            }
        };
        ItemPropertyValueChangedDirective.ctorParameters = function () { return [
            { type: String }
        ]; };
        __decorate([
            core.Input()
        ], ItemPropertyValueChangedDirective.prototype, "value", null);
        __decorate([
            core.Output()
        ], ItemPropertyValueChangedDirective.prototype, "valueChanged", void 0);
        ItemPropertyValueChangedDirective = __decorate([
            core.Directive()
        ], ItemPropertyValueChangedDirective);
        return ItemPropertyValueChangedDirective;
    }());
    /** @hidden */
    var ColumnChooserItemBaseDirective = /** @class */ (function (_super) {
        __extends(ColumnChooserItemBaseDirective, _super);
        function ColumnChooserItemBaseDirective(prop) {
            var _this = _super.call(this, prop) || this;
            _this.prop = prop;
            _this.indentation = 30;
            return _this;
        }
        Object.defineProperty(ColumnChooserItemBaseDirective.prototype, "column", {
            get: function () {
                return this.object;
            },
            set: function (value) {
                if (value) {
                    this.object = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnChooserItemBaseDirective.prototype, "name", {
            get: function () {
                return (this.column) ? ((this.column.header) ? this.column.header : this.column.field) : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnChooserItemBaseDirective.prototype, "level", {
            get: function () {
                return this.column.level;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnChooserItemBaseDirective.prototype, "calcIndent", {
            get: function () {
                return this.indentation * this.level;
            },
            enumerable: true,
            configurable: true
        });
        ColumnChooserItemBaseDirective.ctorParameters = function () { return [
            { type: String }
        ]; };
        __decorate([
            core.Input()
        ], ColumnChooserItemBaseDirective.prototype, "column", null);
        __decorate([
            core.Input()
        ], ColumnChooserItemBaseDirective.prototype, "indentation", void 0);
        __decorate([
            core.Input()
        ], ColumnChooserItemBaseDirective.prototype, "container", void 0);
        ColumnChooserItemBaseDirective = __decorate([
            core.Directive()
        ], ColumnChooserItemBaseDirective);
        return ColumnChooserItemBaseDirective;
    }(ItemPropertyValueChangedDirective));

    /** @hidden */
    var IgxColumnHidingItemDirective = /** @class */ (function (_super) {
        __extends(IgxColumnHidingItemDirective, _super);
        function IgxColumnHidingItemDirective() {
            return _super.call(this, 'hidden') || this;
        }
        Object.defineProperty(IgxColumnHidingItemDirective.prototype, "disabled", {
            get: function () {
                return this.column.disableHiding;
            },
            enumerable: true,
            configurable: true
        });
        IgxColumnHidingItemDirective = __decorate([
            core.Directive({
                selector: '[igxColumnHidingItem]'
            })
        ], IgxColumnHidingItemDirective);
        return IgxColumnHidingItemDirective;
    }(ColumnChooserItemBaseDirective));

    var CustomFilteringStrategy = /** @class */ (function (_super) {
        __extends(CustomFilteringStrategy, _super);
        function CustomFilteringStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CustomFilteringStrategy.prototype.filter = function (data, expressionsTree) {
            var _this = this;
            var res = [];
            data.forEach(function (item) {
                if (_this.matchRecord(item, expressionsTree.filteringOperands[0])) {
                    res.push(item);
                }
                else if (item.column.columnGroup) {
                    if (item.column.allChildren.findIndex(function (child) {
                        return _this.matchRecord(child, expressionsTree.filteringOperands[1]) ||
                            _this.matchRecord(child, expressionsTree.filteringOperands[2]);
                    }) > -1) {
                        res.push(item);
                    }
                }
            });
            return res;
        };
        return CustomFilteringStrategy;
    }(FilteringStrategy));
    /** @hidden */
    var ColumnChooserBaseDirective = /** @class */ (function () {
        function ColumnChooserBaseDirective(cdr) {
            this.cdr = cdr;
            /**
             * Hides/ shows the filtering columns input from the UI.
             */
            this.disableFilter = false;
            /**
             * Access to the columnHidingUI:
             * ```typescript
             * @ViewChild('column-hiding-component')
             *  public columnHidingUI: IgxColumnHidingComponent;
             * ```
             * Sets/gets the max height of the column area.
             * ```typescript
             * let columnsAreaMaxHeight =  this.columnHidingUI.columnsAreaMaxHeight;
             * ```
             *
             * ```html
             * <igx-column-hiding [columnsAreaMaxHeight]="200px"></igx-column-hiding>
             * ```
             */
            this.columnsAreaMaxHeight = '100%';
            /**
             * Sets/Gets the css class selector.
             * By default the value of the `class` attribute is `"igx-column-hiding"`.
             * ```typescript
             * let cssCLass =  this.columnHidingUI.cssClass;
             * ```
             * ```typescript
             * this.columnHidingUI.cssClass = 'column-chooser';
             * ```
             */
            this.cssClass = 'igx-column-hiding';
            /**
             *@hidden
             */
            this._currentColumns = [];
            /**
             *@hidden
             */
            this._gridColumns = [];
            /**
             *@hidden
             */
            this._rawColumns = [];
            /**
             *@hidden
             */
            this._columnDisplayOrder = exports.ColumnDisplayOrder.DisplayOrder;
            /**
             *@hidden
             */
            this._filterCriteria = '';
            /**
             *@hidden
             */
            this._filterColumnsPrompt = '';
            /**
             *@hidden
             */
            this._title = '';
        }
        Object.defineProperty(ColumnChooserBaseDirective.prototype, "columns", {
            /**
             * Gets the grid columns that are going to be manipulated.
             * ```typescript
             * let gridColumns = this.columnHidingUI.columns;
             * ```
             */
            get: function () {
                return this._gridColumns;
            },
            /**
             * Sets the the grid columns that are going to be manipulated.
             * ```html
             * <igx-column-hiding [columns]="grid.columns"></igx-column-hiding>
             * ```
             */
            set: function (value) {
                if (value) {
                    this._gridColumns = value;
                    this.createColumnItems();
                    if (this.filterCriteria) {
                        this.filter();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnChooserBaseDirective.prototype, "title", {
            /**
             * Sets/gets the title of the column chooser.
             * ```typescript
             * let title =  this.columnHidingUI.title;
             * ```
             */
            get: function () {
                return this._title;
            },
            /**
             * ```html
             * <igx-column-hiding [title]="'IgxColumnHidingComponent Title'"></igx-column-hiding>
             * ```
             */
            set: function (value) {
                this._title = (value) ? value : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnChooserBaseDirective.prototype, "filterColumnsPrompt", {
            /**
             * Gets the prompt that is displayed in the filter input.
             * ```typescript
             * let filterColumnsPrompt =  this.columnHidingUI.filterColumnsPrompt;
             * ```
             */
            get: function () {
                return this._filterColumnsPrompt;
            },
            /**
             * Sets the prompt that is going to be displayed in the filter input.
             * ```html
             * <igx-column-hiding [filterColumnsPrompt]="'Type here to search'"></igx-column-hiding>
             * ```
             */
            set: function (value) {
                this._filterColumnsPrompt = (value) ? value : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnChooserBaseDirective.prototype, "columnItems", {
            /**
             * Gets the items of the selected columns.
             * ```typescript
             * let columnItems =  this.columnHidingUI.columnItems;
             * ```
             */
            get: function () {
                return this._currentColumns;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnChooserBaseDirective.prototype, "filterCriteria", {
            /**
             * Gets the value which filters the columns list.
             * ```typescript
             * let filterCriteria =  this.columnHidingUI.filterCriteria;
             * ```
             */
            get: function () {
                return this._filterCriteria;
            },
            /**
             * Sets the value which filters the columns list.
             * ```html
             *  <igx-column-hiding [filterCriteria]="'ID'"></igx-column-hiding>
             * ```
             */
            set: function (value) {
                if (!value || value.length === 0) {
                    this.clearFiltering();
                    this._filterCriteria = '';
                    this.cdr.detectChanges();
                    return;
                }
                else if (this._filterCriteria && this._filterCriteria.length > value.length) {
                    this.clearFiltering();
                }
                this._filterCriteria = value;
                this.filter();
                this.cdr.detectChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColumnChooserBaseDirective.prototype, "columnDisplayOrder", {
            /**
             * Gets the display order of the columns.
             * ```typescript
             * let columnDisplayOrder  =  this.columnHidingUI.columnDisplayOrder;
             * ```
             */
            get: function () {
                return this._columnDisplayOrder;
            },
            /**
             * Sets the display order of the columns.
             * ```typescript
             * this.columnHidingUI.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;
             * ```
             */
            set: function (value) {
                if (value !== undefined) {
                    this.orderColumns(value);
                    if (this._filterCriteria.length > 0) {
                        this.filter();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        ColumnChooserBaseDirective.prototype.ngOnDestroy = function () {
            var e_1, _a;
            try {
                for (var _b = __values(this._currentColumns), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    item.valueChanged.unsubscribe();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         *@hidden
         */
        ColumnChooserBaseDirective.prototype.createColumnItems = function () {
            var _this = this;
            if (this._gridColumns.length > 0) {
                this._rawColumns = [];
                this._gridColumns.forEach(function (column) {
                    var item = _this.createColumnItem(_this, column);
                    if (item) {
                        _this._rawColumns.push(item);
                    }
                });
                this._currentColumns = this._rawColumns.slice(0);
                this.orderColumns(this._columnDisplayOrder);
            }
        };
        /**
         *@hidden
         */
        ColumnChooserBaseDirective.prototype.orderColumns = function (value) {
            this._columnDisplayOrder = value;
            if (value === exports.ColumnDisplayOrder[exports.ColumnDisplayOrder.Alphabetical] ||
                value === exports.ColumnDisplayOrder.Alphabetical) {
                this._currentColumns = this._rawColumns.slice(0).sort(function (current, next) {
                    return current.name.toLowerCase().localeCompare(next.name.toLowerCase());
                });
            }
            else {
                this._currentColumns = this._rawColumns;
            }
        };
        /**
         *@hidden
         */
        ColumnChooserBaseDirective.prototype.filter = function () {
            var filteringExpressionsTree = new FilteringExpressionsTree(exports.FilteringLogic.Or);
            filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('name'));
            filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('field'));
            filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('header'));
            var strategy = new CustomFilteringStrategy();
            this._currentColumns = strategy.filter(this._currentColumns, filteringExpressionsTree);
        };
        /**
         *@hidden
         */
        ColumnChooserBaseDirective.prototype.createFilteringExpression = function (fieldName) {
            return {
                condition: IgxStringFilteringOperand.instance().condition('contains'),
                fieldName: fieldName,
                ignoreCase: true,
                searchVal: this._filterCriteria
            };
        };
        /**
         *@hidden
         */
        ColumnChooserBaseDirective.prototype.clearFiltering = function () {
            this.createColumnItems();
        };
        ColumnChooserBaseDirective.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], ColumnChooserBaseDirective.prototype, "columns", null);
        __decorate([
            core.Input()
        ], ColumnChooserBaseDirective.prototype, "title", null);
        __decorate([
            core.Input()
        ], ColumnChooserBaseDirective.prototype, "filterColumnsPrompt", null);
        __decorate([
            core.Input()
        ], ColumnChooserBaseDirective.prototype, "disableFilter", void 0);
        __decorate([
            core.Input()
        ], ColumnChooserBaseDirective.prototype, "columnItems", null);
        __decorate([
            core.Input()
        ], ColumnChooserBaseDirective.prototype, "filterCriteria", null);
        __decorate([
            core.Input()
        ], ColumnChooserBaseDirective.prototype, "columnDisplayOrder", null);
        __decorate([
            core.Input()
        ], ColumnChooserBaseDirective.prototype, "columnsAreaMaxHeight", void 0);
        __decorate([
            core.HostBinding('attr.class')
        ], ColumnChooserBaseDirective.prototype, "cssClass", void 0);
        ColumnChooserBaseDirective = __decorate([
            core.Directive()
        ], ColumnChooserBaseDirective);
        return ColumnChooserBaseDirective;
    }());

    var IgxColumnHidingComponent = /** @class */ (function (_super) {
        __extends(IgxColumnHidingComponent, _super);
        function IgxColumnHidingComponent(cdr) {
            var _this = _super.call(this, cdr) || this;
            _this.cdr = cdr;
            /**
             * Sets/gets the text of the button that shows all columns if they are hidden.
             * ```typescript
             * let showAllButtonText =  this.columnHiding.showAllText;
             * ```
             *
             * ```html
             * <igx-column-hiding [showAllText] = "'Show Columns'"></igx-column-hiding>
             * ```
             * @memberof IgxColumnHidingComponent
             */
            _this.showAllText = 'Show All';
            /**
             * Sets/gets the text of the button that hides all columns if they are shown.
             * ```typescript
             * let hideAllButtonText =  this.columnHiding.hideAllText;
             * ```
             *
             * ```html
             * <igx-column-hiding [hideAllText] = "'Hide Columns'"></igx-column-hiding>
             * ```
             * @memberof IgxColumnHidingComponent
             */
            _this.hideAllText = 'Hide All';
            /**
             * An event that is emitted after the columns visibility is changed.
             * Provides references to the `column` and the `newValue` properties as event arguments.
             * ```html
             *  <igx-column-hiding (onColumnVisibilityChanged) = "onColumnVisibilityChanged($event)"></igx-column-hiding>
             * ```
             * @memberof IgxColumnHidingComponent
             */
            _this.onColumnVisibilityChanged = new core.EventEmitter();
            _this.destroy$ = new rxjs.Subject();
            return _this;
        }
        Object.defineProperty(IgxColumnHidingComponent.prototype, "disableHideAll", {
            /**
             * Returns a boolean indicating whether the `HIDE ALL` button is disabled.
             * ```html
             * <igx-column-hiding #columnHidingUI
             *     [columns]="grid.columns" [title]="'Column Hiding'">
             * </igx-column-hiding>
             * ```
             * ```typescript
             * @ViewChild("'columnHidingUI'")
             * public columnHiding: IgxColumnHidingComponent;
             * let isHideAlldisabled =  this.columnHiding.disableHideAll;
             * ```
             *@memberof IgxColumnHidingComponent
             */
            get: function () {
                if (!this.columnItems || this.columnItems.length < 1 ||
                    this.hiddenColumnsCount === this.columns.length) {
                    return true;
                }
                else if (this.hidableColumns.length < 1 ||
                    this.hidableColumns.length === this.hidableColumns.filter(function (col) { return col.value; }).length) {
                    return true;
                }
                else {
                    return false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnHidingComponent.prototype, "disableShowAll", {
            /**
             * Returns a boolean indicating whether the `SHOW ALL` button is disabled.
             * ```typescript
             * let isShowAlldisabled =  this.columnHiding.disableShowAll;
             * ```
             * @memberof IgxColumnHidingComponent
             */
            get: function () {
                if (!this.columnItems || this.columnItems.length < 1 ||
                    this.hiddenColumnsCount < 1 || this.hidableColumns.length < 1) {
                    return true;
                }
                else if (this.hidableColumns.length === this.hidableColumns.filter(function (col) { return !col.value; }).length) {
                    return true;
                }
                else {
                    return false;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnHidingComponent.prototype, "hiddenColumnsCount", {
            /**
             * Gets the count of the hidden columns.
             * ```typescript
             * let hiddenColumnsCount =  this.columnHiding.hiddenColumnsCount;
             * ```
             * @memberof IgxColumnHidingComponent
             */
            get: function () {
                return (this.columns) ? this.columns.filter(function (col) { return col.hidden; }).length : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnHidingComponent.prototype, "hidableColumns", {
            /**
             *@hidden
             */
            get: function () {
                return this.columnItems.filter(function (col) { return !col.disabled; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxColumnHidingComponent.prototype.createColumnItem = function (container, column) {
            var _this = this;
            if (column.grid.hasColumnLayouts && !column.columnLayout) {
                return null;
            }
            var item = new IgxColumnHidingItemDirective();
            item.container = container;
            item.column = column;
            item.valueChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function (args) {
                _this.onVisibilityChanged({ column: item.column, newValue: args.newValue });
            });
            return item;
        };
        /**
         * Shows all columns in the grid.
         * ```typescript
         * this.columnHiding.showAllColumns();
         * ```
         * @memberof IgxColumnHidingComponent
         */
        IgxColumnHidingComponent.prototype.showAllColumns = function () {
            var e_1, _a;
            var collection = this.hidableColumns;
            try {
                for (var collection_1 = __values(collection), collection_1_1 = collection_1.next(); !collection_1_1.done; collection_1_1 = collection_1.next()) {
                    var col = collection_1_1.value;
                    col.value = false;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (collection_1_1 && !collection_1_1.done && (_a = collection_1.return)) _a.call(collection_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * Hides all columns in the grid.
         * ```typescript
         * this.columnHiding.hideAllColumns();
         * ```
         * @memberof IgxColumnHidingComponent
         */
        IgxColumnHidingComponent.prototype.hideAllColumns = function () {
            var e_2, _a;
            var collection = this.hidableColumns;
            try {
                for (var collection_2 = __values(collection), collection_2_1 = collection_2.next(); !collection_2_1.done; collection_2_1 = collection_2.next()) {
                    var col = collection_2_1.value;
                    col.value = true;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (collection_2_1 && !collection_2_1.done && (_a = collection_2.return)) _a.call(collection_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        };
        /**
         * @hidden
         */
        IgxColumnHidingComponent.prototype.onVisibilityChanged = function (args) {
            this.onColumnVisibilityChanged.emit(args);
        };
        /**
         *@hidden
         */
        IgxColumnHidingComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        IgxColumnHidingComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxColumnHidingComponent.prototype, "disableHideAll", null);
        __decorate([
            core.Input()
        ], IgxColumnHidingComponent.prototype, "disableShowAll", null);
        __decorate([
            core.Input()
        ], IgxColumnHidingComponent.prototype, "showAllText", void 0);
        __decorate([
            core.Input()
        ], IgxColumnHidingComponent.prototype, "hideAllText", void 0);
        __decorate([
            core.Output()
        ], IgxColumnHidingComponent.prototype, "onColumnVisibilityChanged", void 0);
        IgxColumnHidingComponent = __decorate([
            core.Component({
                preserveWhitespaces: false,
                selector: 'igx-column-hiding',
                template: "<div class=\"igx-column-hiding__header\">\n    <h4 class=\"igx-column-hiding__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-hiding__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-hiding__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox\n        *ngFor=\"let columnItem of hidableColumns\"\n        class=\"igx-column-hiding__columns-item\"\n        (onColumnVisibilityChanged)=\"onVisibilityChanged($event)\"\n        (change)=\"columnItem.value = !columnItem.value\"\n        [checked]=\"columnItem.value\"\n        [disabled]=\"columnItem.disabled\"\n        [style.margin-left.px]=\"columnItem.calcIndent\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n\n<div class=\"igx-column-hiding__buttons\">\n    <button igxButton igxRipple (click)=\"showAllColumns()\" [disabled]=\"disableShowAll\">{{ showAllText }}</button>\n    <button igxButton igxRipple (click)=\"hideAllColumns()\" [disabled]=\"disableHideAll\">{{ hideAllText }}</button>\n</div>\n"
            })
        ], IgxColumnHidingComponent);
        return IgxColumnHidingComponent;
    }(ColumnChooserBaseDirective));

    var IgxColumnPinningItemDirective = /** @class */ (function (_super) {
        __extends(IgxColumnPinningItemDirective, _super);
        function IgxColumnPinningItemDirective() {
            return _super.call(this, 'pinned') || this;
        }
        Object.defineProperty(IgxColumnPinningItemDirective.prototype, "pinnable", {
            /**
             * Returns whether a column could be pinned.
             * It's not possible to pin a column if there is not enough space for the unpinned area.
             * ```typescript
             * const columnItem: IgxColumnPinningItemDirective;
             * this.columnItem.pinnable;
             * ```
             */
            get: function () {
                return this.column.pinnable;
            },
            enumerable: true,
            configurable: true
        });
        IgxColumnPinningItemDirective = __decorate([
            core.Directive({
                selector: '[igxColumnPinningItem]'
            })
        ], IgxColumnPinningItemDirective);
        return IgxColumnPinningItemDirective;
    }(ColumnChooserItemBaseDirective));

    var IgxColumnPinningComponent = /** @class */ (function (_super) {
        __extends(IgxColumnPinningComponent, _super);
        function IgxColumnPinningComponent(cdr) {
            var _this = _super.call(this, cdr) || this;
            _this.cdr = cdr;
            return _this;
        }
        /**
         * @hidden
         */
        IgxColumnPinningComponent.prototype.createColumnItem = function (container, column) {
            if (column.level !== 0 || column.disablePinning) {
                return null;
            }
            var item = new IgxColumnPinningItemDirective();
            item.container = container;
            item.column = column;
            return item;
        };
        /**
         * @hidden
         */
        IgxColumnPinningComponent.prototype.checkboxValueChange = function (event, columnItem) {
            if (event.checked && !columnItem.pinnable) {
                event.checkbox.checked = false;
                return false;
            }
            columnItem.value = !columnItem.value;
        };
        IgxColumnPinningComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        IgxColumnPinningComponent = __decorate([
            core.Component({
                preserveWhitespaces: false,
                selector: 'igx-column-pinning',
                template: "\n<div class=\"igx-column-hiding__header\">\n    <h4 class=\"igx-column-hiding__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-hiding__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-hiding__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox igxColumnPinningItem\n        *ngFor=\"let columnItem of columnItems\"\n        class=\"igx-column-hiding__columns-item\"\n        (change)=\"checkboxValueChange($event, columnItem)\"\n        [checked]=\"columnItem.value\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n"
            })
        ], IgxColumnPinningComponent);
        return IgxColumnPinningComponent;
    }(ColumnChooserBaseDirective));

    /**
     * This class encapsulates the Toolbar's logic and is internally used by
     * the `IgxGridComponent`, `IgxTreeGridComponent` and `IgxHierarchicalGridComponent`.
     */
    var IgxGridToolbarComponent = /** @class */ (function (_super) {
        __extends(IgxGridToolbarComponent, _super);
        function IgxGridToolbarComponent(gridAPI, cdr, excelExporter, csvExporter, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.gridAPI = gridAPI;
            _this.cdr = cdr;
            _this.excelExporter = excelExporter;
            _this.csvExporter = csvExporter;
            _this._displayDensityOptions = _displayDensityOptions;
            _this._filterColumnsPrompt = 'Filter columns list ...';
            _this._positionSettings = {
                horizontalDirection: exports.HorizontalAlignment.Left,
                horizontalStartPoint: exports.HorizontalAlignment.Right,
                verticalDirection: exports.VerticalAlignment.Bottom,
                verticalStartPoint: exports.VerticalAlignment.Bottom
            };
            _this._overlaySettings = {
                positionStrategy: new ConnectedPositioningStrategy(_this._positionSettings),
                scrollStrategy: new AbsoluteScrollStrategy(),
                modal: false,
                closeOnOutsideClick: true,
                excludePositionTarget: true
            };
            return _this;
        }
        Object.defineProperty(IgxGridToolbarComponent.prototype, "filterColumnsPrompt", {
            /**
             * Gets the default text shown in the filtering box.
             * ```typescript
             * const filterPrompt = this.grid.toolbar.filterColumnsPrompt;
             * ```
             */
            get: function () {
                return this._filterColumnsPrompt;
            },
            /**
             * Sets the default text shown in the filtering box.
             * ```typescript
             * this.grid.toolbar.filterColumnsPrompt('Filter columns ...');
             * ```
             */
            set: function (value) {
                this._filterColumnsPrompt = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "defaultDropDownsMaxHeight", {
            /**
             * Gets the height for the `IgxGridToolbarComponent`'s drop down panels.
             * ```typescript
             * const dropdownHeight = this.grid.toolbar.defaultDropDownsMaxHeight;
             * ```
             */
            get: function () {
                var gridHeight = this.grid.calcHeight;
                return (gridHeight) ? gridHeight * 0.7 + 'px' : '100%';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "grid", {
            /**
             * Returns a reference to the `IgxGridComponent` component, hosting the `IgxGridToolbarComponent`.
             * ```typescript
             * const grid = this.igxGrid1.toolbar.grid;
             * ```
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "shouldShowExportButton", {
            /**
             * Returns whether the `IgxGridComponent` renders an export button.
             * ```typescript
             * const exportButton = this.igxGrid1.toolbar.shouldShowExportButton;
             * ```
             */
            get: function () {
                return (this.grid != null && (this.grid.exportExcel || this.grid.exportCsv));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "shouldShowExportExcelButton", {
            /**
             * Returns whether the `IgxGridComponent` renders an Excel export button.
             * ```typescript
             * const exportExcelButton = this.igxGrid1.toolbar.shouldShowExportExcelButton;
             * ```
             */
            get: function () {
                return (this.grid != null && this.grid.exportExcel);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "shouldShowExportCsvButton", {
            /**
             * Returns whether the `IgxGridComponent` renders an CSV export button.
             * ```typescript
             * const exportCSVButton = this.igxGrid1.toolbar.shouldShowExportCsvButton;
             * ```
             */
            get: function () {
                return (this.grid != null && this.grid.exportCsv);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "pinnedColumnsCount", {
            /**
             * Returns how many columns are pinned.
             * ```typescript
             * const pinnedCount = this.igxGrid1.toolbar.pinnedColumnsCount;
             * ```
             */
            get: function () {
                return this.grid.pinnedColumns.filter(function (col) { return !col.columnLayout; }).length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "hostClass", {
            /**
             * Returns the theme of the `IgxGridToolbarComponent`.
             * ```typescript
             * const toolbarTheme = this.grid.toolbar.hostClass;
             * ```
             */
            get: function () {
                return this.getComponentDensityClass('igx-grid-toolbar');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the title of `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarTitle = this.igxGrid1.toolbar.getTitle();
         * ```
         */
        IgxGridToolbarComponent.prototype.getTitle = function () {
            return this.grid != null ? this.grid.toolbarTitle : '';
        };
        /**
         * Returns the text of the export button of the `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarExportText = this.igxGrid1.toolbar.getTitle();
         * ```
         */
        IgxGridToolbarComponent.prototype.getExportText = function () {
            return this.grid != null ? this.grid.exportText : '';
        };
        /**
         * Returns the text of the Excel export button of the `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarExcelText = this.igxGrid1.toolbar.getExportExcelText();
         * ```
         */
        IgxGridToolbarComponent.prototype.getExportExcelText = function () {
            return this.grid != null ? this.grid.exportExcelText : '';
        };
        /**
         * Returns the text of the CSV export button of the `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarCSVText = this.igxGrid1.toolbar.getExportCsvText();
         * ```
         */
        IgxGridToolbarComponent.prototype.getExportCsvText = function () {
            return this.grid != null ? this.grid.exportCsvText : '';
        };
        /**
         * Toggles the export button's dropdown menu.
         * ```typescript
         * this.igxGrid1.toolbar.exportClicked();
         * ```
         */
        IgxGridToolbarComponent.prototype.exportClicked = function () {
            this._overlaySettings.positionStrategy.settings.target = this.exportButton.nativeElement;
            this._overlaySettings.outlet = this.grid.outletDirective;
            this.exportDropdown.toggle(this._overlaySettings);
        };
        /**
         * Exports the grid to excel.
         * ```typescript
         * this.igxGrid1.toolbar.exportToExcelClicked();
         * ```
         */
        IgxGridToolbarComponent.prototype.exportToExcelClicked = function () {
            this.performExport(this.excelExporter, 'excel');
        };
        /**
         * Exports the grid to CSV.
         * ```typescript
         * this.igxGrid1.toolbar.exportToCsvClicked();
         * ```
         */
        IgxGridToolbarComponent.prototype.exportToCsvClicked = function () {
            this.performExport(this.csvExporter, 'csv');
        };
        IgxGridToolbarComponent.prototype.performExport = function (exp, exportType) {
            this.exportClicked();
            var fileName = 'ExportedData';
            var options = exportType === 'excel' ?
                new IgxExcelExporterOptions(fileName) :
                new IgxCsvExporterOptions(fileName, exports.CsvFileTypes.CSV);
            var args = { grid: this.grid, exporter: exp, options: options, cancel: false };
            this.grid.onToolbarExporting.emit(args);
            if (args.cancel) {
                return;
            }
            exp.export(this.grid, options);
        };
        /**
         * Toggles the Column Hiding UI.
         * ```typescript
         * this.grid1.toolbar.toggleColumnHidingUI();
         * ```
         */
        IgxGridToolbarComponent.prototype.toggleColumnHidingUI = function () {
            this._overlaySettings.positionStrategy.settings.target = this.columnHidingButton.nativeElement;
            this._overlaySettings.outlet = this.grid.outletDirective;
            this.columnHidingDropdown.toggle(this._overlaySettings);
        };
        /**
         * Toggles the Column Pinning UI.
         * ```typescript
         * this.grid1.toolbar.toggleColumnPinningUI();
         * ```
         */
        IgxGridToolbarComponent.prototype.toggleColumnPinningUI = function () {
            this._overlaySettings.positionStrategy.settings.target = this.columnPinningButton.nativeElement;
            this._overlaySettings.outlet = this.grid.outletDirective;
            this.columnPinningDropdown.toggle(this._overlaySettings);
        };
        /**
         * @hidden @internal
         */
        IgxGridToolbarComponent.prototype.showAdvancedFilteringUI = function () {
            this.grid.openAdvancedFilteringDialog();
        };
        Object.defineProperty(IgxGridToolbarComponent.prototype, "context", {
            /**
             * Returns the `context` object which represents the `template context` binding into the
             * `toolbar custom container` by providing references to the parent IgxGird and the toolbar itself.
             * ```typescript
             * const context =  this.igxGrid.toolbar.context;
             * ```
             */
            get: function () {
                return {
                    // $implicit: this
                    grid: this.grid,
                    toolbar: this
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridToolbarComponent.prototype, "customContentTemplate", {
            /** @hidden */
            get: function () {
                if (this.grid != null && this.grid.toolbarCustomContentTemplate != null) {
                    return this.grid.toolbarCustomContentTemplate.template;
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxGridToolbarComponent.ctorParameters = function () { return [
            { type: GridBaseAPIService },
            { type: core.ChangeDetectorRef },
            { type: IgxExcelExporterService, decorators: [{ type: core.Optional }] },
            { type: IgxCsvExporterService, decorators: [{ type: core.Optional }] },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.HostBinding('class.igx-grid-toolbar'),
            core.Input()
        ], IgxGridToolbarComponent.prototype, "gridID", void 0);
        __decorate([
            core.Input()
        ], IgxGridToolbarComponent.prototype, "filterColumnsPrompt", null);
        __decorate([
            core.Input()
        ], IgxGridToolbarComponent.prototype, "defaultDropDownsMaxHeight", null);
        __decorate([
            core.ViewChild('columnHidingDropdown', { read: IgxDropDownComponent })
        ], IgxGridToolbarComponent.prototype, "columnHidingDropdown", void 0);
        __decorate([
            core.ViewChild(IgxColumnHidingComponent)
        ], IgxGridToolbarComponent.prototype, "columnHidingUI", void 0);
        __decorate([
            core.ViewChild('columnHidingButton', { read: IgxButtonDirective })
        ], IgxGridToolbarComponent.prototype, "columnHidingButton", void 0);
        __decorate([
            core.ViewChild('exportDropdown', { read: IgxDropDownComponent })
        ], IgxGridToolbarComponent.prototype, "exportDropdown", void 0);
        __decorate([
            core.ViewChild('btnExport', { read: IgxButtonDirective })
        ], IgxGridToolbarComponent.prototype, "exportButton", void 0);
        __decorate([
            core.ViewChild('columnPinningDropdown', { read: IgxDropDownComponent })
        ], IgxGridToolbarComponent.prototype, "columnPinningDropdown", void 0);
        __decorate([
            core.ViewChild(IgxColumnPinningComponent)
        ], IgxGridToolbarComponent.prototype, "columnPinningUI", void 0);
        __decorate([
            core.ViewChild('columnPinningButton', { read: IgxButtonDirective })
        ], IgxGridToolbarComponent.prototype, "columnPinningButton", void 0);
        __decorate([
            core.HostBinding('attr.class')
        ], IgxGridToolbarComponent.prototype, "hostClass", null);
        IgxGridToolbarComponent = __decorate([
            core.Component({
                selector: 'igx-grid-toolbar',
                template: "<span class=\"igx-grid-toolbar__title\" *ngIf=\"getTitle()\">\n    {{ getTitle() }}\n</span>\n\n<div class=\"igx-grid-toolbar__custom-content\" *ngIf=\"customContentTemplate != null\">\n    <ng-container *ngTemplateOutlet=\"customContentTemplate; context: context\">\n    </ng-container>\n</div>\n\n<div class=\"igx-grid-toolbar__actions\">\n    <div *ngIf=\"grid.allowAdvancedFiltering\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #advancedFilteringButton name=\"btnAdvancedFiltering\" igxRipple\n            (click)=\"showAdvancedFilteringUI()\"\n                [ngClass]=\"grid.advancedFilteringExpressionsTree ? 'igx-grid-toolbar__adv-filter--filtered' : 'igx-grid-toolbar__adv-filter'\">\n            <div class=\"igx-grid-toolbar__button-space\">\n                <igx-icon>\n                    filter_list\n                </igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_title}}</span>\n            </div>\n        </button>\n    </div>\n\n    <div *ngIf=\"grid.columnHiding\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #columnHidingButton name=\"btnColumnHiding\" igxRipple\n            (click)=\"toggleColumnHidingUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount > 0\">visibility_off</igx-icon>\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount === 0\">visibility</igx-icon>\n                <span>{{ grid.hiddenColumnsCount }}</span>\n                <span>{{ grid.hiddenColumnsText }}</span>\n            </div>\n        </button>\n        <igx-drop-down #columnHidingDropdown>\n            <igx-column-hiding\n                [columns]=\"grid.columns\"\n                [title]=\"grid.columnHidingTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\"\n                (onColumnVisibilityChanged)=\"grid.toggleColumnVisibility($event)\">\n            </igx-column-hiding>\n        </igx-drop-down>\n    </div>\n    <div *ngIf=\"grid.columnPinning\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #columnPinningButton name=\"btnColumnPinning\" igxRipple\n            (click)=\"toggleColumnPinningUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"pinnedColumnsCount > 0\">lock</igx-icon>\n                <igx-icon *ngIf=\"pinnedColumnsCount === 0\">lock_open</igx-icon>\n                <span>{{ pinnedColumnsCount }}</span>\n                <span>{{ grid.pinnedColumnsText }}</span>\n                <span></span>\n            </div>\n        </button>\n        <igx-drop-down #columnPinningDropdown>\n            <igx-column-pinning\n                [columns]=\"grid.columns\"\n                [title]=\"grid.columnPinningTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\"></igx-column-pinning>\n        </igx-drop-down>\n    </div>\n\n    <div class=\"igx-grid-toolbar__dropdown\" *ngIf=\"shouldShowExportButton\" id=\"btnExport\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" igxRipple #btnExport\n                (click)=\"exportClicked()\">\n            <span class=\"igx-grid-toolbar__button-space\">\n                <igx-icon fontSet=\"material\">import_export</igx-icon>\n                <span>{{ getExportText() }}</span>\n                <igx-icon fontSet=\"material\">arrow_drop_down</igx-icon>\n            </span>\n        </button>\n\n        <igx-drop-down #exportDropdown>\n            <ul class=\"igx-grid-toolbar__dd-list\">\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportExcelButton\" id=\"btnExportExcel\"\n                (click)=\"exportToExcelClicked()\">{{ getExportExcelText() }}</li>\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportCsvButton\" id=\"btnExportCsv\"\n                (click)=\"exportToCsvClicked()\">{{ getExportCsvText() }}</li>\n            </ul>\n        </igx-drop-down>\n    </div>\n</div>\n"
            }),
            __param(2, core.Optional()),
            __param(3, core.Optional()),
            __param(4, core.Optional()), __param(4, core.Inject(DisplayDensityToken))
        ], IgxGridToolbarComponent);
        return IgxGridToolbarComponent;
    }(DisplayDensityBase));

    /** @hidden */
    var IgxRowEditTemplateDirective = /** @class */ (function () {
        function IgxRowEditTemplateDirective() {
        }
        IgxRowEditTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxRowEdit]'
            })
        ], IgxRowEditTemplateDirective);
        return IgxRowEditTemplateDirective;
    }());
    /** @hidden */
    var IgxRowEditTextDirective = /** @class */ (function () {
        function IgxRowEditTextDirective() {
        }
        IgxRowEditTextDirective = __decorate([
            core.Directive({
                selector: '[igxRowEditText]'
            })
        ], IgxRowEditTextDirective);
        return IgxRowEditTextDirective;
    }());
    /** @hidden */
    var IgxRowEditActionsDirective = /** @class */ (function () {
        function IgxRowEditActionsDirective() {
        }
        IgxRowEditActionsDirective = __decorate([
            core.Directive({
                selector: '[igxRowEditActions]'
            })
        ], IgxRowEditActionsDirective);
        return IgxRowEditActionsDirective;
    }());
    // TODO: Refactor circular ref, deps and logic
    /** @hidden */
    var IgxRowEditTabStopDirective = /** @class */ (function () {
        function IgxRowEditTabStopDirective(api, element) {
            var _this = this;
            this.api = api;
            this.element = element;
            /**
             * Sets the cell in edit mode and focus its native element
             * @param cellIndex index of the cell to activate
             */
            this.activateCell = function () {
                var cell = _this.grid.rowInEditMode.cells.find(function (e) { return e.visibleColumnIndex === _this.currentCellIndex; });
                cell.nativeElement.focus();
                cell.setEditMode(true);
                _this.currentCellIndex = -1;
            };
        }
        Object.defineProperty(IgxRowEditTabStopDirective.prototype, "grid", {
            get: function () {
                return this.api.grid;
            },
            enumerable: true,
            configurable: true
        });
        IgxRowEditTabStopDirective.prototype.handleTab = function (event) {
            event.stopPropagation();
            if ((this.grid.rowEditTabs.last === this && !event.shiftKey) ||
                (this.grid.rowEditTabs.first === this && event.shiftKey)) {
                this.move(event);
            }
        };
        IgxRowEditTabStopDirective.prototype.handleEscape = function (event) {
            this.grid.endEdit(false, event);
            var activeNode = this.grid.selectionService.activeElement;
            //  on right click activeNode is deleted, so we may have no one
            if (activeNode) {
                var cell = this.grid.navigation.getCellElementByVisibleIndex(activeNode.row, activeNode.layout ? activeNode.layout.columnVisibleIndex : activeNode.column);
                cell.focus();
            }
        };
        /**
         * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.
         * If cell is out of view first scrolls to the cell
         * @param event keyboard event containing information about whether SHIFT key was pressed
         */
        IgxRowEditTabStopDirective.prototype.move = function (event) {
            event.preventDefault();
            this.currentCellIndex = event.shiftKey ? this.grid.lastEditableColumnIndex : this.grid.firstEditableColumnIndex;
            if (!this.grid.navigation.isColumnFullyVisible(this.currentCellIndex)) {
                this.grid.navigation.performHorizontalScrollToCell(this.grid.rowInEditMode.index, this.currentCellIndex, false, this.activateCell);
            }
            else {
                this.activateCell();
            }
        };
        IgxRowEditTabStopDirective.ctorParameters = function () { return [
            { type: GridBaseAPIService },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.HostListener('keydown.Tab', ["$event"]),
            core.HostListener('keydown.Shift.Tab', ["$event"])
        ], IgxRowEditTabStopDirective.prototype, "handleTab", null);
        __decorate([
            core.HostListener('keydown.Escape', ["$event"])
        ], IgxRowEditTabStopDirective.prototype, "handleEscape", null);
        IgxRowEditTabStopDirective = __decorate([
            core.Directive({
                selector: "[igxRowEditTabStop]"
            })
        ], IgxRowEditTabStopDirective);
        return IgxRowEditTabStopDirective;
    }());

    var IgxGridGroupByRowComponent = /** @class */ (function () {
        function IgxGridGroupByRowComponent(gridAPI, gridSelection, element, cdr) {
            this.gridAPI = gridAPI;
            this.gridSelection = gridSelection;
            this.element = element;
            this.cdr = cdr;
            /**
             * @hidden
             */
            this.defaultCssClass = 'igx-grid__group-row';
            /**
             * @hidden
             */
            this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';
            /**
             * @hidden
             */
            this.isFocused = false;
            /**
             * @hidden
             */
            this.tabindex = 0;
        }
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "focused", {
            /**
             * Returns whether the row is focused.
             * ```
             * let gridRowFocused = this.grid1.rowList.first.focused;
             * ```
             */
            get: function () {
                return this.isFocused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "expanded", {
            /**
             * Returns whether the group row is expanded.
             * ```typescript
             * const groupRowExpanded = this.grid1.rowList.first.expanded;
             * ```
             */
            get: function () {
                return this.grid.isExpandedGroup(this.groupRow);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "describedBy", {
            /**
             * @hidden
             */
            get: function () {
                var grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';
                return this.gridID + '_' + grRowExpr;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "dataRowIndex", {
            get: function () {
                return this.index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "nativeElement", {
            /**
             * Returns a reference to the underlying HTML element.
             * ```typescript
             * const groupRowElement = this.nativeElement;
             * ```
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "styleClasses", {
            /**
             * Returns the style classes applied to the group rows.
             * ```typescript
             * const groupCssStyles = this.grid1.rowList.first.styleClasses;
             * ```
             */
            get: function () {
                return this.defaultCssClass + " " + (this.paddingIndentationCssClass + "-") + this.groupRow.level +
                    (this.focused ? " " + this.defaultCssClass + "--active" : '');
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxGridGroupByRowComponent.prototype.onFocus = function () {
            this.isFocused = true;
        };
        /**
         *@hidden
         */
        IgxGridGroupByRowComponent.prototype.onBlur = function () {
            this.isFocused = false;
        };
        /**
         * Toggles the group row.
         * ```typescript
         * this.grid1.rowList.first.toggle()
         * ```
         */
        IgxGridGroupByRowComponent.prototype.toggle = function () {
            var isVirtualized = !this.grid.verticalScrollContainer.dc.instance.notVirtual;
            var groupRowIndex = this.index;
            this.grid.toggleGroup(this.groupRow);
            if (isVirtualized) {
                var groupRow = this.grid.nativeElement.querySelector("[data-rowIndex=\"" + groupRowIndex + "\"]");
                if (groupRow) {
                    groupRow.focus();
                }
            }
        };
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "iconTemplate", {
            get: function () {
                if (this.expanded) {
                    return this.grid.rowExpandedIndicatorTemplate || this.defaultGroupByExpandedTemplate;
                }
                else {
                    return this.grid.rowCollapsedIndicatorTemplate || this.defaultGroupByCollapsedTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "selectionNode", {
            get: function () {
                return {
                    row: this.index,
                    column: this.gridSelection.activeElement ? this.gridSelection.activeElement.column : 0
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxGridGroupByRowComponent.prototype.onKeydown = function (event) {
            // TODO: Refactor
            var key = event.key.toLowerCase();
            if (!SUPPORTED_KEYS.has(key)) {
                return;
            }
            event.stopPropagation();
            var keydownArgs = { targetType: 'groupRow', target: this, event: event, cancel: false };
            this.grid.onGridKeydown.emit(keydownArgs);
            if (keydownArgs.cancel) {
                return;
            }
            event.preventDefault();
            if (!this.isKeySupportedInGroupRow(key, event.shiftKey, event.altKey) || event.ctrlKey) {
                return;
            }
            if (this.isToggleKey(key, event.altKey)) {
                if ((this.expanded && ROW_COLLAPSE_KEYS.has(key)) || (!this.expanded && ROW_EXPAND_KEYS.has(key))) {
                    this.toggle();
                }
                return;
            }
            var selection = this.gridSelection;
            selection.keyboardState.shift = event.shiftKey && !(key === 'tab');
            var activeNode = selection.activeElement ? Object.assign({}, selection.activeElement) : this.selectionNode;
            activeNode.row = this.index;
            switch (key) {
                case 'arrowdown':
                case 'down':
                    this.grid.navigation.navigateDown(this.nativeElement, activeNode);
                    break;
                case 'arrowup':
                case 'up':
                    this.grid.navigation.navigateUp(this.nativeElement, activeNode);
                    break;
                case 'tab':
                    this.handleTabKey(event.shiftKey, activeNode);
                    break;
            }
        };
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "grid", {
            /**
             * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
             * ```typescript
             * this.grid1.rowList.first.grid;
             * ```
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridGroupByRowComponent.prototype, "dataType", {
            /**
             * @hidden
             */
            get: function () {
                var column = this.grid.getColumnByName(this.groupRow.expression.fieldName);
                return (column && column.dataType) || exports.DataType.String;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridGroupByRowComponent.prototype.handleTabKey = function (shift, activeNode) {
            if (shift) {
                this.grid.navigation.performShiftTabKey(this.nativeElement, activeNode);
            }
            else {
                if (this.index === this.grid.dataView.length - 1 && this.grid.rootSummariesEnabled) {
                    this.grid.navigation.onKeydownHome(0, true);
                }
                else {
                    var orderedColumns = this.grid.navigation.gridOrderedColumns;
                    var lastCol = orderedColumns[orderedColumns.length - 1];
                    activeNode.column = lastCol.columnLayoutChild ? lastCol.parent.visibleIndex : lastCol.visibleIndex;
                    this.grid.navigation.performTab(this.nativeElement, activeNode);
                }
            }
        };
        IgxGridGroupByRowComponent.prototype.isKeySupportedInGroupRow = function (key, shift, alt) {
            if (shift === void 0) { shift = false; }
            if (alt === void 0) { alt = false; }
            if (shift) {
                return ['down', 'up', 'arrowdown', 'arrowup', 'tab'].indexOf(key) !== -1;
            }
            return this.isToggleKey(key, alt) ? true : ['down', 'up', 'arrowdown', 'arrowup', 'tab'].indexOf(key) !== -1;
        };
        IgxGridGroupByRowComponent.prototype.isToggleKey = function (key, altKey) {
            return altKey && ['left', 'right', 'up', 'down', 'arrowleft', 'arrowright', 'arrowup', 'arrowdown'].indexOf(key) !== -1;
        };
        IgxGridGroupByRowComponent.ctorParameters = function () { return [
            { type: GridBaseAPIService },
            { type: IgxGridSelectionService },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.ViewChild('defaultGroupByExpandedTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridGroupByRowComponent.prototype, "defaultGroupByExpandedTemplate", void 0);
        __decorate([
            core.ViewChild('defaultGroupByCollapsedTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridGroupByRowComponent.prototype, "defaultGroupByCollapsedTemplate", void 0);
        __decorate([
            core.Input()
        ], IgxGridGroupByRowComponent.prototype, "isFocused", void 0);
        __decorate([
            core.Input()
        ], IgxGridGroupByRowComponent.prototype, "index", void 0);
        __decorate([
            core.Input()
        ], IgxGridGroupByRowComponent.prototype, "gridID", void 0);
        __decorate([
            core.Input()
        ], IgxGridGroupByRowComponent.prototype, "groupRow", void 0);
        __decorate([
            core.ViewChild('groupContent', { static: true })
        ], IgxGridGroupByRowComponent.prototype, "groupContent", void 0);
        __decorate([
            core.HostBinding('attr.aria-expanded')
        ], IgxGridGroupByRowComponent.prototype, "expanded", null);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxGridGroupByRowComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('attr.aria-describedby')
        ], IgxGridGroupByRowComponent.prototype, "describedBy", null);
        __decorate([
            core.HostBinding('attr.data-rowIndex')
        ], IgxGridGroupByRowComponent.prototype, "dataRowIndex", null);
        __decorate([
            core.HostBinding('class')
        ], IgxGridGroupByRowComponent.prototype, "styleClasses", null);
        __decorate([
            core.HostListener('focus')
        ], IgxGridGroupByRowComponent.prototype, "onFocus", null);
        __decorate([
            core.HostListener('blur')
        ], IgxGridGroupByRowComponent.prototype, "onBlur", null);
        __decorate([
            core.HostListener('keydown', ['$event'])
        ], IgxGridGroupByRowComponent.prototype, "onKeydown", null);
        IgxGridGroupByRowComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-groupby-row',
                template: "<ng-container #defaultGroupRow>\n    <div (click)=\"toggle()\" class=\"igx-grid__grouping-indicator\">\n            <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n            </ng-container>\n    </div>\n\n    <div class=\"igx-grid__group-content\" #groupContent>\n        <ng-container *ngTemplateOutlet=\"grid.groupRowTemplate ? grid.groupRowTemplate : defaultGroupByTemplate; context: { $implicit: groupRow }\">\n        </ng-container>\n    </div>\n\n    <ng-template #defaultGroupByExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n    </ng-template>\n\n    <ng-template #defaultGroupByCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </ng-template>\n\n\n    <ng-template #defaultGroupByTemplate>\n        <div class=\"igx-group-label\">\n            <igx-icon fontSet=\"material\" class=\"igx-group-label__icon\">group_work</igx-icon>\n            <span class=\"igx-group-label__column-name\">\n            {{ groupRow.expression ? groupRow.expression.fieldName : '' }}:\n            </span>\n\n            <ng-container *ngIf=\"dataType === 'boolean' || dataType === 'string'; else default\" >\n                <span class=\"igx-group-label__text\">{{ groupRow.value }}</span>\n            </ng-container>\n            <ng-template #default>\n                <ng-container *ngIf=\"dataType === 'number'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | number }}</span>\n                </ng-container>\n                <ng-container *ngIf=\"dataType === 'date'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | date }}</span>\n                </ng-container>\n            </ng-template>\n\n            <igx-badge [value]=\"groupRow.records ? groupRow.records.length : 0\" class='igx-group-label__count-badge'></igx-badge>\n        </div>\n    </ng-template>\n</ng-container>\n"
            })
        ], IgxGridGroupByRowComponent);
        return IgxGridGroupByRowComponent;
    }());

    var MoveDirection;
    (function (MoveDirection) {
        MoveDirection["LEFT"] = "left";
        MoveDirection["RIGHT"] = "right";
    })(MoveDirection || (MoveDirection = {}));
    /** @hidden */
    var IgxGridNavigationService = /** @class */ (function () {
        function IgxGridNavigationService() {
        }
        Object.defineProperty(IgxGridNavigationService.prototype, "displayContainerWidth", {
            get: function () {
                return Math.round(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridNavigationService.prototype, "displayContainerScrollLeft", {
            get: function () {
                return Math.ceil(this.grid.headerContainer.scrollPosition);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridNavigationService.prototype, "verticalDisplayContainerElement", {
            get: function () {
                return this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridNavigationService.prototype.horizontalScroll = function (rowIndex) {
            var rowComp = this.grid.dataRowList.find(function (row) { return row.index === rowIndex; }) || this.grid.dataRowList.first;
            if (!rowComp) {
                rowComp = this.grid.summariesRowList.find(function (row) { return row.index === rowIndex; });
            }
            return rowComp.virtDirRow;
        };
        IgxGridNavigationService.prototype.getColumnUnpinnedIndex = function (visibleColumnIndex) {
            var column = this.grid.unpinnedColumns.find(function (col) { return !col.columnGroup && col.visibleIndex === visibleColumnIndex; });
            return this.grid.pinnedColumns.length ? this.grid.unpinnedColumns.filter(function (c) { return !c.columnGroup; }).indexOf(column) :
                visibleColumnIndex;
        };
        IgxGridNavigationService.prototype.isColumnFullyVisible = function (columnIndex) {
            return this.isColumnRightEdgeVisible(columnIndex) && this.isColumnLeftEdgeVisible(columnIndex);
        };
        IgxGridNavigationService.prototype.isColumnRightEdgeVisible = function (columnIndex) {
            var forOfDir = this.forOfDir();
            if (this.isColumnPinned(columnIndex, forOfDir)) {
                return true;
            }
            var index = this.getColumnUnpinnedIndex(columnIndex);
            return this.displayContainerWidth >= forOfDir.getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft;
        };
        IgxGridNavigationService.prototype.isColumnLeftEdgeVisible = function (columnIndex) {
            var forOfDir = this.forOfDir();
            if (this.isColumnPinned(columnIndex, forOfDir)) {
                return true;
            }
            var index = this.getColumnUnpinnedIndex(columnIndex);
            return this.displayContainerScrollLeft <= forOfDir.getColumnScrollLeft(index);
        };
        IgxGridNavigationService.prototype.forOfDir = function () {
            var forOfDir;
            if (this.grid.dataRowList.length > 0) {
                forOfDir = this.grid.dataRowList.first.virtDirRow;
            }
            else {
                forOfDir = this.grid.headerContainer;
            }
            return forOfDir;
        };
        IgxGridNavigationService.prototype.isColumnPinned = function (columnIndex, forOfDir) {
            var horizontalScroll = forOfDir.getScroll();
            var column = this.grid.columnList.filter(function (c) { return !c.columnGroup; }).find(function (col) { return col.visibleIndex === columnIndex; });
            return (!horizontalScroll.clientWidth || column.pinned);
        };
        Object.defineProperty(IgxGridNavigationService.prototype, "gridOrderedColumns", {
            get: function () {
                return __spread(this.grid.pinnedColumns, this.grid.unpinnedColumns).filter(function (c) { return !c.columnGroup; });
            },
            enumerable: true,
            configurable: true
        });
        IgxGridNavigationService.prototype.isRowInEditMode = function (rowIndex) {
            return this.grid.rowEditable && (this.grid.rowInEditMode && this.grid.rowInEditMode.index === rowIndex);
        };
        IgxGridNavigationService.prototype.findNextEditable = function (direction, visibleColumnIndex) {
            // go trough all columns in one cycle instead of
            // splice().reverse().find()
            var gridColumns = this.gridOrderedColumns;
            var start = visibleColumnIndex;
            var end = 0;
            var step = 0;
            var result = -1;
            if (direction === MoveDirection.LEFT) {
                end = 0;
                step = -1;
            }
            else if (direction === MoveDirection.RIGHT) {
                end = gridColumns.length - 1;
                step = 1;
            }
            for (var c = start; (c * step) <= end; c += step) {
                var column = gridColumns[c];
                if (column.editable) {
                    result = c;
                    break;
                }
            }
            return result;
        };
        IgxGridNavigationService.prototype.getCellElementByVisibleIndex = function (rowIndex, visibleColumnIndex, isSummary) {
            if (isSummary === void 0) { isSummary = false; }
            var cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
            return this.grid.nativeElement.querySelector(cellSelector + "[data-rowindex=\"" + rowIndex + "\"][data-visibleIndex=\"" + visibleColumnIndex + "\"]");
        };
        IgxGridNavigationService.prototype.onKeydownArrowRight = function (element, selectedNode) {
            var rowIndex = selectedNode.row;
            var visibleColumnIndex = selectedNode.column;
            var isSummary = selectedNode.isSummaryRow;
            if (this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
                return;
            }
            if (this.isColumnRightEdgeVisible(visibleColumnIndex + 1)) { // if next column is fully visible or is pinned
                if (element.classList.contains('igx-grid__td--pinned-last') || element.classList.contains('igx-grid-summary--pinned-last')) {
                    if (this.isColumnLeftEdgeVisible(visibleColumnIndex + 1)) {
                        element.nextElementSibling.firstElementChild.focus({ preventScroll: true });
                    }
                    else {
                        this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
                        this.grid.parentVirtDir.onChunkLoad
                            .pipe(operators.first())
                            .subscribe(function () {
                            element.nextElementSibling.firstElementChild.focus({ preventScroll: true });
                        });
                        this.horizontalScroll(rowIndex).scrollTo(0);
                    }
                }
                else {
                    element.nextElementSibling.focus({ preventScroll: true });
                }
            }
            else {
                this.performHorizontalScrollToCell(rowIndex, visibleColumnIndex + 1, isSummary);
            }
        };
        IgxGridNavigationService.prototype.onKeydownArrowLeft = function (element, selectedNode) {
            var rowIndex = selectedNode.row;
            var visibleColumnIndex = selectedNode.column;
            var isSummary = selectedNode.isSummaryRow;
            if (visibleColumnIndex === 0) {
                return;
            }
            var index = this.getColumnUnpinnedIndex(visibleColumnIndex - 1);
            if (!element.previousElementSibling && this.grid.pinnedColumns.length && index === -1) {
                element.parentNode.previousElementSibling.focus({ preventScroll: true });
            }
            else if (!this.isColumnLeftEdgeVisible(visibleColumnIndex - 1)) {
                this.performHorizontalScrollToCell(rowIndex, visibleColumnIndex - 1, isSummary);
            }
            else {
                element.previousElementSibling.focus({ preventScroll: true });
            }
        };
        IgxGridNavigationService.prototype.movePreviousEditable = function (rowIndex, currentColumnVisibleIndex) {
            var prevEditableColumnIndex = this.findNextEditable(MoveDirection.LEFT, currentColumnVisibleIndex - 1);
            if (prevEditableColumnIndex === -1) {
                if (this.grid.rowEditTabs.length) {
                    //  TODO: make gridAPI visible for internal use and remove cast to any
                    this.grid.gridAPI.submit_value();
                    this.grid.rowEditTabs.last.element.nativeElement.focus();
                    return;
                }
                else {
                    // In case when row edit template is empty select last editable cell
                    prevEditableColumnIndex = this.grid.lastEditableColumnIndex;
                }
            }
            this.focusEditableTarget(rowIndex, prevEditableColumnIndex);
        };
        IgxGridNavigationService.prototype.moveNextEditable = function (rowIndex, currentColumnVisibleIndex) {
            var nextEditableColumnIndex = this.findNextEditable(MoveDirection.RIGHT, currentColumnVisibleIndex + 1);
            if (nextEditableColumnIndex === -1) {
                if (this.grid.rowEditTabs.length) {
                    //  TODO: make gridAPI visible for internal use and remove cast to any
                    this.grid.gridAPI.submit_value();
                    this.grid.rowEditTabs.first.element.nativeElement.focus();
                    return;
                }
                else {
                    // In case when row edit template is empty select first editable cell
                    nextEditableColumnIndex = this.grid.firstEditableColumnIndex;
                }
            }
            this.focusEditableTarget(rowIndex, nextEditableColumnIndex);
        };
        IgxGridNavigationService.prototype.focusEditableTarget = function (rowIndex, columnIndex) {
            if (this.isColumnFullyVisible(columnIndex)) {
                this.getCellElementByVisibleIndex(rowIndex, columnIndex).focus();
            }
            else {
                this.performHorizontalScrollToCell(rowIndex, columnIndex);
            }
        };
        IgxGridNavigationService.prototype.onKeydownHome = function (rowIndex, isSummary) {
            if (isSummary === void 0) { isSummary = false; }
            var rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
            var rowElement = rowList.find(function (row) { return row.index === rowIndex; });
            var cellSelector = this.getCellSelector(0, isSummary);
            if (!rowElement) {
                return;
            }
            rowElement = rowElement.nativeElement;
            var firstCell = rowElement.querySelector(cellSelector);
            if (this.grid.pinnedColumns.length || this.displayContainerScrollLeft === 0) {
                firstCell.focus({ preventScroll: true });
            }
            else {
                this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
                this.grid.parentVirtDir.onChunkLoad
                    .pipe(operators.first())
                    .subscribe(function () {
                    firstCell = rowElement.querySelector(cellSelector);
                    firstCell.focus({ preventScroll: true });
                });
                this.horizontalScroll(rowIndex).scrollTo(0);
            }
        };
        IgxGridNavigationService.prototype.onKeydownEnd = function (rowIndex, isSummary) {
            var _this = this;
            if (isSummary === void 0) { isSummary = false; }
            var index = this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex;
            var rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
            var rowElement = rowList.find(function (row) { return row.index === rowIndex; });
            if (!rowElement) {
                return;
            }
            rowElement = rowElement.nativeElement;
            if (this.isColumnRightEdgeVisible(index)) {
                var allCells = rowElement.querySelectorAll(this.getCellSelector(-1, isSummary));
                allCells[allCells.length - 1].focus({ preventScroll: true });
            }
            else {
                this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
                this.grid.parentVirtDir.onChunkLoad
                    .pipe(operators.first())
                    .subscribe(function () {
                    var allCells = rowElement.querySelectorAll(_this.getCellSelector(-1, isSummary));
                    allCells[allCells.length - 1].focus({ preventScroll: true });
                });
                this.horizontalScroll(rowIndex).scrollTo(this.getColumnUnpinnedIndex(index));
            }
        };
        IgxGridNavigationService.prototype.navigateTop = function (visibleColumnIndex) {
            var _this = this;
            var targetIndex = this.findFirstDataRowIndex();
            var verticalScroll = this.grid.verticalScrollContainer.getScroll();
            var cellSelector = this.getCellSelector(visibleColumnIndex);
            var targetScr = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, false);
            if (targetScr >= verticalScroll.scrollTop) {
                var cells = this.grid.nativeElement.querySelectorAll(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                cells[0].focus();
            }
            else {
                this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
                this.grid.verticalScrollContainer.scrollTo(targetIndex !== -1 ? targetIndex : 0);
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(operators.debounceTime(10)).pipe(operators.first()).subscribe(function () {
                    var cells = _this.grid.nativeElement.querySelectorAll(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                    if (cells.length > 0) {
                        cells[0].focus();
                    }
                });
            }
        };
        IgxGridNavigationService.prototype.findFirstDataRowIndex = function () {
            var _this = this;
            var dv = this.grid.dataView;
            return dv.findIndex(function (rec) { return !_this.grid.isGroupByRecord(rec) && !_this.grid.isDetailRecord(rec); });
        };
        IgxGridNavigationService.prototype.findLastDataRowIndex = function () {
            var i = this.grid.dataView.length;
            while (i--) {
                var rec = this.grid.dataView[i];
                if (!this.grid.isGroupByRecord(rec) && !this.grid.isDetailRecord(rec)) {
                    return i;
                }
            }
        };
        IgxGridNavigationService.prototype.navigateBottom = function (visibleColumnIndex) {
            var _this = this;
            var targetIndex = this.findLastDataRowIndex();
            var targetScr = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, true);
            var verticalScroll = this.grid.verticalScrollContainer.getScroll();
            var cellSelector = this.getCellSelector(visibleColumnIndex);
            if (verticalScroll.scrollHeight === 0 ||
                verticalScroll.scrollTop === targetScr) {
                var cells = this.grid.nativeElement.querySelectorAll(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                cells[cells.length - 1].focus();
            }
            else {
                this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
                this.grid.verticalScrollContainer.scrollTo(targetIndex !== -1 ? targetIndex : this.grid.dataView.length - 1);
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(operators.debounceTime(10)).pipe(operators.first()).subscribe(function () {
                    var cells = _this.grid.nativeElement.querySelectorAll(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                    if (cells.length > 0) {
                        cells[cells.length - 1].focus({ preventScroll: true });
                    }
                });
            }
        };
        IgxGridNavigationService.prototype.navigateUp = function (rowElement, selectedNode) {
            var _this = this;
            var currentRowIndex = selectedNode.row;
            var visibleColumnIndex = selectedNode.column;
            if (currentRowIndex === 0) {
                return;
            }
            var containerTopOffset = parseInt(this.verticalDisplayContainerElement.style.top, 10);
            if (!rowElement.previousElementSibling ||
                rowElement.previousElementSibling.offsetTop < Math.abs(containerTopOffset)) {
                this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
                this.grid.verticalScrollContainer.scrollTo(currentRowIndex - 1);
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(operators.first())
                    .subscribe(function () {
                    var tag = rowElement.tagName.toLowerCase();
                    rowElement = _this.getRowByIndex(currentRowIndex, tag);
                    _this.focusPreviousElement(rowElement, visibleColumnIndex);
                });
            }
            else {
                this.focusPreviousElement(rowElement, visibleColumnIndex);
            }
        };
        IgxGridNavigationService.prototype.focusPreviousElement = function (currentRowEl, visibleColumnIndex) {
            this.focusElem(currentRowEl.previousElementSibling, visibleColumnIndex);
        };
        IgxGridNavigationService.prototype.navigateDown = function (rowElement, selectedNode) {
            var _this = this;
            var currentRowIndex = selectedNode.row;
            var visibleColumnIndex = selectedNode.column;
            if (currentRowIndex === this.grid.dataView.length - 1 ||
                (currentRowIndex === 0 && rowElement.tagName.toLowerCase() === 'igx-grid-summary-row')) {
                // check if this is rootSummary row
                return;
            }
            var rowHeight = this.grid.verticalScrollContainer.getSizeAt(currentRowIndex + 1);
            var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
            var targetEndTopOffset = rowElement.nextElementSibling ?
                rowElement.nextElementSibling.offsetTop + rowHeight + parseInt(this.verticalDisplayContainerElement.style.top, 10) :
                containerHeight + rowHeight;
            this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
            if (containerHeight && containerHeight < targetEndTopOffset) {
                var nextIndex_1 = currentRowIndex + 1;
                this.grid.verticalScrollContainer.scrollTo(nextIndex_1);
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(operators.first())
                    .subscribe(function () {
                    rowElement = _this.getNextRowByIndex(nextIndex_1);
                    _this.focusElem(rowElement, visibleColumnIndex);
                });
            }
            else {
                this.focusNextElement(rowElement, visibleColumnIndex);
            }
        };
        IgxGridNavigationService.prototype.focusElem = function (rowElement, visibleColumnIndex) {
            if (rowElement.tagName.toLowerCase() === 'igx-grid-groupby-row' || rowElement.className === 'igx-grid__tr-container') {
                rowElement.focus();
            }
            else {
                var isSummaryRow = rowElement.tagName.toLowerCase() === 'igx-grid-summary-row';
                if (this.isColumnFullyVisible(visibleColumnIndex)) {
                    var cellSelector = this.getCellSelector(visibleColumnIndex, isSummaryRow);
                    var cell = rowElement.querySelector(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                    cell.focus();
                    return cell;
                }
                this.performHorizontalScrollToCell(parseInt(rowElement.getAttribute('data-rowindex'), 10), visibleColumnIndex, isSummaryRow);
            }
        };
        IgxGridNavigationService.prototype.focusNextElement = function (rowElement, visibleColumnIndex) {
            return this.focusElem(rowElement.nextElementSibling, visibleColumnIndex);
        };
        IgxGridNavigationService.prototype.goToFirstCell = function () {
            var _this = this;
            var targetIndex = this.findFirstDataRowIndex();
            var targetScr = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, false);
            var verticalScroll = this.grid.verticalScrollContainer.getScroll();
            if (verticalScroll.scrollTop === targetScr) {
                this.onKeydownHome(this.grid.dataRowList.first.index);
            }
            else {
                this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
                this.grid.verticalScrollContainer.scrollTo(targetIndex !== -1 ? targetIndex : 0);
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(operators.first()).subscribe(function () {
                    _this.onKeydownHome(_this.grid.dataRowList.first.index);
                });
            }
        };
        IgxGridNavigationService.prototype.goToLastCell = function () {
            var _this = this;
            var targetIndex = this.findLastDataRowIndex();
            var targetScr = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex, true);
            var verticalScroll = this.grid.verticalScrollContainer.getScroll();
            if (verticalScroll.scrollHeight === 0 ||
                verticalScroll.scrollTop === targetScr) {
                var rows = this.getAllRows();
                var rowIndex = parseInt(rows[rows.length - 1].getAttribute('data-rowIndex'), 10);
                this.onKeydownEnd(rowIndex);
            }
            else {
                this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
                this.grid.verticalScrollContainer.scrollTo(targetIndex !== -1 ? targetIndex : this.grid.dataView.length - 1);
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(operators.first()).subscribe(function () {
                    var rows = _this.getAllRows();
                    if (rows.length > 0) {
                        var rowIndex = parseInt(rows[rows.length - 1].getAttribute('data-rowIndex'), 10);
                        _this.onKeydownEnd(rowIndex);
                    }
                });
            }
        };
        IgxGridNavigationService.prototype.goToLastBodyElement = function () {
            var _this = this;
            var verticalScroll = this.grid.verticalScrollContainer.getScroll();
            if (verticalScroll.scrollHeight === 0 ||
                verticalScroll.scrollTop === verticalScroll.scrollHeight - this.grid.verticalScrollContainer.igxForContainerSize) {
                var rowIndex = this.grid.dataView.length - 1;
                var row = this.grid.nativeElement.querySelector("[data-rowindex=\"" + rowIndex + "\"]");
                var isRowTarget = row.tagName.toLowerCase() === 'igx-grid-groupby-row' ||
                    this.grid.isDetailRecord(this.grid.dataView[rowIndex]);
                if (row && isRowTarget) {
                    row.focus();
                    return;
                }
                var isSummary = (row && row.tagName.toLowerCase() === 'igx-grid-summary-row') ? true : false;
                this.onKeydownEnd(rowIndex, isSummary);
            }
            else {
                this.grid.verticalScrollContainer.scrollTo(this.grid.dataView.length - 1);
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(operators.first()).subscribe(function () {
                    var rowIndex = _this.grid.dataView.length - 1;
                    var row = _this.grid.nativeElement.querySelector("[data-rowindex=\"" + rowIndex + "\"]");
                    var isRowTarget = row.tagName.toLowerCase() === 'igx-grid-groupby-row' ||
                        _this.grid.isDetailRecord(_this.grid.dataView[rowIndex]);
                    if (row && isRowTarget) {
                        row.focus();
                        return;
                    }
                    var isSummary = (row && row.tagName.toLowerCase() === 'igx-grid-summary-row') ? true : false;
                    _this.onKeydownEnd(rowIndex, isSummary);
                });
            }
        };
        IgxGridNavigationService.prototype.performTab = function (currentRowEl, selectedNode) {
            var rowIndex = selectedNode.row;
            var visibleColumnIndex = selectedNode.column;
            var isSummaryRow = selectedNode.isSummaryRow;
            var nextIsDetailRow = rowIndex + 1 <= this.grid.dataView.length - 1 ?
                this.grid.isDetailRecord(this.grid.dataView[rowIndex + 1]) : false;
            var isLastColumn = this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex;
            if (isSummaryRow && rowIndex === 0 &&
                this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
                return;
            }
            if (this.isRowInEditMode(rowIndex)) {
                this.moveNextEditable(rowIndex, visibleColumnIndex);
                return;
            }
            if (nextIsDetailRow && isLastColumn) {
                this.navigateDown(currentRowEl, { row: rowIndex, column: visibleColumnIndex });
                return;
            }
            if (isLastColumn) {
                var rowEl = this.grid.rowList.find(function (row) { return row.index === rowIndex + 1; }) ?
                    this.grid.rowList.find(function (row) { return row.index === rowIndex + 1; }) :
                    this.grid.summariesRowList.find(function (row) { return row.index === rowIndex + 1; });
                if (rowIndex === this.grid.dataView.length - 1 && this.grid.rootSummariesEnabled) {
                    this.onKeydownHome(0, true);
                    return;
                }
                if (rowEl) {
                    this.navigateDown(currentRowEl, { row: rowIndex, column: 0 });
                }
            }
            else {
                var cell = this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummaryRow);
                if (cell) {
                    this.onKeydownArrowRight(cell, selectedNode);
                }
            }
        };
        IgxGridNavigationService.prototype.moveFocusToFilterCell = function (toStart) {
            if (this.grid.filteringService.isFilterRowVisible) {
                this.grid.filteringService.focusFilterRowCloseButton();
                return;
            }
            var columns = this.grid.filteringService.unpinnedFilterableColumns;
            var targetIndex = toStart ? 0 : columns.length - 1;
            var visibleIndex = columns[targetIndex].visibleIndex;
            var isVisible = toStart ? this.isColumnLeftEdgeVisible(visibleIndex) : this.isColumnRightEdgeVisible(visibleIndex);
            if (isVisible) {
                this.grid.filteringService.focusFilterCellChip(columns[targetIndex], false);
            }
            else {
                this.grid.filteringService.scrollToFilterCell(columns[targetIndex], false);
            }
        };
        IgxGridNavigationService.prototype.navigatePrevFilterCell = function (column, eventArgs) {
            var cols = this.grid.filteringService.unpinnedFilterableColumns;
            var prevFilterableIndex = cols.indexOf(column) - 1;
            var visibleIndex = column.visibleIndex;
            if (visibleIndex === 0 || prevFilterableIndex < 0) {
                // prev is not filter cell
                var firstFiltarableCol = this.getFirstPinnedFilterableColumn();
                if (!firstFiltarableCol || column === firstFiltarableCol) {
                    eventArgs.preventDefault();
                }
                return;
            }
            var prevColumn = cols[prevFilterableIndex];
            var prevVisibleIndex = prevColumn.visibleIndex;
            if (prevFilterableIndex >= 0 && visibleIndex > 0 && !this.isColumnLeftEdgeVisible(prevVisibleIndex) && !column.pinned) {
                eventArgs.preventDefault();
                this.grid.filteringService.scrollToFilterCell(prevColumn, false);
            }
        };
        IgxGridNavigationService.prototype.navigateFirstCellIfPossible = function (eventArgs) {
            if (this.grid.rowList.length > 0) {
                if (this.grid.rowList.filter(function (row) { return row instanceof IgxGridGroupByRowComponent; }).length > 0) {
                    eventArgs.stopPropagation();
                    return;
                }
                this.goToFirstCell();
            }
            else if (this.grid.rootSummariesEnabled) {
                this.onKeydownHome(0, true);
            }
            eventArgs.preventDefault();
        };
        IgxGridNavigationService.prototype.navigateNextFilterCell = function (column, eventArgs) {
            var cols = this.grid.filteringService.unpinnedFilterableColumns;
            var nextFilterableIndex = cols.indexOf(column) + 1;
            if (nextFilterableIndex >= this.grid.filteringService.unpinnedFilterableColumns.length) {
                // next is not filter cell
                this.navigateFirstCellIfPossible(eventArgs);
                return;
            }
            var nextColumn = cols[nextFilterableIndex];
            var nextVisibleIndex = nextColumn.visibleIndex;
            if (!column.pinned && !this.isColumnRightEdgeVisible(nextVisibleIndex)) {
                eventArgs.preventDefault();
                this.grid.filteringService.scrollToFilterCell(nextColumn, true);
            }
            else if (column === this.getLastPinnedFilterableColumn() && !this.isColumnRightEdgeVisible(nextVisibleIndex)) {
                this.grid.filteringService.scrollToFilterCell(nextColumn, false);
                eventArgs.stopPropagation();
            }
        };
        IgxGridNavigationService.prototype.getLastPinnedFilterableColumn = function () {
            var pinnedFilterableColums = this.grid.pinnedColumns.filter(function (col) { return !(col.columnGroup) && col.filterable; });
            return pinnedFilterableColums[pinnedFilterableColums.length - 1];
        };
        IgxGridNavigationService.prototype.getFirstPinnedFilterableColumn = function () {
            return this.grid.pinnedColumns.filter(function (col) { return !(col.columnGroup) && col.filterable; })[0];
        };
        IgxGridNavigationService.prototype.performShiftTabKey = function (currentRowEl, selectedNode) {
            var _this = this;
            var rowIndex = selectedNode.row;
            var visibleColumnIndex = selectedNode.column;
            var isSummary = selectedNode.isSummaryRow;
            if (isSummary && rowIndex === 0 && visibleColumnIndex === 0 && this.grid.rowList.length) {
                this.goToLastBodyElement();
                return;
            }
            if (this.isRowInEditMode(rowIndex)) {
                this.movePreviousEditable(rowIndex, visibleColumnIndex);
                return;
            }
            var prevIsDetailRow = rowIndex > 0 ? this.grid.isDetailRecord(this.grid.dataView[rowIndex - 1]) : false;
            if (visibleColumnIndex === 0 && prevIsDetailRow) {
                var target_1 = currentRowEl.previousElementSibling;
                var applyFocusFunc_1 = function () {
                    target_1 = _this.getRowByIndex(rowIndex - 1, '');
                    target_1.focus({ preventScroll: true });
                };
                if (target_1) {
                    applyFocusFunc_1();
                }
                else {
                    this.performVerticalScrollToCell(rowIndex - 1, visibleColumnIndex, function () {
                        applyFocusFunc_1();
                    });
                }
                return;
            }
            if (visibleColumnIndex === 0) {
                if (rowIndex === 0 && this.grid.allowFiltering && this.grid.filterMode === exports.FilterMode.quickFilter) {
                    this.moveFocusToFilterCell();
                }
                else {
                    this.navigateUp(currentRowEl, {
                        row: rowIndex,
                        column: this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex
                    });
                }
            }
            else {
                var cell = this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary);
                if (cell) {
                    this.onKeydownArrowLeft(cell, selectedNode);
                }
            }
        };
        IgxGridNavigationService.prototype.shouldPerformVerticalScroll = function (targetRowIndex, visibleColumnIndex) {
            var containerTopOffset = parseInt(this.verticalDisplayContainerElement.style.top, 10);
            var targetRow = this.getRowByIndex(targetRowIndex, '');
            var rowHeight = this.grid.verticalScrollContainer.getSizeAt(targetRowIndex);
            var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
            var targetEndTopOffset = targetRow ? targetRow.offsetTop + rowHeight + containerTopOffset :
                containerHeight + rowHeight;
            if (!targetRow || targetRow.offsetTop < Math.abs(containerTopOffset)
                || containerHeight && containerHeight < targetEndTopOffset) {
                return true;
            }
            else {
                return false;
            }
        };
        IgxGridNavigationService.prototype.performVerticalScrollToCell = function (rowIndex, visibleColIndex, cb) {
            this.grid.verticalScrollContainer.scrollTo(rowIndex);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(operators.first()).subscribe(function () {
                cb();
            });
        };
        IgxGridNavigationService.prototype.performHorizontalScrollToCell = function (rowIndex, visibleColumnIndex, isSummary, cb) {
            var _this = this;
            if (isSummary === void 0) { isSummary = false; }
            var unpinnedIndex = this.getColumnUnpinnedIndex(visibleColumnIndex);
            this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
            this.grid.parentVirtDir.onChunkLoad
                .pipe(operators.first())
                .subscribe(function () {
                if (cb) {
                    cb();
                }
                else {
                    var cellElement = _this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary);
                    if (cellElement) {
                        cellElement.focus({ preventScroll: true });
                    }
                }
            });
            this.horizontalScroll(rowIndex).scrollTo(unpinnedIndex);
        };
        IgxGridNavigationService.prototype.getFocusableGrid = function () {
            return this.grid;
        };
        IgxGridNavigationService.prototype.getRowByIndex = function (index, selector) {
            var _this = this;
            if (selector === void 0) { selector = this.getRowSelector(); }
            var gridTag = this.grid.nativeElement.tagName.toLocaleLowerCase();
            var row = Array.from(this.grid.tbody.nativeElement.querySelectorAll(selector + "[data-rowindex=\"" + index + "\"]"))
                .find(function (x) { return _this.getClosestElemByTag(x, gridTag).getAttribute('id') === _this.grid.id; });
            return row;
        };
        IgxGridNavigationService.prototype.getNextRowByIndex = function (nextIndex) {
            var _this = this;
            var gridTag = this.grid.nativeElement.tagName.toLocaleLowerCase();
            var row = Array.from(this.grid.tbody.nativeElement.querySelectorAll("[data-rowindex=\"" + nextIndex + "\"]")).find(function (x) { return _this.getClosestElemByTag(x, gridTag).getAttribute('id') === _this.grid.id; });
            return row;
        };
        IgxGridNavigationService.prototype.getAllRows = function () {
            var selector = this.getRowSelector();
            return this.grid.nativeElement.querySelectorAll(selector);
        };
        IgxGridNavigationService.prototype.getCellSelector = function (visibleIndex, isSummary) {
            if (isSummary === void 0) { isSummary = false; }
            if (visibleIndex === 0 && this.grid.hasDetails && !isSummary) {
                return 'igx-expandable-grid-cell';
            }
            return isSummary ? 'igx-grid-summary-cell' : 'igx-grid-cell';
        };
        IgxGridNavigationService.prototype.getRowSelector = function () {
            return 'igx-grid-row';
        };
        IgxGridNavigationService.prototype.getClosestElemByTag = function (sourceElem, targetTag) {
            var result = sourceElem;
            while (result !== null && result.nodeType === 1) {
                if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                    return result;
                }
                result = result.parentNode;
            }
            return null;
        };
        IgxGridNavigationService = __decorate([
            core.Injectable()
        ], IgxGridNavigationService);
        return IgxGridNavigationService;
    }());

    /* tslint:disable */
    var icons = [
        {
            name: 'add_filter',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M19 15v-3h-2v3h-3v2h3v3h2v-3h3v-2h-3zM5 10h10v2H5zM2 5h16v2H2zM8 15h4v2H8z\"/>\n      </svg>"
        },
        {
            name: 'contains',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"Layer_1\" data-name=\"Layer 1\" viewBox=\"0 0 24 24\">\n        <path d=\"M3 3v18h18V3zm16 16H5V5h14z\"/>\n        <path d=\"M12 11.3a4.39 4.39 0 0 0-2.54.63 2.07 2.07 0 0 0-.9 1.78 2.29 2.29 0 0 0 .66 1.74 2.63 2.63 0 0 0 1.89.63 2.39 2.39 0 0 0 1.32-.37 3.05 3.05 0 0 0 1-.93 3.72 3.72 0 0 0 .08.57c0 .19.1.38.16.58h1.79a4.51 4.51 0 0 1-.21-.88 5.57 5.57 0 0 1-.07-.93v-3.5a2.44 2.44 0 0 0-.84-2 3.34 3.34 0 0 0-2.22-.7 3.54 3.54 0 0 0-2.3.72A1.93 1.93 0 0 0 9 10.29h1.71a.93.93 0 0 1 .29-.71 1.5 1.5 0 0 1 1-.29 1.45 1.45 0 0 1 1 .35 1.3 1.3 0 0 1 .37 1v.69zm1.4 1.08v1.17a1.61 1.61 0 0 1-.71.77 2.27 2.27 0 0 1-1.21.34 1.18 1.18 0 0 1-.84-.27.92.92 0 0 1-.3-.72 1.16 1.16 0 0 1 .44-.9 1.76 1.76 0 0 1 1.22-.39z\"/>\n      </svg>"
        },
        {
            name: 'does_not_contain',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21,19.74V3H4.26L2.89,1.63,1.63,2.92,3,4.29V21H19.73l1.37,1.37,1.27-1.26ZM5,19V6.28l5.28,5.27a3.19,3.19,0,0,0-.81.38,2.07,2.07,0,0,0-.9,1.78,2.29,2.29,0,0,0,.66,1.74,2.63,2.63,0,0,0,1.89.63,2.39,2.39,0,0,0,1.32-.37,3.05,3.05,0,0,0,1-.93,3.72,3.72,0,0,0,.08.57c0,.19.1.38.16.58h1L17.73,19Zm5.79-6.23a1.31,1.31,0,0,1,.45-.25l1.37,1.36.28.29a1.57,1.57,0,0,1-.19.15,2.27,2.27,0,0,1-1.21.34,1.18,1.18,0,0,1-.84-.27.92.92,0,0,1-.3-.72A1.16,1.16,0,0,1,10.79,12.77Zm2.6-1.47h-.83L10.94,9.68l.08-.1a1.5,1.5,0,0,1,1-.29,1.45,1.45,0,0,1,1,.35,1.3,1.3,0,0,1,.37,1ZM19,17.74l-3.85-3.85V10.62a2.44,2.44,0,0,0-.84-2,3.34,3.34,0,0,0-2.22-.7,3.64,3.64,0,0,0-2.24.67L6.26,5H19Z\"/>\n    </svg>"
        },
        {
            name: 'all',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M2 14h8v2H2zM2 6h12v2H2zM16 17l-3-3-1.5 1.5L16 20l7-7-1.5-1.5L16 17zM2 10h12v2H2z\"/>\n      </svg>\n      "
        },
        {
            name: 'empty',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5 17h2v2H5zM13 17h2v2h-2zM5 13h2v2H5zM17 17h2v2h-2zM13 5h2v2h-2zM9 17h2v2H9zM17 9h2v2h-2zM17 13h2v2h-2zM17 5h2v2h-2zM5 9h2v2H5zM5 5h2v2H5zM9 5h2v2H9z\"/>\n      </svg>"
        },
        {
            name: 'end_expression',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M13.14 6.76L17.49 12l-4.35 5.24 1.54 1.28L20.09 12l-5.41-6.52-1.54 1.28z\"/>\n        <path d=\"M11.91 11h2v2h-2zM7.91 11h2v2h-2zM3.91 11h2v2h-2z\"/>\n      </svg>"
        },
        {
            name: 'ends_with',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M3 14.5h2v2H3zM11 14.5h2v2h-2zM7 14.5h2v2H7zM20.8 14.8v-3A2.1 2.1 0 0 0 20 10a3 3 0 0 0-2-.6 3 3 0 0 0-2 .6 1.7 1.7 0 0 0-.7 1.5h1.5a.8.8 0 0 1 .3-.7 1.3 1.3 0 0 1 .9-.3 1.3 1.3 0 0 1 .9.4 1.1 1.1 0 0 1 .3.8v.6H18a3.8 3.8 0 0 0-2.2.6 1.8 1.8 0 0 0-.8 1.5 2 2 0 0 0 .6 1.6 2.3 2.3 0 0 0 1.6.6 2.1 2.1 0 0 0 1.2-.4 2.8 2.8 0 0 0 .8-.8 4.3 4.3 0 0 0 .1.5l.1.5H21a4.1 4.1 0 0 1-.2-.7 5.4 5.4 0 0 1 0-1zm-1.6-.5a1.5 1.5 0 0 1-.6.7 2 2 0 0 1-1 .2 1.1 1.1 0 0 1-.8-.2.8.8 0 0 1-.2-.6 1 1 0 0 1 .3-.8 1.5 1.5 0 0 1 1.1-.3h1.2z\"/>\n      </svg>"
        },
        {
            name: 'equals',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5 13.5h14v2H5zM5 8.5h14v2H5z\"/>\n      </svg>"
        },
        {
            name: 'greater_than_or_equal',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5.99 19h12.02v2H5.99zM18 9.47L6 3v2.11L15.09 10 6 14.9v2.11l12-6.47V9.47z\"/>\n      </svg>"
        },
        {
            name: 'greater_than',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M6 7.11L15.09 12 6 16.89V19l12-6.46v-1.08L6 5v2.11z\"/>\n      </svg>\n      "
        },
        {
            name: 'is_after',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M15 7h4v10h-4v2h6V5h-6v2zM11 3h2v18h-2zM7 5h2v2H7zM3 5h2v2H3zM3 17h2v2H3zM3 13h2v2H3zM3 9h2v2H3zM7 17h2v2H7z\"/>\n      </svg>"
        },
        {
            name: 'is_before',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M3 19h6v-2H5V7h4V5H3v14zM11 3h2v18h-2zM15 5h2v2h-2zM19 5h2v2h-2zM19 13h2v2h-2zM15 17h2v2h-2zM19 17h2v2h-2zM19 9h2v2h-2z\"/>\n      </svg>"
        },
        {
            name: 'is_false',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M8 5a7 7 0 1 0 7 7 7 7 0 0 0-7-7zm4.31 9.79l-1.52 1.52L8 13.52l-2.79 2.79-1.52-1.52L6.48 12 3.69 9.21l1.52-1.52L8 10.48l2.79-2.79 1.52 1.52L9.52 12zM18 7a5 5 0 0 0-3 1.06 7.48 7.48 0 0 1 .49 1 3.89 3.89 0 1 1 0 5.82 8.08 8.08 0 0 1-.49 1A5 5 0 1 0 18 7z\"/>\n        <path d=\"M17.52 13.85l2.91-2.92-.78-.78-2.13 2.12-1.17-1.15-.38.37-.41.41.42.42L17 13.34l.52.51z\"/>\n      </svg>"
        },
        {
            name: 'is_not_null',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M16.58 6.07l.79-1.36-1.74-1-.78 1.35a7.5 7.5 0 0 0-7.43 12.87l-.79 1.36 1.74 1 .78-1.35a7.5 7.5 0 0 0 7.43-12.87zM6.5 12A5.5 5.5 0 0 1 12 6.5a5.65 5.65 0 0 1 1.84.32l-5.41 9.36A5.49 5.49 0 0 1 6.5 12zm5.5 5.5a5.65 5.65 0 0 1-1.84-.32l5.41-9.36A5.5 5.5 0 0 1 12 17.5z\"/>\n      </svg>"
        },
        {
            name: 'is_null',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M12 4.5a7.5 7.5 0 1 0 7.5 7.5A7.5 7.5 0 0 0 12 4.5zm0 13a5.5 5.5 0 1 1 5.5-5.5 5.5 5.5 0 0 1-5.5 5.5z\"/>\n      </svg>"
        },
        {
            name: 'is_true',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M19.44 14.22zM16.56 14.22zM16.56 14.22L18 12.79l1.44 1.43.78-.78L18.79 12l1.43-1.44-.78-.78L18 11.21l-1.44-1.43-.78.78L17.21 12l-1.43 1.44.78.78z\"/>\n        <path d=\"M18 7a5 5 0 0 0-3 1.06 7.48 7.48 0 0 1 .49 1 3.89 3.89 0 1 1 0 5.82 8.08 8.08 0 0 1-.49 1A5 5 0 1 0 18 7zM8 5a7 7 0 1 0 7 7 7 7 0 0 0-7-7zm-.93 10.18l-3.38-3.37 1.13-1.12 2.25 2.25 4.11-4.12 1.13 1.12z\"/>\n      </svg>"
        },
        {
            name: 'last_month',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M17.5 14a4.48 4.48 0 1 0 4.5 4.5 4.47 4.47 0 0 0-4.5-4.5zm3.5 5.5h-4v2l-3-3 3-3v2h4zM5 9h2v2H5zM5 13h2v2H5zM10 13h2v2h-2zM5 17h2v2H5zM10 17h2v2h-2zM10 9h2v2h-2zM15 9h2v2h-2z\"/>\n        <path d=\"M4 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H7V1H5v2H4a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H4z\"/>\n      </svg>"
        },
        {
            name: 'last_year',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21 10v11H7v2h14a2 2 0 0 0 2-2V10z\"/>\n        <path d=\"M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z\"/>\n        <path d=\"M8.87 9l-2.99 3 2.99 3v-2.25h5.26v-1.5H8.87V9z\"/>\n      </svg>"
        },
        {
            name: 'less_than_or_equal',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5.99 19h12.02v2H5.99zM18 14.9L8.91 10 18 5.11V3L6 9.47v1.07l12 6.47V14.9z\"/>\n      </svg>"
        },
        {
            name: 'less_than',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M6 12.54L18 19v-2.11L8.91 12 18 7.11V5L6 11.46v1.08z\"/>\n      </svg>"
        },
        {
            name: 'next_month',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M20 14.76a4.5 4.5 0 1 0 2 3.74 4.47 4.47 0 0 0-2-3.74zm-2 6.74v-2h-4v-2h4v-2l3 3zM5 9h2v2H5zM5 13h2v2H5zM10 13h2v2h-2zM5 17h2v2H5zM10 17h2v2h-2zM10 9h2v2h-2zM15 9h2v2h-2z\"/>\n        <path d=\"M4 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H7V1H5v2H4a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H4z\"/>\n      </svg>"
        },
        {
            name: 'next_year',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21 21H7v2h14a2 2 0 0 0 2-2V10h-2z\"/>\n        <path d=\"M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z\"/>\n        <path d=\"M11.13 11.25H5.88v1.5h5.25V15l3-3-3-3v2.25z\"/>\n      </svg>"
        },
        {
            name: 'not_empty',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5 9h2v2H5zM9 17h2v2H9zM13 17h2v2h-2zM17 9h2v2h-2zM17 5h2v2h-2zM5 17h2v2H5zM13 5h2v2h-2zM5 13h2v2H5zM19 15v-2h-2v.47L18.53 15H19zM11 7V5H9v.46L10.54 7H11zM2.76 1.76L1.5 3.06 20.97 22.5l1.26-1.26-8.89-8.89L2.76 1.76z\"/>\n      </svg>"
        },
        {
            name: 'not_equal',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M17.37 4.71l-1.74-1-2.76 4.79H5v2h6.71l-1.73 3H5v2h3.82l-2.19 3.79 1.74 1 2.76-4.79H19v-2h-6.71l1.73-3H19v-2h-3.82l2.19-3.79z\"/>\n      </svg>"
        },
        {
            name: 'start_expression',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M18.1 11h2v2h-2zM10.1 11h2v2h-2z\"/>\n        <path d=\"M10.9 6.8L9.3 5.5 4 12l5.4 6.5 1.6-1.3L6.5 12 11 6.8zM14.1 11h2v2h-2z\"/>\n      </svg>"
        },
        {
            name: 'starts_with',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path fill=\"none\" d=\"M4.97 13.23h3.06L6.5 9.12l-1.53 4.11z\"/>\n        <path d=\"M5.89 7.5L2 16.5h1.72l.73-1.8h4.1l.73 1.8H11l-3.89-9zM5 13.23l1.5-4.11L8 13.23zM12 14.5h2v2h-2zM20 14.5h2v2h-2zM16 14.5h2v2h-2z\"/>\n      </svg>"
        },
        {
            name: 'this_month',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M6 9h2v2H6zM6 13h2v2H6zM11 13h2v2h-2zM6 17h2v2H6zM11 17h2v2h-2zM11 9h2v2h-2zM16 9h2v2h-2zM21 14.76a4.5 4.5 0 1 0 2 3.74 4.47 4.47 0 0 0-2-3.74zm-2.94 5.41l-1.75-1.76.69-.71 1.05 1L20 16.83l.71.71z\"/>\n        <path d=\"M5 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H8V1H6v2H5a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H5z\"/>\n      </svg>"
        },
        {
            name: 'this_year',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21 21H7v2h14a2 2 0 0 0 2-2V10h-2z\"/>\n        <path d=\"M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z\"/>\n        <path d=\"M8.85 13.15l-1.77-1.77-.88.89 2.65 2.65 4.95-4.96-.88-.88-4.07 4.07z\"/>\n      </svg>"
        },
        {
            name: 'today',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M19 4h-1V2h-2v2H8V2H6v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V9h14z\"/>\n        <path d=\"M16.53 12.06L15.47 11l-4.88 4.88-2.12-2.12-1.06 1.06L10.59 18l5.94-5.94z\"/>\n      </svg>"
        },
        {
            name: 'ungroup',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M15 15h5v5h-5zM6 13h5v5H6zM13 6h5v5h-5zM6 6h5v5H6z\"/>\n        <path d=\"M20 2H4a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h9v-2H4V4h16v9h2V4a2 2 0 0 0-2-2z\"/>\n      </svg>"
        },
        {
            name: 'yesterday',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M10.68 15.38h6.13v-1.75h-6.13V11l-3.49 3.5 3.49 3.5v-2.62z\"/>\n        <path d=\"M19 4h-1V2h-2v2H8V2H6v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V9h14z\"/>\n      </svg>"
        },
        {
            name: 'pin',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M15.18 2.25l7.07 7.07-2.83-.01-3.54 3.55.01 4.24-3.53-3.54-5.66 5.66H5.28V17.8l5.66-5.66L7.4 8.61l4.24.01 3.55-3.54-.01-2.83z\"/>\n      </svg>"
        },
        {
            name: 'unpin',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path fill=\"none\" d=\"M0 0h24v25H0V0z\"/>\n        <path d=\"M11.84 14.08L6.7 19.22H5.28V17.8l5.14-5.14L2 4.26 3.29 3l18 18L20 22.21zm4-.49l-5-5h.73l3.55-3.54v-2.8l7.07 7.07h-2.77l-3.54 3.54z\" />\n      </svg>"
        },
        {
            name: 'ungroup',
            value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n          <path d=\"M18,4.5H6A1.5,1.5,0,0,0,4.5,6V18A1.5,1.5,0,0,0,6,19.5h6.75V18H6V6H18v6.75h1.5V6A1.5,1.5,0,0,0,18,4.5Z\"/>\n          <rect x=\"7.5\" y=\"12.75\" width=\"3.75\" height=\"3.75\"/>\n          <rect x=\"14.25\" y=\"14.25\" width=\"3.75\" height=\"3.75\"/>\n          <rect x=\"7.5\" y=\"7.5\" width=\"3.75\" height=\"3.75\"/>\n          <rect x=\"12.75\" y=\"7.5\" width=\"3.75\" height=\"3.75\"/>\n        </svg>"
        }
    ];

    /**
     * @hidden
     * @internal
     */
    var IgxGridCellStyleClassesPipe = /** @class */ (function () {
        function IgxGridCellStyleClassesPipe() {
        }
        IgxGridCellStyleClassesPipe.prototype.transform = function (cssClasses, value, data, field, index) {
            var e_1, _a;
            if (!cssClasses) {
                return '';
            }
            var result = [];
            try {
                for (var _b = __values(Object.keys(cssClasses)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var cssClass = _c.value;
                    var callbackOrValue = cssClasses[cssClass];
                    var apply = typeof callbackOrValue === 'function' ? callbackOrValue(data, field, value, index) : callbackOrValue;
                    if (apply) {
                        result.push(cssClass);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result.join(' ');
        };
        IgxGridCellStyleClassesPipe = __decorate([
            core.Pipe({
                name: 'igxCellStyleClasses'
            })
        ], IgxGridCellStyleClassesPipe);
        return IgxGridCellStyleClassesPipe;
    }());
    /**
     * @hidden
     * @internal
     */
    var IgxGridCellStylesPipe = /** @class */ (function () {
        function IgxGridCellStylesPipe() {
        }
        IgxGridCellStylesPipe.prototype.transform = function (styles, value, data, field, index) {
            var e_2, _a;
            var css = {};
            if (!styles) {
                return css;
            }
            try {
                for (var _b = __values(Object.keys(styles)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var prop = _c.value;
                    var res = styles[prop];
                    css[prop] = typeof res === 'function' ? res(data, field, value, index) : res;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return css;
        };
        IgxGridCellStylesPipe = __decorate([
            core.Pipe({
                name: 'igxCellStyles'
            })
        ], IgxGridCellStylesPipe);
        return IgxGridCellStylesPipe;
    }());
    /**
     * @hidden
     * @internal
     */
    var IgxGridNotGroupedPipe = /** @class */ (function () {
        function IgxGridNotGroupedPipe() {
        }
        IgxGridNotGroupedPipe.prototype.transform = function (value) {
            return value.filter(function (item) { return !item.columnGroup; });
        };
        IgxGridNotGroupedPipe = __decorate([
            core.Pipe({
                name: 'igxNotGrouped'
            })
        ], IgxGridNotGroupedPipe);
        return IgxGridNotGroupedPipe;
    }());
    /**
     * @hidden
     * @internal
     */
    var IgxGridTopLevelColumns = /** @class */ (function () {
        function IgxGridTopLevelColumns() {
        }
        IgxGridTopLevelColumns.prototype.transform = function (value) {
            return value.filter(function (item) { return item.level === 0; });
        };
        IgxGridTopLevelColumns = __decorate([
            core.Pipe({
                name: 'igxTopLevel'
            })
        ], IgxGridTopLevelColumns);
        return IgxGridTopLevelColumns;
    }());
    /**
     * @hidden
     * @internal
     */
    var IgxGridFilterConditionPipe = /** @class */ (function () {
        function IgxGridFilterConditionPipe() {
        }
        IgxGridFilterConditionPipe.prototype.transform = function (value) {
            return value.split(/(?=[A-Z])/).join(' ');
        };
        IgxGridFilterConditionPipe = __decorate([
            core.Pipe({
                name: 'filterCondition',
                pure: true
            })
        ], IgxGridFilterConditionPipe);
        return IgxGridFilterConditionPipe;
    }());
    /**
     * @hidden
     * @internal
     */
    var IgxGridTransactionPipe = /** @class */ (function () {
        function IgxGridTransactionPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridTransactionPipe.prototype.transform = function (collection, id, pipeTrigger) {
            var grid = this.gridAPI.grid;
            if (grid.transactions.enabled) {
                var result = DataUtil.mergeTransactions(cloneArray(collection), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
                return result;
            }
            return collection;
        };
        IgxGridTransactionPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxGridTransactionPipe = __decorate([
            core.Pipe({
                name: 'gridTransaction',
                pure: true
            })
        ], IgxGridTransactionPipe);
        return IgxGridTransactionPipe;
    }());
    /**
     * @hidden
     * @internal
     */
    var IgxGridPaginatorOptionsPipe = /** @class */ (function () {
        function IgxGridPaginatorOptionsPipe() {
        }
        IgxGridPaginatorOptionsPipe.prototype.transform = function (values) {
            return Array.from(new Set(__spread(values))).sort(function (a, b) { return a - b; });
        };
        IgxGridPaginatorOptionsPipe = __decorate([
            core.Pipe({
                name: 'paginatorOptions',
                pure: true,
            })
        ], IgxGridPaginatorOptionsPipe);
        return IgxGridPaginatorOptionsPipe;
    }());
    /**
     * @hidden
     * @internal
     */
    var IgxHasVisibleColumnsPipe = /** @class */ (function () {
        function IgxHasVisibleColumnsPipe() {
        }
        IgxHasVisibleColumnsPipe.prototype.transform = function (values, hasVisibleColumns) {
            if (!(values && values.length)) {
                return values;
            }
            return hasVisibleColumns ? values : [];
        };
        IgxHasVisibleColumnsPipe = __decorate([
            core.Pipe({
                name: 'visibleColumns',
                pure: true
            })
        ], IgxHasVisibleColumnsPipe);
        return IgxHasVisibleColumnsPipe;
    }());
    /**
     * @hidden
     * @internal
     */
    var IgxDatePipeComponent = /** @class */ (function (_super) {
        __extends(IgxDatePipeComponent, _super);
        function IgxDatePipeComponent(locale) {
            var _this = 
            // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
            _super.call(this, locale) || this;
            _this.DEFAULT_DATE_FORMAT = 'mediumDate';
            return _this;
        }
        IgxDatePipeComponent.prototype.transform = function (value, locale) {
            if (value && value instanceof Date) {
                if (locale) {
                    return _super.prototype.transform.call(this, value, this.DEFAULT_DATE_FORMAT, undefined, locale);
                }
                else {
                    return _super.prototype.transform.call(this, value);
                }
            }
            else {
                return value;
            }
        };
        IgxDatePipeComponent.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [core.LOCALE_ID,] }] }
        ]; };
        IgxDatePipeComponent = __decorate([
            core.Pipe({
                name: 'igxdate'
            }),
            __param(0, core.Inject(core.LOCALE_ID))
        ], IgxDatePipeComponent);
        return IgxDatePipeComponent;
    }(common.DatePipe));
    /**
     * @hidden
     * @internal
     */
    var IgxDecimalPipeComponent = /** @class */ (function (_super) {
        __extends(IgxDecimalPipeComponent, _super);
        function IgxDecimalPipeComponent(locale) {
            // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
            return _super.call(this, locale) || this;
        }
        IgxDecimalPipeComponent.prototype.transform = function (value, locale) {
            if (value && typeof value === 'number') {
                if (locale) {
                    return _super.prototype.transform.call(this, value, undefined, locale);
                }
                else {
                    return _super.prototype.transform.call(this, value);
                }
            }
            else {
                return value;
            }
        };
        IgxDecimalPipeComponent.ctorParameters = function () { return [
            { type: String, decorators: [{ type: core.Inject, args: [core.LOCALE_ID,] }] }
        ]; };
        IgxDecimalPipeComponent = __decorate([
            core.Pipe({
                name: 'igxdecimal'
            }),
            __param(0, core.Inject(core.LOCALE_ID))
        ], IgxDecimalPipeComponent);
        return IgxDecimalPipeComponent;
    }(common.DecimalPipe));

    var FILTERING_ICONS_FONT_SET = 'filtering-icons';
    /**
     *@hidden
     */
    var ExpressionUI = /** @class */ (function () {
        function ExpressionUI() {
            this.isSelected = false;
            this.isVisible = true;
        }
        return ExpressionUI;
    }());
    /**
     *@hidden
     */
    var IgxFilteringService = /** @class */ (function () {
        function IgxFilteringService(gridAPI, iconService) {
            this.gridAPI = gridAPI;
            this.iconService = iconService;
            this.columnsWithComplexFilter = new Set();
            this.areEventsSubscribed = false;
            this.destroy$ = new rxjs.Subject();
            this.isFiltering = false;
            this.columnToExpressionsMap = new Map();
            this.columnStartIndex = -1;
            this._filterIconsRegistered = false;
            this.isFilterRowVisible = false;
            this.filteredColumn = null;
            this.selectedExpression = null;
            this.columnToFocus = null;
            this.shouldFocusNext = false;
            this.columnToMoreIconHidden = new Map();
        }
        IgxFilteringService.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        Object.defineProperty(IgxFilteringService.prototype, "displayContainerWidth", {
            get: function () {
                return parseInt(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth, 10);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxFilteringService.prototype, "displayContainerScrollLeft", {
            get: function () {
                return this.grid.headerContainer.scrollPosition;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxFilteringService.prototype, "areAllColumnsInView", {
            get: function () {
                return parseInt(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth, 10) === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxFilteringService.prototype, "unpinnedFilterableColumns", {
            get: function () {
                return this.grid.unpinnedColumns.filter(function (col) { return !col.columnGroup && col.filterable; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxFilteringService.prototype, "unpinnedColumns", {
            get: function () {
                return this.grid.unpinnedColumns.filter(function (col) { return !col.columnGroup; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxFilteringService.prototype, "datePipe", {
            get: function () {
                if (!this._datePipe) {
                    this._datePipe = new IgxDatePipeComponent(this.grid.locale);
                }
                return this._datePipe;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Subscribe to grid's events.
         */
        IgxFilteringService.prototype.subscribeToEvents = function () {
            var _this = this;
            if (!this.areEventsSubscribed) {
                this.areEventsSubscribed = true;
                this.grid.onColumnResized.pipe(operators.takeUntil(this.destroy$)).subscribe(function (eventArgs) {
                    _this.updateFilteringCell(eventArgs.column);
                });
                this.grid.parentVirtDir.onChunkLoad.pipe(operators.takeUntil(this.destroy$)).subscribe(function (eventArgs) {
                    if (eventArgs.startIndex !== _this.columnStartIndex) {
                        _this.columnStartIndex = eventArgs.startIndex;
                        _this.grid.filterCellList.forEach(function (filterCell) {
                            filterCell.updateFilterCellArea();
                        });
                    }
                    if (_this.columnToFocus) {
                        _this.focusFilterCellChip(_this.columnToFocus, false);
                        _this.columnToFocus = null;
                    }
                });
                this.grid.onColumnMovingEnd.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                    _this.grid.filterCellList.forEach(function (filterCell) {
                        filterCell.updateFilterCellArea();
                    });
                });
                this.grid.onColumnVisibilityChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function (eventArgs) {
                    if (_this.grid.filteringRow && _this.grid.filteringRow.column === eventArgs.column) {
                        _this.grid.filteringRow.close();
                    }
                });
            }
        };
        /**
         * Internal method to create expressionsTree and filter grid used in both filter modes.
         */
        IgxFilteringService.prototype.filterInternal = function (field, expressions) {
            if (expressions === void 0) { expressions = null; }
            this.isFiltering = true;
            var expressionsTree;
            if (expressions instanceof FilteringExpressionsTree) {
                expressionsTree = expressions;
            }
            else {
                expressionsTree = this.createSimpleFilteringTree(field, expressions);
            }
            if (expressionsTree.filteringOperands.length === 0) {
                this.clearFilter(field);
            }
            else {
                this.filter(field, null, expressionsTree);
            }
            this.isFiltering = false;
        };
        /**
         * Execute filtering on the grid.
         */
        IgxFilteringService.prototype.filter = function (field, value, conditionOrExpressionTree, ignoreCase) {
            var _this = this;
            var col = this.gridAPI.get_column_by_name(field);
            var filteringIgnoreCase = ignoreCase || (col ? col.filteringIgnoreCase : false);
            if (conditionOrExpressionTree) {
                this.gridAPI.filter(field, value, conditionOrExpressionTree, filteringIgnoreCase);
            }
            else {
                var expressionsTreeForColumn = this.grid.filteringExpressionsTree.find(field);
                if (!expressionsTreeForColumn) {
                    throw new Error('Invalid condition or Expression Tree!');
                }
                else if (expressionsTreeForColumn instanceof FilteringExpressionsTree) {
                    this.gridAPI.filter(field, value, expressionsTreeForColumn, filteringIgnoreCase);
                }
                else {
                    var expressionForColumn = expressionsTreeForColumn;
                    this.gridAPI.filter(field, value, expressionForColumn.condition, filteringIgnoreCase);
                }
            }
            // Wait for the change detection to update filtered data through the pipes and then emit the event.
            requestAnimationFrame(function () { return _this.grid.onFilteringDone.emit(col.filteringExpressionsTree); });
        };
        /**
         * Clear the filter of a given column.
         */
        IgxFilteringService.prototype.clearFilter = function (field) {
            var _this = this;
            if (field) {
                var column = this.gridAPI.get_column_by_name(field);
                if (!column) {
                    return;
                }
            }
            this.isFiltering = true;
            this.gridAPI.clear_filter(field);
            // Wait for the change detection to update filtered data through the pipes and then emit the event.
            requestAnimationFrame(function () { return _this.grid.onFilteringDone.emit(null); });
            if (field) {
                var expressions = this.getExpressions(field);
                expressions.length = 0;
            }
            this.isFiltering = false;
        };
        /**
         * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
         */
        IgxFilteringService.prototype.filterGlobal = function (value, condition, ignoreCase) {
            var _this = this;
            this.gridAPI.filter_global(value, condition, ignoreCase);
            // Wait for the change detection to update filtered data through the pipes and then emit the event.
            requestAnimationFrame(function () { return _this.grid.onFilteringDone.emit(_this.grid.filteringExpressionsTree); });
        };
        /**
         * Register filtering SVG icons in the icon service.
         */
        IgxFilteringService.prototype.registerSVGIcons = function () {
            var e_1, _a;
            if (!this._filterIconsRegistered) {
                try {
                    for (var icons_1 = __values(icons), icons_1_1 = icons_1.next(); !icons_1_1.done; icons_1_1 = icons_1.next()) {
                        var icon = icons_1_1.value;
                        if (!this.iconService.isSvgIconCached(icon.name, FILTERING_ICONS_FONT_SET)) {
                            this.iconService.addSvgIconFromText(icon.name, icon.value, FILTERING_ICONS_FONT_SET);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (icons_1_1 && !icons_1_1.done && (_a = icons_1.return)) _a.call(icons_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                this._filterIconsRegistered = true;
            }
        };
        /**
         * Returns the ExpressionUI array for a given column.
         */
        IgxFilteringService.prototype.getExpressions = function (columnId) {
            if (!this.columnToExpressionsMap.has(columnId)) {
                var column = this.grid.columns.find(function (col) { return col.field === columnId; });
                var expressionUIs = new Array();
                if (column) {
                    this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, expressionUIs);
                    this.columnToExpressionsMap.set(columnId, expressionUIs);
                }
                return expressionUIs;
            }
            return this.columnToExpressionsMap.get(columnId);
        };
        /**
         * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.
         */
        IgxFilteringService.prototype.refreshExpressions = function () {
            var _this = this;
            if (!this.isFiltering) {
                this.columnsWithComplexFilter.clear();
                this.columnToExpressionsMap.forEach(function (value, key) {
                    var column = _this.grid.columns.find(function (col) { return col.field === key; });
                    if (column) {
                        value.length = 0;
                        _this.generateExpressionsList(column.filteringExpressionsTree, _this.grid.filteringExpressionsTree.operator, value);
                        var isComplex = _this.isFilteringTreeComplex(column.filteringExpressionsTree);
                        if (isComplex) {
                            _this.columnsWithComplexFilter.add(key);
                        }
                        _this.updateFilteringCell(column);
                    }
                    else {
                        _this.columnToExpressionsMap.delete(key);
                    }
                });
            }
        };
        /**
         * Remove an ExpressionUI for a given column.
         */
        IgxFilteringService.prototype.removeExpression = function (columnId, indexToRemove) {
            var expressionsList = this.getExpressions(columnId);
            if (indexToRemove === 0 && expressionsList.length > 1) {
                expressionsList[1].beforeOperator = null;
            }
            else if (indexToRemove === expressionsList.length - 1) {
                expressionsList[indexToRemove - 1].afterOperator = null;
            }
            else {
                expressionsList[indexToRemove - 1].afterOperator = expressionsList[indexToRemove + 1].beforeOperator;
                expressionsList[0].beforeOperator = null;
                expressionsList[expressionsList.length - 1].afterOperator = null;
            }
            expressionsList.splice(indexToRemove, 1);
        };
        /**
         * Generate filtering tree for a given column from existing ExpressionUIs.
         */
        IgxFilteringService.prototype.createSimpleFilteringTree = function (columnId, expressionUIList) {
            if (expressionUIList === void 0) { expressionUIList = null; }
            var expressionsList = expressionUIList ? expressionUIList : this.getExpressions(columnId);
            var expressionsTree = new FilteringExpressionsTree(exports.FilteringLogic.Or, columnId);
            var currAndBranch;
            var currExpressionUI;
            for (var i = 0; i < expressionsList.length; i++) {
                currExpressionUI = expressionsList[i];
                if (!currExpressionUI.expression.condition.isUnary && currExpressionUI.expression.searchVal === null) {
                    if (currExpressionUI.afterOperator === exports.FilteringLogic.And && !currAndBranch) {
                        currAndBranch = new FilteringExpressionsTree(exports.FilteringLogic.And, columnId);
                        expressionsTree.filteringOperands.push(currAndBranch);
                    }
                    continue;
                }
                if ((currExpressionUI.beforeOperator === undefined || currExpressionUI.beforeOperator === null ||
                    currExpressionUI.beforeOperator === exports.FilteringLogic.Or) &&
                    currExpressionUI.afterOperator === exports.FilteringLogic.And) {
                    currAndBranch = new FilteringExpressionsTree(exports.FilteringLogic.And, columnId);
                    expressionsTree.filteringOperands.push(currAndBranch);
                    currAndBranch.filteringOperands.push(currExpressionUI.expression);
                }
                else if (currExpressionUI.beforeOperator === exports.FilteringLogic.And) {
                    currAndBranch.filteringOperands.push(currExpressionUI.expression);
                }
                else {
                    expressionsTree.filteringOperands.push(currExpressionUI.expression);
                    currAndBranch = null;
                }
            }
            return expressionsTree;
        };
        /**
         * Returns whether a complex filter is applied to a given column.
         */
        IgxFilteringService.prototype.isFilterComplex = function (columnId) {
            if (this.columnsWithComplexFilter.has(columnId)) {
                return true;
            }
            var column = this.grid.columns.find(function (col) { return col.field === columnId; });
            var isComplex = column && this.isFilteringTreeComplex(column.filteringExpressionsTree);
            if (isComplex) {
                this.columnsWithComplexFilter.add(columnId);
            }
            return isComplex;
        };
        /**
         * Returns the string representation of the FilteringLogic operator.
         */
        IgxFilteringService.prototype.getOperatorAsString = function (operator) {
            if (operator === 0) {
                return this.grid.resourceStrings.igx_grid_filter_operator_and;
            }
            else {
                return this.grid.resourceStrings.igx_grid_filter_operator_or;
            }
        };
        /**
         * Generate the label of a chip from a given filtering expression.
         */
        IgxFilteringService.prototype.getChipLabel = function (expression) {
            if (expression.condition.isUnary) {
                return this.grid.resourceStrings["igx_grid_filter_" + expression.condition.name] || expression.condition.name;
            }
            else if (expression.searchVal instanceof Date) {
                return this.datePipe.transform(expression.searchVal, this.grid.locale);
            }
            else {
                return expression.searchVal;
            }
        };
        /**
         * Updates the content of a filterCell.
         */
        IgxFilteringService.prototype.updateFilteringCell = function (column) {
            var filterCell = column.filterCell;
            if (filterCell) {
                filterCell.updateFilterCellArea();
            }
        };
        /**
         * Focus a chip in a filterCell.
         */
        IgxFilteringService.prototype.focusFilterCellChip = function (column, focusFirst) {
            var filterCell = column.filterCell;
            if (filterCell) {
                filterCell.focusChip(focusFirst);
            }
        };
        /**
         * Focus the close button in the filtering row.
         */
        IgxFilteringService.prototype.focusFilterRowCloseButton = function () {
            this.grid.filteringRow.closeButton.nativeElement.focus();
        };
        Object.defineProperty(IgxFilteringService.prototype, "filteredData", {
            get: function () {
                return this.grid.filteredData;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Scrolls to a filterCell.
         */
        IgxFilteringService.prototype.scrollToFilterCell = function (column, shouldFocusNext) {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.columnToFocus = column;
            this.shouldFocusNext = shouldFocusNext;
            var currentColumnRight = 0;
            var currentColumnLeft = 0;
            for (var index = 0; index < this.unpinnedColumns.length; index++) {
                currentColumnRight += parseInt(this.unpinnedColumns[index].width, 10);
                if (this.unpinnedColumns[index] === column) {
                    currentColumnLeft = currentColumnRight - parseInt(this.unpinnedColumns[index].width, 10);
                    break;
                }
            }
            var forOfDir = this.grid.headerContainer;
            var width = this.displayContainerWidth + this.displayContainerScrollLeft;
            if (shouldFocusNext) {
                forOfDir.scrollPosition += currentColumnRight - width;
            }
            else {
                forOfDir.scrollPosition = currentColumnLeft;
            }
        };
        IgxFilteringService.prototype.isFilteringTreeComplex = function (expressions) {
            if (!expressions) {
                return false;
            }
            if (expressions instanceof FilteringExpressionsTree) {
                var expressionsTree = expressions;
                if (expressionsTree.operator === exports.FilteringLogic.Or) {
                    var andOperatorsCount = this.getChildAndOperatorsCount(expressionsTree);
                    // having more that 'And' and operator in the sub-tree means that the filter could not be represented without parentheses.
                    return andOperatorsCount > 1;
                }
                var isComplex = false;
                for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
                    isComplex = isComplex || this.isFilteringTreeComplex(expressionsTree.filteringOperands[i]);
                }
                return isComplex;
            }
            return false;
        };
        IgxFilteringService.prototype.getChildAndOperatorsCount = function (expressions) {
            var count = 0;
            var operand;
            for (var i = 0; i < expressions.filteringOperands.length; i++) {
                operand = expressions[i];
                if (operand instanceof FilteringExpressionsTree) {
                    if (operand.operator === exports.FilteringLogic.And) {
                        count++;
                    }
                    count = count + this.getChildAndOperatorsCount(operand);
                }
            }
            return count;
        };
        IgxFilteringService.prototype.generateExpressionsList = function (expressions, operator, expressionsUIs) {
            this.generateExpressionsListRecursive(expressions, operator, expressionsUIs);
            // The beforeOperator of the first expression and the afterOperator of the last expression should be null
            if (expressionsUIs.length) {
                expressionsUIs[expressionsUIs.length - 1].afterOperator = null;
            }
        };
        IgxFilteringService.prototype.generateExpressionsListRecursive = function (expressions, operator, expressionsUIs) {
            if (!expressions) {
                return;
            }
            if (expressions instanceof FilteringExpressionsTree) {
                var expressionsTree = expressions;
                for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
                    this.generateExpressionsListRecursive(expressionsTree.filteringOperands[i], expressionsTree.operator, expressionsUIs);
                }
                if (expressionsUIs.length) {
                    expressionsUIs[expressionsUIs.length - 1].afterOperator = operator;
                }
            }
            else {
                var exprUI = new ExpressionUI();
                exprUI.expression = expressions;
                exprUI.afterOperator = operator;
                var prevExprUI = expressionsUIs[expressionsUIs.length - 1];
                if (prevExprUI) {
                    exprUI.beforeOperator = prevExprUI.afterOperator;
                }
                expressionsUIs.push(exprUI);
            }
        };
        IgxFilteringService.prototype.isFilteringExpressionsTreeEmpty = function (expressionTree) {
            if (FilteringExpressionsTree.empty(expressionTree)) {
                return true;
            }
            var expr;
            for (var i = 0; i < expressionTree.filteringOperands.length; i++) {
                expr = expressionTree.filteringOperands[i];
                if ((expr instanceof FilteringExpressionsTree)) {
                    var exprTree = expr;
                    if (exprTree.filteringOperands && exprTree.filteringOperands.length) {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
            return true;
        };
        IgxFilteringService.ctorParameters = function () { return [
            { type: GridBaseAPIService },
            { type: IgxIconService }
        ]; };
        IgxFilteringService = __decorate([
            core.Injectable()
        ], IgxFilteringService);
        return IgxFilteringService;
    }());

    /**
     * @hidden
     * @internal
     */
    var IgxColumnResizingService = /** @class */ (function () {
        function IgxColumnResizingService(zone) {
            this.zone = zone;
            /**
             *@hidden
             */
            this.resizeCursor = null;
            /**
             *@hidden
             */
            this.showResizer = false;
        }
        Object.defineProperty(IgxColumnResizingService.prototype, "resizerHeight", {
            /**
             *@hidden
             */
            get: function () {
                var height = this.column.grid.getVisibleContentHeight();
                // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
                var columnHeightMultiplier = 1;
                if (this.column.columnLayoutChild) {
                    columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
                }
                if (this.column.level !== 0) {
                    height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
                }
                return height;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnResizingService.prototype, "restrictResizeMin", {
            /**
             * Returns the minimal possible width to which the column can be resized.
             */
            get: function () {
                var actualMinWidth = parseFloat(this.column.minWidth);
                var minWidth = actualMinWidth < parseFloat(this.column.width) ? actualMinWidth : parseFloat(this.column.width);
                return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnResizingService.prototype, "restrictResizeMax", {
            /**
             * Returns the maximal possible width to which the column can be resized.
             */
            get: function () {
                var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
                if (this.column.maxWidth) {
                    return parseFloat(this.column.maxWidth) - actualWidth;
                }
                else {
                    return Number.MAX_SAFE_INTEGER;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Autosizes the column to the longest currently visible cell value, including the header cell.
         * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
         * then the column is sized to its maxWidth.
         * If the column is pinned and the autosized column width will cause the pinned area to become bigger
         * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
         */
        IgxColumnResizingService.prototype.autosizeColumnOnDblClick = function () {
            var currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
            var size = this.column.getLargestCellWidth();
            if (this.column.maxWidth && (parseFloat(size) > parseFloat(this.column.maxWidth))) {
                this.column.width = parseFloat(this.column.maxWidth) + 'px';
            }
            else if (parseFloat(size) < parseFloat(this.column.minWidth)) {
                this.column.width = this.column.minWidth + 'px';
            }
            else {
                this.column.width = size;
            }
            this.zone.run(function () { });
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        };
        /**
         * Resizes the column regaridng to the column minWidth and maxWidth.
         */
        IgxColumnResizingService.prototype.resizeColumn = function (event) {
            this.showResizer = false;
            var diff = event.clientX - this.startResizePos;
            var currentColWidth = parseFloat(this.column.width);
            var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
            currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
            var colMinWidth = this.getColMinWidth(this.column);
            var colMaxWidth = this.getColMaxWidth(this.column);
            if (this.column.grid.hasColumnLayouts) {
                this.resizeColumnLayoutFor(this.column, diff);
            }
            else {
                if (currentColWidth + diff < colMinWidth) {
                    this.column.width = colMinWidth + 'px';
                }
                else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
                    this.column.width = colMaxWidth + 'px';
                }
                else {
                    this.column.width = (currentColWidth + diff) + 'px';
                }
            }
            this.zone.run(function () { });
            if (currentColWidth !== parseFloat(this.column.width)) {
                this.column.grid.onColumnResized.emit({
                    column: this.column,
                    prevWidth: currentColWidth.toString(),
                    newWidth: this.column.width
                });
            }
            this.isColumnResizing = false;
        };
        IgxColumnResizingService.prototype.getColMinWidth = function (column) {
            var currentColWidth = parseFloat(column.width);
            var actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
            currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
            var actualMinWidth = parseFloat(column.minWidth);
            return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
        };
        IgxColumnResizingService.prototype.getColMaxWidth = function (column) {
            return column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(column.maxWidth);
        };
        IgxColumnResizingService.prototype.resizeColumnLayoutFor = function (column, diff) {
            var _this = this;
            var relativeColumns = column.getResizableColUnderEnd();
            var combinedSpan = relativeColumns.reduce(function (acc, col) { return acc + col.spanUsed; }, 0);
            // Resize first those who might reach min/max width
            var columnsToResize = __spread(relativeColumns);
            var updatedDiff = diff;
            var updatedCombinedSpan = combinedSpan;
            var setMinMaxCols = false;
            var _loop_1 = function () {
                // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
                // This is because we can have at first 2 cols reaching min width and then after
                // recalculating the diff there might be 1 more that reaches min width.
                setMinMaxCols = false;
                var newCombinedSpan = updatedCombinedSpan;
                var newColsToResize = [];
                columnsToResize.forEach(function (col) {
                    var currentResizeWidth = parseFloat(col.target.calcWidth);
                    var resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                    var minWidth = _this.getColMinWidth(col.target);
                    var maxWidth = _this.getColMaxWidth(col.target);
                    if (currentResizeWidth + resizeScaled < minWidth) {
                        col.target.width = minWidth + 'px';
                        updatedDiff += (currentResizeWidth - minWidth);
                        newCombinedSpan -= col.spanUsed;
                        setMinMaxCols = true;
                    }
                    else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                        col.target.width = maxWidth + 'px';
                        updatedDiff -= (maxWidth - currentResizeWidth);
                        newCombinedSpan -= col.spanUsed;
                        setMinMaxCols = true;
                    }
                    else {
                        // Save new ones that can be resized
                        newColsToResize.push(col);
                    }
                });
                updatedCombinedSpan = newCombinedSpan;
                columnsToResize = newColsToResize;
            };
            do {
                _loop_1();
            } while (setMinMaxCols);
            // Those left that don't reach min/max size resize them normally.
            columnsToResize.forEach(function (col) {
                var currentResizeWidth = parseFloat(col.target.calcWidth);
                var resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
                col.target.width = (currentResizeWidth + resizeScaled) + 'px';
            });
        };
        IgxColumnResizingService.ctorParameters = function () { return [
            { type: core.NgZone }
        ]; };
        IgxColumnResizingService = __decorate([
            core.Injectable()
        ], IgxColumnResizingService);
        return IgxColumnResizingService;
    }());

    /** @hidden */
    var IgxListBaseDirective = /** @class */ (function (_super) {
        __extends(IgxListBaseDirective, _super);
        function IgxListBaseDirective(_displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this._displayDensityOptions = _displayDensityOptions;
            return _this;
        }
        IgxListBaseDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        IgxListBaseDirective = __decorate([
            core.Directive({
                selector: '[igxListBase]'
            }),
            __param(0, core.Optional()), __param(0, core.Inject(DisplayDensityToken))
        ], IgxListBaseDirective);
        return IgxListBaseDirective;
    }(DisplayDensityBase));

    (function (IgxListPanState) {
        IgxListPanState[IgxListPanState["NONE"] = 0] = "NONE";
        IgxListPanState[IgxListPanState["LEFT"] = 1] = "LEFT";
        IgxListPanState[IgxListPanState["RIGHT"] = 2] = "RIGHT";
    })(exports.IgxListPanState || (exports.IgxListPanState = {}));
    var IgxEmptyListTemplateDirective = /** @class */ (function () {
        function IgxEmptyListTemplateDirective(template) {
            this.template = template;
        }
        IgxEmptyListTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxEmptyListTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxEmptyList]'
            })
        ], IgxEmptyListTemplateDirective);
        return IgxEmptyListTemplateDirective;
    }());
    var IgxDataLoadingTemplateDirective = /** @class */ (function () {
        function IgxDataLoadingTemplateDirective(template) {
            this.template = template;
        }
        IgxDataLoadingTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxDataLoadingTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxDataLoading]'
            })
        ], IgxDataLoadingTemplateDirective);
        return IgxDataLoadingTemplateDirective;
    }());
    var IgxListItemLeftPanningTemplateDirective = /** @class */ (function () {
        function IgxListItemLeftPanningTemplateDirective(template) {
            this.template = template;
        }
        IgxListItemLeftPanningTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxListItemLeftPanningTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxListItemLeftPanning]'
            })
        ], IgxListItemLeftPanningTemplateDirective);
        return IgxListItemLeftPanningTemplateDirective;
    }());
    var IgxListItemRightPanningTemplateDirective = /** @class */ (function () {
        function IgxListItemRightPanningTemplateDirective(template) {
            this.template = template;
        }
        IgxListItemRightPanningTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxListItemRightPanningTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxListItemRightPanning]'
            })
        ], IgxListItemRightPanningTemplateDirective);
        return IgxListItemRightPanningTemplateDirective;
    }());

    /**
     * The Ignite UI List Item component is a container intended for row items in the Ignite UI for Angular List component.
     *
     * Example:
     * ```html
     * <igx-list>
     *   <igx-list-item isHeader="true">Contacts</igx-list-item>
     *   <igx-list-item *ngFor="let contact of contacts">
     *     <span class="name">{{ contact.name }}</span>
     *     <span class="phone">{{ contact.phone }}</span>
     *   </igx-list-item>
     * </igx-list>
     * ```
     */
    var IgxListItemComponent = /** @class */ (function () {
        function IgxListItemComponent(list, elementRef, _renderer) {
            this.list = list;
            this.elementRef = elementRef;
            this._renderer = _renderer;
            /**
             *@hidden
             */
            this._panState = exports.IgxListPanState.NONE;
            /**
             *@hidden
             */
            this.panOffset = 0;
            /**
             * @hidden
             */
            this._index = null;
            /**
             *@hidden
             */
            this.lastPanDir = exports.IgxListPanState.NONE;
            /**
             * Sets/gets whether the `list item` is hidden.
             * By default the `hidden` value is `false`.
             * ```html
             * <igx-list-item [hidden] = "true">Hidden Item</igx-list-item>
             * ```
             * ```typescript
             * let isHidden =  this.listItem.hidden;
             * ```
             * @memberof IgxListItemComponent
             */
            this.hidden = false;
            /**
             * Gets the `touch-action` style of the `list item`.
             * ```typescript
             * let touchAction = this.listItem.touchAction;
             * ```
             */
            this.touchAction = 'pan-y';
        }
        Object.defineProperty(IgxListItemComponent.prototype, "role", {
            /**
             * Gets the `role` attribute of the `list item`.
             * ```typescript
             * let itemRole =  this.listItem.role;
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this.isHeader ? 'separator' : 'listitem';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "headerStyle", {
            /**
             * Indicates whether `list item` should have header style.
             * ```typescript
             * let headerStyle =  this.listItem.headerStyle;
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this.isHeader;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "innerStyle", {
            /**
             * Applies the inner style of the `list item` if the item is not counted as header.
             * ```typescript
             * let innerStyle =  this.listItem.innerStyle;
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                return !this.isHeader;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "display", {
            /**
             * Returns string value which describes the display mode of the `list item`.
             * ```typescript
             * let isHidden = this.listItem.display;
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this.hidden ? 'none' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxListItemComponent.prototype.clicked = function (evt) {
            this.list.onItemClicked.emit({ item: this, event: evt, direction: this.lastPanDir });
            this.lastPanDir = exports.IgxListPanState.NONE;
        };
        /**
         *@hidden
         */
        IgxListItemComponent.prototype.panStart = function (ev) {
            if (this.isTrue(this.isHeader)) {
                return;
            }
            if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
                return;
            }
        };
        /**
         *@hidden
         */
        IgxListItemComponent.prototype.panMove = function (ev) {
            if (this.isTrue(this.isHeader)) {
                return;
            }
            if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
                return;
            }
            var isPanningToLeft = ev.deltaX < 0;
            if (isPanningToLeft && this.isTrue(this.list.allowLeftPanning)) {
                this.showLeftPanTemplate();
                this.setContentElementLeft(Math.max(this.maxLeft, ev.deltaX));
            }
            else if (!isPanningToLeft && this.isTrue(this.list.allowRightPanning)) {
                this.showRightPanTemplate();
                this.setContentElementLeft(Math.min(this.maxRight, ev.deltaX));
            }
        };
        /**
         *@hidden
         */
        IgxListItemComponent.prototype.panEnd = function (ev) {
            if (this.isTrue(this.isHeader)) {
                return;
            }
            if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
                return;
            }
            // the translation offset of the current list item content
            var relativeOffset = this.panOffset;
            var widthTriggeringGrip = this.width * this.list.panEndTriggeringThreshold;
            if (relativeOffset === 0) {
                return; // no panning has occured
            }
            var dir = relativeOffset > 0 ? exports.IgxListPanState.RIGHT : exports.IgxListPanState.LEFT;
            this.lastPanDir = dir;
            var oldPanState = this._panState;
            if (Math.abs(relativeOffset) < widthTriggeringGrip) {
                this.setContentElementLeft(0);
                this._panState = exports.IgxListPanState.NONE;
                this.hideLeftAndRightPanTemplates();
                return;
            }
            var args = { item: this, direction: dir, keepItem: false };
            if (dir === exports.IgxListPanState.LEFT) {
                this.list.onLeftPan.emit(args);
            }
            else {
                this.list.onRightPan.emit(args);
            }
            if (args.keepItem === true) {
                this.setContentElementLeft(0);
                this._panState = exports.IgxListPanState.NONE;
            }
            else {
                if (dir === exports.IgxListPanState.LEFT) {
                    this.setContentElementLeft(this.maxLeft);
                    this._panState = exports.IgxListPanState.LEFT;
                }
                else {
                    this.setContentElementLeft(this.maxRight);
                    this._panState = exports.IgxListPanState.RIGHT;
                }
            }
            if (oldPanState !== this._panState) {
                var args2 = { oldState: oldPanState, newState: this._panState, item: this };
                this.list.onPanStateChange.emit(args2);
            }
            this.hideLeftAndRightPanTemplates();
        };
        /**
         *@hidden
         */
        IgxListItemComponent.prototype.showLeftPanTemplate = function () {
            this.setLeftAndRightTemplatesVisibility('visible', 'hidden');
        };
        /**
         *@hidden
         */
        IgxListItemComponent.prototype.showRightPanTemplate = function () {
            this.setLeftAndRightTemplatesVisibility('hidden', 'visible');
        };
        /**
         *@hidden
         */
        IgxListItemComponent.prototype.hideLeftAndRightPanTemplates = function () {
            var _this = this;
            setTimeout(function () {
                _this.setLeftAndRightTemplatesVisibility('hidden', 'hidden');
            }, 500);
        };
        /**
         *@hidden
         */
        IgxListItemComponent.prototype.setLeftAndRightTemplatesVisibility = function (leftVisibility, rightVisibility) {
            if (this.leftPanningTemplateElement && this.leftPanningTemplateElement.nativeElement) {
                this.leftPanningTemplateElement.nativeElement.style.visibility = leftVisibility;
            }
            if (this.rightPanningTemplateElement && this.rightPanningTemplateElement.nativeElement) {
                this.rightPanningTemplateElement.nativeElement.style.visibility = rightVisibility;
            }
        };
        Object.defineProperty(IgxListItemComponent.prototype, "panState", {
            /**
             * Gets the `panState` of a `list item`.
             * ```typescript
             * let itemPanState =  this.listItem.panState;
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this._panState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "index", {
            /**
             * Gets the `index` of a `list item`.
             * ```typescript
             * let itemIndex =  this.listItem.index;
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this._index !== null ? this._index : this.list.children.toArray().indexOf(this);
            },
            /**
             * Sets the `index` of the `list item`.
             * ```typescript
             * this.listItem.index = index;
             * ```
             * @memberof IgxListItemComponent
             */
            set: function (value) {
                this._index = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "element", {
            /**
             * Returns an element reference to the list item.
             * ```typescript
             * let listItemElement =  this.listItem.element.
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "contentElement", {
            /**
             * Returns a reference container which contains the list item's content.
             * ```typescript
             * let listItemContainer =  this.listItem.contentElement.
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                var candidates = this.element.getElementsByClassName('igx-list__item-content');
                return (candidates && candidates.length > 0) ? candidates[0] : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "context", {
            /**
             * Returns the `context` object which represents the `template context` binding into the `list item container`
             * by providing the `$implicit` declaration which is the `IgxListItemComponent` itself.
             * ```typescript
             * let listItemComponent = this.listItem.context;
             * ```
             */
            get: function () {
                return {
                    $implicit: this
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "width", {
            /**
             * Gets the width of a `list item`.
             * ```typescript
             * let itemWidth = this.listItem.width;
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                if (this.element) {
                    return this.element.offsetWidth;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "maxLeft", {
            /**
             * Gets the maximum left position of the `list item`.
             * ```typescript
             * let maxLeft = this.listItem.maxLeft;
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                return -this.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListItemComponent.prototype, "maxRight", {
            /**
             * Gets the maximum right position of the `list item`.
             * ```typescript
             * let maxRight = this.listItem.maxRight;
             * ```
             * @memberof IgxListItemComponent
             */
            get: function () {
                return this.width;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxListItemComponent.prototype.setContentElementLeft = function (value) {
            this.panOffset = value;
            this.contentElement.style.transform = 'translateX(' + value + 'px)';
        };
        /**
         *@hidden
         */
        IgxListItemComponent.prototype.isTrue = function (value) {
            if (typeof (value) === 'boolean') {
                return value;
            }
            else {
                return value === 'true';
            }
        };
        IgxListItemComponent.ctorParameters = function () { return [
            { type: IgxListBaseDirective },
            { type: core.ElementRef },
            { type: core.Renderer2 }
        ]; };
        __decorate([
            core.ViewChild('leftPanningTmpl')
        ], IgxListItemComponent.prototype, "leftPanningTemplateElement", void 0);
        __decorate([
            core.ViewChild('rightPanningTmpl')
        ], IgxListItemComponent.prototype, "rightPanningTemplateElement", void 0);
        __decorate([
            core.Input()
        ], IgxListItemComponent.prototype, "isHeader", void 0);
        __decorate([
            core.Input()
        ], IgxListItemComponent.prototype, "hidden", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxListItemComponent.prototype, "role", null);
        __decorate([
            core.HostBinding('attr.aria-label')
        ], IgxListItemComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.HostBinding('style.touch-action')
        ], IgxListItemComponent.prototype, "touchAction", void 0);
        __decorate([
            core.HostBinding('class.igx-list__header')
        ], IgxListItemComponent.prototype, "headerStyle", null);
        __decorate([
            core.HostBinding('class.igx-list__item-base')
        ], IgxListItemComponent.prototype, "innerStyle", null);
        __decorate([
            core.HostBinding('style.display')
        ], IgxListItemComponent.prototype, "display", null);
        __decorate([
            core.HostListener('click', ['$event'])
        ], IgxListItemComponent.prototype, "clicked", null);
        __decorate([
            core.HostListener('panstart', ['$event'])
        ], IgxListItemComponent.prototype, "panStart", null);
        __decorate([
            core.HostListener('panmove', ['$event'])
        ], IgxListItemComponent.prototype, "panMove", null);
        __decorate([
            core.HostListener('panend', ['$event'])
        ], IgxListItemComponent.prototype, "panEnd", null);
        __decorate([
            core.Input()
        ], IgxListItemComponent.prototype, "index", null);
        IgxListItemComponent = __decorate([
            core.Component({
                providers: [HammerGesturesManager],
                selector: 'igx-list-item',
                template: "   \n<div *ngIf=\"!isHeader && list.listItemLeftPanningTemplate != null\" #leftPanningTmpl class=\"igx-list__item-right\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemLeftPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<div *ngIf=\"!isHeader && list.listItemRightPanningTemplate != null\" #rightPanningTmpl class=\"igx-list__item-left\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemRightPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<ng-template #itemsContent>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #itemThumbnails>\n    <div class=\"igx-list__item-thumbnail\">\n        <ng-content select=\"[igxListThumbnail], igx-list__item-thumbnail, igx-avatar\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemLines>\n    <div class=\"igx-list__item-lines\">\n        <ng-content select=\"[igxListLine], .igx-list__item-lines, [igxListLineTitle], [igxListLineSubTitle], .igx-list__item-line-title, .igx-list__item-line-subtitle\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemActions>\n    <div class=\"igx-list__item-actions\">\n        <ng-content select=\"[igxListAction], .igx-list__item-actions\"></ng-content>\n    </div>\n</ng-template>\n\n    \n<ng-container *ngIf=\"isHeader\">\n    <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n</ng-container>\n\n<ng-container *ngIf=\"!isHeader\">\n    <div class=\"igx-list__item-content\">\n        <ng-container *ngTemplateOutlet=\"itemThumbnails\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemLines\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemActions\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n    </div>\n</ng-container>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            })
        ], IgxListItemComponent);
        return IgxListItemComponent;
    }());

    var NEXT_ID$l = 0;
    /**
     * igxListThumbnail is container for the List media
     * Use it to wrap anything you want to be used as a thumbnail.
     */
    var IgxListThumbnailDirective = /** @class */ (function () {
        function IgxListThumbnailDirective() {
        }
        IgxListThumbnailDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: '[igxListThumbnail]'
            })
        ], IgxListThumbnailDirective);
        return IgxListThumbnailDirective;
    }());
    /**
     * igxListAction is container for the List action
     * Use it to wrap anything you want to be used as a list action: icon, checkbox...
     */
    var IgxListActionDirective = /** @class */ (function () {
        function IgxListActionDirective() {
        }
        IgxListActionDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: '[igxListAction]'
            })
        ], IgxListActionDirective);
        return IgxListActionDirective;
    }());
    /**
     * igxListLine is container for the List text content
     * Use it to wrap anything you want to be used as a plane text.
     */
    var IgxListLineDirective = /** @class */ (function () {
        function IgxListLineDirective() {
        }
        IgxListLineDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLine]'
            })
        ], IgxListLineDirective);
        return IgxListLineDirective;
    }());
    /**
     * igxListLineTitle is a directive that add class to the target element
     * Use it to make anything to look like list Title.
     */
    var IgxListLineTitleDirective = /** @class */ (function () {
        function IgxListLineTitleDirective() {
            this.cssClass = 'igx-list__item-line-title';
        }
        __decorate([
            core.HostBinding('class.igx-list__item-line-title')
        ], IgxListLineTitleDirective.prototype, "cssClass", void 0);
        IgxListLineTitleDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLineTitle]'
            })
        ], IgxListLineTitleDirective);
        return IgxListLineTitleDirective;
    }());
    /**
     * igxListLineSubTitle is a directive that add class to the target element
     * Use it to make anything to look like list Subtitle.
     */
    var IgxListLineSubTitleDirective = /** @class */ (function () {
        function IgxListLineSubTitleDirective() {
            this.cssClass = 'igx-list__item-line-subtitle';
        }
        __decorate([
            core.HostBinding('class.igx-list__item-line-subtitle')
        ], IgxListLineSubTitleDirective.prototype, "cssClass", void 0);
        IgxListLineSubTitleDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLineSubTitle]'
            })
        ], IgxListLineSubTitleDirective);
        return IgxListLineSubTitleDirective;
    }());
    /**
     * Displays a collection of data items in a templatable list format
     *
     * @igxModule IgxListModule
     *
     * @igxTheme igx-list-theme
     *
     * @igxKeywords list, data
     *
     * @igxGroup Grids & Lists
     *
     * @remarks
     * The Ignite UI List displays rows of items and supports one or more header items as well as search and filtering
     * of list items. Each list item is completely templatable and will support any valid HTML or Angular component.
     *
     * @example
     * ```html
     * <igx-list>
     *   <igx-list-item isHeader="true">Contacts</igx-list-item>
     *   <igx-list-item *ngFor="let contact of contacts">
     *     <span class="name">{{ contact.name }}</span>
     *     <span class="phone">{{ contact.phone }}</span>
     *   </igx-list-item>
     * </igx-list>
     * ```
     */
    var IgxListComponent = /** @class */ (function (_super) {
        __extends(IgxListComponent, _super);
        function IgxListComponent(element, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.element = element;
            _this._displayDensityOptions = _displayDensityOptions;
            /**
             * Provides a threshold after which the item's panning will be completed automatically.
             *
             * @remarks
             * By default this property is set to 0.5 which is 50% of the list item's width.
             *
             * @example
             * ```html
             * <igx-list [panEndTriggeringThreshold]="0.8"></igx-list>
             * ```
             */
            _this.panEndTriggeringThreshold = 0.5;
            /**
             * Sets/gets the `id` of the list.
             *
             * @remarks
             * If not set, the `id` of the first list component will be `"igx-list-0"`.
             *
             * @example
             * ```html
             * <igx-list id="my-first-list"></igx-list>
             * ```
             * ```typescript
             * let listId = this.list.id;
             * ```
             */
            _this.id = "igx-list-" + NEXT_ID$l++;
            /**
             * Sets/gets whether the left panning of an item is allowed.
             *
             * @remarks
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-list [allowLeftPanning]="true"></igx-list>
             * ```
             * ```typescript
             * let isLeftPanningAllowed = this.list.allowLeftPanning;
             * ```
             */
            _this.allowLeftPanning = false;
            /**
             * Sets/gets whether the right panning of an item is allowed.
             *
             * @remarks
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-list [allowRightPanning]="true"></igx-list>
             * ```
             * ```typescript
             * let isRightPanningAllowed = this.list.allowRightPanning;
             * ```
             */
            _this.allowRightPanning = false;
            /**
             * Sets/gets whether the list is currently loading data.
             *
             * @remarks
             * Set it to display the dataLoadingTemplate while data is being retrieved.
             * Default value is `false`.
             *
             * @example
             * ```html
             *  <igx-list [isLoading]="true"></igx-list>
             * ```
             * ```typescript
             * let isLoading = this.list.isLoading;
             * ```
             */
            _this.isLoading = false;
            /**
             * Event emitted when a left pan gesture is executed on a list item.
             *
             * @remarks
             * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
             *
             * @example
             * ```html
             * <igx-list [allowLeftPanning]="true" (onLeftPan)="onLeftPan($event)"></igx-list>
             * ```
             */
            _this.onLeftPan = new core.EventEmitter();
            /**
             * Event emitted when a right pan gesture is executed on a list item.
             *
             * @remarks
             * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
             *
             * @example
             * ```html
             * <igx-list [allowRightPanning]="true" (onRightPan)="onRightPan($event)"></igx-list>
             * ```
             */
            _this.onRightPan = new core.EventEmitter();
            /**
             *
             * Event emitted when a pan gesture is executed on a list item.
             *
             * @remarks
             * Provides references to the `IgxListItemComponent` and `IgxListPanState` as event arguments.
             *
             * @example
             * ```html
             * <igx-list (onPanStateChange)="onPanStateChange($event)"></igx-list>
             * ```
            */
            _this.onPanStateChange = new core.EventEmitter();
            /**
             * Event emitted when a list item is clicked.
             *
             * @remarks
             * Provides references to the `IgxListItemComponent` and `Event` as event arguments.
             *
             * @example
             * ```html
             * <igx-list (onItemClicked)="onItemClicked($event)"></igx-list>
             * ```
             */
            _this.onItemClicked = new core.EventEmitter();
            return _this;
        }
        IgxListComponent_1 = IgxListComponent;
        Object.defineProperty(IgxListComponent.prototype, "sortedChildren", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.children !== undefined) {
                    return this.children.toArray()
                        .sort(function (a, b) {
                        return a.index - b.index;
                    });
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "role", {
            /**
             * Gets the `role` attribute value.
             *
             * @example
             * ```typescript
             * let listRole =  this.list.role;
             * ```
             */
            get: function () {
                return 'list';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "isListEmpty", {
            /**
             * Gets a boolean indicating if the list is empty.
             *
             * @example
             * ```typescript
             * let isEmpty =  this.list.isListEmpty;
             * ```
             */
            get: function () {
                return !this.children || this.children.length === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "cssClass", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return !this.isListEmpty && this.displayDensity === exports.DisplayDensity.comfortable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "cssClassCompact", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return !this.isListEmpty && this.displayDensity === exports.DisplayDensity.compact;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "cssClassCosy", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return !this.isListEmpty && this.displayDensity === exports.DisplayDensity.cosy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "items", {
            /**
             * Gets the list `items` excluding the header ones.
             *
             * @example
             * ```typescript
             * let listItems: IgxListItemComponent[] = this.list.items;
             * ```
             */
            get: function () {
                var e_1, _a;
                var items = [];
                if (this.children !== undefined) {
                    try {
                        for (var _b = __values(this.sortedChildren), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var child = _c.value;
                            if (!child.isHeader) {
                                items.push(child);
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                return items;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "headers", {
            /**
             * Gets the header list `items`.
             *
             * @example
             * ```typescript
             * let listHeaders: IgxListItemComponent[] =  this.list.headers;
             * ```
             */
            get: function () {
                var e_2, _a;
                var headers = [];
                if (this.children !== undefined) {
                    try {
                        for (var _b = __values(this.children.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var child = _c.value;
                            if (child.isHeader) {
                                headers.push(child);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                return headers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "context", {
            /**
             * Gets the `context` object of the template binding.
             *
             * @remark
             * Gets the `context` object which represents the `template context` binding into the `list container`
             * by providing the `$implicit` declaration which is the `IgxListComponent` itself.
             *
             * @example
             * ```typescript
             * let listComponent =  this.list.context;
             * ```
             */
            get: function () {
                return {
                    $implicit: this
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxListComponent.prototype, "template", {
            /**
             * Gets a `TemplateRef` to the currently used template.
             *
             * @example
             * ```typescript
             * let listTemplate = this.list.template;
             * ```
             */
            get: function () {
                if (this.isLoading) {
                    return this.dataLoadingTemplate ? this.dataLoadingTemplate.template : this.defaultDataLoadingTemplate;
                }
                else {
                    return this.emptyListTemplate ? this.emptyListTemplate.template : this.defaultEmptyListTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        var IgxListComponent_1;
        IgxListComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return IgxListItemComponent; }), { descendants: true })
        ], IgxListComponent.prototype, "children", void 0);
        __decorate([
            core.ContentChild(IgxEmptyListTemplateDirective, { read: IgxEmptyListTemplateDirective })
        ], IgxListComponent.prototype, "emptyListTemplate", void 0);
        __decorate([
            core.ContentChild(IgxDataLoadingTemplateDirective, { read: IgxDataLoadingTemplateDirective })
        ], IgxListComponent.prototype, "dataLoadingTemplate", void 0);
        __decorate([
            core.ContentChild(IgxListItemLeftPanningTemplateDirective, { read: IgxListItemLeftPanningTemplateDirective })
        ], IgxListComponent.prototype, "listItemLeftPanningTemplate", void 0);
        __decorate([
            core.ContentChild(IgxListItemRightPanningTemplateDirective, { read: IgxListItemRightPanningTemplateDirective })
        ], IgxListComponent.prototype, "listItemRightPanningTemplate", void 0);
        __decorate([
            core.Input()
        ], IgxListComponent.prototype, "panEndTriggeringThreshold", void 0);
        __decorate([
            core.ViewChild('defaultEmptyList', { read: core.TemplateRef, static: true })
        ], IgxListComponent.prototype, "defaultEmptyListTemplate", void 0);
        __decorate([
            core.ViewChild('defaultDataLoading', { read: core.TemplateRef, static: true })
        ], IgxListComponent.prototype, "defaultDataLoadingTemplate", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxListComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxListComponent.prototype, "allowLeftPanning", void 0);
        __decorate([
            core.Input()
        ], IgxListComponent.prototype, "allowRightPanning", void 0);
        __decorate([
            core.Input()
        ], IgxListComponent.prototype, "isLoading", void 0);
        __decorate([
            core.Output()
        ], IgxListComponent.prototype, "onLeftPan", void 0);
        __decorate([
            core.Output()
        ], IgxListComponent.prototype, "onRightPan", void 0);
        __decorate([
            core.Output()
        ], IgxListComponent.prototype, "onPanStateChange", void 0);
        __decorate([
            core.Output()
        ], IgxListComponent.prototype, "onItemClicked", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxListComponent.prototype, "role", null);
        __decorate([
            core.HostBinding('class.igx-list-empty')
        ], IgxListComponent.prototype, "isListEmpty", null);
        __decorate([
            core.HostBinding('class.igx-list')
        ], IgxListComponent.prototype, "cssClass", null);
        __decorate([
            core.HostBinding('class.igx-list--compact')
        ], IgxListComponent.prototype, "cssClassCompact", null);
        __decorate([
            core.HostBinding('class.igx-list--cosy')
        ], IgxListComponent.prototype, "cssClassCosy", null);
        IgxListComponent = IgxListComponent_1 = __decorate([
            core.Component({
                selector: 'igx-list',
                template: "<ng-content></ng-content>\n\n<ng-template #defaultEmptyList>\n    <article class=\"message\">\n        There are no items in the list.\n    </article>\n</ng-template>\n\n<ng-template #defaultDataLoading>\n    <article class=\"message\">\n        Loading data from the server...\n    </article>\n</ng-template>\n\n<ng-container *ngIf=\"!children || children.length === 0 || isLoading\">\n    <ng-container *ngTemplateOutlet=\"template; context: context\">\n    </ng-container>\n</ng-container>\n",
                providers: [{ provide: IgxListBaseDirective, useExisting: IgxListComponent_1 }]
            }),
            __param(1, core.Optional()), __param(1, core.Inject(DisplayDensityToken))
        ], IgxListComponent);
        return IgxListComponent;
    }(IgxListBaseDirective));
    /**
     * @hidden
     */
    var IgxListModule = /** @class */ (function () {
        function IgxListModule() {
        }
        IgxListModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxListBaseDirective,
                    IgxListComponent,
                    IgxListItemComponent,
                    IgxListThumbnailDirective,
                    IgxListActionDirective,
                    IgxListLineDirective,
                    IgxListLineTitleDirective,
                    IgxListLineSubTitleDirective,
                    IgxDataLoadingTemplateDirective,
                    IgxEmptyListTemplateDirective,
                    IgxListItemLeftPanningTemplateDirective,
                    IgxListItemRightPanningTemplateDirective
                ],
                exports: [
                    IgxListComponent,
                    IgxListItemComponent,
                    IgxListThumbnailDirective,
                    IgxListActionDirective,
                    IgxListLineDirective,
                    IgxListLineTitleDirective,
                    IgxListLineSubTitleDirective,
                    IgxDataLoadingTemplateDirective,
                    IgxEmptyListTemplateDirective,
                    IgxListItemLeftPanningTemplateDirective,
                    IgxListItemRightPanningTemplateDirective
                ],
                imports: [
                    common.CommonModule,
                    IgxRippleModule
                ]
            })
        ], IgxListModule);
        return IgxListModule;
    }());

    var IgxExcelStyleLoadingValuesTemplateDirective = /** @class */ (function () {
        function IgxExcelStyleLoadingValuesTemplateDirective(template) {
            this.template = template;
        }
        IgxExcelStyleLoadingValuesTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxExcelStyleLoadingValuesTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxExcelStyleLoading]'
            })
        ], IgxExcelStyleLoadingValuesTemplateDirective);
        return IgxExcelStyleLoadingValuesTemplateDirective;
    }());
    /**
     * @hidden
     */
    var IgxExcelStyleSearchComponent = /** @class */ (function () {
        function IgxExcelStyleSearchComponent(cdr) {
            this.cdr = cdr;
        }
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "isLoading", {
            get: function () {
                return this._isLoading;
            },
            set: function (value) {
                this._isLoading = value;
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "valuesLoadingTemplate", {
            get: function () {
                if (this.grid.excelStyleLoadingValuesTemplateDirective) {
                    return this.grid.excelStyleLoadingValuesTemplateDirective.template;
                }
                else {
                    return this.defaultExcelStyleLoadingValuesTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxExcelStyleSearchComponent.prototype.ngAfterViewInit = function () {
            this.refreshSize();
        };
        IgxExcelStyleSearchComponent.prototype.refreshSize = function () {
            var _this = this;
            requestAnimationFrame(function () {
                _this.virtDir.recalcUpdateSizes();
            });
        };
        IgxExcelStyleSearchComponent.prototype.clearInput = function () {
            this.searchValue = null;
        };
        IgxExcelStyleSearchComponent.prototype.onCheckboxChange = function (eventArgs) {
            var _this = this;
            var selectedIndex = this.data.indexOf(eventArgs.checkbox.value);
            if (selectedIndex === 0) {
                this.data.forEach(function (element) {
                    element.isSelected = eventArgs.checked;
                    _this.data[0].indeterminate = false;
                });
            }
            else {
                eventArgs.checkbox.value.isSelected = eventArgs.checked;
                if (!this.data.slice(1, this.data.length).find(function (el) { return el.isSelected === false; })) {
                    this.data[0].indeterminate = false;
                    this.data[0].isSelected = true;
                }
                else if (!this.data.slice(1, this.data.length).find(function (el) { return el.isSelected === true; })) {
                    this.data[0].indeterminate = false;
                    this.data[0].isSelected = false;
                }
                else {
                    this.data[0].indeterminate = true;
                }
            }
            eventArgs.checkbox.nativeCheckbox.nativeElement.blur();
        };
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "itemSize", {
            get: function () {
                var itemSize = '40px';
                switch (this.displayDensity) {
                    case exports.DisplayDensity.cosy:
                        itemSize = '32px';
                        break;
                    case exports.DisplayDensity.compact:
                        itemSize = '24px';
                        break;
                    default: break;
                }
                return itemSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "containerSize", {
            get: function () {
                return this.list.element.nativeElement.offsetHeight;
            },
            enumerable: true,
            configurable: true
        });
        IgxExcelStyleSearchComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxExcelStyleSearchComponent.prototype, "grid", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleSearchComponent.prototype, "data", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleSearchComponent.prototype, "inline", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleSearchComponent.prototype, "column", void 0);
        __decorate([
            core.ViewChild('input', { read: IgxInputDirective, static: true })
        ], IgxExcelStyleSearchComponent.prototype, "searchInput", void 0);
        __decorate([
            core.ViewChild('list', { read: IgxListComponent, static: true })
        ], IgxExcelStyleSearchComponent.prototype, "list", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleSearchComponent.prototype, "displayDensity", void 0);
        __decorate([
            core.ViewChild(IgxForOfDirective, { static: true })
        ], IgxExcelStyleSearchComponent.prototype, "virtDir", void 0);
        __decorate([
            core.ViewChild('defaultExcelStyleLoadingValuesTemplate', { read: core.TemplateRef, static: true })
        ], IgxExcelStyleSearchComponent.prototype, "defaultExcelStyleLoadingValuesTemplate", void 0);
        IgxExcelStyleSearchComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-search',
                template: "<igx-input-group\n            type=\"box\"\n            [displayDensity]=\"displayDensity\"\n            [supressInputAutofocus]=\"true\">\n    <igx-icon igxPrefix>search</igx-icon>\n    <input\n        #input\n        igxInput\n        tabindex=\"0\"\n        [(ngModel)]=\"searchValue\"\n        [placeholder]=\"column.grid.resourceStrings.igx_grid_excel_search_placeholder\"\n        autocomplete=\"off\"/>\n    <igx-icon\n        igxSuffix\n        *ngIf=\"searchValue || searchValue === 0\"\n        (click)=\"clearInput()\"\n        tabindex=\"0\">\n        clear\n    </igx-icon>\n</igx-input-group>\n\n<igx-list #list [displayDensity]=\"displayDensity\" [isLoading]=\"isLoading\">\n    <div [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\">\n        <igx-list-item\n            *igxFor=\"let item of data | excelStyleSearchFilter: searchValue; scrollOrientation : 'vertical'; containerSize: containerSize; itemSize: itemSize\">\n            <igx-checkbox\n            [value]=\"item\"\n            tabindex=\"-1\"\n            [checked]=\"item.isSelected\"\n            [disableRipple]=\"true\"\n            [indeterminate]=\"item.indeterminate\"\n            [disableTransitions]=\"true\"\n            (change)=\"onCheckboxChange($event)\">\n                {{ column.formatter && !item.isSpecial ? column.formatter(item.label) : column.dataType === 'number' ? (item.label | igxdecimal:\n                    column.grid.locale) : column.dataType === 'date' ? (item.label | igxdate: column.grid.locale) : item.label }}\n            </igx-checkbox>\n        </igx-list-item>\n    </div>\n\n    <ng-template igxDataLoading>        \n        <div class=\"igx-excel-filter__loading\">\n            <ng-container *ngTemplateOutlet=\"valuesLoadingTemplate\">\n            </ng-container>\n        </div>\n    </ng-template>\n</igx-list>\n\n<ng-template #defaultExcelStyleLoadingValuesTemplate>\n    <igx-circular-bar [indeterminate]=\"true\">\n    </igx-circular-bar>\n</ng-template>\n"
            })
        ], IgxExcelStyleSearchComponent);
        return IgxExcelStyleSearchComponent;
    }());

    /**
     * @hidden
     */
    var IgxExcelStyleDefaultExpressionComponent = /** @class */ (function () {
        function IgxExcelStyleDefaultExpressionComponent(cdr) {
            this.cdr = cdr;
            this._dropDownOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false,
                positionStrategy: new ConnectedPositioningStrategy(),
                scrollStrategy: new CloseScrollStrategy()
            };
            this.onExpressionRemoved = new core.EventEmitter();
            this.onLogicOperatorChanged = new core.EventEmitter();
        }
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "inputValuesElement", {
            get: function () {
                return this.inputValuesDirective;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "isLast", {
            get: function () {
                return this.expressionsList[this.expressionsList.length - 1] === this.expressionUI;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "isSingle", {
            get: function () {
                return this.expressionsList.length === 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "inputConditionsPlaceholder", {
            get: function () {
                return this.grid.resourceStrings['igx_grid_filter_condition_placeholder'];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "inputValuePlaceholder", {
            get: function () {
                return this.grid.resourceStrings['igx_grid_filter_row_placeholder'];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "type", {
            get: function () {
                switch (this.column.dataType) {
                    case exports.DataType.Number:
                        return 'number';
                    default:
                        return 'text';
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxExcelStyleDefaultExpressionComponent.prototype.ngAfterViewInit = function () {
            this._dropDownOverlaySettings.outlet = this.column.grid.outletDirective;
            this._dropDownOverlaySettings.positionStrategy.settings.target = this.inputGroupConditions.element.nativeElement;
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.focus = function () {
            var _this = this;
            // use requestAnimationFrame to focus the values input because when initializing the component
            // datepicker's input group is not yet fully initialized
            requestAnimationFrame(function () { return _this.inputValuesElement.focus(); });
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.isConditionSelected = function (conditionName) {
            return this.expressionUI.expression.condition && this.expressionUI.expression.condition.name === conditionName;
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.getConditionName = function (condition) {
            return condition ? this.translateCondition(condition.name) : null;
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.getInputWidth = function () {
            return this.inputGroupConditions.element.nativeElement.offsetWidth + 'px';
        };
        Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "conditions", {
            get: function () {
                return this.column.filters.conditionList();
            },
            enumerable: true,
            configurable: true
        });
        IgxExcelStyleDefaultExpressionComponent.prototype.translateCondition = function (value) {
            return this.grid.resourceStrings["igx_grid_filter_" + this.getCondition(value).name] || value;
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.getIconName = function () {
            if (this.column.dataType === exports.DataType.Boolean && this.expressionUI.expression.condition === null) {
                return this.getCondition(this.conditions[0]).iconName;
            }
            else if (!this.expressionUI.expression.condition) {
                return 'filter_list';
            }
            else {
                return this.expressionUI.expression.condition.iconName;
            }
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.toggleCustomDialogDropDown = function () {
            this.dropdownConditions.toggle(this._dropDownOverlaySettings);
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.getCondition = function (value) {
            return this.column.filters.condition(value);
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onConditionsChanged = function (eventArgs) {
            var value = eventArgs.newSelection.value;
            this.expressionUI.expression.condition = this.getCondition(value);
            this.focus();
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onValuesInput = function (eventArgs) {
            this.expressionUI.expression.searchVal = DataUtil.parseValue(this.column.dataType, eventArgs.target.value);
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onLogicOperatorButtonClicked = function (eventArgs, buttonIndex) {
            if (this.logicOperatorButtonGroup.selectedButtons.length === 0) {
                eventArgs.stopPropagation();
                this.logicOperatorButtonGroup.selectButton(buttonIndex);
            }
            else {
                this.onLogicOperatorChanged.emit({
                    target: this.expressionUI,
                    newValue: buttonIndex
                });
            }
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onLogicOperatorKeyDown = function (eventArgs, buttonIndex) {
            if (eventArgs.key === "Enter" /* ENTER */) {
                this.logicOperatorButtonGroup.selectButton(buttonIndex);
                this.onLogicOperatorChanged.emit({
                    target: this.expressionUI,
                    newValue: buttonIndex
                });
            }
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onRemoveButtonClick = function () {
            this.onExpressionRemoved.emit(this.expressionUI);
        };
        IgxExcelStyleDefaultExpressionComponent.prototype.onInputConditionsKeyDown = function (eventArgs) {
            if (eventArgs.altKey && (eventArgs.key === "ArrowDown" /* DOWN_ARROW */ || eventArgs.key === "Down" /* DOWN_ARROW_IE */)) {
                this.toggleCustomDialogDropDown();
            }
            if (eventArgs.key === "Tab" /* TAB */ && eventArgs.shiftKey && this.expressionsList[0] === this.expressionUI) {
                eventArgs.preventDefault();
            }
            event.stopPropagation();
        };
        IgxExcelStyleDefaultExpressionComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "column", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "expressionUI", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "expressionsList", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "grid", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "displayDensity", void 0);
        __decorate([
            core.Output()
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "onExpressionRemoved", void 0);
        __decorate([
            core.Output()
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "onLogicOperatorChanged", void 0);
        __decorate([
            core.ViewChild('inputGroupConditions', { read: IgxInputGroupComponent, static: true })
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "inputGroupConditions", void 0);
        __decorate([
            core.ViewChild('inputValues', { read: IgxInputDirective, static: true })
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "inputValuesDirective", void 0);
        __decorate([
            core.ViewChild('dropdownConditions', { read: IgxDropDownComponent, static: true })
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "dropdownConditions", void 0);
        __decorate([
            core.ViewChild('logicOperatorButtonGroup', { read: IgxButtonGroupComponent })
        ], IgxExcelStyleDefaultExpressionComponent.prototype, "logicOperatorButtonGroup", void 0);
        IgxExcelStyleDefaultExpressionComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-default-expression',
                template: "<igx-drop-down\n    #dropdownConditions\n    [maxHeight]=\"'200px'\"\n    [width]=\"getInputWidth()\"\n    [displayDensity]=\"displayDensity\"\n    (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<igx-input-group\n    #inputGroupConditions\n    (click)=\"toggleCustomDialogDropDown()\"\n    type=\"box\"\n    [displayDensity]=\"displayDensity\"\n    [supressInputAutofocus]=\"true\">\n\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n\n    <input\n        igxInput\n        (keydown)=\"onInputConditionsKeyDown($event)\"\n        [igxDropDownItemNavigation]=\"dropdownConditions\"\n        tabindex=\"0\"\n        [placeholder]=\"inputConditionsPlaceholder\"\n        autocomplete=\"off\"\n        [value]=\"getConditionName(expressionUI.expression.condition)\"\n        [readonly]=\"true\"\n    />\n</igx-input-group>\n\n<igx-input-group #inputGroupValues type=\"box\" [displayDensity]=\"displayDensity\" [supressInputAutofocus]=\"true\">\n    <input\n        #inputValues\n        igxInput\n        [type]=\"type\"\n        tabindex=\"0\"\n        [placeholder]=\"inputValuePlaceholder\"\n        [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"\n        autocomplete=\"off\"\n        [value]=\"expressionUI.expression.searchVal\"\n        (input)=\"onValuesInput($event)\"\n    />\n</igx-input-group>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\">\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #orButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n"
            })
        ], IgxExcelStyleDefaultExpressionComponent);
        return IgxExcelStyleDefaultExpressionComponent;
    }());

    /**
     * @hidden
     */
    var IgxExcelStyleDateExpressionComponent = /** @class */ (function (_super) {
        __extends(IgxExcelStyleDateExpressionComponent, _super);
        function IgxExcelStyleDateExpressionComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(IgxExcelStyleDateExpressionComponent.prototype, "inputValuesElement", {
            get: function () {
                return this.datePicker.getEditElement();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleDateExpressionComponent.prototype, "inputDatePlaceholder", {
            get: function () {
                return this.grid.resourceStrings['igx_grid_filter_row_date_placeholder'];
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.ViewChild('datePicker', { read: IgxDatePickerComponent, static: true })
        ], IgxExcelStyleDateExpressionComponent.prototype, "datePicker", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleDateExpressionComponent.prototype, "displayDensity", void 0);
        IgxExcelStyleDateExpressionComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-date-expression',
                template: "<igx-drop-down\n    #dropdownConditions\n    [maxHeight]=\"'200px'\"\n    [width]=\"getInputWidth()\"\n    [displayDensity]=\"displayDensity\"\n    (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<igx-input-group\n    #inputGroupConditions\n    (click)=\"toggleCustomDialogDropDown()\"\n    type=\"box\"\n    [displayDensity]=\"displayDensity\"\n    [supressInputAutofocus]=\"true\">\n\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n\n    <input\n        igxInput\n        (keydown)=\"onInputConditionsKeyDown($event)\"\n        tabindex=\"0\"\n        [igxDropDownItemNavigation]=\"dropdownConditions\"\n        [placeholder]=\"inputConditionsPlaceholder\"\n        autocomplete=\"off\"\n        [value]=\"getConditionName(expressionUI.expression.condition)\"\n        [readonly]=\"true\"\n    />\n</igx-input-group>\n\n<igx-date-picker #datePicker mode=\"dropdown\" [(ngModel)]=\"expressionUI.expression.searchVal\" [locale]=\"grid.locale\" [outlet]=\"grid.outletDirective\">\n    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"displayDensity\" [supressInputAutofocus]=\"true\">\n            <input #input\n                    igxInput\n                    tabindex=\"0\"\n                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                    [placeholder]=\"inputDatePlaceholder\"\n                    autocomplete=\"off\"\n                    [value]=\"value | igxdate: grid.locale\"\n                    [readonly]=\"true\"\n                    [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"/>\n        </igx-input-group>\n    </ng-template>\n</igx-date-picker>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\" >\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        tabindex=\"0\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #orButton\n        tabindex=\"0\"\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n"
            })
        ], IgxExcelStyleDateExpressionComponent);
        return IgxExcelStyleDateExpressionComponent;
    }(IgxExcelStyleDefaultExpressionComponent));

    /**
     * @hidden
     */
    var IgxExcelStyleCustomDialogComponent = /** @class */ (function () {
        function IgxExcelStyleCustomDialogComponent(cdr) {
            this.cdr = cdr;
            this.expressionsList = new Array();
            this._customDialogPositionSettings = {
                verticalDirection: exports.VerticalAlignment.Middle,
                horizontalDirection: exports.HorizontalAlignment.Center,
                horizontalStartPoint: exports.HorizontalAlignment.Center,
                verticalStartPoint: exports.VerticalAlignment.Middle
            };
            this._customDialogOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false,
                positionStrategy: new AutoPositionStrategy(this._customDialogPositionSettings),
                scrollStrategy: new AbsoluteScrollStrategy()
            };
        }
        IgxExcelStyleCustomDialogComponent.prototype.ngAfterViewInit = function () {
            this._customDialogOverlaySettings.outlet = this.grid.outlet;
        };
        Object.defineProperty(IgxExcelStyleCustomDialogComponent.prototype, "template", {
            get: function () {
                if (this.column.dataType === exports.DataType.Date) {
                    return this.dateExpressionTemplate;
                }
                return this.defaultExpressionTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleCustomDialogComponent.prototype, "grid", {
            get: function () {
                return this.filteringService.grid;
            },
            enumerable: true,
            configurable: true
        });
        IgxExcelStyleCustomDialogComponent.prototype.onCustomDialogOpening = function () {
            if (this.selectedOperator) {
                this.createInitialExpressionUIElement();
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.onCustomDialogOpened = function () {
            if (this.expressionComponents.first) {
                this.expressionComponents.first.focus();
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.open = function (esf) {
            this._customDialogOverlaySettings.positionStrategy.settings.target =
                this.overlayComponentId ?
                    this.grid.rootGrid ? this.grid.rootGrid.nativeElement : this.grid.nativeElement :
                    esf;
            this.toggle.open(this._customDialogOverlaySettings);
        };
        IgxExcelStyleCustomDialogComponent.prototype.onClearButtonClick = function () {
            this.filteringService.clearFilter(this.column.field);
            this.createInitialExpressionUIElement();
            this.cdr.detectChanges();
        };
        IgxExcelStyleCustomDialogComponent.prototype.closeDialog = function () {
            if (this.overlayComponentId) {
                this.overlayService.hide(this.overlayComponentId);
            }
            else {
                this.toggle.close();
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.onApplyButtonClick = function () {
            this.expressionsList = this.expressionsList.filter(function (element) { return element.expression.condition &&
                (element.expression.searchVal || element.expression.searchVal === 0 || element.expression.condition.isUnary); });
            if (this.expressionsList.length > 0) {
                this.expressionsList[0].beforeOperator = null;
                this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
            }
            this.filteringService.filterInternal(this.column.field, this.expressionsList);
            this.closeDialog();
        };
        IgxExcelStyleCustomDialogComponent.prototype.onAddButtonClick = function () {
            var exprUI = new ExpressionUI();
            exprUI.expression = {
                condition: null,
                fieldName: this.column.field,
                ignoreCase: this.column.filteringIgnoreCase,
                searchVal: null
            };
            this.expressionsList[this.expressionsList.length - 1].afterOperator = exports.FilteringLogic.And;
            exprUI.beforeOperator = this.expressionsList[this.expressionsList.length - 1].afterOperator;
            this.expressionsList.push(exprUI);
            this.markChildrenForCheck();
            this.scrollToBottom();
        };
        IgxExcelStyleCustomDialogComponent.prototype.onExpressionRemoved = function (event) {
            var indexToRemove = this.expressionsList.indexOf(event);
            if (indexToRemove === 0 && this.expressionsList.length > 1) {
                this.expressionsList[1].beforeOperator = null;
            }
            else if (indexToRemove === this.expressionsList.length - 1) {
                this.expressionsList[indexToRemove - 1].afterOperator = null;
            }
            else {
                this.expressionsList[indexToRemove - 1].afterOperator = this.expressionsList[indexToRemove + 1].beforeOperator;
                this.expressionsList[0].beforeOperator = null;
                this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
            }
            this.expressionsList.splice(indexToRemove, 1);
            this.cdr.detectChanges();
            this.markChildrenForCheck();
        };
        IgxExcelStyleCustomDialogComponent.prototype.onLogicOperatorChanged = function (event) {
            var index = this.expressionsList.indexOf(event.target);
            event.target.afterOperator = event.newValue;
            if (index + 1 < this.expressionsList.length) {
                this.expressionsList[index + 1].beforeOperator = event.newValue;
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.onKeyDown = function (eventArgs) {
            eventArgs.stopPropagation();
        };
        IgxExcelStyleCustomDialogComponent.prototype.onApplyButtonKeyDown = function (eventArgs) {
            if (eventArgs.key === "Tab" /* TAB */ && !eventArgs.shiftKey) {
                eventArgs.stopPropagation();
                eventArgs.preventDefault();
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.createCondition = function (conditionName) {
            switch (this.column.dataType) {
                case exports.DataType.Boolean:
                    return IgxBooleanFilteringOperand.instance().condition(conditionName);
                case exports.DataType.Number:
                    return IgxNumberFilteringOperand.instance().condition(conditionName);
                case exports.DataType.Date:
                    return IgxDateFilteringOperand.instance().condition(conditionName);
                default:
                    return IgxStringFilteringOperand.instance().condition(conditionName);
            }
        };
        IgxExcelStyleCustomDialogComponent.prototype.markChildrenForCheck = function () {
            this.expressionComponents.forEach(function (x) { return x.cdr.markForCheck(); });
            this.expressionDateComponents.forEach(function (x) { return x.cdr.markForCheck(); });
        };
        IgxExcelStyleCustomDialogComponent.prototype.createInitialExpressionUIElement = function () {
            this.expressionsList = [];
            var firstExprUI = new ExpressionUI();
            firstExprUI.expression = {
                condition: this.createCondition(this.selectedOperator),
                fieldName: this.column.field,
                ignoreCase: this.column.filteringIgnoreCase,
                searchVal: null
            };
            firstExprUI.afterOperator = exports.FilteringLogic.And;
            this.expressionsList.push(firstExprUI);
            var secondExprUI = new ExpressionUI();
            secondExprUI.expression = {
                condition: null,
                fieldName: this.column.field,
                ignoreCase: this.column.filteringIgnoreCase,
                searchVal: null
            };
            secondExprUI.beforeOperator = exports.FilteringLogic.And;
            this.expressionsList.push(secondExprUI);
        };
        IgxExcelStyleCustomDialogComponent.prototype.scrollToBottom = function () {
            var _this = this;
            requestAnimationFrame(function () {
                _this.expressionsContainer.nativeElement.scrollTop = _this.expressionsContainer.nativeElement.scrollHeight;
            });
        };
        IgxExcelStyleCustomDialogComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxExcelStyleCustomDialogComponent.prototype, "expressionsList", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleCustomDialogComponent.prototype, "column", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleCustomDialogComponent.prototype, "selectedOperator", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleCustomDialogComponent.prototype, "filteringService", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleCustomDialogComponent.prototype, "overlayComponentId", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleCustomDialogComponent.prototype, "overlayService", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleCustomDialogComponent.prototype, "displayDensity", void 0);
        __decorate([
            core.ViewChildren(IgxExcelStyleDefaultExpressionComponent)
        ], IgxExcelStyleCustomDialogComponent.prototype, "expressionComponents", void 0);
        __decorate([
            core.ViewChildren(IgxExcelStyleDateExpressionComponent)
        ], IgxExcelStyleCustomDialogComponent.prototype, "expressionDateComponents", void 0);
        __decorate([
            core.ViewChild('toggle', { read: IgxToggleDirective, static: true })
        ], IgxExcelStyleCustomDialogComponent.prototype, "toggle", void 0);
        __decorate([
            core.ViewChild('defaultExpressionTemplate', { read: core.TemplateRef })
        ], IgxExcelStyleCustomDialogComponent.prototype, "defaultExpressionTemplate", void 0);
        __decorate([
            core.ViewChild('dateExpressionTemplate', { read: core.TemplateRef })
        ], IgxExcelStyleCustomDialogComponent.prototype, "dateExpressionTemplate", void 0);
        __decorate([
            core.ViewChild('expressionsContainer', { static: true })
        ], IgxExcelStyleCustomDialogComponent.prototype, "expressionsContainer", void 0);
        IgxExcelStyleCustomDialogComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-custom-dialog',
                template: "<article #toggle igxToggle\n    class=\"igx-excel-filter__secondary\"\n    [ngClass]=\"{\n        'igx-excel-filter__secondary--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__secondary--compact': grid.displayDensity === 'compact'\n    }\"\n    (keydown)=\"onKeyDown($event)\"\n    (onOpening)=\"onCustomDialogOpening()\"\n    (onOpened)=\"onCustomDialogOpened()\">\n    <header class=\"igx-excel-filter__secondary-header\">\n        <h4 class=\"igx-typography__h6\">\n            {{ grid.resourceStrings.igx_grid_excel_custom_dialog_header }}{{ column.header || column.field }}\n        </h4>\n    </header>\n\n    <article #expressionsContainer class=\"igx-excel-filter__secondary-main\">\n        <ng-container *ngIf=\"column.dataType === 'date'\">\n            <igx-excel-style-date-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-date-expression>\n        </ng-container>\n\n        <ng-container *ngIf=\"column.dataType !== 'date'\">\n            <igx-excel-style-default-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-default-expression>\n        </ng-container>\n\n        <button igxButton [displayDensity]=\"displayDensity\"\n            class=\"igx-excel-filter__add-filter\"\n            (click)=\"onAddButtonClick()\">\n            <igx-icon>add</igx-icon>\n            <span>{{ grid.resourceStrings.igx_grid_excel_custom_dialog_add }}</span>\n        </button>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"closeDialog()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\" (keydown)=\"onApplyButtonKeyDown($event)\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n"
            })
        ], IgxExcelStyleCustomDialogComponent);
        return IgxExcelStyleCustomDialogComponent;
    }());

    /**
     * @hidden
     */
    var IgxExcelStyleSortingComponent = /** @class */ (function () {
        function IgxExcelStyleSortingComponent() {
            this.destroy$ = new rxjs.Subject();
        }
        IgxExcelStyleSortingComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.grid.sortingExpressionsChange.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.updateSelectedButtons(_this.column.field);
            });
            this.updateSelectedButtons(this.column.field);
        };
        IgxExcelStyleSortingComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        IgxExcelStyleSortingComponent.prototype.ngOnChanges = function (changes) {
            if (changes.column && !changes.column.firstChange) {
                this.updateSelectedButtons(changes.column.currentValue.field);
            }
        };
        IgxExcelStyleSortingComponent.prototype.updateSelectedButtons = function (fieldName) {
            var _this = this;
            var sortIndex = this.grid.sortingExpressions.findIndex(function (s) { return s.fieldName === fieldName; });
            this.sortButtonGroup.buttons.forEach(function (b, i) {
                _this.sortButtonGroup.deselectButton(i);
            });
            if (sortIndex !== -1) {
                var sortDirection = this.grid.sortingExpressions[sortIndex].dir;
                this.sortButtonGroup.selectButton(sortDirection - 1);
            }
        };
        IgxExcelStyleSortingComponent.prototype.onSortButtonClicked = function (sortDirection) {
            if (this.sortButtonGroup.selectedIndexes.length === 0) {
                if (this.grid.isColumnGrouped(this.column.field)) {
                    this.sortButtonGroup.selectButton(sortDirection - 1);
                }
                else {
                    this.grid.clearSort(this.column.field);
                }
            }
            else {
                this.grid.sort({ fieldName: this.column.field, dir: sortDirection, ignoreCase: true });
            }
        };
        __decorate([
            core.Input()
        ], IgxExcelStyleSortingComponent.prototype, "column", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleSortingComponent.prototype, "grid", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleSortingComponent.prototype, "displayDensity", void 0);
        __decorate([
            core.ViewChild('sortButtonGroup', { read: IgxButtonGroupComponent, static: true })
        ], IgxExcelStyleSortingComponent.prototype, "sortButtonGroup", void 0);
        IgxExcelStyleSortingComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-sorting',
                template: "<header>\n    {{ grid.resourceStrings.igx_grid_excel_filter_sorting_header }}\n</header>\n<igx-buttongroup #sortButtonGroup [multiSelection]=\"false\">\n    <button igxButton \n        [displayDensity]=\"displayDensity\"\n        [attr.data-togglable]=\"true\"\n        (click)=\"onSortButtonClicked(1)\"\n        >\n        <igx-icon>arrow_upwards</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short:\n            grid.resourceStrings.igx_grid_excel_filter_sorting_asc  }}\n        </span>\n    </button>\n\n    <button igxButton\n        [displayDensity]=\"displayDensity\"\n        [attr.data-togglable]=\"true\"\n        (click)=\"onSortButtonClicked(2)\"\n        >\n        <igx-icon>arrow_downwards</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short:\n            grid.resourceStrings.igx_grid_excel_filter_sorting_desc\n         }}\n        </span>\n    </button>\n</igx-buttongroup>\n"
            })
        ], IgxExcelStyleSortingComponent);
        return IgxExcelStyleSortingComponent;
    }());

    /**
     *@hidden
     */
    var FilterListItem = /** @class */ (function () {
        function FilterListItem() {
            this.isSpecial = false;
        }
        return FilterListItem;
    }());
    var IgxExcelStyleSortingTemplateDirective = /** @class */ (function () {
        function IgxExcelStyleSortingTemplateDirective(template) {
            this.template = template;
        }
        IgxExcelStyleSortingTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxExcelStyleSortingTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxExcelStyleSorting]'
            })
        ], IgxExcelStyleSortingTemplateDirective);
        return IgxExcelStyleSortingTemplateDirective;
    }());
    var IgxExcelStyleMovingTemplateDirective = /** @class */ (function () {
        function IgxExcelStyleMovingTemplateDirective(template) {
            this.template = template;
        }
        IgxExcelStyleMovingTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxExcelStyleMovingTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxExcelStyleMoving]'
            })
        ], IgxExcelStyleMovingTemplateDirective);
        return IgxExcelStyleMovingTemplateDirective;
    }());
    var IgxExcelStyleHidingTemplateDirective = /** @class */ (function () {
        function IgxExcelStyleHidingTemplateDirective(template) {
            this.template = template;
        }
        IgxExcelStyleHidingTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxExcelStyleHidingTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxExcelStyleHiding]'
            })
        ], IgxExcelStyleHidingTemplateDirective);
        return IgxExcelStyleHidingTemplateDirective;
    }());
    var IgxExcelStylePinningTemplateDirective = /** @class */ (function () {
        function IgxExcelStylePinningTemplateDirective(template) {
            this.template = template;
        }
        IgxExcelStylePinningTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxExcelStylePinningTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxExcelStylePinning]'
            })
        ], IgxExcelStylePinningTemplateDirective);
        return IgxExcelStylePinningTemplateDirective;
    }());
    /**
     * A component used for presenting Excel style filtering UI for a specific column.
     * It is used internally in the Grid, but could also be hosted in a container outside of it.
     *
     * Example:
     * ```html
     * <igx-grid-excel-style-filtering
     *     [column]="grid1.columns[0]">
     * </igx-grid-excel-style-filtering>
     * ```
     */
    var IgxGridExcelStyleFilteringComponent = /** @class */ (function () {
        function IgxGridExcelStyleFilteringComponent(cdr) {
            this.cdr = cdr;
            this.shouldOpenSubMenu = true;
            this.expressionsList = new Array();
            this.destroy$ = new rxjs.Subject();
            this.containsNullOrEmpty = false;
            this.selectAllSelected = true;
            this.selectAllIndeterminate = false;
            this.filterValues = new Set();
            /**
             * @hidden @internal
             */
            this.listData = new Array();
            /**
             * @hidden @internal
             */
            this.uniqueValues = [];
            this._subMenuPositionSettings = {
                verticalStartPoint: exports.VerticalAlignment.Top
            };
            this._subMenuOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false,
                positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
                scrollStrategy: new AbsoluteScrollStrategy()
            };
            /**
             * @hidden @internal
             */
            this.className = 'igx-excel-filter';
            /**
             * @hidden @internal
             */
            this.inline = true;
        }
        IgxGridExcelStyleFilteringComponent_1 = IgxGridExcelStyleFilteringComponent;
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "column", {
            /**
             * Returns the current column.
             */
            get: function () {
                return this._column;
            },
            /**
             * An @Input property that sets the column.
             */
            set: function (value) {
                var _this = this;
                this._column = value;
                if (this._columnPinning) {
                    this._columnPinning.unsubscribe();
                }
                if (this._columnVisibilityChanged) {
                    this._columnVisibilityChanged.unsubscribe();
                }
                if (this._filteringChanged) {
                    this._filteringChanged.unsubscribe();
                }
                if (this._densityChanged) {
                    this._densityChanged.unsubscribe();
                }
                if (this._column) {
                    this._column.grid.filteringService.registerSVGIcons();
                    this.isColumnPinnable = this.column.pinnable;
                    this.init();
                    this._columnPinning = this.grid.onColumnPinning.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        requestAnimationFrame(function () {
                            _this.isColumnPinnable = _this.column.pinnable;
                            if (!_this.cdr.destroyed) {
                                _this.cdr.detectChanges();
                            }
                        });
                    });
                    this._columnVisibilityChanged = this.grid.onColumnVisibilityChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        _this.cdr.detectChanges();
                    });
                    this._filteringChanged = this.grid.filteringExpressionsTreeChange.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        _this.init();
                    });
                    this._densityChanged = this.grid.onDensityChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        _this.cdr.detectChanges();
                    });
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "filteringService", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.grid.filteringService;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "minHeight", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (!this.inline) {
                    var minHeight = 600;
                    switch (this.grid.displayDensity) {
                        case exports.DisplayDensity.cosy:
                            minHeight = 465;
                            break;
                        case exports.DisplayDensity.compact:
                            minHeight = 330;
                            break;
                        default: break;
                    }
                    return minHeight + "px";
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "maxHeight", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (!this.inline) {
                    var maxHeight = 730;
                    switch (this.grid.displayDensity) {
                        case exports.DisplayDensity.cosy:
                            maxHeight = 565;
                            break;
                        case exports.DisplayDensity.compact:
                            maxHeight = 405;
                            break;
                        default: break;
                    }
                    return maxHeight + "px";
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "grid", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.column.grid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "conditions", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.column.filters.conditionList();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "subMenuText", {
            /**
             * @hidden @internal
             */
            get: function () {
                switch (this.column.dataType) {
                    case exports.DataType.Boolean:
                        return this.grid.resourceStrings.igx_grid_excel_boolean_filter;
                    case exports.DataType.Number:
                        return this.grid.resourceStrings.igx_grid_excel_number_filter;
                    case exports.DataType.Date:
                        return this.grid.resourceStrings.igx_grid_excel_date_filter;
                    default:
                        return this.grid.resourceStrings.igx_grid_excel_text_filter;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        IgxGridExcelStyleFilteringComponent.prototype.init = function () {
            this.expressionsList = new Array();
            this.filteringService.generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);
            this.populateColumnData();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.clearFilterClass = function () {
            if (this.column.filteringExpressionsTree) {
                return 'igx-excel-filter__actions-clear';
            }
            return 'igx-excel-filter__actions-clear--disabled';
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.pinClass = function () {
            return this.isColumnPinnable ? 'igx-excel-filter__actions-pin' : 'igx-excel-filter__actions-pin--disabled';
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.initialize = function (column, overlayService, overlayComponentId) {
            var _this = this;
            this.inline = false;
            this.column = column;
            this.overlayService = overlayService;
            this.overlayComponentId = overlayComponentId;
            this._subMenuOverlaySettings.outlet = this.grid.outlet;
            requestAnimationFrame(function () {
                _this.excelStyleSearch.searchInput.nativeElement.focus();
            });
            this.grid.onColumnMoving.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                _this.closeDropdown();
            });
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.getCondition = function (value) {
            return this.column.filters.condition(value);
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.translateCondition = function (value) {
            return this.grid.resourceStrings["igx_grid_filter_" + this.getCondition(value).name] || value;
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onPin = function () {
            this.column.pinned = !this.column.pinned;
            this.closeDropdown();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onHideToggle = function () {
            this.column.hidden = !this.column.hidden;
            this.grid.onColumnVisibilityChanged.emit({ column: this.column, newValue: this.column.hidden });
            this.closeDropdown();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onTextFilterClick = function (eventArgs) {
            if (this.shouldOpenSubMenu) {
                this._subMenuOverlaySettings.positionStrategy.settings.target = eventArgs.currentTarget;
                var gridRect = this.grid.nativeElement.getBoundingClientRect();
                var dropdownRect = this.mainDropdown.nativeElement.getBoundingClientRect();
                var x = dropdownRect.left + dropdownRect.width;
                var x1 = gridRect.left + gridRect.width;
                x += window.pageXOffset;
                x1 += window.pageXOffset;
                if (Math.abs(x - x1) < 200) {
                    this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = exports.HorizontalAlignment.Left;
                    this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = exports.HorizontalAlignment.Left;
                }
                else {
                    this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = exports.HorizontalAlignment.Right;
                    this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = exports.HorizontalAlignment.Right;
                }
                this.subMenu.open(this._subMenuOverlaySettings);
                this.shouldOpenSubMenu = false;
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onTextFilterKeyDown = function (eventArgs) {
            if (eventArgs.key === "Enter" /* ENTER */) {
                this.onTextFilterClick(eventArgs);
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onSubMenuClosed = function () {
            var _this = this;
            requestAnimationFrame(function () {
                _this.shouldOpenSubMenu = true;
            });
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onSubMenuSelection = function (eventArgs) {
            if (this.expressionsList && this.expressionsList.length &&
                this.expressionsList[0].expression.condition.name !== 'in') {
                this.customDialog.expressionsList = this.expressionsList;
            }
            this.customDialog.selectedOperator = eventArgs.newSelection.value;
            eventArgs.cancel = true;
            if (this.overlayComponentId) {
                this.mainDropdown.nativeElement.style.display = 'none';
            }
            this.subMenu.close();
            this.customDialog.open(this.mainDropdown.nativeElement);
        };
        IgxGridExcelStyleFilteringComponent.prototype.areExpressionsSelectable = function () {
            if (this.expressionsList.length === 1 &&
                (this.expressionsList[0].expression.condition.name === 'equals' ||
                    this.expressionsList[0].expression.condition.name === 'true' ||
                    this.expressionsList[0].expression.condition.name === 'false' ||
                    this.expressionsList[0].expression.condition.name === 'empty' ||
                    this.expressionsList[0].expression.condition.name === 'in')) {
                return true;
            }
            var selectableExpressionsCount = this.expressionsList.filter(function (exp) {
                return (exp.beforeOperator === 1 || exp.afterOperator === 1) &&
                    (exp.expression.condition.name === 'equals' ||
                        exp.expression.condition.name === 'true' ||
                        exp.expression.condition.name === 'false' ||
                        exp.expression.condition.name === 'empty' ||
                        exp.expression.condition.name === 'in');
            }).length;
            return selectableExpressionsCount === this.expressionsList.length;
        };
        IgxGridExcelStyleFilteringComponent.prototype.areExpressionsValuesInTheList = function () {
            if (this.column.dataType === exports.DataType.Boolean) {
                return true;
            }
            if (this.filterValues.size === 1) {
                var firstValue = this.filterValues.values().next().value;
                if (!firstValue && firstValue !== 0) {
                    return true;
                }
            }
            for (var index = 0; index < this.uniqueValues.length; index++) {
                if (this.filterValues.has(this.uniqueValues[index])) {
                    return true;
                }
            }
            return false;
        };
        IgxGridExcelStyleFilteringComponent.prototype.populateColumnData = function () {
            if (this.grid.uniqueColumnValuesStrategy) {
                this.cdr.detectChanges();
                this.renderColumnValuesRemotely();
            }
            else {
                this.renderColumnValuesFromData();
            }
        };
        IgxGridExcelStyleFilteringComponent.prototype.renderColumnValuesRemotely = function () {
            var _this = this;
            this.excelStyleSearch.isLoading = true;
            var expressionsTree = this.getColumnFilterExpressionsTree();
            this.grid.uniqueColumnValuesStrategy(this.column, expressionsTree, function (colVals) {
                var columnValues = (_this.column.dataType === exports.DataType.Date) ?
                    colVals.map(function (val) { return val ? val.toDateString() : val; }) : colVals;
                _this.renderValues(columnValues);
                _this.excelStyleSearch.isLoading = false;
                _this.excelStyleSearch.refreshSize();
            });
        };
        IgxGridExcelStyleFilteringComponent.prototype.renderColumnValuesFromData = function () {
            var data = this.column.gridAPI.get_all_data(this.grid.id);
            var expressionsTree = this.getColumnFilterExpressionsTree();
            if (expressionsTree.filteringOperands.length) {
                var state = { expressionsTree: expressionsTree };
                data = DataUtil.filter(cloneArray(data), state);
            }
            var columnField = this.column.field;
            var columnValues = (this.column.dataType === exports.DataType.Date) ?
                data.map(function (record) { return record[columnField] ? record[columnField].toDateString() : record[columnField]; }) :
                data.map(function (record) { return record[columnField]; });
            this.renderValues(columnValues);
        };
        IgxGridExcelStyleFilteringComponent.prototype.renderValues = function (columnValues) {
            this.generateUniqueValues(columnValues);
            this.generateFilterValues(this.column.dataType === exports.DataType.Date);
            this.generateListData();
        };
        IgxGridExcelStyleFilteringComponent.prototype.generateUniqueValues = function (columnValues) {
            this.uniqueValues = Array.from(new Set(columnValues));
        };
        IgxGridExcelStyleFilteringComponent.prototype.generateFilterValues = function (isDateColumn) {
            if (isDateColumn === void 0) { isDateColumn = false; }
            if (isDateColumn) {
                this.filterValues = new Set(this.expressionsList.reduce(function (arr, e) {
                    if (e.expression.condition.name === 'in') {
                        return __spread(arr, Array.from(e.expression.searchVal.values()).map(function (v) {
                            return new Date(v).toDateString();
                        }));
                    }
                    return __spread(arr, [e.expression.searchVal ? e.expression.searchVal.toDateString() : e.expression.searchVal]);
                }, []));
            }
            else {
                this.filterValues = new Set(this.expressionsList.reduce(function (arr, e) {
                    if (e.expression.condition.name === 'in') {
                        return __spread(arr, Array.from(e.expression.searchVal.values()));
                    }
                    return __spread(arr, [e.expression.searchVal]);
                }, []));
            }
        };
        IgxGridExcelStyleFilteringComponent.prototype.generateListData = function () {
            var _this = this;
            this.listData = new Array();
            var shouldUpdateSelection = this.areExpressionsSelectable() && this.areExpressionsValuesInTheList();
            if (this.column.dataType === exports.DataType.Boolean) {
                this.addBooleanItems();
            }
            else {
                this.addItems(shouldUpdateSelection);
            }
            this.listData.sort(function (a, b) { return _this.sortData(a, b); });
            if (this.column.dataType === exports.DataType.Date) {
                this.uniqueValues = this.uniqueValues.map(function (value) { return new Date(value); });
            }
            if (this.containsNullOrEmpty) {
                this.addBlanksItem(shouldUpdateSelection);
            }
            this.addSelectAllItem();
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        };
        IgxGridExcelStyleFilteringComponent.prototype.getColumnFilterExpressionsTree = function () {
            var e_1, _a;
            var gridExpressionsTree = this.grid.filteringExpressionsTree;
            var expressionsTree = new FilteringExpressionsTree(gridExpressionsTree.operator, gridExpressionsTree.fieldName);
            try {
                for (var _b = __values(gridExpressionsTree.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var operand = _c.value;
                    if (operand instanceof FilteringExpressionsTree) {
                        var columnExprTree = operand;
                        if (columnExprTree.fieldName === this.column.field) {
                            break;
                        }
                    }
                    expressionsTree.filteringOperands.push(operand);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return expressionsTree;
        };
        IgxGridExcelStyleFilteringComponent.prototype.addBooleanItems = function () {
            var _this = this;
            this.selectAllSelected = true;
            this.selectAllIndeterminate = false;
            this.uniqueValues.forEach(function (element) {
                var filterListItem = new FilterListItem();
                if (element !== undefined && element !== null && element !== '') {
                    if (_this.column.filteringExpressionsTree) {
                        if (element === true && _this.expressionsList.find(function (exp) { return exp.expression.condition.name === 'true'; })) {
                            filterListItem.isSelected = true;
                            _this.selectAllIndeterminate = true;
                        }
                        else if (element === false && _this.expressionsList.find(function (exp) { return exp.expression.condition.name === 'false'; })) {
                            filterListItem.isSelected = true;
                            _this.selectAllIndeterminate = true;
                        }
                        else {
                            filterListItem.isSelected = false;
                        }
                    }
                    else {
                        filterListItem.isSelected = true;
                    }
                    filterListItem.value = element;
                    filterListItem.label = element;
                    filterListItem.indeterminate = false;
                    _this.listData.push(filterListItem);
                }
                else {
                    _this.containsNullOrEmpty = true;
                }
            });
        };
        IgxGridExcelStyleFilteringComponent.prototype.addItems = function (shouldUpdateSelection) {
            var _this = this;
            this.selectAllSelected = true;
            this.selectAllIndeterminate = false;
            this.uniqueValues.forEach(function (element) {
                if (element !== undefined && element !== null && element !== '') {
                    var filterListItem = new FilterListItem();
                    if (_this.column.filteringExpressionsTree) {
                        if (shouldUpdateSelection) {
                            if (_this.filterValues.has(element)) {
                                filterListItem.isSelected = true;
                            }
                            else {
                                filterListItem.isSelected = false;
                            }
                            _this.selectAllIndeterminate = true;
                        }
                        else {
                            filterListItem.isSelected = false;
                            _this.selectAllSelected = false;
                        }
                    }
                    else {
                        filterListItem.isSelected = true;
                    }
                    if (_this.column.dataType === exports.DataType.Date) {
                        filterListItem.value = new Date(element);
                        filterListItem.label = new Date(element);
                    }
                    else {
                        filterListItem.value = element;
                        filterListItem.label = element;
                    }
                    filterListItem.indeterminate = false;
                    _this.listData.push(filterListItem);
                }
                else {
                    _this.containsNullOrEmpty = true;
                }
            });
        };
        IgxGridExcelStyleFilteringComponent.prototype.addSelectAllItem = function () {
            var selectAll = new FilterListItem();
            selectAll.isSelected = this.selectAllSelected;
            selectAll.value = this.grid.resourceStrings.igx_grid_excel_select_all;
            selectAll.label = this.grid.resourceStrings.igx_grid_excel_select_all;
            selectAll.indeterminate = this.selectAllIndeterminate;
            selectAll.isSpecial = true;
            this.listData.unshift(selectAll);
        };
        IgxGridExcelStyleFilteringComponent.prototype.addBlanksItem = function (shouldUpdateSelection) {
            var blanks = new FilterListItem();
            if (this.column.filteringExpressionsTree) {
                if (shouldUpdateSelection) {
                    if (this.filterValues.has(null)) {
                        blanks.isSelected = true;
                    }
                    else {
                        blanks.isSelected = false;
                    }
                }
            }
            else {
                blanks.isSelected = true;
            }
            blanks.value = null;
            blanks.label = this.grid.resourceStrings.igx_grid_excel_blanks;
            blanks.indeterminate = false;
            blanks.isSpecial = true;
            this.listData.unshift(blanks);
        };
        IgxGridExcelStyleFilteringComponent.prototype.sortData = function (a, b) {
            var valueA = a.value;
            var valueB = b.value;
            if (typeof (a) === exports.DataType.String) {
                valueA = a.value.toUpperCase();
                valueB = b.value.toUpperCase();
            }
            if (valueA < valueB) {
                return -1;
            }
            else if (valueA > valueB) {
                return 1;
            }
            else {
                return 0;
            }
        };
        IgxGridExcelStyleFilteringComponent.prototype.selectAllFilterItems = function () {
            this.listData.forEach(function (filterListItem) {
                filterListItem.isSelected = true;
                filterListItem.indeterminate = false;
            });
            this.excelStyleSearch.cdr.detectChanges();
        };
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "sortingTemplate", {
            // TODO: sort members by access modifier
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.grid.excelStyleSortingTemplateDirective) {
                    return this.grid.excelStyleSortingTemplateDirective.template;
                }
                else {
                    return this.defaultExcelStyleSortingTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "movingTemplate", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.grid.excelStyleMovingTemplateDirective) {
                    return this.grid.excelStyleMovingTemplateDirective.template;
                }
                else {
                    return this.defaultExcelStyleMovingTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "pinningTemplate", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.grid.excelStylePinningTemplateDirective) {
                    return this.grid.excelStylePinningTemplateDirective.template;
                }
                else {
                    return this.defaultExcelStylePinningTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "hidingTemplate", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.grid.excelStyleHidingTemplateDirective) {
                    return this.grid.excelStyleHidingTemplateDirective.template;
                }
                else {
                    return this.defaultExcelStyleHidingTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "applyButtonDisabled", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.listData[0] && !this.listData[0].isSelected && !this.listData[0].indeterminate;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.applyFilter = function () {
            var _this = this;
            var filterTree = new FilteringExpressionsTree(exports.FilteringLogic.Or, this.column.field);
            var selectedItems = this.listData.slice(1, this.listData.length).filter(function (el) { return el.isSelected === true; });
            var unselectedItem = this.listData.slice(1, this.listData.length).find(function (el) { return el.isSelected === false; });
            if (unselectedItem) {
                if (selectedItems.length <= IgxGridExcelStyleFilteringComponent_1.filterOptimizationThreshold) {
                    selectedItems.forEach(function (element) {
                        var condition = null;
                        if (element.value !== null && element.value !== undefined) {
                            if (_this.column.dataType === exports.DataType.Boolean) {
                                condition = _this.createCondition(element.value.toString());
                            }
                            else {
                                condition = _this.createCondition('equals');
                            }
                        }
                        else {
                            condition = _this.createCondition('empty');
                        }
                        filterTree.filteringOperands.push({
                            condition: condition,
                            fieldName: _this.column.field,
                            ignoreCase: _this.column.filteringIgnoreCase,
                            searchVal: element.value
                        });
                    });
                }
                else {
                    var blanksItemIndex = selectedItems.findIndex(function (e) { return e.value === null || e.value === undefined; });
                    var blanksItem = void 0;
                    if (blanksItemIndex >= 0) {
                        blanksItem = selectedItems[blanksItemIndex];
                        selectedItems.splice(blanksItemIndex, 1);
                    }
                    filterTree.filteringOperands.push({
                        condition: this.createCondition('in'),
                        fieldName: this.column.field,
                        ignoreCase: this.column.filteringIgnoreCase,
                        searchVal: new Set(this.column.dataType === exports.DataType.Date ?
                            selectedItems.map(function (d) { return new Date(d.value.getFullYear(), d.value.getMonth(), d.value.getDate()).toISOString(); }) :
                            selectedItems.map(function (e) { return e.value; }))
                    });
                    if (blanksItem) {
                        filterTree.filteringOperands.push({
                            condition: this.createCondition('empty'),
                            fieldName: this.column.field,
                            ignoreCase: this.column.filteringIgnoreCase,
                            searchVal: blanksItem.value
                        });
                    }
                }
                this.filteringService.filterInternal(this.column.field, filterTree);
                this.expressionsList = new Array();
                this.filteringService.generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);
            }
            else {
                this.filteringService.clearFilter(this.column.field);
            }
            this.closeDropdown();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.cancel = function () {
            if (!this.overlayComponentId) {
                this.init();
            }
            this.closeDropdown();
        };
        IgxGridExcelStyleFilteringComponent.prototype.closeDropdown = function () {
            if (this.overlayComponentId) {
                this.overlayService.hide(this.overlayComponentId);
                this.overlayComponentId = null;
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onKeyDown = function (eventArgs) {
            if (eventArgs.key === "Escape" /* ESCAPE */ || eventArgs.key === "Esc" /* ESCAPE_IE */) {
                this.closeDropdown();
            }
            eventArgs.stopPropagation();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.clearFilter = function () {
            this.filteringService.clearFilter(this.column.field);
            this.selectAllFilterItems();
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.onClearFilterKeyDown = function (eventArgs) {
            if (eventArgs.key === "Enter" /* ENTER */) {
                this.clearFilter();
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridExcelStyleFilteringComponent.prototype.showCustomFilterItem = function () {
            var exprTree = this.column.filteringExpressionsTree;
            return exprTree && exprTree.filteringOperands && exprTree.filteringOperands.length &&
                !(exprTree.filteringOperands[0].condition &&
                    exprTree.filteringOperands[0].condition.name === 'in');
        };
        IgxGridExcelStyleFilteringComponent.prototype.createCondition = function (conditionName) {
            switch (this.column.dataType) {
                case exports.DataType.Boolean:
                    return IgxBooleanFilteringOperand.instance().condition(conditionName);
                case exports.DataType.Number:
                    return IgxNumberFilteringOperand.instance().condition(conditionName);
                case exports.DataType.Date:
                    return IgxDateFilteringOperand.instance().condition(conditionName);
                default:
                    return IgxStringFilteringOperand.instance().condition(conditionName);
            }
        };
        var IgxGridExcelStyleFilteringComponent_1;
        IgxGridExcelStyleFilteringComponent.filterOptimizationThreshold = 2;
        IgxGridExcelStyleFilteringComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxGridExcelStyleFilteringComponent.prototype, "column", null);
        __decorate([
            core.HostBinding('style.max-height')
        ], IgxGridExcelStyleFilteringComponent.prototype, "maxHeight", null);
        __decorate([
            core.HostBinding('class.igx-excel-filter')
        ], IgxGridExcelStyleFilteringComponent.prototype, "className", void 0);
        __decorate([
            core.HostBinding('class.igx-excel-filter--inline')
        ], IgxGridExcelStyleFilteringComponent.prototype, "inline", void 0);
        __decorate([
            core.ViewChild('dropdown', { read: core.ElementRef })
        ], IgxGridExcelStyleFilteringComponent.prototype, "mainDropdown", void 0);
        __decorate([
            core.ViewChild('subMenu', { read: IgxDropDownComponent })
        ], IgxGridExcelStyleFilteringComponent.prototype, "subMenu", void 0);
        __decorate([
            core.ViewChild('customDialog', { read: IgxExcelStyleCustomDialogComponent })
        ], IgxGridExcelStyleFilteringComponent.prototype, "customDialog", void 0);
        __decorate([
            core.ViewChild('excelStyleSearch', { read: IgxExcelStyleSearchComponent })
        ], IgxGridExcelStyleFilteringComponent.prototype, "excelStyleSearch", void 0);
        __decorate([
            core.ViewChild('excelStyleSorting', { read: IgxExcelStyleSortingComponent })
        ], IgxGridExcelStyleFilteringComponent.prototype, "excelStyleSorting", void 0);
        __decorate([
            core.ViewChild('defaultExcelStyleSortingTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridExcelStyleFilteringComponent.prototype, "defaultExcelStyleSortingTemplate", void 0);
        __decorate([
            core.ViewChild('defaultExcelStyleHidingTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridExcelStyleFilteringComponent.prototype, "defaultExcelStyleHidingTemplate", void 0);
        __decorate([
            core.ViewChild('defaultExcelStyleMovingTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridExcelStyleFilteringComponent.prototype, "defaultExcelStyleMovingTemplate", void 0);
        __decorate([
            core.ViewChild('defaultExcelStylePinningTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridExcelStyleFilteringComponent.prototype, "defaultExcelStylePinningTemplate", void 0);
        IgxGridExcelStyleFilteringComponent = IgxGridExcelStyleFilteringComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-excel-style-filtering',
                template: "<ng-template #defaultExcelStyleSortingTemplate>\n    <igx-excel-style-sorting #excelStyleSorting\n        class=\"igx-excel-filter__sort\"\n        [column]=\"column\"\n        [grid]=\"grid\"\n        [displayDensity]=\"grid.displayDensity\">\n    </igx-excel-style-sorting>\n</ng-template>\n\n<ng-template #defaultExcelStyleMovingTemplate>\n    <igx-excel-style-column-moving\n        class=\"igx-excel-filter__move\"\n        [column]=\"column\"\n        [grid]=\"grid\"\n        [isColumnPinnable]=\"isColumnPinnable\"\n        [displayDensity]=\"grid.displayDensity\">\n    </igx-excel-style-column-moving>\n</ng-template>\n\n<ng-template #defaultExcelStylePinningTemplate>\n    <div [ngClass]=\"pinClass()\"\n        (click)=\"onPin()\"\n        tabindex=\"0\"\n        *ngIf=\"!column.pinned\">\n        <span>{{ grid.resourceStrings.igx_grid_excel_pin }}</span>\n        <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n    </div>\n\n    <div class=\"igx-excel-filter__actions-unpin\"\n        (click)=\"onPin()\"\n        tabindex=\"0\"\n        *ngIf=\"column.pinned\">\n        <span>{{ grid.resourceStrings.igx_grid_excel_unpin }}</span>\n        <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n    </div>\n</ng-template>\n\n<ng-template #defaultExcelStyleHidingTemplate>\n    <div class=\"igx-excel-filter__actions-hide\"\n        tabindex=\"0\"\n        (click)=\"onHideToggle()\">\n        <span>{{ column.hidden ? grid.resourceStrings.igx_grid_excel_show : grid.resourceStrings.igx_grid_excel_hide }}</span>\n        <igx-icon>{{ column.hidden ? 'visibility' : 'visibility_off' }}</igx-icon>\n    </div>\n</ng-template>\n\n<article #dropdown\n    *ngIf=\"column\"\n    class=\"igx-excel-filter__menu\"\n    [ngClass]=\"{\n        'igx-excel-filter__menu--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__menu--compact': grid.displayDensity === 'compact'\n    }\"\n    [id]=\"overlayComponentId\"\n    (keydown)=\"onKeyDown($event)\"\n    [style.min-height]=\"minHeight\"\n    [style.max-height]=\"maxHeight\">\n\n    <header class=\"igx-excel-filter__menu-header\">\n        <h4>{{ column.header || column.field }}</h4>\n        <div *ngIf=\"grid.displayDensity!=='comfortable'\" class=\"igx-excel-filter__menu-header-actions\">\n            <button *ngIf=\"!column.disablePinning && !column.pinned\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                (click)=\"onPin()\"\n                [disabled]=\"!isColumnPinnable\"\n                tabindex=\"0\">\n                <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n            </button>\n            <button *ngIf=\"!column.disablePinning && column.pinned\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                (click)=\"onPin()\"\n                tabindex=\"0\">\n                <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n            </button>\n            <button *ngIf=\"!column.disableHiding\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                tabindex=\"0\"\n                (click)=\"onHideToggle()\">\n                <igx-icon>{{ column.hidden ? 'visibility' : 'visibility_off' }}</igx-icon>\n            </button>\n        </div>\n    </header>\n\n    <div *ngIf=\"column.sortable\">\n        <ng-container *ngTemplateOutlet=\"sortingTemplate\"></ng-container>\n    </div>\n\n    <section class=\"igx-excel-filter__actions\">\n\n        <div *ngIf=\"column.movable\">\n            <ng-container *ngTemplateOutlet=\"movingTemplate\"></ng-container>\n        </div>\n\n        <div *ngIf=\"!column.disablePinning && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"pinningTemplate\"></ng-container>\n        </div>\n\n        <div *ngIf=\"!column.disableHiding && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"hidingTemplate\"></ng-container>\n        </div>\n\n        <div\n            tabindex=\"0\"\n            [ngClass]=\"clearFilterClass()\"\n            (keydown)=\"onClearFilterKeyDown($event)\"\n            (click)=\"clearFilter()\">\n            <span>{{ grid.resourceStrings.igx_grid_excel_filter_clear }}</span>\n            <igx-icon>clear</igx-icon>\n        </div>\n\n        <div\n            tabindex=\"0\"\n            class=\"igx-excel-filter__actions-filter\"\n            (keydown)=\"onTextFilterKeyDown($event)\"\n            (click)=\"onTextFilterClick($event)\"\n            [igxDropDownItemNavigation]=\"subMenu\" >\n            <span>{{ subMenuText }}</span>\n            <igx-icon>keyboard_arrow_right</igx-icon>\n        </div>\n    </section>\n\n    <igx-excel-style-search\n        class=\"igx-excel-filter__menu-main\"\n        #excelStyleSearch\n        [column]=\"column\"\n        [data]=\"listData\"\n        [grid]=\"grid\"\n        [inline]=\"inline\"\n        [displayDensity]=\"grid.displayDensity\">\n    </igx-excel-style-search>\n\n    <footer class=\"igx-excel-filter__menu-footer\">\n        <button igxButton [displayDensity]=\"grid.displayDensity\" (click)=\"cancel()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n        <button igxButton=\"raised\" [displayDensity]=\"grid.displayDensity\" [disabled]=\"applyButtonDisabled\" (click)=\"applyFilter()\">{{ grid.resourceStrings.igx_grid_excel_apply }}</button>\n    </footer>\n</article>\n\n<igx-drop-down\n    *ngIf=\"column\"\n    #subMenu\n    [maxHeight]=\"'397px'\"\n    [displayDensity]=\"grid.displayDensity\"\n    (onSelection)=\"onSubMenuSelection($event)\"\n    (onClosed)=\"onSubMenuClosed()\">\n    <div>\n        <igx-drop-down-item\n            *ngFor=\"let condition of conditions\"\n            [value]=\"condition\">\n            <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span style=\"margin-left: 16px\">{{ translateCondition(condition) }}</span>\n        </igx-drop-down-item>\n        <igx-drop-down-item *ngIf=\"showCustomFilterItem()\">\n            <igx-icon>filter_list</igx-icon>\n            <span style=\"margin-left: 16px\">{{ grid.resourceStrings.igx_grid_excel_custom_filter }}</span>\n        </igx-drop-down-item>\n    </div>\n</igx-drop-down>\n\n<igx-excel-style-custom-dialog\n    *ngIf=\"column\"\n    #customDialog\n    [column]=\"column\"\n    [filteringService]=\"filteringService\"\n    [overlayComponentId]=\"overlayComponentId\"\n    [overlayService]=\"overlayService\"\n    [displayDensity]=\"grid.displayDensity\">\n</igx-excel-style-custom-dialog>\n"
            })
        ], IgxGridExcelStyleFilteringComponent);
        return IgxGridExcelStyleFilteringComponent;
    }());

    /** @hidden */
    var ExcelStylePositionStrategy = /** @class */ (function (_super) {
        __extends(ExcelStylePositionStrategy, _super);
        function ExcelStylePositionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ExcelStylePositionStrategy.prototype.shouldFitInViewPort = function (connectedFit) {
            return true;
        };
        ExcelStylePositionStrategy.prototype.fitInViewport = function (element, connectedFit) {
            var heightOverflow = connectedFit.contentElementRect.height - connectedFit.viewPortRect.height;
            if (heightOverflow > 0) {
                element.style.width = 'auto';
                element.style.height = connectedFit.viewPortRect.height + "px";
            }
            else {
                element.style.height = Math.max(connectedFit.viewPortRect.height - connectedFit.targetRect.bottom - 1, connectedFit.contentElementRect.height) + "px";
            }
            _super.prototype.fitInViewport.call(this, element, connectedFit);
        };
        return ExcelStylePositionStrategy;
    }(AutoPositionStrategy));

    /**
     * @hidden
     */
    var IgxGridHeaderComponent = /** @class */ (function () {
        function IgxGridHeaderComponent(gridAPI, colResizingService, cdr, elementRef, zone, _filteringService, _moduleRef, _overlayService) {
            this.gridAPI = gridAPI;
            this.colResizingService = colResizingService;
            this.cdr = cdr;
            this.elementRef = elementRef;
            this.zone = zone;
            this._filteringService = _filteringService;
            this._moduleRef = _moduleRef;
            this._overlayService = _overlayService;
            this._destroy$ = new rxjs.Subject();
            this.hostRole = 'columnheader';
            this.tabindex = 0;
            this.sortDirection = exports.SortingDirection.None;
        }
        Object.defineProperty(IgxGridHeaderComponent.prototype, "styleClasses", {
            get: function () {
                var e_1, _a;
                var defaultClasses = [
                    'igx-grid__th--fw',
                    this.column.headerClasses
                ];
                var classList = {
                    'igx-grid__th': !this.column.columnGroup,
                    'asc': this.ascending,
                    'desc': this.descending,
                    'igx-grid__th--number': this.column.dataType === exports.DataType.Number,
                    'igx-grid__th--sortable': this.column.sortable,
                    'igx-grid__th--filtrable': this.column.filterable && this.grid.filteringService.isFilterRowVisible,
                    'igx-grid__th--sorted': this.sorted
                };
                try {
                    for (var _b = __values(Object.keys(classList)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var klass = _c.value;
                        if (classList[klass]) {
                            defaultClasses.push(klass);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return defaultClasses.join(' ');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "height", {
            get: function () {
                if (this.grid.hasColumnGroups) {
                    return (this.grid.maxLevelHeaderDepth + 1 - this.column.level) * this.grid.defaultRowHeight / this.grid._baseFontSize;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "ascending", {
            get: function () {
                return this.sortDirection === exports.SortingDirection.Asc;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "descending", {
            get: function () {
                return this.sortDirection === exports.SortingDirection.Desc;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "sortingIcon", {
            get: function () {
                if (this.sortDirection !== exports.SortingDirection.None) {
                    // arrow_downward and arrow_upward
                    // are material icons ligature strings
                    return this.sortDirection === exports.SortingDirection.Asc ? 'arrow_upward' : 'arrow_downward';
                }
                return 'arrow_upward';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "sorted", {
            get: function () {
                return this.sortDirection !== exports.SortingDirection.None;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "filterIconClassName", {
            get: function () {
                return this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderComponent.prototype, "headerID", {
            get: function () {
                return this.gridID + "_" + this.column.field;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridHeaderComponent.prototype.ngOnInit = function () {
            this.initFilteringSettings();
        };
        IgxGridHeaderComponent.prototype.ngDoCheck = function () {
            this.getSortDirection();
            this.cdr.markForCheck();
        };
        IgxGridHeaderComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next(true);
            this._destroy$.complete();
            if (this._componentOverlayId) {
                this._overlayService.hide(this._componentOverlayId);
            }
        };
        IgxGridHeaderComponent.prototype.onClick = function (event) {
            if (!this.colResizingService.isColumnResizing) {
                event.stopPropagation();
                if (this.grid.filteringService.isFilterRowVisible) {
                    if (this.column.filterable && !this.column.columnGroup &&
                        !this.grid.filteringService.isFilterComplex(this.column.field)) {
                        this.grid.filteringService.filteredColumn = this.column;
                    }
                }
                else if (this.column.sortable) {
                    this.triggerSort();
                }
            }
        };
        IgxGridHeaderComponent.prototype.onFilteringIconClick = function (event) {
            event.stopPropagation();
            this.toggleFilterDropdown();
        };
        Object.defineProperty(IgxGridHeaderComponent.prototype, "grid", {
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridHeaderComponent.prototype.getSortDirection = function () {
            var _this = this;
            var expr = this.gridAPI.grid.sortingExpressions.find(function (x) { return x.fieldName === _this.column.field; });
            this.sortDirection = expr ? expr.dir : exports.SortingDirection.None;
        };
        IgxGridHeaderComponent.prototype.onSortingIconClick = function (event) {
            if (this.grid.filteringService.isFilterRowVisible) {
                event.stopPropagation();
                this.triggerSort();
            }
        };
        IgxGridHeaderComponent.prototype.triggerSort = function () {
            var _this = this;
            var groupingExpr = this.grid.groupingExpressions ?
                this.grid.groupingExpressions.find(function (expr) { return expr.fieldName === _this.column.field; }) : null;
            var sortDir = groupingExpr ?
                this.sortDirection + 1 > exports.SortingDirection.Desc ? exports.SortingDirection.Asc : exports.SortingDirection.Desc
                : this.sortDirection + 1 > exports.SortingDirection.Desc ? exports.SortingDirection.None : this.sortDirection + 1;
            this.sortDirection = sortDir;
            this.grid.sort({ fieldName: this.column.field, dir: this.sortDirection, ignoreCase: this.column.sortingIgnoreCase,
                strategy: this.column.sortStrategy });
        };
        IgxGridHeaderComponent.prototype.toggleFilterDropdown = function () {
            if (!this._componentOverlayId) {
                var headerTarget = this.elementRef.nativeElement;
                var filterIconTarget = headerTarget.querySelector('.' + this.filterIconClassName);
                this._filterMenuOverlaySettings.positionStrategy.settings.target = filterIconTarget;
                this._filterMenuOverlaySettings.outlet = this.grid.outlet;
                this._componentOverlayId =
                    this._overlayService.attach(IgxGridExcelStyleFilteringComponent, this._filterMenuOverlaySettings, this._moduleRef);
                this._overlayService.show(this._componentOverlayId, this._filterMenuOverlaySettings);
            }
        };
        IgxGridHeaderComponent.prototype.initFilteringSettings = function () {
            var _this = this;
            this._filterMenuPositionSettings = {
                verticalStartPoint: exports.VerticalAlignment.Bottom,
                openAnimation: animations.useAnimation(fadeIn, {
                    params: {
                        duration: '250ms'
                    }
                }),
                closeAnimation: animations.useAnimation(fadeOut, {
                    params: {
                        duration: '200ms'
                    }
                })
            };
            this._filterMenuOverlaySettings = {
                closeOnOutsideClick: true,
                modal: false,
                positionStrategy: new ExcelStylePositionStrategy(this._filterMenuPositionSettings),
                scrollStrategy: new AbsoluteScrollStrategy()
            };
            this._overlayService.onOpening.pipe(operators.filter(function (overlay) { return overlay.id === _this._componentOverlayId; }), operators.takeUntil(this._destroy$)).subscribe(function (eventArgs) {
                _this.onOverlayOpening(eventArgs);
            });
            this._overlayService.onClosed.pipe(operators.filter(function (overlay) { return overlay.id === _this._componentOverlayId; }), operators.takeUntil(this._destroy$)).subscribe(function () {
                _this.onOverlayClosed();
            });
        };
        IgxGridHeaderComponent.prototype.onOverlayOpening = function (eventArgs) {
            var instance = eventArgs.componentRef.instance;
            if (instance) {
                instance.initialize(this.column, this._overlayService, eventArgs.id);
            }
        };
        IgxGridHeaderComponent.prototype.onOverlayClosed = function () {
            this._componentOverlayId = null;
        };
        IgxGridHeaderComponent.ctorParameters = function () { return [
            { type: GridBaseAPIService },
            { type: IgxColumnResizingService },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: IgxFilteringService },
            { type: core.NgModuleRef },
            { type: IgxOverlayService, decorators: [{ type: core.Inject, args: [IgxOverlayService,] }] }
        ]; };
        __decorate([
            core.Input()
        ], IgxGridHeaderComponent.prototype, "column", void 0);
        __decorate([
            core.Input()
        ], IgxGridHeaderComponent.prototype, "gridID", void 0);
        __decorate([
            core.HostBinding('class')
        ], IgxGridHeaderComponent.prototype, "styleClasses", null);
        __decorate([
            core.HostBinding('style.height.rem')
        ], IgxGridHeaderComponent.prototype, "height", null);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxGridHeaderComponent.prototype, "hostRole", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxGridHeaderComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('attr.id')
        ], IgxGridHeaderComponent.prototype, "headerID", null);
        __decorate([
            core.HostListener('click', ['$event'])
        ], IgxGridHeaderComponent.prototype, "onClick", null);
        IgxGridHeaderComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-header',
                template: "<ng-template #defaultColumn>\n    <span [attr.title]=\"column.header || column.field\">{{ column.header || column.field }}</span>\n</ng-template>\n\n<span class=\"igx-grid__th-title\">\n    <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n    </ng-container>\n</span>\n<div class=\"igx-grid__th-icons\" *ngIf=\"!column.columnGroup\">\n    <igx-icon [attr.draggable]=\"false\"\n        class=\"sort-icon\"\n        *ngIf=\"column.sortable\"\n        (click)=\"onSortingIconClick($event)\">\n        {{sortingIcon}}\n    </igx-icon>\n\n    <igx-icon [ngClass]=\"filterIconClassName\" [attr.draggable]=\"false\" (click)=\"onFilteringIconClick($event)\"\n        *ngIf=\"grid.allowFiltering == true && column.filterable && grid.filterMode == 'excelStyleFilter'\">\n        filter_list\n    </igx-icon>\n</div>\n"
            }),
            __param(7, core.Inject(IgxOverlayService))
        ], IgxGridHeaderComponent);
        return IgxGridHeaderComponent;
    }());

    /**
     * @hidden
     */
    var IgxGridFilteringCellComponent = /** @class */ (function () {
        function IgxGridFilteringCellComponent(cdr, filteringService) {
            this.cdr = cdr;
            this.filteringService = filteringService;
            this.baseClass = 'igx-grid__filtering-cell-indicator';
            this.currentTemplate = null;
            this.moreFiltersCount = 0;
            this.cssClass = 'igx-grid__filtering-cell';
            this.filteringService.subscribeToEvents();
        }
        IgxGridFilteringCellComponent.prototype.ngOnInit = function () {
            this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
        };
        IgxGridFilteringCellComponent.prototype.ngAfterViewInit = function () {
            this.updateFilterCellArea();
        };
        IgxGridFilteringCellComponent.prototype.ngDoCheck = function () {
            this.updateFilterCellArea();
        };
        IgxGridFilteringCellComponent.prototype.onTabKeyDown = function (eventArgs) {
            if (this.isLastElementFocused()) {
                this.filteringService.grid.navigation.navigateNextFilterCell(this.column, eventArgs);
            }
            eventArgs.stopPropagation();
        };
        IgxGridFilteringCellComponent.prototype.onShiftTabKeyDown = function (eventArgs) {
            if (this.isFirstElementFocused()) {
                this.filteringService.grid.navigation.navigatePrevFilterCell(this.column, eventArgs);
            }
            eventArgs.stopPropagation();
        };
        /**
         * Returns whether a chip with a given index is visible or not.
         */
        IgxGridFilteringCellComponent.prototype.isChipVisible = function (index) {
            var expression = this.expressionsList[index];
            return !!(expression && expression.isVisible);
        };
        /**
         * Updates the filtering cell area.
         */
        IgxGridFilteringCellComponent.prototype.updateFilterCellArea = function () {
            this.expressionsList = this.filteringService.getExpressions(this.column.field);
            this.updateVisibleFilters();
        };
        Object.defineProperty(IgxGridFilteringCellComponent.prototype, "template", {
            get: function () {
                if (!this.column.filterable) {
                    this.currentTemplate = null;
                    return null;
                }
                if (this.column.filterCellTemplate) {
                    this.currentTemplate = this.column.filterCellTemplate;
                    return this.column.filterCellTemplate;
                }
                var expressionTree = this.column.filteringExpressionsTree;
                if (!expressionTree || expressionTree.filteringOperands.length === 0) {
                    this.currentTemplate = this.emptyFilter;
                    return this.emptyFilter;
                }
                if (this.filteringService.isFilterComplex(this.column.field)) {
                    this.currentTemplate = this.complexFilter;
                    return this.complexFilter;
                }
                this.currentTemplate = this.defaultFilter;
                return this.defaultFilter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringCellComponent.prototype, "context", {
            /**
             * Gets the context passed to the filter template.
             * @memberof IgxGridFilteringCellComponent
             */
            get: function () {
                return {
                    column: this.column
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Chip clicked event handler.
         */
        IgxGridFilteringCellComponent.prototype.onChipClicked = function (expression) {
            if (expression) {
                this.expressionsList.forEach(function (item) {
                    item.isSelected = (item.expression === expression);
                });
            }
            else if (this.expressionsList.length > 0) {
                this.expressionsList.forEach(function (item) {
                    item.isSelected = false;
                });
                this.expressionsList[0].isSelected = true;
            }
            var index = this.filteringService.unpinnedFilterableColumns.indexOf(this.column);
            if (index >= 0 && !this.isColumnRightVisible(index)) {
                this.filteringService.scrollToFilterCell(this.filteringService.unpinnedFilterableColumns[index], true);
            }
            else if (index >= 0 && !this.isColumnLeftVisible(index)) {
                this.filteringService.scrollToFilterCell(this.filteringService.unpinnedFilterableColumns[index], false);
            }
            this.filteringService.filteredColumn = this.column;
            this.filteringService.isFilterRowVisible = true;
            this.filteringService.selectedExpression = expression;
        };
        /**
         * Chip removed event handler.
         */
        IgxGridFilteringCellComponent.prototype.onChipRemoved = function (eventArgs, item) {
            var indexToRemove = this.expressionsList.indexOf(item);
            this.removeExpression(indexToRemove);
            this.focusChip();
        };
        /**
         * Clears the filtering.
         */
        IgxGridFilteringCellComponent.prototype.clearFiltering = function () {
            this.filteringService.clearFilter(this.column.field);
            this.cdr.detectChanges();
        };
        /**
         * Chip keydown event handler.
         */
        IgxGridFilteringCellComponent.prototype.onChipKeyDown = function (eventArgs, expression) {
            if (eventArgs.key === "Enter" /* ENTER */) {
                eventArgs.preventDefault();
                this.onChipClicked(expression);
            }
        };
        /**
         * Returns the filtering indicator class.
         */
        IgxGridFilteringCellComponent.prototype.filteringIndicatorClass = function () {
            var _a;
            return _a = {},
                _a[this.baseClass] = !this.isMoreIconHidden(),
                _a[this.baseClass + "--hidden"] = this.isMoreIconHidden(),
                _a;
        };
        /**
         * Focus a chip depending on the current visible template.
         */
        IgxGridFilteringCellComponent.prototype.focusChip = function (focusFirst) {
            if (focusFirst === void 0) { focusFirst = false; }
            if (this.currentTemplate === this.defaultFilter) {
                if (focusFirst) {
                    this.focusFirstElement();
                }
                else {
                    this.focusElement();
                }
            }
            else if (this.currentTemplate === this.emptyFilter) {
                this.ghostChip.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
            }
            else if (this.currentTemplate === this.complexFilter) {
                this.complexChip.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
            }
        };
        IgxGridFilteringCellComponent.prototype.removeExpression = function (indexToRemove) {
            if (indexToRemove === 0 && this.expressionsList.length === 1) {
                this.clearFiltering();
                return;
            }
            this.filteringService.removeExpression(this.column.field, indexToRemove);
            this.updateVisibleFilters();
            this.filteringService.filterInternal(this.column.field);
        };
        IgxGridFilteringCellComponent.prototype.isMoreIconHidden = function () {
            return this.filteringService.columnToMoreIconHidden.get(this.column.field);
        };
        IgxGridFilteringCellComponent.prototype.updateVisibleFilters = function () {
            this.expressionsList.forEach(function (ex) { return ex.isVisible = true; });
            if (this.moreIcon) {
                this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
            }
            this.cdr.detectChanges();
            if (this.chipsArea && this.expressionsList.length > 1) {
                var areaWidth = this.chipsArea.element.nativeElement.offsetWidth;
                var viewWidth = 0;
                var chipsAreaElements = this.chipsArea.element.nativeElement.children;
                var visibleChipsCount = 0;
                var moreIconWidth = this.moreIcon.nativeElement.offsetWidth -
                    parseInt(document.defaultView.getComputedStyle(this.moreIcon.nativeElement)['margin-left'], 10);
                for (var index = 0; index < chipsAreaElements.length - 1; index++) {
                    if (viewWidth + chipsAreaElements[index].offsetWidth < areaWidth) {
                        viewWidth += chipsAreaElements[index].offsetWidth;
                        if (index % 2 === 0) {
                            visibleChipsCount++;
                        }
                        else {
                            viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-left'], 10);
                            viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-right'], 10);
                        }
                    }
                    else {
                        if (index % 2 !== 0 && viewWidth + moreIconWidth > areaWidth) {
                            visibleChipsCount--;
                        }
                        else if (visibleChipsCount > 0 && viewWidth - chipsAreaElements[index - 1].offsetWidth + moreIconWidth > areaWidth) {
                            visibleChipsCount--;
                        }
                        this.moreFiltersCount = this.expressionsList.length - visibleChipsCount;
                        this.filteringService.columnToMoreIconHidden.set(this.column.field, false);
                        break;
                    }
                }
                for (var i = visibleChipsCount; i < this.expressionsList.length; i++) {
                    this.expressionsList[i].isVisible = false;
                }
                this.cdr.detectChanges();
            }
        };
        IgxGridFilteringCellComponent.prototype.isFirstElementFocused = function () {
            return !(this.chipsArea && this.chipsArea.chipsList.length > 0 &&
                this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(".igx-chip__item") !== document.activeElement);
        };
        IgxGridFilteringCellComponent.prototype.isLastElementFocused = function () {
            if (this.chipsArea) {
                if (this.isMoreIconHidden() && this.chipsArea.chipsList.last.elementRef.nativeElement.querySelector(".igx-chip__remove") !==
                    document.activeElement) {
                    return false;
                }
                else if (!this.isMoreIconHidden() && this.moreIcon.nativeElement !== document.activeElement) {
                    return false;
                }
            }
            return true;
        };
        IgxGridFilteringCellComponent.prototype.focusFirstElement = function () {
            if (this.chipsArea.chipsList.length > 0) {
                this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
            }
            else {
                this.moreIcon.nativeElement.focus();
            }
        };
        IgxGridFilteringCellComponent.prototype.focusElement = function () {
            if (this.filteringService.shouldFocusNext) {
                if (!this.isMoreIconHidden() && this.chipsArea.chipsList.length === 0) {
                    this.moreIcon.nativeElement.focus();
                }
                else {
                    this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
                }
            }
            else {
                if (!this.isMoreIconHidden()) {
                    this.moreIcon.nativeElement.focus();
                }
                else {
                    this.chipsArea.chipsList.last.elementRef.nativeElement.querySelector(".igx-chip__remove").focus();
                }
            }
        };
        IgxGridFilteringCellComponent.prototype.isColumnRightVisible = function (columnIndex) {
            if (this.filteringService.areAllColumnsInView) {
                return true;
            }
            var currentColumnRight = 0;
            for (var index = 0; index < this.filteringService.unpinnedColumns.length; index++) {
                currentColumnRight += parseInt(this.filteringService.unpinnedColumns[index].width, 10);
                if (this.filteringService.unpinnedColumns[index] === this.filteringService.unpinnedFilterableColumns[columnIndex]) {
                    break;
                }
            }
            var width = this.filteringService.displayContainerWidth + this.filteringService.displayContainerScrollLeft;
            return currentColumnRight <= width;
        };
        IgxGridFilteringCellComponent.prototype.isColumnLeftVisible = function (columnIndex) {
            if (this.filteringService.areAllColumnsInView) {
                return true;
            }
            var currentColumnLeft = 0;
            for (var index = 0; index < this.filteringService.unpinnedColumns.length; index++) {
                if (this.filteringService.unpinnedColumns[index] === this.filteringService.unpinnedFilterableColumns[columnIndex]) {
                    break;
                }
                currentColumnLeft += parseInt(this.filteringService.unpinnedColumns[index].width, 10);
            }
            return currentColumnLeft >= this.filteringService.displayContainerScrollLeft;
        };
        IgxGridFilteringCellComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: IgxFilteringService }
        ]; };
        __decorate([
            core.Input()
        ], IgxGridFilteringCellComponent.prototype, "column", void 0);
        __decorate([
            core.ViewChild('emptyFilter', { read: core.TemplateRef, static: true })
        ], IgxGridFilteringCellComponent.prototype, "emptyFilter", void 0);
        __decorate([
            core.ViewChild('defaultFilter', { read: core.TemplateRef, static: true })
        ], IgxGridFilteringCellComponent.prototype, "defaultFilter", void 0);
        __decorate([
            core.ViewChild('complexFilter', { read: core.TemplateRef, static: true })
        ], IgxGridFilteringCellComponent.prototype, "complexFilter", void 0);
        __decorate([
            core.ViewChild('chipsArea', { read: IgxChipsAreaComponent })
        ], IgxGridFilteringCellComponent.prototype, "chipsArea", void 0);
        __decorate([
            core.ViewChild('moreIcon', { read: core.ElementRef })
        ], IgxGridFilteringCellComponent.prototype, "moreIcon", void 0);
        __decorate([
            core.ViewChild('ghostChip', { read: IgxChipComponent })
        ], IgxGridFilteringCellComponent.prototype, "ghostChip", void 0);
        __decorate([
            core.ViewChild('complexChip', { read: IgxChipComponent })
        ], IgxGridFilteringCellComponent.prototype, "complexChip", void 0);
        __decorate([
            core.HostBinding('class.igx-grid__filtering-cell')
        ], IgxGridFilteringCellComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostListener('keydown.tab', ['$event'])
        ], IgxGridFilteringCellComponent.prototype, "onTabKeyDown", null);
        __decorate([
            core.HostListener('keydown.shift.tab', ['$event'])
        ], IgxGridFilteringCellComponent.prototype, "onShiftTabKeyDown", null);
        IgxGridFilteringCellComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-filtering-cell',
                template: "<ng-template #emptyFilter>\n        <igx-chips-area [attr.draggable]=\"false\" class=\"igx-filtering-chips\">\n            <igx-chip #ghostChip [attr.draggable]=\"false\" (click)=\"onChipClicked()\" (keydown)=\"onChipKeyDown($event)\" [displayDensity]=\"'cosy'\">\n                <igx-icon [attr.draggable]=\"false\" igxPrefix>filter_list</igx-icon>\n                <span [attr.draggable]=\"false\">{{filteringService.grid.resourceStrings.igx_grid_filter}}</span>\n            </igx-chip>\n        </igx-chips-area>\n</ng-template>\n\n<ng-template #defaultFilter>\n    <igx-chips-area #chipsArea class=\"igx-filtering-chips\">\n        <ng-container *ngFor=\"let item of expressionsList; let last = last; let index = index;\" >\n            <igx-chip\n                *ngIf=\"isChipVisible(index)\"\n                [removable]=\"true\"\n                [displayDensity]=\"'cosy'\"\n                (click)=\"onChipClicked(item.expression)\"\n                (keydown)=\"onChipKeyDown($event, item.expression)\"\n                (onRemove)=\"onChipRemoved($event, item)\">\n                <igx-icon igxPrefix\n                    fontSet=\"filtering-icons\"\n                    [name]=\"item.expression.condition.iconName\">\n                </igx-icon>\n                <span #label>\n                    {{filteringService.getChipLabel(item.expression)}}\n                </span>\n            </igx-chip>\n            <span class=\"igx-filtering-chips__connector\" *ngIf=\"!last && isChipVisible(index + 1)\">{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n        </ng-container>\n        <div #moreIcon [ngClass]=\"filteringIndicatorClass()\" (click)=\"onChipClicked()\" (keydown)=\"onChipKeyDown($event)\" tabindex=\"0\">\n            <igx-icon>filter_list</igx-icon>\n            <igx-badge [value]=\"moreFiltersCount\"></igx-badge>\n        </div>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #complexFilter>\n    <igx-chip #complexChip [removable]=\"true\" [displayDensity]=\"'cosy'\" (onRemove)=\"clearFiltering()\">\n        <igx-icon igxPrefix>filter_list</igx-icon>\n        <span>{{filteringService.grid.resourceStrings.igx_grid_complex_filter}}</span>\n    </igx-chip>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n"
            })
        ], IgxGridFilteringCellComponent);
        return IgxGridFilteringCellComponent;
    }());

    var Z_INDEX = 9999;
    /**
     * @hidden
     */
    var IgxGridHeaderGroupComponent = /** @class */ (function () {
        function IgxGridHeaderGroupComponent(cdr, gridAPI, element, colResizingService, filteringService) {
            this.cdr = cdr;
            this.gridAPI = gridAPI;
            this.element = element;
            this.colResizingService = colResizingService;
            this.filteringService = filteringService;
        }
        IgxGridHeaderGroupComponent_1 = IgxGridHeaderGroupComponent;
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "gridRowSpan", {
            get: function () {
                return this.column.gridRowSpan;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "gridColumnSpan", {
            get: function () {
                return this.column.gridColumnSpan;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "rowEnd", {
            get: function () {
                return this.column.rowEnd;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "colEnd", {
            get: function () {
                return this.column.colEnd;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "rowStart", {
            get: function () {
                return this.column.rowStart;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "colStart", {
            get: function () {
                return this.column.colStart;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "width", {
            /**
             * Gets the width of the header group.
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return this.grid.getHeaderGroupWidth(this.column);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "styleClasses", {
            /**
             * Gets the style classes of the header group.
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                var e_1, _a;
                var defaultClasses = [
                    'igx-grid__thead-item',
                    this.column.headerGroupClasses
                ];
                var classList = {
                    'igx-grid__th--pinned': this.isPinned,
                    'igx-grid__th--pinned-last': this.isLastPinned,
                    'igx-grid__drag-col-header': this.isHeaderDragged,
                    'igx-grid__th--filtering': this.isFiltered
                };
                try {
                    for (var _b = __values(Object.keys(classList)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var className = _c.value;
                        if (classList[className]) {
                            defaultClasses.push(className);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return defaultClasses.join(' ');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "zIndex", {
            /**
             * @hidden
             */
            get: function () {
                if (!this.column.pinned) {
                    return null;
                }
                return Z_INDEX - this.grid.pinnedColumns.indexOf(this.column);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "grid", {
            /**
             * Gets the grid of the header group.
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isFiltered", {
            /**
             * Gets whether the header group belongs to a column that is filtered.
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return this.filteringService.filteredColumn === this.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isLastPinned", {
            /**
             * Gets whether the header group is stored in the last column in the pinned area.
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return !this.grid.hasColumnLayouts ? this.column.isLastPinned : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "groupDisplayStyle", {
            get: function () {
                return this.grid.hasColumnLayouts && this.column.children && !isIE() ? 'flex' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isPinned", {
            /**
             * Gets whether the header group is stored in a pinned column.
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return this.column.pinned;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isHeaderDragged", {
            /**
             * Gets whether the header group belongs to a column that is moved.
             * @memberof IgxGridHeaderGroupComponent
             */
            get: function () {
                return this.grid.draggedColumn === this.column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "hasLastPinnedChildColumn", {
            /**
             * @hidden
             */
            get: function () {
                return this.column.allChildren.some(function (child) { return child.isLastPinned; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "height", {
            /**
             * @hidden
             */
            get: function () {
                return this.element.nativeElement.getBoundingClientRect().height;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxGridHeaderGroupComponent.prototype.onMouseDown = function (event) {
            // hack for preventing text selection in IE and Edge while dragging the resizer
            event.preventDefault();
        };
        IgxGridHeaderGroupComponent.prototype.ngDoCheck = function () {
            this.cdr.markForCheck();
        };
        var IgxGridHeaderGroupComponent_1;
        IgxGridHeaderGroupComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: GridBaseAPIService },
            { type: core.ElementRef },
            { type: IgxColumnResizingService },
            { type: IgxFilteringService }
        ]; };
        __decorate([
            core.HostBinding('style.-ms-grid-row-span')
        ], IgxGridHeaderGroupComponent.prototype, "gridRowSpan", null);
        __decorate([
            core.HostBinding('style.-ms-grid-column-span')
        ], IgxGridHeaderGroupComponent.prototype, "gridColumnSpan", null);
        __decorate([
            core.HostBinding('style.grid-row-end')
        ], IgxGridHeaderGroupComponent.prototype, "rowEnd", null);
        __decorate([
            core.HostBinding('style.grid-column-end')
        ], IgxGridHeaderGroupComponent.prototype, "colEnd", null);
        __decorate([
            core.HostBinding('style.-ms-grid-row'),
            core.HostBinding('style.grid-row-start')
        ], IgxGridHeaderGroupComponent.prototype, "rowStart", null);
        __decorate([
            core.HostBinding('style.-ms-grid-column'),
            core.HostBinding('style.grid-column-start')
        ], IgxGridHeaderGroupComponent.prototype, "colStart", null);
        __decorate([
            core.Input()
        ], IgxGridHeaderGroupComponent.prototype, "column", void 0);
        __decorate([
            core.Input()
        ], IgxGridHeaderGroupComponent.prototype, "gridID", void 0);
        __decorate([
            core.ViewChild(IgxGridHeaderComponent)
        ], IgxGridHeaderGroupComponent.prototype, "headerCell", void 0);
        __decorate([
            core.ViewChild(IgxGridFilteringCellComponent)
        ], IgxGridHeaderGroupComponent.prototype, "filterCell", void 0);
        __decorate([
            core.ViewChildren(core.forwardRef(function () { return IgxGridHeaderGroupComponent_1; }), { read: IgxGridHeaderGroupComponent_1 })
        ], IgxGridHeaderGroupComponent.prototype, "children", void 0);
        __decorate([
            core.HostBinding('class')
        ], IgxGridHeaderGroupComponent.prototype, "styleClasses", null);
        __decorate([
            core.HostBinding('style.z-index')
        ], IgxGridHeaderGroupComponent.prototype, "zIndex", null);
        __decorate([
            core.HostBinding('style.display')
        ], IgxGridHeaderGroupComponent.prototype, "groupDisplayStyle", null);
        __decorate([
            core.HostListener('mousedown', ['$event'])
        ], IgxGridHeaderGroupComponent.prototype, "onMouseDown", null);
        IgxGridHeaderGroupComponent = IgxGridHeaderGroupComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-header-group',
                template: "<ng-container *ngIf=\"grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-group igx-grid__mrl-block\"\n     [ngClass]=\"{'igx-grid__th--pinned-last': hasLastPinnedChildColumn}\"\n     [ngStyle]=\"{'grid-template-rows':column.getGridTemplate(true, false),\n     'grid-template-columns':column.getGridTemplate(false, false),\n     '-ms-grid-rows':column.getGridTemplate(true, true),\n     '-ms-grid-columns':column.getGridTemplate(false, true)}\">\n        <ng-container *ngFor=\"let child of column.children\" >\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                [column]=\"child\"\n                [gridID]=\"child.grid.id\"\n                [igxColumnMovingDrag]=\"child\"\n                [ghostHost]=\"grid.outletDirective.nativeElement\"\n                [attr.droppable]=\"true\"\n                [igxColumnMovingDrop]=\"child\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n\n<ng-template #defaultColumn>\n    <span class=\"igx-grid__th-group-title\" [attr.title]=\"column.header\">{{column.header}}</span>\n</ng-template>\n\n<ng-template #defaultCollapseIndicator>\n    <igx-icon [attr.draggable]=\"false\" >\n            {{column.expanded ? 'expand_more' : 'chevron_right'}} </igx-icon>\n</ng-template>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-title\"\n        role=\"columnheader\"\n        [attr.aria-label]=\"column.header || column.field\"\n        [attr.aria-expanded]=\"column.expanded\"\n        tabindex=\"0\"\n        [ngClass]=\"{'igx-grid__th--pinned-last': hasLastPinnedChildColumn, 'igx-grid__th--collapsible': column.collapsible}\"\n        [igxColumnMovingDrag]=\"column\"\n        [ghostHost]=\"grid.outletDirective.nativeElement\"\n        [attr.droppable]=\"true\"\n        [igxColumnMovingDrop]=\"column\">\n        <ng-container *ngIf=\"column.collapsible\">\n            <div class=\"igx-grid__th-expander\" (click)=\"column.expanded = !column.expanded\">\n                <ng-container\n                    *ngTemplateOutlet=\"column.collapsibleIndicatorTemplate ? column.collapsibleIndicatorTemplate : defaultCollapseIndicator; context: {$implicit: column, column: column}\">\n                </ng-container>\n            </div>\n        </ng-container>\n        <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n        </ng-container>\n    </div>\n    <div class=\"igx-grid__thead-group\">\n        <ng-container *ngFor=\"let child of column.children\">\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                                [column]=\"child\"\n                                [gridID]=\"child.grid.id\"\n                                [style.min-width]=\"grid.getHeaderGroupWidth(child)\"\n                                [style.flex-basis]=\"grid.getHeaderGroupWidth(child)\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-container *ngIf=\"!column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <igx-grid-header [igxColumnMovingDrag]=\"column\" [ghostHost]=\"grid.outletDirective.nativeElement\" [attr.droppable]=\"true\" [igxColumnMovingDrop]=\"column\" [gridID]=\"column.grid.id\" [column]=\"column\"></igx-grid-header>\n    <igx-grid-filtering-cell *ngIf=\"grid.allowFiltering && grid.filterMode == 'quickFilter'\" [column]=\"column\" [attr.draggable]=\"false\"></igx-grid-filtering-cell>\n    <span *ngIf=\"!column.columnGroup && column.resizable\" class=\"igx-grid__th-resize-handle\"\n          [igxResizeHandle]=\"column\"\n          [attr.draggable]=\"false\"\n          [style.cursor]=\"colResizingService.resizeCursor\">\n    </span>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n"
            })
        ], IgxGridHeaderGroupComponent);
        return IgxGridHeaderGroupComponent;
    }());

    /** @hidden */
    var IgxGridSummaryService = /** @class */ (function () {
        function IgxGridSummaryService() {
            this.summaryCacheMap = new Map();
            this.rootSummaryID = 'igxGridRootSummary';
            this.summaryHeight = 0;
            this.maxSummariesLenght = 0;
            this.groupingExpressions = [];
            this.retriggerRootPipe = 0;
            this.deleteOperation = false;
        }
        IgxGridSummaryService.prototype.recalculateSummaries = function () {
            this.resetSummaryHeight();
            this.grid.notifyChanges(true);
        };
        IgxGridSummaryService.prototype.clearSummaryCache = function (args) {
            if (!this.summaryCacheMap.size) {
                return;
            }
            if (!args) {
                this.summaryCacheMap.clear();
                if (this.grid && this.grid.rootSummariesEnabled) {
                    this.retriggerRootPipe++;
                }
                return;
            }
            if (args.data) {
                var rowID = this.grid.primaryKey ? args.data[this.grid.primaryKey] : args.data;
                this.removeSummaries(rowID);
            }
            if (args.rowID !== undefined && args.rowID !== null) {
                var columnName = args.cellID ? this.grid.columnList.find(function (col) { return col.index === args.cellID.columnID; }).field : undefined;
                if (columnName && this.grid.rowEditable) {
                    return;
                }
                var isGroupedColumn = this.grid.groupingExpressions &&
                    this.grid.groupingExpressions.map(function (expr) { return expr.fieldName; }).indexOf(columnName) !== -1;
                if (columnName && isGroupedColumn) {
                    columnName = undefined;
                }
                this.removeSummaries(args.rowID, columnName);
            }
        };
        IgxGridSummaryService.prototype.removeSummaries = function (rowID, columnName) {
            var _this = this;
            this.deleteSummaryCache(this.rootSummaryID, columnName);
            if (this.summaryCacheMap.size === 1 && this.summaryCacheMap.has(this.rootSummaryID)) {
                return;
            }
            if (this.isTreeGrid) {
                if (this.grid.transactions.enabled && this.deleteOperation) {
                    this.deleteOperation = false;
                    // TODO: this.removeChildRowSummaries(rowID, columnName);
                    this.summaryCacheMap.clear();
                    return;
                }
                this.removeAllTreeGridSummaries(rowID, columnName);
            }
            else if (this.isHierarchicalGrid) {
                if (this.grid.transactions.enabled && this.deleteOperation) {
                    this.deleteOperation = false;
                    this.summaryCacheMap.clear();
                }
            }
            else {
                var summaryIds = this.getSummaryID(rowID, this.grid.groupingExpressions);
                summaryIds.forEach(function (id) {
                    _this.deleteSummaryCache(id, columnName);
                });
            }
        };
        IgxGridSummaryService.prototype.removeSummariesCachePerColumn = function (columnName) {
            this.summaryCacheMap.forEach(function (cache) {
                if (cache.get(columnName)) {
                    cache.delete(columnName);
                }
            });
            if (this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
        };
        IgxGridSummaryService.prototype.calcMaxSummaryHeight = function () {
            if (this.summaryHeight) {
                return this.summaryHeight;
            }
            if (!this.grid.data) {
                return this.summaryHeight = 0;
            }
            var maxSummaryLength = 0;
            this.grid.columnList.filter(function (col) { return col.hasSummary && !col.hidden; }).forEach(function (column) {
                var getCurrentSummaryColumn = column.summaries.operate([], [], column.field).length;
                if (getCurrentSummaryColumn) {
                    if (maxSummaryLength < getCurrentSummaryColumn) {
                        maxSummaryLength = getCurrentSummaryColumn;
                    }
                }
            });
            this.maxSummariesLenght = maxSummaryLength;
            this.summaryHeight = maxSummaryLength * this.grid.defaultSummaryHeight;
            return this.summaryHeight;
        };
        IgxGridSummaryService.prototype.calculateSummaries = function (rowID, data) {
            var rowSummaries = this.summaryCacheMap.get(rowID);
            if (!rowSummaries) {
                rowSummaries = new Map();
                this.summaryCacheMap.set(rowID, rowSummaries);
            }
            if (!this.hasSummarizedColumns || !data) {
                return rowSummaries;
            }
            this.grid.columnList.filter(function (col) { return col.hasSummary; }).forEach(function (column) {
                if (!rowSummaries.get(column.field)) {
                    rowSummaries.set(column.field, column.summaries.operate(data.map(function (r) { return r[column.field]; }), data, column.field));
                }
            });
            return rowSummaries;
        };
        IgxGridSummaryService.prototype.resetSummaryHeight = function () {
            this.summaryHeight = 0;
            this.grid._summaryPipeTrigger++;
            if (this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
        };
        IgxGridSummaryService.prototype.updateSummaryCache = function (groupingArgs) {
            if (this.summaryCacheMap.size === 0 || !this.hasSummarizedColumns) {
                return;
            }
            if (this.groupingExpressions.length === 0) {
                this.groupingExpressions = groupingArgs.expressions.map(function (record) { return record.fieldName; });
                return;
            }
            if (groupingArgs.length === 0) {
                this.groupingExpressions = [];
                this.clearSummaryCache();
                return;
            }
            this.compareGroupingExpressions(this.groupingExpressions, groupingArgs);
            this.groupingExpressions = groupingArgs.expressions.map(function (record) { return record.fieldName; });
        };
        Object.defineProperty(IgxGridSummaryService.prototype, "hasSummarizedColumns", {
            get: function () {
                var summarizedColumns = this.grid.columnList.filter(function (col) { return col.hasSummary && !col.hidden; });
                return summarizedColumns.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridSummaryService.prototype.deleteSummaryCache = function (id, columnName) {
            if (this.summaryCacheMap.get(id)) {
                var filteringApplied = columnName && this.grid.filteringExpressionsTree &&
                    this.grid.filteringExpressionsTree.filteringOperands.map(function (expr) { return expr.fieldName; }).indexOf(columnName) !== -1;
                if (columnName && this.summaryCacheMap.get(id).get(columnName) && !filteringApplied) {
                    this.summaryCacheMap.get(id).delete(columnName);
                }
                else {
                    this.summaryCacheMap.delete(id);
                }
                if (id === this.rootSummaryID && this.grid.rootSummariesEnabled) {
                    this.retriggerRootPipe++;
                }
            }
        };
        IgxGridSummaryService.prototype.getSummaryID = function (rowID, groupingExpressions) {
            var _this = this;
            if (groupingExpressions.length === 0) {
                return [];
            }
            var summaryIDs = [];
            var data = this.grid.data;
            if (this.grid.transactions.enabled) {
                data = DataUtil.mergeTransactions(cloneArray(this.grid.data), this.grid.transactions.getAggregatedChanges(true), this.grid.primaryKey);
            }
            var rowData = this.grid.primaryKey ? data.find(function (rec) { return rec[_this.grid.primaryKey] === rowID; }) : rowID;
            var id = '{ ';
            groupingExpressions.forEach(function (expr) {
                id += "'" + expr.fieldName + "': '" + rowData[expr.fieldName] + "'";
                summaryIDs.push(id.concat(' }'));
                id += ', ';
            });
            return summaryIDs;
        };
        IgxGridSummaryService.prototype.removeAllTreeGridSummaries = function (rowID, columnName) {
            var row = this.grid.records.get(rowID);
            if (!row) {
                return;
            }
            row = row.children ? row : row.parent;
            while (row) {
                rowID = row.rowID;
                this.deleteSummaryCache(rowID, columnName);
                row = row.parent;
            }
        };
        // TODO: remove only deleted rows
        IgxGridSummaryService.prototype.removeChildRowSummaries = function (rowID, columnName) {
        };
        IgxGridSummaryService.prototype.compareGroupingExpressions = function (current, groupingArgs) {
            var _this = this;
            var newExpressions = groupingArgs.expressions.map(function (record) { return record.fieldName; });
            var removedCols = groupingArgs.ungroupedColumns;
            if (current.length <= newExpressions.length) {
                var newExpr = newExpressions.slice(0, current.length).toString();
                if (current.toString() !== newExpr) {
                    this.clearSummaryCache();
                }
            }
            else {
                var currExpr = current.slice(0, newExpressions.length).toString();
                if (currExpr !== newExpressions.toString()) {
                    this.clearSummaryCache();
                    return;
                }
                removedCols.map(function (col) { return col.field; }).forEach(function (colName) {
                    _this.summaryCacheMap.forEach(function (cache, id) {
                        if (id.indexOf(colName) !== -1) {
                            _this.summaryCacheMap.delete(id);
                        }
                    });
                });
            }
        };
        Object.defineProperty(IgxGridSummaryService.prototype, "isTreeGrid", {
            get: function () {
                return this.grid.nativeElement.tagName.toLowerCase() === 'igx-tree-grid';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridSummaryService.prototype, "isHierarchicalGrid", {
            get: function () {
                return this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
            },
            enumerable: true,
            configurable: true
        });
        IgxGridSummaryService = __decorate([
            core.Injectable()
        ], IgxGridSummaryService);
        return IgxGridSummaryService;
    }());

    var IgxSummaryCellComponent = /** @class */ (function () {
        function IgxSummaryCellComponent(element) {
            this.element = element;
            this.firstCellIndentation = 0;
            this.hasSummary = false;
            this.tabindex = 0;
        }
        Object.defineProperty(IgxSummaryCellComponent.prototype, "visibleColumnIndex", {
            get: function () {
                return this.column.visibleIndex;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "describeby", {
            get: function () {
                return "Summary_" + this.column.field;
            },
            enumerable: true,
            configurable: true
        });
        IgxSummaryCellComponent.prototype.onFocus = function () {
            this.focused = true;
        };
        IgxSummaryCellComponent.prototype.onBlur = function () {
            this.focused = false;
        };
        Object.defineProperty(IgxSummaryCellComponent.prototype, "selectionNode", {
            get: function () {
                return {
                    row: this.rowIndex,
                    column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
                    isSummaryRow: true
                };
            },
            enumerable: true,
            configurable: true
        });
        IgxSummaryCellComponent.prototype.dispatchEvent = function (event) {
            // TODO: Refactor
            var key = event.key.toLowerCase();
            var ctrl = event.ctrlKey;
            var shift = event.shiftKey;
            if (!SUPPORTED_KEYS.has(key)) {
                return;
            }
            event.stopPropagation();
            var args = { targetType: 'summaryCell', target: this, event: event, cancel: false };
            this.grid.onGridKeydown.emit(args);
            if (args.cancel) {
                return;
            }
            event.preventDefault();
            if (!this.isKeySupportedInCell(key, ctrl)) {
                return;
            }
            this.grid.selectionService.keyboardState.shift = shift && !(key === 'tab');
            var row = this.getRowElementByIndex(this.rowIndex);
            switch (key) {
                case 'tab':
                    if (shift) {
                        this.grid.navigation.performShiftTabKey(row, this.selectionNode);
                        break;
                    }
                    this.grid.navigation.performTab(row, this.selectionNode);
                    break;
                case 'arrowleft':
                case 'home':
                case 'left':
                    if (ctrl || key === 'home') {
                        this.grid.navigation.onKeydownHome(this.rowIndex, true);
                        break;
                    }
                    this.grid.navigation.onKeydownArrowLeft(this.nativeElement, this.selectionNode);
                    break;
                case 'end':
                case 'arrowright':
                case 'right':
                    if (ctrl || key === 'end') {
                        this.grid.navigation.onKeydownEnd(this.rowIndex, true);
                        break;
                    }
                    this.grid.navigation.onKeydownArrowRight(this.nativeElement, this.selectionNode);
                    break;
                case 'arrowup':
                case 'up':
                    this.grid.navigation.navigateUp(row, this.selectionNode);
                    break;
                case 'arrowdown':
                case 'down':
                    this.grid.navigation.navigateDown(row, this.selectionNode);
                    break;
            }
        };
        Object.defineProperty(IgxSummaryCellComponent.prototype, "width", {
            get: function () {
                return this.column.getCellWidth();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "nativeElement", {
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "columnDatatype", {
            get: function () {
                return this.column.dataType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "itemHeight", {
            get: function () {
                return this.column.grid.defaultSummaryHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSummaryCellComponent.prototype, "grid", {
            /**
            * @hidden
            */
            get: function () {
                return this.column.grid;
            },
            enumerable: true,
            configurable: true
        });
        IgxSummaryCellComponent.prototype.getRowElementByIndex = function (rowIndex) {
            var summaryRows = this.grid.summariesRowList.toArray();
            return summaryRows.find(function (sr) { return sr.dataRowIndex === rowIndex; }).nativeElement;
        };
        IgxSummaryCellComponent.prototype.isKeySupportedInCell = function (key, ctrl) {
            if (ctrl) {
                return ['arrowup', 'arrowdown', 'up', 'down', 'end', 'home'].indexOf(key) === -1;
            }
            return ['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright', 'home', 'end', 'tab'].indexOf(key) !== -1;
        };
        IgxSummaryCellComponent.prototype.translateSummary = function (summary) {
            return this.grid.resourceStrings["igx_grid_summary_" + summary.key] || summary.label;
        };
        IgxSummaryCellComponent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxSummaryCellComponent.prototype, "summaryResults", void 0);
        __decorate([
            core.Input()
        ], IgxSummaryCellComponent.prototype, "column", void 0);
        __decorate([
            core.Input()
        ], IgxSummaryCellComponent.prototype, "firstCellIndentation", void 0);
        __decorate([
            core.Input()
        ], IgxSummaryCellComponent.prototype, "hasSummary", void 0);
        __decorate([
            core.Input()
        ], IgxSummaryCellComponent.prototype, "density", void 0);
        __decorate([
            core.Input(),
            core.HostBinding('attr.data-rowIndex')
        ], IgxSummaryCellComponent.prototype, "rowIndex", void 0);
        __decorate([
            core.HostBinding('attr.data-visibleIndex')
        ], IgxSummaryCellComponent.prototype, "visibleColumnIndex", null);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxSummaryCellComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('attr.aria-describedby')
        ], IgxSummaryCellComponent.prototype, "describeby", null);
        __decorate([
            core.HostBinding('class.igx-grid-summary--active')
        ], IgxSummaryCellComponent.prototype, "focused", void 0);
        __decorate([
            core.HostListener('focus')
        ], IgxSummaryCellComponent.prototype, "onFocus", null);
        __decorate([
            core.HostListener('blur')
        ], IgxSummaryCellComponent.prototype, "onBlur", null);
        __decorate([
            core.HostListener('keydown', ['$event'])
        ], IgxSummaryCellComponent.prototype, "dispatchEvent", null);
        IgxSummaryCellComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-summary-cell',
                template: "<ng-container *ngIf=\"hasSummary\">\n    <ng-container *ngFor=\"let summary of summaryResults\">\n            <div class=\"igx-grid-summary__item\" [style.height.px]=\"itemHeight\">\n\n                <ng-container *ngIf=\"visibleColumnIndex === 0 && firstCellIndentation >= 0\">\n                    <div class=\"igx-grid__tree-cell--padding-level-{{firstCellIndentation}}\"></div>\n\n                    <div #indicator class=\"igx-grid__tree-grouping-indicator\" style=\"visibility: hidden\">\n                        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n                    </div>\n                </ng-container>\n\n                <span class=\"igx-grid-summary__label\" title=\"{{ summary.label }}\">{{ translateSummary(summary) }}</span>\n                <span class=\"igx-grid-summary__result\" title=\"{{ summary.summaryResult }}\">\n                    {{ columnDatatype === 'number' ? (summary.summaryResult | igxdecimal: grid.locale) : columnDatatype === 'date' ? (summary.summaryResult | igxdate: grid.locale) : (summary.summaryResult) }}\n                </span>\n            </div>\n    </ng-container>\n</ng-container>\n"
            })
        ], IgxSummaryCellComponent);
        return IgxSummaryCellComponent;
    }());

    var IgxSummaryRowComponent = /** @class */ (function () {
        function IgxSummaryRowComponent(gridAPI, element, cdr) {
            this.gridAPI = gridAPI;
            this.element = element;
            this.cdr = cdr;
            this.firstCellIndentation = -1;
        }
        Object.defineProperty(IgxSummaryRowComponent.prototype, "dataRowIndex", {
            get: function () {
                return this.index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSummaryRowComponent.prototype, "minHeight", {
            get: function () {
                return this.grid.summaryService.calcMaxSummaryHeight() - 1;
            },
            enumerable: true,
            configurable: true
        });
        IgxSummaryRowComponent.prototype.ngDoCheck = function () {
            this.cdr.markForCheck();
        };
        Object.defineProperty(IgxSummaryRowComponent.prototype, "grid", {
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSummaryRowComponent.prototype, "nativeElement", {
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        IgxSummaryRowComponent.prototype.getColumnSummaries = function (columnName) {
            if (!this.summaries.get(columnName)) {
                return [];
            }
            return this.summaries.get(columnName);
        };
        Object.defineProperty(IgxSummaryRowComponent.prototype, "pinnedColumns", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.pinnedColumns;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSummaryRowComponent.prototype, "unpinnedColumns", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.unpinnedColumns;
            },
            enumerable: true,
            configurable: true
        });
        IgxSummaryRowComponent.ctorParameters = function () { return [
            { type: GridBaseAPIService },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxSummaryRowComponent.prototype, "summaries", void 0);
        __decorate([
            core.Input()
        ], IgxSummaryRowComponent.prototype, "gridID", void 0);
        __decorate([
            core.Input()
        ], IgxSummaryRowComponent.prototype, "index", void 0);
        __decorate([
            core.Input()
        ], IgxSummaryRowComponent.prototype, "firstCellIndentation", void 0);
        __decorate([
            core.HostBinding('attr.data-rowIndex')
        ], IgxSummaryRowComponent.prototype, "dataRowIndex", null);
        __decorate([
            core.ViewChildren(IgxSummaryCellComponent, { read: IgxSummaryCellComponent })
        ], IgxSummaryRowComponent.prototype, "summaryCells", void 0);
        __decorate([
            core.ViewChild('igxDirRef', { read: IgxGridForOfDirective })
        ], IgxSummaryRowComponent.prototype, "virtDirRow", void 0);
        IgxSummaryRowComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-summary-row',
                template: "<ng-container *ngIf=\"summaries.size\">\n    <ng-container *ngIf=\"grid.summariesMargin\">\n        <div\n        class=\"igx-grid__summaries-patch\"\n        [style.min-width.px]=\"grid.summariesMargin\"\n        [style.flex-basis.px]=\"grid.summariesMargin\"\n        ></div>\n    </ng-container>\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <igx-grid-summary-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [rowIndex]=\"index\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\"\n            [style.min-width]=\"col.getCellWidth()\"\n            [style.max-width]=\"col.getCellWidth()\"\n            [style.flex-basis]=\"col.getCellWidth()\">\n        </igx-grid-summary-cell>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\" [igxForSizePropName]='\"calcPixelWidth\"' #igxDirRef>\n        <igx-grid-summary-cell\n            class=\"igx-grid-summary igx-grid-summary--fw\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [column]=\"col\"\n            [rowIndex]=\"index\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\"\n            [style.min-width]=\"col.getCellWidth()\"\n            [style.max-width]=\"col.getCellWidth()\"\n            [style.flex-basis]=\"col.getCellWidth()\">\n        </igx-grid-summary-cell>\n    </ng-template>\n</ng-container>\n",
                providers: [IgxForOfSyncService]
            })
        ], IgxSummaryRowComponent);
        return IgxSummaryRowComponent;
    }());

    var DragScrollDirection;
    (function (DragScrollDirection) {
        DragScrollDirection[DragScrollDirection["NONE"] = 0] = "NONE";
        DragScrollDirection[DragScrollDirection["LEFT"] = 1] = "LEFT";
        DragScrollDirection[DragScrollDirection["TOP"] = 2] = "TOP";
        DragScrollDirection[DragScrollDirection["RIGHT"] = 3] = "RIGHT";
        DragScrollDirection[DragScrollDirection["BOTTOM"] = 4] = "BOTTOM";
        DragScrollDirection[DragScrollDirection["TOPLEFT"] = 5] = "TOPLEFT";
        DragScrollDirection[DragScrollDirection["TOPRIGHT"] = 6] = "TOPRIGHT";
        DragScrollDirection[DragScrollDirection["BOTTOMLEFT"] = 7] = "BOTTOMLEFT";
        DragScrollDirection[DragScrollDirection["BOTTOMRIGHT"] = 8] = "BOTTOMRIGHT";
    })(DragScrollDirection || (DragScrollDirection = {}));
    var IgxGridDragSelectDirective = /** @class */ (function () {
        function IgxGridDragSelectDirective(ref, zone) {
            var _this = this;
            this.ref = ref;
            this.zone = zone;
            this.onDragStop = new core.EventEmitter();
            this.onDragScroll = new core.EventEmitter();
            this.end$ = new rxjs.Subject();
            this.lastDirection = DragScrollDirection.NONE;
            this.startDragSelection = function (ev) {
                if (!_this.activeDrag) {
                    return;
                }
                var x = ev.clientX;
                var y = ev.clientY;
                var direction = _this._measureDimensions(x, y);
                if (direction === _this.lastDirection) {
                    return;
                }
                _this.unsubscribe();
                _this._sub = _this._interval$.subscribe(function () { return _this.onDragScroll.emit(direction); });
                _this.lastDirection = direction;
            };
            this.stopDragSelection = function () {
                if (!_this.activeDrag) {
                    return;
                }
                _this.onDragStop.emit(false);
                _this.unsubscribe();
                _this.lastDirection = DragScrollDirection.NONE;
            };
            this._interval$ = rxjs.interval(100).pipe(operators.takeUntil(this.end$), operators.filter(function () { return _this.activeDrag; }));
        }
        Object.defineProperty(IgxGridDragSelectDirective.prototype, "activeDrag", {
            get: function () {
                return this._activeDrag;
            },
            set: function (val) {
                if (val !== this._activeDrag) {
                    this.unsubscribe();
                    this._activeDrag = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridDragSelectDirective.prototype, "nativeElement", {
            get: function () {
                return this.ref.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridDragSelectDirective.prototype, "clientRect", {
            get: function () {
                return this.nativeElement.getBoundingClientRect();
            },
            enumerable: true,
            configurable: true
        });
        IgxGridDragSelectDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.nativeElement.addEventListener('pointerover', _this.startDragSelection);
                _this.nativeElement.addEventListener('pointerleave', _this.stopDragSelection);
            });
        };
        IgxGridDragSelectDirective.prototype.ngOnDestroy = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.nativeElement.removeEventListener('pointerover', _this.startDragSelection);
                _this.nativeElement.removeEventListener('pointerleave', _this.stopDragSelection);
            });
            this.unsubscribe();
            this.end$.complete();
        };
        IgxGridDragSelectDirective.prototype._measureDimensions = function (x, y) {
            var direction;
            var rect = this.clientRect;
            var RATIO = 0.15;
            var offsetX = Math.trunc(x - rect.left);
            var offsetY = Math.trunc(y - rect.top);
            var left = offsetX <= rect.width * RATIO;
            var right = offsetX >= rect.width * (1 - RATIO);
            var top = offsetY <= rect.height * RATIO;
            var bottom = offsetY >= rect.height * (1 - RATIO);
            if (top && left) {
                direction = DragScrollDirection.TOPLEFT;
            }
            else if (top && right) {
                direction = DragScrollDirection.TOPRIGHT;
            }
            else if (bottom && left) {
                direction = DragScrollDirection.BOTTOMLEFT;
            }
            else if (bottom && right) {
                direction = DragScrollDirection.BOTTOMRIGHT;
            }
            else if (top) {
                direction = DragScrollDirection.TOP;
            }
            else if (bottom) {
                direction = DragScrollDirection.BOTTOM;
            }
            else if (left) {
                direction = DragScrollDirection.LEFT;
            }
            else if (right) {
                direction = DragScrollDirection.RIGHT;
            }
            else {
                direction = DragScrollDirection.NONE;
            }
            return direction;
        };
        IgxGridDragSelectDirective.prototype.unsubscribe = function () {
            if (this._sub) {
                this._sub.unsubscribe();
            }
        };
        IgxGridDragSelectDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.Input('igxGridDragSelect')
        ], IgxGridDragSelectDirective.prototype, "activeDrag", null);
        __decorate([
            core.Output()
        ], IgxGridDragSelectDirective.prototype, "onDragStop", void 0);
        __decorate([
            core.Output()
        ], IgxGridDragSelectDirective.prototype, "onDragScroll", void 0);
        IgxGridDragSelectDirective = __decorate([
            core.Directive({
                selector: '[igxGridDragSelect]'
            })
        ], IgxGridDragSelectDirective);
        return IgxGridDragSelectDirective;
    }());

    /**
     * @hidden
     * @internal
     */
    var IgxColumnResizerDirective = /** @class */ (function () {
        function IgxColumnResizerDirective(element, document, zone) {
            var _this = this;
            this.element = element;
            this.document = document;
            this.zone = zone;
            this.restrictHResizeMin = Number.MIN_SAFE_INTEGER;
            this.restrictHResizeMax = Number.MAX_SAFE_INTEGER;
            this.resizeEnd = new rxjs.Subject();
            this.resizeStart = new rxjs.Subject();
            this.resize = new rxjs.Subject();
            this._destroy = new rxjs.Subject();
            this.resizeStart.pipe(operators.map(function (event) { return event.clientX; }), operators.takeUntil(this._destroy), operators.switchMap(function (offset) { return _this.resize.pipe(operators.map(function (event) { return event.clientX - offset; }), operators.takeUntil(_this.resizeEnd), operators.takeUntil(_this._destroy)); })).subscribe(function (pos) {
                var left = _this._left + pos;
                var min = _this._left - _this.restrictHResizeMin;
                var max = _this._left + _this.restrictHResizeMax;
                _this.left = left < min ? min : left;
                if (left > max) {
                    _this.left = max;
                }
            });
        }
        IgxColumnResizerDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                rxjs.fromEvent(_this.document.defaultView, 'mousemove').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(_this._destroy)).subscribe(function (res) { return _this.onMousemove(res); });
                rxjs.fromEvent(_this.document.defaultView, 'mouseup').pipe(operators.takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onMouseup(res); });
            });
        };
        IgxColumnResizerDirective.prototype.ngOnDestroy = function () {
            this._destroy.next(true);
            this._destroy.complete();
        };
        Object.defineProperty(IgxColumnResizerDirective.prototype, "left", {
            set: function (val) {
                var _this = this;
                requestAnimationFrame(function () { return _this.element.nativeElement.style.left = val + 'px'; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnResizerDirective.prototype, "top", {
            set: function (val) {
                var _this = this;
                requestAnimationFrame(function () { return _this.element.nativeElement.style.top = val + 'px'; });
            },
            enumerable: true,
            configurable: true
        });
        IgxColumnResizerDirective.prototype.onMouseup = function (event) {
            this.resizeEnd.next(event);
            this.resizeEnd.complete();
        };
        IgxColumnResizerDirective.prototype.onMousedown = function (event) {
            event.preventDefault();
            var parent = this.element.nativeElement.parentElement.parentElement;
            this.left = this._left = event.clientX - parent.getBoundingClientRect().left;
            this.top = event.target.getBoundingClientRect().top - parent.getBoundingClientRect().top;
            this.resizeStart.next(event);
        };
        IgxColumnResizerDirective.prototype.onMousemove = function (event) {
            event.preventDefault();
            this.resize.next(event);
        };
        IgxColumnResizerDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.Input()
        ], IgxColumnResizerDirective.prototype, "restrictHResizeMin", void 0);
        __decorate([
            core.Input()
        ], IgxColumnResizerDirective.prototype, "restrictHResizeMax", void 0);
        __decorate([
            core.Output()
        ], IgxColumnResizerDirective.prototype, "resizeEnd", void 0);
        __decorate([
            core.Output()
        ], IgxColumnResizerDirective.prototype, "resizeStart", void 0);
        __decorate([
            core.Output()
        ], IgxColumnResizerDirective.prototype, "resize", void 0);
        IgxColumnResizerDirective = __decorate([
            core.Directive({
                selector: '[igxResizer]'
            }),
            __param(1, core.Inject(common.DOCUMENT))
        ], IgxColumnResizerDirective);
        return IgxColumnResizerDirective;
    }());

    var IgxGridColumnResizerComponent = /** @class */ (function () {
        function IgxGridColumnResizerComponent(colResizingService) {
            this.colResizingService = colResizingService;
        }
        IgxGridColumnResizerComponent.ctorParameters = function () { return [
            { type: IgxColumnResizingService }
        ]; };
        __decorate([
            core.ViewChild(IgxColumnResizerDirective, { static: true })
        ], IgxGridColumnResizerComponent.prototype, "resizer", void 0);
        IgxGridColumnResizerComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-column-resizer',
                template: "<div class=\"igx-grid__th-resize-line\"\n    [style.left.px]=\"-99999\" igxResizer\n    [style.height.px]=\"colResizingService.resizerHeight\"\n    [restrictHResizeMax]=\"colResizingService.restrictResizeMax\"\n    [restrictHResizeMin]=\"colResizingService.restrictResizeMin\"\n    (resizeEnd)=\"colResizingService.resizeColumn($event)\">\n</div>\n"
            })
        ], IgxGridColumnResizerComponent);
        return IgxGridColumnResizerComponent;
    }());

    /**
     * @hidden
     */
    var IgxGridFilteringRowComponent = /** @class */ (function () {
        function IgxGridFilteringRowComponent(filteringService, element, cdr) {
            this.filteringService = filteringService;
            this.element = element;
            this.cdr = cdr;
            this._positionSettings = {
                horizontalStartPoint: exports.HorizontalAlignment.Left,
                verticalStartPoint: exports.VerticalAlignment.Bottom
            };
            this._conditionsOverlaySettings = {
                excludePositionTarget: true,
                closeOnOutsideClick: true,
                modal: false,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
            };
            this._operatorsOverlaySettings = {
                excludePositionTarget: true,
                closeOnOutsideClick: true,
                modal: false,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
            };
            this.chipAreaScrollOffset = 0;
            this._column = null;
            this.isKeyPressed = false;
            this.isComposing = false;
            this._cancelChipClick = false;
            this.cssClass = 'igx-grid__filtering-row';
        }
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "column", {
            get: function () {
                return this._column;
            },
            set: function (val) {
                if (this._column) {
                    this.expressionsList.forEach(function (exp) { return exp.isSelected = false; });
                }
                if (val) {
                    this._column = val;
                    this.expressionsList = this.filteringService.getExpressions(this._column.field);
                    this.resetExpression();
                    this.chipAreaScrollOffset = 0;
                    this.transform(this.chipAreaScrollOffset);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "value", {
            get: function () {
                return this.expression ? this.expression.searchVal : null;
            },
            set: function (val) {
                var _this = this;
                if (!val && val !== 0) {
                    this.expression.searchVal = null;
                    this.showHideArrowButtons();
                }
                else {
                    this.expression.searchVal = DataUtil.parseValue(this.column.dataType, val);
                    if (this.expressionsList.find(function (item) { return item.expression === _this.expression; }) === undefined) {
                        this.addExpression(true);
                    }
                }
                this.filter();
            },
            enumerable: true,
            configurable: true
        });
        IgxGridFilteringRowComponent.prototype.ngAfterViewInit = function () {
            this._conditionsOverlaySettings.outlet = this.column.grid.outletDirective;
            this._operatorsOverlaySettings.outlet = this.column.grid.outletDirective;
            var selectedItem = this.expressionsList.find(function (expr) { return expr.isSelected === true; });
            if (selectedItem) {
                this.expression = selectedItem.expression;
            }
            this.input.nativeElement.focus();
        };
        IgxGridFilteringRowComponent.prototype.onTabKeydown = function (event) {
            event.stopPropagation();
            if (document.activeElement === this.closeButton.nativeElement && !event.shiftKey) {
                this.filteringService.grid.navigation.navigateFirstCellIfPossible(event);
            }
        };
        IgxGridFilteringRowComponent.prototype.onEscKeydown = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.close();
        };
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "disabled", {
            get: function () {
                return !(this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "template", {
            get: function () {
                if (this.column.dataType === exports.DataType.Date) {
                    return this.defaultDateUI;
                }
                return this.defaultFilterUI;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "type", {
            get: function () {
                switch (this.column.dataType) {
                    case exports.DataType.String:
                    case exports.DataType.Boolean:
                        return 'text';
                    case exports.DataType.Number:
                        return 'number';
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "conditions", {
            get: function () {
                return this.column.filters.conditionList();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "isUnaryCondition", {
            get: function () {
                if (this.expression.condition) {
                    return this.expression.condition.isUnary;
                }
                else {
                    return true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "placeholder", {
            get: function () {
                if (this.expression.condition && this.expression.condition.isUnary) {
                    return this.filteringService.getChipLabel(this.expression);
                }
                else if (this.column.dataType === exports.DataType.Date) {
                    return this.filteringService.grid.resourceStrings.igx_grid_filter_row_date_placeholder;
                }
                else if (this.column.dataType === exports.DataType.Boolean) {
                    return this.filteringService.grid.resourceStrings.igx_grid_filter_row_boolean_placeholder;
                }
                else {
                    return this.filteringService.grid.resourceStrings.igx_grid_filter_row_placeholder;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Event handler for keydown on the input group's prefix.
         */
        IgxGridFilteringRowComponent.prototype.onPrefixKeyDown = function (event) {
            if ((event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) && this.dropDownConditions.collapsed) {
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                event.stopImmediatePropagation();
            }
            else if (event.key === "Tab" /* TAB */) {
                if (event.shiftKey) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                else if (!this.dropDownConditions.collapsed) {
                    this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                }
            }
        };
        /**
         * Event handler for keydown on the input.
         */
        IgxGridFilteringRowComponent.prototype.onInputKeyDown = function (event) {
            this.isKeyPressed = true;
            if (this.column.dataType === exports.DataType.Boolean) {
                if (event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) {
                    this.inputGroupPrefix.nativeElement.focus();
                    this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                    event.stopPropagation();
                    return;
                }
            }
            if (event.key === "Enter" /* ENTER */) {
                if (this.isComposing) {
                    return;
                }
                this.commitInput();
            }
            else if (event.altKey && (event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */)) {
                this.inputGroupPrefix.nativeElement.focus();
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            }
            else if (event.key === "Escape" /* ESCAPE */ || event.key === "Esc" /* ESCAPE_IE */) {
                event.preventDefault();
                this.close();
            }
            event.stopPropagation();
        };
        /**
         * Event handler for keyup on the input.
         */
        IgxGridFilteringRowComponent.prototype.onInputKeyUp = function (eventArgs) {
            this.isKeyPressed = false;
        };
        /**
         * Event handler for input on the input.
         */
        IgxGridFilteringRowComponent.prototype.onInput = function (eventArgs) {
            // The 'iskeyPressed' flag is needed for a case in IE, because the input event is fired on focus and for some reason,
            // when you have a japanese character as a placeholder, on init the value here is empty string .
            if (isEdge() || this.isKeyPressed || eventArgs.target.value) {
                this.value = eventArgs.target.value;
            }
        };
        /**
         * Event handler for compositionstart on the input.
         */
        IgxGridFilteringRowComponent.prototype.onCompositionStart = function () {
            this.isComposing = true;
        };
        /**
         * Event handler for compositionend on the input.
         */
        IgxGridFilteringRowComponent.prototype.onCompositionEnd = function () {
            this.isComposing = false;
        };
        /**
         * Event handler for input click event.
         */
        IgxGridFilteringRowComponent.prototype.onInputClick = function () {
            if (this.column.dataType === exports.DataType.Boolean && this.dropDownConditions.collapsed) {
                this.inputGroupPrefix.nativeElement.focus();
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            }
        };
        /**
         * Event handler for datepicker's close.
         */
        IgxGridFilteringRowComponent.prototype.datePickerClose = function () {
            this.input.nativeElement.focus();
        };
        /**
         * Returns the filtering operation condition for a given value.
         */
        IgxGridFilteringRowComponent.prototype.getCondition = function (value) {
            return this.column.filters.condition(value);
        };
        /**
         * Returns the translated condition name for a given value.
         */
        IgxGridFilteringRowComponent.prototype.translateCondition = function (value) {
            return this.filteringService.grid.resourceStrings["igx_grid_filter_" + this.getCondition(value).name] || value;
        };
        /**
         * Returns the icon name of the current condition.
         */
        IgxGridFilteringRowComponent.prototype.getIconName = function () {
            if (this.column.dataType === exports.DataType.Boolean && this.expression.condition === null) {
                return this.getCondition(this.conditions[0]).iconName;
            }
            else {
                return this.expression.condition.iconName;
            }
        };
        /**
         * Returns whether a given condition is selected in dropdown.
         */
        IgxGridFilteringRowComponent.prototype.isConditionSelected = function (conditionName) {
            if (this.expression.condition) {
                return this.expression.condition.name === conditionName;
            }
            else {
                return false;
            }
        };
        /**
         * Clears the current filtering.
         */
        IgxGridFilteringRowComponent.prototype.clearFiltering = function () {
            this.filteringService.clearFilter(this.column.field);
            this.resetExpression();
            if (this.input) {
                this.input.nativeElement.focus();
            }
            this.cdr.detectChanges();
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        };
        /**
         * Commits the value of the input.
         */
        IgxGridFilteringRowComponent.prototype.commitInput = function () {
            var selectedItem = this.expressionsList.filter(function (ex) { return ex.isSelected === true; });
            selectedItem.forEach(function (e) { return e.isSelected = false; });
            var indexToDeselect = -1;
            for (var index = 0; index < this.expressionsList.length; index++) {
                var expression = this.expressionsList[index].expression;
                if (expression.searchVal === null && !expression.condition.isUnary) {
                    indexToDeselect = index;
                }
            }
            if (indexToDeselect !== -1) {
                this.removeExpression(indexToDeselect, this.expression);
            }
            this.resetExpression();
            this.scrollChipsWhenAddingExpression();
        };
        /**
         * Clears the value of the input.
         */
        IgxGridFilteringRowComponent.prototype.clearInput = function () {
            this.value = null;
        };
        /**
         * Event handler for keydown on clear button.
         */
        IgxGridFilteringRowComponent.prototype.onClearKeyDown = function (eventArgs) {
            if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
                eventArgs.preventDefault();
                this.clearInput();
                this.input.nativeElement.focus();
            }
        };
        /**
         * Event handler for click on clear button.
         */
        IgxGridFilteringRowComponent.prototype.onClearClick = function () {
            this.clearInput();
            this.input.nativeElement.focus();
        };
        /**
         * Event handler for keydown on commit button.
         */
        IgxGridFilteringRowComponent.prototype.onCommitKeyDown = function (eventArgs) {
            if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
                eventArgs.preventDefault();
                this.commitInput();
                this.input.nativeElement.focus();
            }
        };
        /**
         * Event handler for click on commit button.
         */
        IgxGridFilteringRowComponent.prototype.onCommitClick = function () {
            this.commitInput();
            this.input.nativeElement.focus();
        };
        /**
         * Event handler for focusout on the input group.
         */
        IgxGridFilteringRowComponent.prototype.onInputGroupFocusout = function () {
            var _this = this;
            if (!this.value && this.value !== 0 &&
                this.expression.condition && !this.expression.condition.isUnary) {
                return;
            }
            requestAnimationFrame(function () {
                var focusedElement = document.activeElement;
                if (focusedElement.className === 'igx-chip__remove') {
                    return;
                }
                if (!(focusedElement && _this.inputGroup.nativeElement.contains(focusedElement))
                    && _this.dropDownConditions.collapsed) {
                    _this.commitInput();
                }
            });
        };
        /**
         * Closes the filtering edit row.
         */
        IgxGridFilteringRowComponent.prototype.close = function () {
            var _this = this;
            if (this.expressionsList.length === 1 &&
                this.expressionsList[0].expression.searchVal === null &&
                this.expressionsList[0].expression.condition.isUnary === false) {
                this.filteringService.getExpressions(this.column.field).pop();
            }
            else {
                this.expressionsList.forEach(function (item) {
                    if (item.expression.searchVal === null && !item.expression.condition.isUnary) {
                        _this.filteringService.removeExpression(_this.column.field, _this.expressionsList.indexOf(item));
                    }
                });
            }
            this.filteringService.isFilterRowVisible = false;
            this.filteringService.updateFilteringCell(this.column);
            this.filteringService.focusFilterCellChip(this.column, true);
            this.filteringService.filteredColumn = null;
            this.filteringService.selectedExpression = null;
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        };
        /*
        * noop
        */
        IgxGridFilteringRowComponent.prototype.noop = function () { };
        /**
         *  Event handler for date picker's selection.
         */
        IgxGridFilteringRowComponent.prototype.onDateSelected = function (value) {
            this.value = value;
            this.commitInput();
        };
        /**
         * Opens the conditions dropdown.
         */
        IgxGridFilteringRowComponent.prototype.toggleConditionsDropDown = function (target) {
            this._conditionsOverlaySettings.positionStrategy.settings.target = target;
            this.dropDownConditions.toggle(this._conditionsOverlaySettings);
        };
        /**
         * Opens the logic operators dropdown.
         */
        IgxGridFilteringRowComponent.prototype.toggleOperatorsDropDown = function (eventArgs, index) {
            this._operatorsOverlaySettings.positionStrategy.settings.target = eventArgs.target.parentElement;
            this.dropDownOperators.toArray()[index].toggle(this._operatorsOverlaySettings);
        };
        /**
         * Event handler for change event in conditions dropdown.
         */
        IgxGridFilteringRowComponent.prototype.onConditionsChanged = function (eventArgs) {
            var _this = this;
            var value = eventArgs.newSelection.value;
            this.expression.condition = this.getCondition(value);
            if (this.expression.condition.isUnary) {
                // update grid's filtering on the next cycle to ensure the drop-down is closed
                // if the drop-down is not closed this event handler will be invoked multiple times
                requestAnimationFrame(function () { return _this.unaryConditionChangedCallback(); });
            }
            else {
                requestAnimationFrame(function () { return _this.conditionChangedCallback(); });
            }
            if (this.input) {
                // Add requestAnimationFrame becasue of an issue in IE, where you are still able to write in the input,
                // if it has been focused and then set to readonly.
                requestAnimationFrame(function () { return _this.input.nativeElement.focus(); });
            }
        };
        IgxGridFilteringRowComponent.prototype.onChipPointerdown = function (args, chip) {
            var activeElement = document.activeElement;
            this._cancelChipClick = chip.selected && activeElement &&
                this.inputGroup.nativeElement.contains(activeElement);
        };
        IgxGridFilteringRowComponent.prototype.onChipClick = function (args, item) {
            if (this._cancelChipClick) {
                return;
            }
            this._cancelChipClick = false;
            this.expressionsList.forEach(function (ex) { return ex.isSelected = false; });
            this.toggleChip(item);
        };
        IgxGridFilteringRowComponent.prototype.toggleChip = function (item) {
            item.isSelected = !item.isSelected;
            if (item.isSelected) {
                this.expression = item.expression;
                if (this.input) {
                    this.input.nativeElement.focus();
                }
            }
        };
        /**
         * Event handler for chip keydown event.
         */
        IgxGridFilteringRowComponent.prototype.onChipKeyDown = function (eventArgs, item) {
            if (eventArgs.key === "Enter" /* ENTER */) {
                eventArgs.preventDefault();
                this.toggleChip(item);
            }
        };
        /**
         * Scrolls the first chip into view if the tab key is pressed on the left arrow.
         */
        IgxGridFilteringRowComponent.prototype.onLeftArrowKeyDown = function (event) {
            if (event.key === "Tab" /* TAB */) {
                this.chipAreaScrollOffset = 0;
                this.transform(this.chipAreaScrollOffset);
            }
        };
        /**
         * Event handler for chip removed event.
         */
        IgxGridFilteringRowComponent.prototype.onChipRemoved = function (eventArgs, item) {
            var indexToRemove = this.expressionsList.indexOf(item);
            this.removeExpression(indexToRemove, item.expression);
            this.scrollChipsOnRemove();
        };
        /**
         * Event handler for logic operator changed event.
         */
        IgxGridFilteringRowComponent.prototype.onLogicOperatorChanged = function (eventArgs, expression) {
            var _this = this;
            if (eventArgs.oldSelection) {
                expression.afterOperator = eventArgs.newSelection.value;
                this.expressionsList[this.expressionsList.indexOf(expression) + 1].beforeOperator = expression.afterOperator;
                // update grid's filtering on the next cycle to ensure the drop-down is closed
                // if the drop-down is not closed this event handler will be invoked multiple times
                requestAnimationFrame(function () { return _this.filter(); });
            }
        };
        /**
         * Scrolls the chips into the chip area when left or right arrows are pressed.
         */
        IgxGridFilteringRowComponent.prototype.scrollChipsOnArrowPress = function (arrowPosition) {
            var count = 0;
            var chipAraeChildren = this.chipsArea.element.nativeElement.children;
            var containerRect = this.container.nativeElement.getBoundingClientRect();
            if (arrowPosition === 'right') {
                for (var index = 0; index < chipAraeChildren.length; index++) {
                    if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.right)) {
                        count++;
                    }
                }
                if (count < chipAraeChildren.length) {
                    this.chipAreaScrollOffset -= Math.ceil(chipAraeChildren[count].getBoundingClientRect().right) -
                        Math.ceil(containerRect.right) + 1;
                    this.transform(this.chipAreaScrollOffset);
                }
            }
            if (arrowPosition === 'left') {
                for (var index = 0; index < chipAraeChildren.length; index++) {
                    if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().left) < Math.ceil(containerRect.left)) {
                        count++;
                    }
                }
                if (count > 0) {
                    this.chipAreaScrollOffset += Math.ceil(containerRect.left) -
                        Math.ceil(chipAraeChildren[count - 1].getBoundingClientRect().left) + 1;
                    this.transform(this.chipAreaScrollOffset);
                }
            }
        };
        IgxGridFilteringRowComponent.prototype.showHideArrowButtons = function () {
            var _this = this;
            requestAnimationFrame(function () {
                if (_this.filteringService.isFilterRowVisible) {
                    var containerWidth = _this.container.nativeElement.getBoundingClientRect().width;
                    _this.chipsAreaWidth = _this.chipsArea.element.nativeElement.getBoundingClientRect().width;
                    _this.showArrows = _this.chipsAreaWidth >= containerWidth && _this.isColumnFiltered;
                    // TODO: revise the cdr.detectChanges() usage here
                    if (!_this.cdr.destroyed) {
                        _this.cdr.detectChanges();
                    }
                }
            });
        };
        IgxGridFilteringRowComponent.prototype.addExpression = function (isSelected) {
            var exprUI = new ExpressionUI();
            exprUI.expression = this.expression;
            exprUI.beforeOperator = this.expressionsList.length > 0 ? exports.FilteringLogic.And : null;
            exprUI.isSelected = isSelected;
            this.expressionsList.push(exprUI);
            var length = this.expressionsList.length;
            if (this.expressionsList[length - 2]) {
                this.expressionsList[length - 2].afterOperator = this.expressionsList[length - 1].beforeOperator;
            }
            this.showHideArrowButtons();
        };
        IgxGridFilteringRowComponent.prototype.removeExpression = function (indexToRemove, expression) {
            if (indexToRemove === 0 && this.expressionsList.length === 1) {
                this.clearFiltering();
                return;
            }
            this.filteringService.removeExpression(this.column.field, indexToRemove);
            this.filter();
            if (this.expression === expression) {
                this.resetExpression();
            }
            this.showHideArrowButtons();
        };
        IgxGridFilteringRowComponent.prototype.resetExpression = function () {
            this.expression = {
                fieldName: this.column.field,
                condition: null,
                searchVal: null,
                ignoreCase: this.column.filteringIgnoreCase
            };
            if (this.column.dataType !== exports.DataType.Boolean) {
                this.expression.condition = this.getCondition(this.conditions[0]);
            }
            if (this.column.dataType === exports.DataType.Date && this.input) {
                this.input.nativeElement.value = null;
            }
            this.showHideArrowButtons();
        };
        IgxGridFilteringRowComponent.prototype.scrollChipsWhenAddingExpression = function () {
            var chipAraeChildren = this.chipsArea.element.nativeElement.children;
            if (!chipAraeChildren || chipAraeChildren.length === 0) {
                return;
            }
            var containerRectRight = Math.ceil(this.container.nativeElement.getBoundingClientRect().right);
            var lastChipRectRight = Math.ceil(chipAraeChildren[chipAraeChildren.length - 1].getBoundingClientRect().right);
            if (lastChipRectRight >= containerRectRight) {
                this.chipAreaScrollOffset -= lastChipRectRight - containerRectRight;
                this.transform(this.chipAreaScrollOffset);
            }
        };
        /**
         * @hidden
         * Resets the chips area
         * @memberof IgxGridFilteringRowComponent
         */
        IgxGridFilteringRowComponent.prototype.resetChipsArea = function () {
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
            this.showHideArrowButtons();
        };
        IgxGridFilteringRowComponent.prototype.transform = function (offset) {
            var _this = this;
            requestAnimationFrame(function () {
                _this.chipsArea.element.nativeElement.style.transform = "translate(" + offset + "px)";
            });
        };
        IgxGridFilteringRowComponent.prototype.scrollChipsOnRemove = function () {
            var count = 0;
            var chipAraeChildren = this.chipsArea.element.nativeElement.children;
            var containerRect = this.container.nativeElement.getBoundingClientRect();
            for (var index = 0; index < chipAraeChildren.length; index++) {
                if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.left)) {
                    count++;
                }
            }
            if (count <= 2) {
                this.chipAreaScrollOffset = 0;
            }
            else {
                var dif = chipAraeChildren[count].id === 'chip' ? count - 2 : count - 1;
                this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[dif].getBoundingClientRect().left) + 1;
            }
            this.transform(this.chipAreaScrollOffset);
        };
        IgxGridFilteringRowComponent.prototype.conditionChangedCallback = function () {
            if (!!this.expression.searchVal || this.expression.searchVal === 0) {
                this.filter();
            }
            else if (this.value) {
                this.value = null;
            }
        };
        IgxGridFilteringRowComponent.prototype.unaryConditionChangedCallback = function () {
            var _this = this;
            if (this.value) {
                this.value = null;
            }
            if (this.expressionsList.find(function (item) { return item.expression === _this.expression; }) === undefined) {
                this.addExpression(true);
            }
            this.filter();
        };
        IgxGridFilteringRowComponent.prototype.filter = function () {
            this.filteringService.filterInternal(this.column.field);
        };
        Object.defineProperty(IgxGridFilteringRowComponent.prototype, "isColumnFiltered", {
            get: function () {
                return this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridFilteringRowComponent.ctorParameters = function () { return [
            { type: IgxFilteringService },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxGridFilteringRowComponent.prototype, "column", null);
        __decorate([
            core.Input()
        ], IgxGridFilteringRowComponent.prototype, "value", null);
        __decorate([
            core.ViewChild('defaultFilterUI', { read: core.TemplateRef, static: true })
        ], IgxGridFilteringRowComponent.prototype, "defaultFilterUI", void 0);
        __decorate([
            core.ViewChild('defaultDateUI', { read: core.TemplateRef, static: true })
        ], IgxGridFilteringRowComponent.prototype, "defaultDateUI", void 0);
        __decorate([
            core.ViewChild('input', { read: core.ElementRef })
        ], IgxGridFilteringRowComponent.prototype, "input", void 0);
        __decorate([
            core.ViewChild('inputGroupConditions', { read: IgxDropDownComponent, static: true })
        ], IgxGridFilteringRowComponent.prototype, "dropDownConditions", void 0);
        __decorate([
            core.ViewChild('chipsArea', { read: IgxChipsAreaComponent, static: true })
        ], IgxGridFilteringRowComponent.prototype, "chipsArea", void 0);
        __decorate([
            core.ViewChildren('operators', { read: IgxDropDownComponent })
        ], IgxGridFilteringRowComponent.prototype, "dropDownOperators", void 0);
        __decorate([
            core.ViewChild('inputGroup', { read: core.ElementRef })
        ], IgxGridFilteringRowComponent.prototype, "inputGroup", void 0);
        __decorate([
            core.ViewChild('inputGroupPrefix', { read: core.ElementRef })
        ], IgxGridFilteringRowComponent.prototype, "inputGroupPrefix", void 0);
        __decorate([
            core.ViewChild('container', { static: true })
        ], IgxGridFilteringRowComponent.prototype, "container", void 0);
        __decorate([
            core.ViewChild('operand')
        ], IgxGridFilteringRowComponent.prototype, "operand", void 0);
        __decorate([
            core.ViewChild('closeButton', { static: true })
        ], IgxGridFilteringRowComponent.prototype, "closeButton", void 0);
        __decorate([
            core.HostBinding('class.igx-grid__filtering-row')
        ], IgxGridFilteringRowComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostListener('keydown.shift.tab', ['$event']),
            core.HostListener('keydown.tab', ['$event'])
        ], IgxGridFilteringRowComponent.prototype, "onTabKeydown", null);
        __decorate([
            core.HostListener('keydown.esc', ['$event'])
        ], IgxGridFilteringRowComponent.prototype, "onEscKeydown", null);
        IgxGridFilteringRowComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-filtering-row',
                template: "<!-- Have to apply styles inline because of the overlay outlet ... -->\n<igx-drop-down #inputGroupConditions [height]=\"'200px'\" (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item\n        *ngFor=\"let condition of conditions\"\n        [value]=\"condition\"\n        [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span style=\"margin-left: 16px\">{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<ng-template #defaultFilterUI>\n    <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\" (focusout)=\"onInputGroupFocusout()\">\n        <igx-prefix #inputGroupPrefix\n                    (click)=\"toggleConditionsDropDown(inputGroupPrefix)\"\n                    (keydown)=\"onPrefixKeyDown($event)\"\n                    tabindex=\"0\"\n                    [igxDropDownItemNavigation]=\"inputGroupConditions\">\n            <igx-icon fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        </igx-prefix>\n        <input\n            #input\n            igxInput\n            tabindex=\"0\"\n            [placeholder]=\"placeholder\"\n            autocomplete=\"off\"\n            [value]=\"value\"\n            (input)=\"onInput($event)\"\n            [type]=\"type\"\n            [readonly]=\"isUnaryCondition\"\n            (click)=\"onInputClick()\"\n            (compositionstart)=\"onCompositionStart()\"\n            (compositionend)=\"onCompositionEnd()\"\n            (keydown)=\"onInputKeyDown($event)\"\n            (keyup)=\"onInputKeyUp($event)\"/>\n            <igx-suffix *ngIf=\"value || value === 0\" >\n                <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"onClearClick()\" tabindex=\"0\">clear</igx-icon>\n            </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-template #defaultDateUI>\n    <igx-date-picker\n        tabindex=\"0\"\n        mode=\"dropdown\"\n        [value]=\"value\"\n        [outlet]=\"filteringService.grid.outletDirective\"\n        [locale]=\"filteringService.grid.locale\"\n        (onSelection)=\"onDateSelected($event)\"\n        (onClose)=\"datePickerClose()\">\n        <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\">\n            <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\" (focusout)=\"onInputGroupFocusout()\">\n                <igx-prefix #inputGroupPrefix\n                            tabindex=\"0\"\n                            (click)=\"toggleConditionsDropDown(inputGroupPrefix)\"\n                            (keydown)=\"onPrefixKeyDown($event)\"\n                            [igxDropDownItemNavigation]=\"inputGroupConditions\">\n                    <igx-icon fontSet=\"filtering-icons\" [name]=\"expression.condition.iconName\"></igx-icon>\n                </igx-prefix>\n                <input #input\n                       igxInput\n                       tabindex=\"0\"\n                       (click)=\"expression.condition.isUnary ? noop() : openDialog(inputGroup.element.nativeElement)\"\n                       [placeholder]=\"placeholder\"\n                       autocomplete=\"off\"\n                       [value]=\"value | igxdate: filteringService.grid.locale\"\n                       [readonly]=\"true\"\n                       (keydown)=\"onInputKeyDown($event)\"/>\n                <igx-suffix *ngIf=\"value\" (keydown)=\"onClearKeyDown($event)\" (click)=\"clearInput()\" tabindex=\"0\">\n                    <igx-icon>clear</igx-icon>\n                </igx-suffix>\n            </igx-input-group>\n            </ng-template>\n    </igx-date-picker>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-start\" *ngIf=\"showArrows\" (keydown)=\"onLeftArrowKeyDown($event)\" (click)=\"scrollChipsOnArrowPress('left')\">\n    <igx-icon>navigate_before</igx-icon>\n</button>\n\n<div #container class=\"igx-grid__filtering-row-main\">\n    <div>\n         <igx-chips-area #chipsArea>\n            <ng-container *ngFor=\"let item of expressionsList; index as i; let last = last;\" tabindex=\"0\">\n                <igx-chip #chip id='chip'\n                    (pointerdown)=\"onChipPointerdown($event, chip)\"\n                    (click)=\"onChipClick($event, item)\"\n                    (keydown)=\"onChipKeyDown($event, item)\"\n                    (onRemove)=\"onChipRemoved($event, item)\"\n                    [selectable]=\"false\"\n                    [selected]=\"item.isSelected\"\n                    [displayDensity]=\"'cosy'\"\n                    [removable]=\"true\">\n                    <igx-icon\n                        igxPrefix\n                        fontSet=\"filtering-icons\"\n                        [name]=\"item.expression.condition.iconName\">\n                    </igx-icon>\n                    <span>{{filteringService.getChipLabel(item.expression)}}</span>\n                </igx-chip>\n\n                <span id='operand' *ngIf=\"!last\">\n                    <button igxButton (click)=\"toggleOperatorsDropDown($event, i)\" [igxDropDownItemNavigation]=\"operators\">\n                        <igx-icon>expand_more</igx-icon>\n                        <span>{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n                    </button>\n                    <igx-drop-down #operators (onSelection)=\"onLogicOperatorChanged($event, item)\">\n                            <igx-drop-down-item [value]=\"0\" [selected]=\"item.afterOperator === 0\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_and}}</igx-drop-down-item>\n                            <igx-drop-down-item [value]=\"1\" [selected]=\"item.afterOperator === 1\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_or}}</igx-drop-down-item>\n                    </igx-drop-down>\n                </span>\n            </ng-container>\n        </igx-chips-area>\n    </div>\n</div>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-end\" *ngIf=\"showArrows\" (click)=\"scrollChipsOnArrowPress('right')\">\n    <igx-icon>navigate_next</igx-icon>\n</button>\n\n<div #buttonsContainer class=\"igx-grid__filtering-row-editing-buttons\">\n    <button igxButton igxRipple (click)=\"clearFiltering()\" [disabled]=\"disabled\" [tabindex]=\"disabled\">{{filteringService.grid.resourceStrings.igx_grid_filter_row_reset}}</button>\n    <button #closeButton igxButton igxRipple (click)=\"close()\">{{filteringService.grid.resourceStrings.igx_grid_filter_row_close}}</button>\n</div>\n"
            })
        ], IgxGridFilteringRowComponent);
        return IgxGridFilteringRowComponent;
    }());

    /**
     * @hidden
     * @internal
     */
    var DropPosition;
    (function (DropPosition) {
        DropPosition[DropPosition["BeforeDropTarget"] = 0] = "BeforeDropTarget";
        DropPosition[DropPosition["AfterDropTarget"] = 1] = "AfterDropTarget";
        DropPosition[DropPosition["None"] = 2] = "None";
    })(DropPosition || (DropPosition = {}));
    /**
     * @hidden
     * @internal
     */
    var IgxColumnMovingService = /** @class */ (function () {
        function IgxColumnMovingService() {
        }
        Object.defineProperty(IgxColumnMovingService.prototype, "column", {
            get: function () {
                return this._column;
            },
            set: function (val) {
                if (val) {
                    this._column = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingService.prototype, "icon", {
            get: function () {
                return this._icon;
            },
            set: function (val) {
                if (val) {
                    this._icon = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxColumnMovingService.ɵprov = core["ɵɵdefineInjectable"]({ factory: function IgxColumnMovingService_Factory() { return new IgxColumnMovingService(); }, token: IgxColumnMovingService, providedIn: "root" });
        IgxColumnMovingService = __decorate([
            core.Injectable({
                providedIn: 'root',
            })
        ], IgxColumnMovingService);
        return IgxColumnMovingService;
    }());

    /**
     * @hidden
     * @internal
     */
    var IgxColumnMovingDragDirective = /** @class */ (function (_super) {
        __extends(IgxColumnMovingDragDirective, _super);
        function IgxColumnMovingDragDirective(element, viewContainer, zone, renderer, cdr, cms) {
            var _this = _super.call(this, cdr, element, viewContainer, zone, renderer) || this;
            _this.element = element;
            _this.viewContainer = viewContainer;
            _this.zone = zone;
            _this.renderer = renderer;
            _this.cdr = cdr;
            _this.cms = cms;
            _this._ghostClass = 'igx-grid__drag-ghost-image';
            _this.ghostImgIconClass = 'igx-grid__drag-ghost-image-icon';
            _this.ghostImgIconGroupClass = 'igx-grid__drag-ghost-image-icon-group';
            return _this;
        }
        Object.defineProperty(IgxColumnMovingDragDirective.prototype, "data", {
            set: function (val) {
                this._column = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDragDirective.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDragDirective.prototype, "draggable", {
            get: function () {
                return this.column && (this.column.movable || (this.column.groupable && !this.column.columnGroup));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDragDirective.prototype, "icon", {
            get: function () {
                return this.cms.icon;
            },
            enumerable: true,
            configurable: true
        });
        IgxColumnMovingDragDirective.prototype.ngOnDestroy = function () {
            this._unsubscribe();
        };
        IgxColumnMovingDragDirective.prototype.onEscape = function (event) {
            this.cms.cancelDrop = true;
            this.onPointerUp(event);
        };
        IgxColumnMovingDragDirective.prototype.onPointerDown = function (event) {
            var _this = this;
            if (!this.draggable || event.target.getAttribute('draggable') === 'false') {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            this._removeOnDestroy = false;
            this.cms.column = this.column;
            this.ghostClass = this._ghostClass;
            _super.prototype.onPointerDown.call(this, event);
            this.cms.isColumnMoving = true;
            this.column.grid.cdr.detectChanges();
            var args = {
                source: this.column
            };
            this.column.grid.onColumnMovingStart.emit(args);
            this.subscription$ = rxjs.fromEvent(this.column.grid.document.defaultView, 'keydown').subscribe(function (ev) {
                if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                    _this.onEscape(ev);
                }
            });
        };
        IgxColumnMovingDragDirective.prototype.onPointerMove = function (event) {
            event.preventDefault();
            _super.prototype.onPointerMove.call(this, event);
            if (this._dragStarted && this.ghostElement && !this.column.grid.draggedColumn) {
                this.column.grid.draggedColumn = this.column;
                this.column.grid.cdr.detectChanges();
            }
            if (this.cms.isColumnMoving) {
                var args = {
                    source: this.column,
                    cancel: false
                };
                this.column.grid.onColumnMoving.emit(args);
                if (args.cancel) {
                    this.onEscape(event);
                }
            }
        };
        IgxColumnMovingDragDirective.prototype.onPointerUp = function (event) {
            var _this = this;
            // Run it explicitly inside the zone because sometimes onPointerUp executes after the code below.
            this.zone.run(function () {
                _super.prototype.onPointerUp.call(_this, event);
                _this.cms.isColumnMoving = false;
                _this.column.grid.draggedColumn = null;
                _this.column.grid.cdr.detectChanges();
            });
            this._unsubscribe();
        };
        IgxColumnMovingDragDirective.prototype.createGhost = function (pageX, pageY) {
            _super.prototype.createGhost.call(this, pageX, pageY);
            this.ghostElement.style.height = null;
            this.ghostElement.style.minWidth = null;
            this.ghostElement.style.flexBasis = null;
            this.ghostElement.style.position = null;
            var icon = document.createElement('i');
            var text = document.createTextNode('block');
            icon.appendChild(text);
            icon.classList.add('material-icons');
            this.cms.icon = icon;
            if (!this.column.columnGroup) {
                this.renderer.addClass(icon, this.ghostImgIconClass);
                this.ghostElement.insertBefore(icon, this.ghostElement.firstElementChild);
                this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
                this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
            }
            else {
                this.ghostElement.insertBefore(icon, this.ghostElement.childNodes[0]);
                this.renderer.addClass(icon, this.ghostImgIconGroupClass);
                this.ghostElement.children[0].style.paddingLeft = '0px';
                this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
                this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
            }
        };
        IgxColumnMovingDragDirective.prototype._unsubscribe = function () {
            if (this.subscription$) {
                this.subscription$.unsubscribe();
                this.subscription$ = null;
            }
        };
        IgxColumnMovingDragDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.ViewContainerRef },
            { type: core.NgZone },
            { type: core.Renderer2 },
            { type: core.ChangeDetectorRef },
            { type: IgxColumnMovingService }
        ]; };
        __decorate([
            core.Input('igxColumnMovingDrag')
        ], IgxColumnMovingDragDirective.prototype, "data", null);
        IgxColumnMovingDragDirective = __decorate([
            core.Directive({
                selector: '[igxColumnMovingDrag]',
            })
        ], IgxColumnMovingDragDirective);
        return IgxColumnMovingDragDirective;
    }(IgxDragDirective));

    /**
     * @hidden
     */
    var IgxGroupByRowTemplateDirective = /** @class */ (function () {
        function IgxGroupByRowTemplateDirective(template) {
            this.template = template;
        }
        IgxGroupByRowTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxGroupByRowTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxGroupByRow]'
            })
        ], IgxGroupByRowTemplateDirective);
        return IgxGroupByRowTemplateDirective;
    }());
    /**
     * @hidden
     */
    var IgxGridDetailTemplateDirective = /** @class */ (function () {
        function IgxGridDetailTemplateDirective() {
        }
        IgxGridDetailTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxGridDetail]'
            })
        ], IgxGridDetailTemplateDirective);
        return IgxGridDetailTemplateDirective;
    }());
    /**
     * @hidden
     */
    var IgxRowExpandedIndicatorDirective = /** @class */ (function () {
        function IgxRowExpandedIndicatorDirective() {
        }
        IgxRowExpandedIndicatorDirective = __decorate([
            core.Directive({
                selector: '[igxRowExpandedIndicator]'
            })
        ], IgxRowExpandedIndicatorDirective);
        return IgxRowExpandedIndicatorDirective;
    }());
    /**
     * @hidden
     */
    var IgxRowCollapsedIndicatorDirective = /** @class */ (function () {
        function IgxRowCollapsedIndicatorDirective() {
        }
        IgxRowCollapsedIndicatorDirective = __decorate([
            core.Directive({
                selector: '[igxRowCollapsedIndicator]'
            })
        ], IgxRowCollapsedIndicatorDirective);
        return IgxRowCollapsedIndicatorDirective;
    }());
    /**
     * @hidden
     */
    var IgxHeaderExpandIndicatorDirective = /** @class */ (function () {
        function IgxHeaderExpandIndicatorDirective() {
        }
        IgxHeaderExpandIndicatorDirective = __decorate([
            core.Directive({
                selector: '[igxHeaderExpandedIndicator]'
            })
        ], IgxHeaderExpandIndicatorDirective);
        return IgxHeaderExpandIndicatorDirective;
    }());
    /**
     * @hidden
     */
    var IgxHeaderCollapseIndicatorDirective = /** @class */ (function () {
        function IgxHeaderCollapseIndicatorDirective() {
        }
        IgxHeaderCollapseIndicatorDirective = __decorate([
            core.Directive({
                selector: '[igxHeaderCollapsedIndicator]'
            })
        ], IgxHeaderCollapseIndicatorDirective);
        return IgxHeaderCollapseIndicatorDirective;
    }());
    /**
     * @hidden
     */
    var IgxGroupAreaDropDirective = /** @class */ (function (_super) {
        __extends(IgxGroupAreaDropDirective, _super);
        function IgxGroupAreaDropDirective(elementRef, renderer, zone) {
            var _this = _super.call(this, elementRef, renderer, zone) || this;
            _this.elementRef = elementRef;
            _this.renderer = renderer;
            _this.zone = zone;
            _this.hovered = false;
            return _this;
        }
        IgxGroupAreaDropDirective.prototype.onDragEnter = function (event) {
            var drag = event.detail.owner;
            var column = drag.column;
            if (!this.columnBelongsToGrid(column)) {
                return;
            }
            var grid = column.grid;
            var isGrouped = grid.groupingExpressions.findIndex(function (item) { return item.fieldName === column.field; }) !== -1;
            if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
                drag.icon.innerText = 'group_work';
                this.hovered = true;
            }
            else {
                drag.icon.innerText = 'block';
                this.hovered = false;
            }
        };
        IgxGroupAreaDropDirective.prototype.onDragLeave = function (event) {
            var drag = event.detail.owner;
            var column = drag.column;
            if (!this.columnBelongsToGrid(column)) {
                return;
            }
            event.detail.owner.icon.innerText = 'block';
            this.hovered = false;
        };
        IgxGroupAreaDropDirective.prototype.onDragDrop = function (event) {
            var drag = event.detail.owner;
            if (drag instanceof IgxColumnMovingDragDirective) {
                var column_1 = drag.column;
                if (!this.columnBelongsToGrid(column_1)) {
                    return;
                }
                var grid = column_1.grid;
                var isGrouped = grid.groupingExpressions.findIndex(function (item) { return item.fieldName === column_1.field; }) !== -1;
                if (column_1.groupable && !isGrouped && !column_1.columnGroup && !!column_1.field) {
                    grid.groupBy({ fieldName: column_1.field, dir: exports.SortingDirection.Asc, ignoreCase: column_1.sortingIgnoreCase,
                        strategy: column_1.sortStrategy, groupingComparer: column_1.groupingComparer });
                }
            }
        };
        IgxGroupAreaDropDirective.prototype.closestParentByAttr = function (elem, attr) {
            return elem.hasAttribute(attr) ?
                elem :
                this.closestParentByAttr(elem.parentElement, attr);
        };
        IgxGroupAreaDropDirective.prototype.columnBelongsToGrid = function (column) {
            var elem = this.elementRef.nativeElement;
            var closestGridID = this.closestParentByAttr(elem, 'igxGroupAreaDrop').getAttribute('gridId');
            if (!column) {
                return false;
            }
            else {
                var grid = column.grid;
                if (!grid || grid.id !== closestGridID) {
                    return false;
                }
                return true;
            }
        };
        IgxGroupAreaDropDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.HostBinding('class.igx-drop-area--hover')
        ], IgxGroupAreaDropDirective.prototype, "hovered", void 0);
        IgxGroupAreaDropDirective = __decorate([
            core.Directive({
                selector: '[igxGroupAreaDrop]'
            })
        ], IgxGroupAreaDropDirective);
        return IgxGroupAreaDropDirective;
    }(IgxDropDirective));

    /**
     *@hidden
     */
    var ExpressionItem = /** @class */ (function () {
        function ExpressionItem(parent) {
            this.parent = parent;
        }
        return ExpressionItem;
    }());
    /**
     *@hidden
     */
    var ExpressionGroupItem = /** @class */ (function (_super) {
        __extends(ExpressionGroupItem, _super);
        function ExpressionGroupItem(operator, parent) {
            var _this = _super.call(this, parent) || this;
            _this.operator = operator;
            _this.children = [];
            return _this;
        }
        return ExpressionGroupItem;
    }(ExpressionItem));
    /**
     *@hidden
     */
    var ExpressionOperandItem = /** @class */ (function (_super) {
        __extends(ExpressionOperandItem, _super);
        function ExpressionOperandItem(expression, parent) {
            var _this = _super.call(this, parent) || this;
            _this.expression = expression;
            return _this;
        }
        return ExpressionOperandItem;
    }(ExpressionItem));
    /**
     * A component used for presenting advanced filtering UI for a Grid.
     * It is used internally in the Grid, but could also be hosted in a container outside of it.
     *
     * Example:
     * ```html
     * <igx-advanced-filtering-dialog
     *     [grid]="grid1">
     * </igx-advanced-filtering-dialog>
     * ```
     */
    var IgxAdvancedFilteringDialogComponent = /** @class */ (function () {
        function IgxAdvancedFilteringDialogComponent(cdr) {
            this.cdr = cdr;
            /**
             * @hidden @internal
             */
            this.inline = true;
            /**
             * @hidden @internal
             */
            this.selectedExpressions = [];
            /**
             * @hidden @internal
             */
            this.selectedGroups = [];
            this._positionSettings = {
                horizontalStartPoint: exports.HorizontalAlignment.Right,
                verticalStartPoint: exports.VerticalAlignment.Top
            };
            this._overlaySettings = {
                closeOnOutsideClick: false,
                modal: false,
                positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),
                scrollStrategy: new CloseScrollStrategy()
            };
            /**
             * @hidden @internal
             */
            this.columnSelectOverlaySettings = {
                scrollStrategy: new AbsoluteScrollStrategy(),
                modal: false,
                closeOnOutsideClick: false,
                excludePositionTarget: true
            };
            /**
             * @hidden @internal
             */
            this.conditionSelectOverlaySettings = {
                scrollStrategy: new AbsoluteScrollStrategy(),
                modal: false,
                closeOnOutsideClick: false,
                excludePositionTarget: true
            };
            /**
             * @hidden @internal
             */
            this.display = 'block';
            this.destroy$ = new rxjs.Subject();
            this._dblClickDelay = 200;
            this._preventChipClick = false;
        }
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "editingInputsContainer", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._editingInputsContainer;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                var _this = this;
                if ((value && !this._editingInputsContainer) ||
                    (value && this._editingInputsContainer && this._editingInputsContainer.nativeElement !== value.nativeElement)) {
                    requestAnimationFrame(function () {
                        _this.scrollElementIntoView(value.nativeElement);
                    });
                }
                this._editingInputsContainer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "addModeContainer", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._addModeContainer;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                var _this = this;
                if ((value && !this._addModeContainer) ||
                    (value && this._addModeContainer && this._addModeContainer.nativeElement !== value.nativeElement)) {
                    requestAnimationFrame(function () {
                        _this.scrollElementIntoView(value.nativeElement);
                    });
                }
                this._addModeContainer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "currentGroupButtonsContainer", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._currentGroupButtonsContainer;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                var _this = this;
                if ((value && !this._currentGroupButtonsContainer) ||
                    (value && this._currentGroupButtonsContainer && this._currentGroupButtonsContainer.nativeElement !== value.nativeElement)) {
                    requestAnimationFrame(function () {
                        _this.scrollElementIntoView(value.nativeElement);
                    });
                }
                this._currentGroupButtonsContainer = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.ngAfterViewInit = function () {
            this._overlaySettings.outlet = this.overlayOutlet;
            this.columnSelectOverlaySettings.outlet = this.overlayOutlet;
            this.conditionSelectOverlaySettings.outlet = this.overlayOutlet;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "displayDensity", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.grid.displayDensity;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "selectedColumn", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._selectedColumn;
            },
            /**
             * @hidden @internal
             */
            set: function (value) {
                var oldValue = this._selectedColumn;
                if (this._selectedColumn !== value) {
                    this._selectedColumn = value;
                    if (oldValue && this._selectedColumn && this._selectedColumn.dataType !== oldValue.dataType) {
                        this.selectedCondition = null;
                        this.searchValue = null;
                        this.cdr.detectChanges();
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "grid", {
            /**
             * Returns the grid.
             */
            get: function () {
                return this._grid;
            },
            /**
             * An @Input property that sets the grid.
             */
            set: function (grid) {
                var _this = this;
                this._grid = grid;
                if (this._filteringChange) {
                    this._filteringChange.unsubscribe();
                }
                if (this._grid) {
                    this._grid.filteringService.registerSVGIcons();
                    this._filteringChange = this._grid.advancedFilteringExpressionsTreeChange.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                        _this.init();
                    });
                    this.init();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAdvancedFilteringDialogComponent.prototype, "filterableColumns", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.grid.columns.filter(function (col) { return !col.columnGroup && col.filterable; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.dragStart = function (dragArgs) {
            if (!this._overlayComponentId) {
                dragArgs.cancel = true;
                return;
            }
            if (!this.contextMenuToggle.collapsed) {
                this.contextMenuToggle.element.style.display = 'none';
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.dragEnd = function (dragArgs) {
            if (!this.contextMenuToggle.collapsed) {
                this.calculateContextMenuTarget();
                this.contextMenuToggle.reposition();
                this.contextMenuToggle.element.style.display = '';
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onDragMove = function (e) {
            var deltaX = e.nextPageX - e.pageX;
            var deltaY = e.nextPageY - e.pageY;
            e.cancel = true;
            this._overlayService.setOffset(this._overlayComponentId, deltaX, deltaY);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.addCondition = function (parent, afterExpression) {
            this.cancelOperandAdd();
            var operandItem = new ExpressionOperandItem({
                fieldName: null,
                condition: null,
                ignoreCase: true,
                searchVal: null
            }, parent);
            if (afterExpression) {
                var index = parent.children.indexOf(afterExpression);
                parent.children.splice(index + 1, 0, operandItem);
            }
            else {
                parent.children.push(operandItem);
            }
            this.enterExpressionEdit(operandItem);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.addAndGroup = function (parent, afterExpression) {
            this.addGroup(exports.FilteringLogic.And, parent, afterExpression);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.addOrGroup = function (parent, afterExpression) {
            this.addGroup(exports.FilteringLogic.Or, parent, afterExpression);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.endGroup = function (groupItem) {
            this.currentGroup = groupItem.parent;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.commitOperandEdit = function () {
            if (this.editedExpression) {
                this.editedExpression.expression.fieldName = this.selectedColumn.field;
                this.editedExpression.expression.condition = this.selectedColumn.filters.condition(this.selectedCondition);
                this.editedExpression.expression.searchVal = DataUtil.parseValue(this.selectedColumn.dataType, this.searchValue);
                this.editedExpression.columnHeader = this.selectedColumn.header;
                this.editedExpression.inEditMode = false;
                this.editedExpression = null;
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.cancelOperandAdd = function () {
            if (this.addModeExpression) {
                this.addModeExpression.inAddMode = false;
                this.addModeExpression = null;
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.cancelOperandEdit = function () {
            if (this.editedExpression) {
                this.editedExpression.inEditMode = false;
                if (!this.editedExpression.expression.fieldName) {
                    this.deleteItem(this.editedExpression);
                }
                this.editedExpression = null;
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.operandCanBeCommitted = function () {
            return this.selectedColumn && this.selectedCondition &&
                (!!this.searchValue || this.selectedColumn.filters.condition(this.selectedCondition).isUnary);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.exitOperandEdit = function () {
            if (!this.editedExpression) {
                return;
            }
            if (this.operandCanBeCommitted()) {
                this.commitOperandEdit();
            }
            else {
                this.cancelOperandEdit();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.isExpressionGroup = function (expression) {
            return expression instanceof ExpressionGroupItem;
        };
        IgxAdvancedFilteringDialogComponent.prototype.addGroup = function (operator, parent, afterExpression) {
            this.cancelOperandAdd();
            var groupItem = new ExpressionGroupItem(operator, parent);
            if (parent) {
                if (afterExpression) {
                    var index = parent.children.indexOf(afterExpression);
                    parent.children.splice(index + 1, 0, groupItem);
                }
                else {
                    parent.children.push(groupItem);
                }
            }
            else {
                this.rootGroup = groupItem;
            }
            this.addCondition(groupItem);
            this.currentGroup = groupItem;
        };
        IgxAdvancedFilteringDialogComponent.prototype.createExpressionGroupItem = function (expressionTree, parent) {
            var e_1, _a;
            var groupItem;
            if (expressionTree) {
                groupItem = new ExpressionGroupItem(expressionTree.operator, parent);
                try {
                    for (var _b = __values(expressionTree.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var expr = _c.value;
                        if (expr instanceof FilteringExpressionsTree) {
                            groupItem.children.push(this.createExpressionGroupItem(expr, groupItem));
                        }
                        else {
                            var filteringExpr = expr;
                            var exprCopy = {
                                fieldName: filteringExpr.fieldName,
                                condition: filteringExpr.condition,
                                searchVal: filteringExpr.searchVal,
                                ignoreCase: filteringExpr.ignoreCase
                            };
                            var operandItem = new ExpressionOperandItem(exprCopy, groupItem);
                            var column = this.grid.getColumnByName(filteringExpr.fieldName);
                            operandItem.columnHeader = column.header;
                            groupItem.children.push(operandItem);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return groupItem;
        };
        IgxAdvancedFilteringDialogComponent.prototype.createExpressionsTreeFromGroupItem = function (groupItem) {
            var e_2, _a;
            if (!groupItem) {
                return null;
            }
            var expressionsTree = new FilteringExpressionsTree(groupItem.operator);
            try {
                for (var _b = __values(groupItem.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    if (item instanceof ExpressionGroupItem) {
                        var subTree = this.createExpressionsTreeFromGroupItem(item);
                        expressionsTree.filteringOperands.push(subTree);
                    }
                    else {
                        expressionsTree.filteringOperands.push(item.expression);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return expressionsTree;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onChipRemove = function (expressionItem) {
            this.deleteItem(expressionItem);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onChipClick = function (expressionItem) {
            var _this = this;
            this._clickTimer = setTimeout(function () {
                if (!_this._preventChipClick) {
                    _this.onToggleExpression(expressionItem);
                }
                _this._preventChipClick = false;
            }, this._dblClickDelay);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onChipDblClick = function (expressionItem) {
            clearTimeout(this._clickTimer);
            this._preventChipClick = true;
            this.enterExpressionEdit(expressionItem);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.enterExpressionEdit = function (expressionItem) {
            this.clearSelection();
            this.exitOperandEdit();
            this.cancelOperandAdd();
            if (this.editedExpression) {
                this.editedExpression.inEditMode = false;
            }
            expressionItem.hovered = false;
            this.selectedColumn = expressionItem.expression.fieldName ?
                this.grid.getColumnByName(expressionItem.expression.fieldName) : null;
            this.selectedCondition = expressionItem.expression.condition ?
                expressionItem.expression.condition.name : null;
            this.searchValue = expressionItem.expression.searchVal;
            expressionItem.inEditMode = true;
            this.editedExpression = expressionItem;
            this.cdr.detectChanges();
            this.columnSelectOverlaySettings.positionStrategy = new AutoPositionStrategy({ target: this.columnSelect.element });
            this.conditionSelectOverlaySettings.positionStrategy = new AutoPositionStrategy({ target: this.conditionSelect.element });
            if (!this.selectedColumn) {
                this.columnSelect.input.nativeElement.focus();
            }
            else if (this.selectedColumn.filters.condition(this.selectedCondition).isUnary) {
                this.conditionSelect.input.nativeElement.focus();
            }
            else {
                this.searchValueInput.nativeElement.focus();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.clearSelection = function () {
            var e_3, _a, e_4, _b;
            try {
                for (var _c = __values(this.selectedGroups), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    group.selected = false;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this.selectedGroups = [];
            try {
                for (var _e = __values(this.selectedExpressions), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var expr = _f.value;
                    expr.selected = false;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_4) throw e_4.error; }
            }
            this.selectedExpressions = [];
            this.toggleContextMenu();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.enterExpressionAdd = function (expressionItem) {
            this.clearSelection();
            this.exitOperandEdit();
            if (this.addModeExpression) {
                this.addModeExpression.inAddMode = false;
            }
            expressionItem.inAddMode = true;
            this.addModeExpression = expressionItem;
            if (expressionItem.selected) {
                this.toggleExpression(expressionItem);
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.onToggleExpression = function (expressionItem) {
            this.exitOperandEdit();
            this.toggleExpression(expressionItem);
            this.toggleContextMenu();
        };
        IgxAdvancedFilteringDialogComponent.prototype.toggleExpression = function (expressionItem) {
            expressionItem.selected = !expressionItem.selected;
            if (expressionItem.selected) {
                this.selectedExpressions.push(expressionItem);
            }
            else {
                var index = this.selectedExpressions.indexOf(expressionItem);
                this.selectedExpressions.splice(index, 1);
                this.deselectParentRecursive(expressionItem);
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.contextMenuClosed = function () {
            this.contextualGroup = null;
        };
        IgxAdvancedFilteringDialogComponent.prototype.toggleContextMenu = function () {
            var contextualGroup = this.findSingleSelectedGroup();
            if (contextualGroup || this.selectedExpressions.length > 1) {
                this.contextualGroup = contextualGroup;
                if (contextualGroup) {
                    this.filteringLogics = [
                        {
                            label: this.grid.resourceStrings.igx_grid_filter_operator_and,
                            selected: contextualGroup.operator === exports.FilteringLogic.And
                        },
                        {
                            label: this.grid.resourceStrings.igx_grid_filter_operator_or,
                            selected: contextualGroup.operator === exports.FilteringLogic.Or
                        }
                    ];
                }
            }
            else if (this.contextMenuToggle) {
                this.contextMenuToggle.close();
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.findSingleSelectedGroup = function () {
            var e_5, _a;
            var _this = this;
            var _loop_1 = function (group) {
                var containsAllSelectedExpressions = this_1.selectedExpressions.every(function (op) { return _this.isInsideGroup(op, group); });
                if (containsAllSelectedExpressions) {
                    return { value: group };
                }
            };
            var this_1 = this;
            try {
                for (var _b = __values(this.selectedGroups), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    var state_1 = _loop_1(group);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
            }
            return null;
        };
        IgxAdvancedFilteringDialogComponent.prototype.isInsideGroup = function (item, group) {
            if (!item) {
                return false;
            }
            if (item.parent === group) {
                return true;
            }
            return this.isInsideGroup(item.parent, group);
        };
        IgxAdvancedFilteringDialogComponent.prototype.deleteItem = function (expressionItem) {
            if (!expressionItem.parent) {
                this.rootGroup = null;
                this.currentGroup = null;
                return;
            }
            if (expressionItem === this.currentGroup) {
                this.currentGroup = this.currentGroup.parent;
            }
            var children = expressionItem.parent.children;
            var index = children.indexOf(expressionItem);
            children.splice(index, 1);
            if (!children.length) {
                this.deleteItem(expressionItem.parent);
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onKeyDown = function (eventArgs) {
            eventArgs.stopPropagation();
            if (!this.contextMenuToggle.collapsed &&
                (eventArgs.key === "Escape" /* ESCAPE */ || eventArgs.key === "Esc" /* ESCAPE_IE */)) {
                this.clearSelection();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.createAndGroup = function () {
            this.createGroup(exports.FilteringLogic.And);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.createOrGroup = function () {
            this.createGroup(exports.FilteringLogic.Or);
        };
        IgxAdvancedFilteringDialogComponent.prototype.createGroup = function (operator) {
            var e_6, _a;
            var chips = this.chips.toArray();
            var minIndex = this.selectedExpressions.reduce(function (i, e) { return Math.min(i, chips.findIndex(function (c) { return c.data === e; })); }, Number.MAX_VALUE);
            var firstExpression = chips[minIndex].data;
            var parent = firstExpression.parent;
            var groupItem = new ExpressionGroupItem(operator, parent);
            var index = parent.children.indexOf(firstExpression);
            parent.children.splice(index, 0, groupItem);
            try {
                for (var _b = __values(this.selectedExpressions), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var expr = _c.value;
                    this.deleteItem(expr);
                    groupItem.children.push(expr);
                    expr.parent = groupItem;
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_6) throw e_6.error; }
            }
            this.clearSelection();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.deleteFilters = function () {
            var e_7, _a;
            try {
                for (var _b = __values(this.selectedExpressions), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var expr = _c.value;
                    this.deleteItem(expr);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_7) throw e_7.error; }
            }
            this.clearSelection();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onGroupClick = function (groupItem) {
            this.toggleGroup(groupItem);
        };
        IgxAdvancedFilteringDialogComponent.prototype.toggleGroup = function (groupItem) {
            this.exitOperandEdit();
            if (groupItem.children && groupItem.children.length) {
                this.toggleGroupRecursive(groupItem, !groupItem.selected);
                if (!groupItem.selected) {
                    this.deselectParentRecursive(groupItem);
                }
                this.toggleContextMenu();
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.toggleGroupRecursive = function (groupItem, selected) {
            var e_8, _a;
            if (groupItem.selected !== selected) {
                groupItem.selected = selected;
                if (groupItem.selected) {
                    this.selectedGroups.push(groupItem);
                }
                else {
                    var index = this.selectedGroups.indexOf(groupItem);
                    this.selectedGroups.splice(index, 1);
                }
            }
            try {
                for (var _b = __values(groupItem.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var expr = _c.value;
                    if (expr instanceof ExpressionGroupItem) {
                        this.toggleGroupRecursive(expr, selected);
                    }
                    else {
                        var operandExpression = expr;
                        if (operandExpression.selected !== selected) {
                            this.toggleExpression(operandExpression);
                        }
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_8) throw e_8.error; }
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.deselectParentRecursive = function (expressionItem) {
            var parent = expressionItem.parent;
            if (parent) {
                if (parent.selected) {
                    parent.selected = false;
                    var index = this.selectedGroups.indexOf(parent);
                    this.selectedGroups.splice(index, 1);
                }
                this.deselectParentRecursive(parent);
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.calculateContextMenuTarget = function () {
            var _this = this;
            var containerRect = this.expressionsContainer.nativeElement.getBoundingClientRect();
            var chips = this.chips.filter(function (c) { return _this.selectedExpressions.indexOf(c.data) !== -1; });
            var minTop = chips.reduce(function (t, c) {
                return Math.min(t, c.elementRef.nativeElement.getBoundingClientRect().top);
            }, Number.MAX_VALUE);
            minTop = Math.max(containerRect.top, minTop);
            minTop = Math.min(containerRect.bottom, minTop);
            var maxRight = chips.reduce(function (r, c) {
                return Math.max(r, c.elementRef.nativeElement.getBoundingClientRect().right);
            }, 0);
            maxRight = Math.max(maxRight, containerRect.left);
            maxRight = Math.min(maxRight, containerRect.right);
            this._overlaySettings.positionStrategy.settings.target = new Point(maxRight, minTop);
        };
        IgxAdvancedFilteringDialogComponent.prototype.scrollElementIntoView = function (target) {
            var container = this.expressionsContainer.nativeElement;
            var targetOffset = target.offsetTop - container.offsetTop;
            var delta = 10;
            if (container.scrollTop + delta > targetOffset) {
                container.scrollTop = targetOffset - delta;
            }
            else if (container.scrollTop + container.clientHeight < targetOffset + target.offsetHeight + delta) {
                container.scrollTop = targetOffset + target.offsetHeight + delta - container.clientHeight;
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.ungroup = function () {
            var _a, e_9, _b;
            var selectedGroup = this.contextualGroup;
            var parent = selectedGroup.parent;
            if (parent) {
                var index = parent.children.indexOf(selectedGroup);
                (_a = parent.children).splice.apply(_a, __spread([index, 1], selectedGroup.children));
                try {
                    for (var _c = __values(selectedGroup.children), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var expr = _d.value;
                        expr.parent = parent;
                    }
                }
                catch (e_9_1) { e_9 = { error: e_9_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                    }
                    finally { if (e_9) throw e_9.error; }
                }
            }
            this.clearSelection();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.deleteGroup = function () {
            var selectedGroup = this.contextualGroup;
            var parent = selectedGroup.parent;
            if (parent) {
                var index = parent.children.indexOf(selectedGroup);
                parent.children.splice(index, 1);
            }
            else {
                this.rootGroup = null;
            }
            this.clearSelection();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.selectFilteringLogic = function (event) {
            this.contextualGroup.operator = event.index;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.getConditionFriendlyName = function (name) {
            return this.grid.resourceStrings["igx_grid_filter_" + name] || name;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.isDate = function (value) {
            return value instanceof Date;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onExpressionsScrolled = function () {
            if (!this.contextMenuToggle.collapsed) {
                this.calculateContextMenuTarget();
                this.contextMenuToggle.reposition();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.invokeClick = function (eventArgs) {
            if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
                eventArgs.preventDefault();
                eventArgs.currentTarget.click();
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onOutletPointerDown = function (event) {
            // This prevents closing the select's dropdown when clicking the scroll
            event.preventDefault();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.getConditionList = function () {
            return this.selectedColumn ? this.selectedColumn.filters.conditionList() : [];
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.initialize = function (grid, overlayService, overlayComponentId) {
            this.inline = false;
            this.grid = grid;
            this._overlayService = overlayService;
            this._overlayComponentId = overlayComponentId;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.setAddButtonFocus = function () {
            if (this.addRootAndGroupButton) {
                this.addRootAndGroupButton.nativeElement.focus();
            }
            else if (this.addConditionButton) {
                this.addConditionButton.nativeElement.focus();
            }
        };
        IgxAdvancedFilteringDialogComponent.prototype.init = function () {
            this.clearSelection();
            this.cancelOperandAdd();
            this.cancelOperandEdit();
            this.rootGroup = this.createExpressionGroupItem(this.grid.advancedFilteringExpressionsTree);
            this.currentGroup = this.rootGroup;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.context = function (expression, afterExpression) {
            return {
                $implicit: expression,
                afterExpression: afterExpression
            };
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onClearButtonClick = function () {
            this.grid.advancedFilteringExpressionsTree = null;
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.closeDialog = function () {
            if (this._overlayComponentId) {
                this._overlayService.hide(this._overlayComponentId);
            }
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.applyChanges = function () {
            this.exitOperandEdit();
            this.grid.advancedFilteringExpressionsTree = this.createExpressionsTreeFromGroupItem(this.rootGroup);
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.cancelChanges = function () {
            if (!this._overlayComponentId) {
                this.init();
            }
            this.closeDialog();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onApplyButtonClick = function () {
            this.applyChanges();
            this.closeDialog();
        };
        /**
         * @hidden @internal
         */
        IgxAdvancedFilteringDialogComponent.prototype.onChipSelectionEnd = function () {
            var contextualGroup = this.findSingleSelectedGroup();
            if (contextualGroup || this.selectedExpressions.length > 1) {
                this.contextualGroup = contextualGroup;
                this.calculateContextMenuTarget();
                if (this.contextMenuToggle.collapsed) {
                    this.contextMenuToggle.open(this._overlaySettings);
                }
                else {
                    this.contextMenuToggle.reposition();
                }
            }
        };
        IgxAdvancedFilteringDialogComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.ViewChild('columnSelect', { read: IgxSelectComponent })
        ], IgxAdvancedFilteringDialogComponent.prototype, "columnSelect", void 0);
        __decorate([
            core.ViewChild('conditionSelect', { read: IgxSelectComponent })
        ], IgxAdvancedFilteringDialogComponent.prototype, "conditionSelect", void 0);
        __decorate([
            core.ViewChild('searchValueInput', { read: core.ElementRef })
        ], IgxAdvancedFilteringDialogComponent.prototype, "searchValueInput", void 0);
        __decorate([
            core.ViewChild('addRootAndGroupButton', { read: core.ElementRef })
        ], IgxAdvancedFilteringDialogComponent.prototype, "addRootAndGroupButton", void 0);
        __decorate([
            core.ViewChild('addConditionButton', { read: core.ElementRef })
        ], IgxAdvancedFilteringDialogComponent.prototype, "addConditionButton", void 0);
        __decorate([
            core.ViewChild('editingInputsContainer', { read: core.ElementRef })
        ], IgxAdvancedFilteringDialogComponent.prototype, "editingInputsContainer", null);
        __decorate([
            core.ViewChild('addModeContainer', { read: core.ElementRef })
        ], IgxAdvancedFilteringDialogComponent.prototype, "addModeContainer", null);
        __decorate([
            core.ViewChild('currentGroupButtonsContainer', { read: core.ElementRef })
        ], IgxAdvancedFilteringDialogComponent.prototype, "currentGroupButtonsContainer", null);
        __decorate([
            core.ViewChild(IgxToggleDirective)
        ], IgxAdvancedFilteringDialogComponent.prototype, "contextMenuToggle", void 0);
        __decorate([
            core.ViewChildren(IgxChipComponent)
        ], IgxAdvancedFilteringDialogComponent.prototype, "chips", void 0);
        __decorate([
            core.ViewChild('expressionsContainer')
        ], IgxAdvancedFilteringDialogComponent.prototype, "expressionsContainer", void 0);
        __decorate([
            core.ViewChild('overlayOutlet', { read: IgxOverlayOutletDirective, static: true })
        ], IgxAdvancedFilteringDialogComponent.prototype, "overlayOutlet", void 0);
        __decorate([
            core.HostBinding('style.display')
        ], IgxAdvancedFilteringDialogComponent.prototype, "display", void 0);
        __decorate([
            core.Input()
        ], IgxAdvancedFilteringDialogComponent.prototype, "grid", null);
        IgxAdvancedFilteringDialogComponent = __decorate([
            core.Component({
                selector: 'igx-advanced-filtering-dialog',
                template: "<article\n    *ngIf=\"grid\"\n    class=\"igx-advanced-filter\"\n    igxDrag\n    [ghost]=\"false\"\n    [dragTolerance]=\"0\"\n    (dragStart)=\"dragStart($event)\"\n    (dragEnd)=\"dragEnd($event)\"\n    (dragMove)=\"onDragMove($event)\"\n    (keydown)=\"onKeyDown($event)\"\n    [ngClass]=\"{\n        'igx-advanced-filter--cosy': grid.displayDensity === 'cosy',\n        'igx-advanced-filter--compact': grid.displayDensity === 'compact',\n        'igx-advanced-filter--inline': inline\n    }\"\n>\n    <header class=\"igx-advanced-filter__header\" igxDragHandle>\n        <h4 class=\"igx-typography__h6\" style=\"pointer-events: none;\">\n            {{ grid.resourceStrings.igx_grid_advanced_filter_title }}\n        </h4>\n        <div class=\"igx-filter-legend\">\n            <div class=\"igx-filter-legend__item--and\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_and_label }}</span>\n            </div>\n            <div class=\"igx-filter-legend__item--or\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_or_label }}</span>\n            </div>\n        </div>\n    </header>\n\n    <article #expressionsContainer\n             class=\"igx-advanced-filter__main\"\n             (scroll)=\"onExpressionsScrolled()\">\n        <ng-container *ngIf=\"!rootGroup\">\n\n            <button #addRootAndGroupButton\n                igxButton=\"outlined\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"addAndGroup()\"\n            >\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\" [displayDensity]=\"displayDensity\" (click)=\"addOrGroup()\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n            <div class=\"igx-filter-empty\">\n                <h6 class=\"igx-filter-empty__title\">\n                    {{grid.resourceStrings.igx_grid_advanced_filter_initial_text}}\n                </h6>\n            </div>\n        </ng-container>\n\n        <ng-template #addExpressionsTemplate let-expressionItem let-afterExpression=\"afterExpression\">\n            <button #addConditionButton\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addCondition(expressionItem, afterExpression)\"\n            >\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_add_condition}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addAndGroup(expressionItem, afterExpression)\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addOrGroup(expressionItem, afterExpression)\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n        </ng-template>\n\n        <ng-template #filterOperandTemplate let-expressionItem>\n            <div *ngIf=\"!expressionItem.inEditMode\"\n                class=\"igx-filter-tree__expression-item\"\n                (mouseenter)=\"expressionItem.hovered = true\"\n                (mouseleave)=\"expressionItem.hovered = false\"\n                >\n                <igx-chip [data]=\"expressionItem\"\n                          [displayDensity]=\"displayDensity === 'compact' ? 'cosy' : displayDensity\"\n                          [removable]=\"true\"\n                          [selected]=\"expressionItem.selected\"\n                          (keydown)=\"invokeClick($event)\"\n                          (click)=\"onChipClick(expressionItem)\"\n                          (dblclick)=\"onChipDblClick(expressionItem)\"\n                          (onRemove)=\"onChipRemove(expressionItem)\"\n                          (onSelectionDone)=\"onChipSelectionEnd()\"\n                    >\n                    <span igxPrefix class=\"igx-filter-tree__expression-column\">{{ expressionItem.columnHeader || expressionItem.expression.fieldName }}</span>\n                    <igx-icon\n                        igxPrefix\n                        fontSet=\"filtering-icons\"\n                        [name]=\"expressionItem.expression.condition.iconName\"\n                    >\n                    </igx-icon>\n                    <span class=\"igx-filter-tree__expression-condition\">\n                        {{ getConditionFriendlyName(expressionItem.expression.condition.name) }}\n                    </span>\n                    <span igxSuffix *ngIf=\"!expressionItem.expression.condition.isUnary\">\n                        {{ isDate(expressionItem.expression.searchVal) ? (expressionItem.expression.searchVal | igxdate:grid.locale) : expressionItem.expression.searchVal }}\n                    </span>\n                </igx-chip>\n                <div class=\"igx-filter-tree__expression-actions\"\n                *ngIf=\"(expressionItem.selected && selectedExpressions.length === 1) || expressionItem.hovered\">\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionEdit(expressionItem)\">\n                        edit\n                    </igx-icon>\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionAdd(expressionItem)\"\n                        *ngIf=\"!expressionItem.inAddMode && (expressionItem.parent !== currentGroup || expressionItem !== currentGroup.children[currentGroup.children.length - 1])\"\n                    >\n                        add\n                    </igx-icon>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inEditMode\"\n                #editingInputsContainer\n                class=\"igx-filter-tree__inputs\"\n            >\n                <igx-select #columnSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"columnSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_column_placeholder\"\n                            [(ngModel)]=\"selectedColumn\">\n                    <igx-select-item *ngFor=\"let column of filterableColumns\" [value]=\"column\">\n                        {{column.header || column.field}}\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-select #conditionSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"conditionSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_filter_condition_placeholder\"\n                            [(ngModel)]=\"selectedCondition\"\n                            [disabled]=\"!selectedColumn\">\n                    <igx-icon *ngIf=\"selectedColumn && conditionSelect.value && selectedColumn.filters.condition(conditionSelect.value)\"\n                              igxPrefix\n                              fontSet=\"filtering-icons\"\n                              [name]=\"selectedColumn.filters.condition(conditionSelect.value).iconName\">\n                    </igx-icon>\n                    <igx-select-item *ngFor=\"let condition of getConditionList()\" [value]=\"condition\">\n                        <igx-icon fontSet=\"filtering-icons\"\n                                  [name]=\"selectedColumn.filters.condition(condition).iconName\">\n                        </igx-icon>\n                        <span>{{getConditionFriendlyName(condition)}}</span>\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-input-group *ngIf=\"!selectedColumn || selectedColumn.dataType !== 'date'\"\n                                 type=\"box\"\n                                 [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"\n                                 [displayDensity]=\"'compact'\">\n                    <input #searchValueInput\n                           igxInput\n                           [type]=\"selectedColumn && selectedColumn.dataType === 'number' ? 'number' : 'text'\"\n                           [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_value_placeholder\"\n                           [(ngModel)]=\"searchValue\"/>\n                </igx-input-group>\n\n                <igx-date-picker *ngIf=\"selectedColumn && selectedColumn.dataType === 'date'\"\n                                 mode=\"dropdown\"\n                                 [(ngModel)]=\"searchValue\"\n                                 [locale]=\"grid.locale\"\n                                 [outlet]=\"grid.outletDirective\">\n                    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n                        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\">\n                            <input #searchValueInput\n                                    igxInput\n                                    tabindex=\"0\"\n                                    (keydown)=\"invokeClick($event)\"\n                                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                                    [placeholder]=\"grid.resourceStrings.igx_grid_filter_row_date_placeholder\"\n                                    autocomplete=\"off\"\n                                    [value]=\"value | igxdate: grid.locale\"\n                                    [readonly]=\"true\"\n                                    [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"/>\n                        </igx-input-group>\n                    </ng-template>\n                </igx-date-picker>\n\n                <div class=\"igx-filter-tree__inputs-actions\">\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            [disabled]=\"!operandCanBeCommitted()\"\n                            (click)=\"commitOperandEdit()\">\n                        <igx-icon fontSet=\"material\">check</igx-icon>\n                    </button>\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            (click)=\"cancelOperandEdit()\">\n                        <igx-icon fontSet=\"material\">close</igx-icon>\n                    </button>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inAddMode\"\n                #addModeContainer\n                class=\"igx-filter-tree__buttons\"\n            >\n                <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem.parent, expressionItem)\"></ng-container>\n                <button igxButton=\"icon\"\n                        [displayDensity]=\"displayDensity\"\n                        (click)=\"cancelOperandAdd()\">\n                    <igx-icon fontSet=\"material\">close</igx-icon>\n                </button>\n            </div>\n\n        </ng-template>\n\n        <ng-template #expressionTreeTemplate let-expressionItem>\n            <div class=\"igx-filter-tree\">\n                <div tabindex=\"0\"\n                     class=\"igx-filter-tree__line\"\n                     [ngClass]=\"{\n                         'igx-filter-tree__line--and': expressionItem.operator === 0,\n                         'igx-filter-tree__line--or': expressionItem.operator === 1,\n                         'igx-filter-tree__line--selected': expressionItem.selected\n                     }\"\n                     (keydown)=\"invokeClick($event)\"\n                     (click)=\"onGroupClick(expressionItem)\"\n                ></div>\n\n                <div class=\"igx-filter-tree__expression\">\n                    <ng-container *ngFor=\"let expr of expressionItem.children\">\n                        <ng-container *ngTemplateOutlet=\"isExpressionGroup(expr) ? expressionTreeTemplate : filterOperandTemplate; context: context(expr)\"></ng-container>\n                    </ng-container>\n                    <div *ngIf=\"currentGroup === expressionItem\"\n                        #currentGroupButtonsContainer\n                        class=\"igx-filter-tree__buttons\">\n                        <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem)\"></ng-container>\n                        <button igxButton=\"outlined\"\n                                *ngIf=\"expressionItem !== rootGroup\"\n                                [displayDensity]=\"displayDensity\"\n                                [disabled]=\"editedExpression || expressionItem.children.length < 2\"\n                                (click)=\"endGroup(expressionItem)\">\n                            <span>{{grid.resourceStrings.igx_grid_advanced_filter_end_group}}</span>\n                        </button>\n                    </div>\n                </div>\n            </div>\n\n        </ng-template>\n\n        <ng-container *ngIf=\"rootGroup\">\n            <ng-container *ngTemplateOutlet=\"expressionTreeTemplate; context: context(rootGroup)\"></ng-container>\n        </ng-container>\n\n        <div igxToggle\n            class=\"igx-filter-contextual-menu\"\n            (keydown)=\"onKeyDown($event)\"\n            (onClosed)=\"contextMenuClosed()\"\n            [ngClass]=\"{\n                'igx-filter-contextual-menu--cosy': displayDensity === 'cosy',\n                'igx-filter-contextual-menu--compact': displayDensity === 'compact'\n            }\"\n        >\n            <button igxButton=\"icon\"\n                    class=\"igx-filter-contextual-menu__close-btn\"\n                    (click)=\"clearSelection()\"\n            >\n                <igx-icon>close</igx-icon>\n            </button>\n\n            <ng-container *ngIf=\"contextualGroup\">\n                <igx-buttongroup [displayDensity]=\"displayDensity\"\n                                 [multiSelection]=\"false\"\n                                 [values]=\"filteringLogics\"\n                                 type=\"outline\"\n                                 (onSelect)=\"selectFilteringLogic($event)\">\n                </igx-buttongroup>\n\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"!contextualGroup.parent\"\n                    (click)=\"ungroup()\"\n                >\n                    <igx-icon fontSet=\"filtering-icons\" name=\"ungroup\"></igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_ungroup}}</span>\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteGroup()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    <igx-icon>delete</igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_delete}}</span>\n                </button>\n            </ng-container>\n            <ng-container *ngIf=\"!contextualGroup\">\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createAndGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_and_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createOrGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_or_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteFilters()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_delete_filters}}\n                </button>\n            </ng-container>\n        </div>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"cancelChanges()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n<div #overlayOutlet\n     igxOverlayOutlet\n     class=\"igx-advanced-filter__outlet\"\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
            })
        ], IgxAdvancedFilteringDialogComponent);
        return IgxAdvancedFilteringDialogComponent;
    }());

    /**
     * @hidden
     * @internal
     */
    var IgxRowSelectorDirective = /** @class */ (function () {
        function IgxRowSelectorDirective(templateRef) {
            this.templateRef = templateRef;
        }
        IgxRowSelectorDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxRowSelectorDirective = __decorate([
            core.Directive({
                selector: '[igxRowSelector]'
            })
        ], IgxRowSelectorDirective);
        return IgxRowSelectorDirective;
    }());
    /**
     * @hidden
     * @internal
     */
    var IgxHeadSelectorDirective = /** @class */ (function () {
        function IgxHeadSelectorDirective(templateRef) {
            this.templateRef = templateRef;
        }
        IgxHeadSelectorDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxHeadSelectorDirective = __decorate([
            core.Directive({
                selector: '[igxHeadSelector]'
            })
        ], IgxHeadSelectorDirective);
        return IgxHeadSelectorDirective;
    }());

    /**
     * The IgxGridToolbarCustomContentDirective directive is used to mark an 'ng-template' (with
     * the 'igxToolbarCustomContent' selector) defined in the IgxGrid which is used to provide
     * custom content for cener part of the IgxGridToolbar.
     */
    var IgxGridToolbarCustomContentDirective = /** @class */ (function () {
        function IgxGridToolbarCustomContentDirective(template) {
            this.template = template;
        }
        IgxGridToolbarCustomContentDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxGridToolbarCustomContentDirective = __decorate([
            core.Directive({
                selector: '[igxToolbarCustomContent]'
            })
        ], IgxGridToolbarCustomContentDirective);
        return IgxGridToolbarCustomContentDirective;
    }());

    var IgxColumnGroupComponent = /** @class */ (function (_super) {
        __extends(IgxColumnGroupComponent, _super);
        function IgxColumnGroupComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.children = new core.QueryList();
            /**
             * Sets/gets whether the column group is `searchable`.
             * Default value is `true`.
             * ```typescript
             * let isSearchable =  this.columnGroup.searchable;
             * ```
             * ```html
             *  <igx-column-group [searchable] = "false"></igx-column-group>
             * ```
             * @memberof IgxColumnGroupComponent
             */
            _this.searchable = true;
            /**
             *@hidden
             */
            _this.hiddenChange = new core.EventEmitter();
            return _this;
            // constructor(public gridAPI: GridBaseAPIService<IgxGridBaseDirective & IGridDataBindable>, public cdr: ChangeDetectorRef) {
            //     // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
            //     super(gridAPI, cdr);
            // }
        }
        IgxColumnGroupComponent_1 = IgxColumnGroupComponent;
        Object.defineProperty(IgxColumnGroupComponent.prototype, "collapsible", {
            get: function () {
                return this._collapsible && this.checkCollapsibleState();
            },
            /**
             * Set if the column group is collapsible.
             * Default value is `false`
             * ```html
             *  <igx-column-group [collapsible] = "true"></igx-column-group>
             * ```
             * @memberof IgxColumnGroupComponent
             */
            set: function (value) {
                this._collapsible = value;
                this.collapsibleChange.emit(this._collapsible);
                if (this.children && !this.hidden) {
                    if (this._collapsible) {
                        this.setExpandCollapseState();
                    }
                    else {
                        this.children.forEach(function (child) { return child.hidden = false; });
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "expanded", {
            get: function () {
                return this._expanded;
            },
            /**
             * Set whether the group is expanded or collapsed initially.
             * Applied only if the collapsible property is set to `true`
             * Default value is `true`
             * ```html
             *  const state = false
             *  <igx-column-group [(expand)] = "state"></igx-column-group>
             * ```
             * @memberof IgxColumnGroupComponent
             */
            set: function (value) {
                this._expanded = value;
                this.expandedChange.emit(this._expanded);
                if (!this.collapsible) {
                    return;
                }
                if (!this.hidden && this.children) {
                    this.setExpandCollapseState();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "summaries", {
            /**
             * Gets the column group `summaries`.
             * ```typescript
             * let columnGroupSummaries = this.columnGroup.summaries;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._summaries;
            },
            /**
             * Sets the column group `summaries`.
             * ```typescript
             * this.columnGroup.summaries = IgxNumberSummaryOperand;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            set: function (classRef) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "filters", {
            /**
             * Gets the column group `filters`.
             * ```typescript
             * let columnGroupFilters = this.columnGroup.filters;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._filters;
            },
            /**
             * Sets the column group `filters`.
             * ```typescript
             * this.columnGroup.filters = IgxStringFilteringOperand;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            set: function (classRef) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "bodyTemplate", {
            /**
             * Returns a reference to the body template.
             * ```typescript
             * let bodyTemplate = this.columnGroup.bodyTemplate;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._bodyTemplate;
            },
            /**
             * @hidden
             */
            set: function (template) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "collapsibleIndicatorTemplate", {
            /**
             * Allows you to define a custom template for expand/collapse indicator
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._collapseIndicatorTemplate;
            },
            set: function (template) {
                this._collapseIndicatorTemplate = template;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "inlineEditorTemplate", {
            /**
             * Returns a reference to the inline editor template.
             * ```typescript
             * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._inlineEditorTemplate;
            },
            /**
             * @hidden
             */
            set: function (template) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "cells", {
            /**
             * Gets the column group cells.
             * ```typescript
             * let columnCells = this.columnGroup.cells;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "hidden", {
            /**
             * Gets whether the column group is hidden.
             * ```typescript
             * let isHidden = this.columnGroup.hidden;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this.allChildren.every(function (c) { return c.hidden; });
            },
            /**
             * Sets the column group hidden property.
             * ```html
             * <igx-column [hidden] = "true"></igx-column>
             * ```
             *
             * Two-way data binding
             * ```html
             * <igx-column [(hidden)] = "model.columns[0].isHidden"></igx-column>
             * ```
             * @memberof IgxColumnGroupComponent
             */
            set: function (value) {
                var _this = this;
                this._hidden = value;
                this.hiddenChange.emit(this._hidden);
                if (this._hidden || !this.collapsible) {
                    this.children.forEach(function (child) { return child.hidden = _this._hidden; });
                }
                else {
                    this.children.forEach(function (c) {
                        if (c.visibleWhenCollapsed === undefined) {
                            c.hidden = false;
                            return;
                        }
                        c.hidden = _this.expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
                    });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxColumnGroupComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            /*
                @ContentChildren with descendants still returns the `parent`
                component in the query list.
            */
            if (this.headTemplate && this.headTemplate.length) {
                this._headerTemplate = this.headTemplate.toArray()[0].template;
            }
            if (this.collapseIndicatorTemplate) {
                this._collapseIndicatorTemplate = this.collapseIndicatorTemplate.template;
            }
            // currently only ivy fixes the issue, we have to slice only if the first child is group
            if (this.children.first === this) {
                this.children.reset(this.children.toArray().slice(1));
            }
            this.children.forEach(function (child) {
                child.parent = _this;
            });
            if (this.collapsible) {
                this.setExpandCollapseState();
            }
        };
        Object.defineProperty(IgxColumnGroupComponent.prototype, "allChildren", {
            /**
             * Returns the children columns collection.
             * ```typescript
             * let columns =  this.columnGroup.allChildren;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return flatten(this.children.toArray());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "columnGroup", {
            /**
             * Returns a boolean indicating if the column is a `ColumnGroup`.
             * ```typescript
             * let isColumnGroup =  this.columnGroup.columnGroup
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "columnLayout", {
            /**
             * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
             * ```typescript
             * let columnGroup =  this.column.columnGroup;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnGroupComponent.prototype, "width", {
            /**
             * Gets the width of the column group.
             * ```typescript
             * let columnGroupWidth = this.columnGroup.width;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                var isChildrenWidthInPercent = false, width;
                width = "" + this.children.reduce(function (acc, val) {
                    if (val.hidden) {
                        return acc;
                    }
                    if (typeof val.width === 'string' && val.width.indexOf('%') !== -1) {
                        isChildrenWidthInPercent = true;
                        return acc + parseInt(val.width, 10);
                    }
                    return acc + parseInt(val.calcWidth, 10);
                }, 0);
                return isChildrenWidthInPercent ? width + '%' : width + 'px';
            },
            set: function (val) { },
            enumerable: true,
            configurable: true
        });
        var IgxColumnGroupComponent_1;
        __decorate([
            core.ContentChildren(IgxColumnComponent, { read: IgxColumnComponent })
        ], IgxColumnGroupComponent.prototype, "children", void 0);
        __decorate([
            core.Input()
        ], IgxColumnGroupComponent.prototype, "collapsible", null);
        __decorate([
            core.Input()
        ], IgxColumnGroupComponent.prototype, "expanded", null);
        __decorate([
            core.Input()
        ], IgxColumnGroupComponent.prototype, "summaries", null);
        __decorate([
            core.Input()
        ], IgxColumnGroupComponent.prototype, "searchable", void 0);
        __decorate([
            core.Input()
        ], IgxColumnGroupComponent.prototype, "filters", null);
        __decorate([
            core.Input()
        ], IgxColumnGroupComponent.prototype, "collapsibleIndicatorTemplate", null);
        __decorate([
            core.Input()
        ], IgxColumnGroupComponent.prototype, "hidden", null);
        __decorate([
            core.Output()
        ], IgxColumnGroupComponent.prototype, "hiddenChange", void 0);
        IgxColumnGroupComponent = IgxColumnGroupComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: core.forwardRef(function () { return IgxColumnGroupComponent_1; }) }],
                selector: 'igx-column-group',
                template: ""
            })
        ], IgxColumnGroupComponent);
        return IgxColumnGroupComponent;
    }(IgxColumnComponent));

    var ghostBackgroundClass = 'igx-grid__tr--ghost';
    var gridCellClass = 'igx-grid__td';
    var rowSelectedClass = 'igx-grid__tr--selected';
    var cellSelectedClass = 'igx-grid__td--selected';
    var cellActiveClass = 'igx-grid__td--active';
    /**
     * @hidden
     */
    var IgxRowDragDirective = /** @class */ (function (_super) {
        __extends(IgxRowDragDirective, _super);
        function IgxRowDragDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._rowDragStarted = false;
            _this.transitionEndEvent = function (evt) {
                if (_this.ghostElement) {
                    _this.ghostElement.removeEventListener('transitionend', _this.transitionEndEvent, false);
                }
                _this.endDragging();
            };
            return _this;
        }
        Object.defineProperty(IgxRowDragDirective.prototype, "data", {
            get: function () {
                return this.row;
            },
            set: function (val) {
                this.row = val;
            },
            enumerable: true,
            configurable: true
        });
        IgxRowDragDirective.prototype.onPointerDown = function (event) {
            event.preventDefault();
            this._rowDragStarted = false;
            this._removeOnDestroy = false;
            _super.prototype.onPointerDown.call(this, event);
        };
        IgxRowDragDirective.prototype.onPointerMove = function (event) {
            var _this = this;
            _super.prototype.onPointerMove.call(this, event);
            if (this._dragStarted && !this._rowDragStarted) {
                this._rowDragStarted = true;
                var args = {
                    dragDirective: this,
                    dragData: this.row,
                    cancel: false,
                    owner: this.row.grid
                };
                this.row.grid.onRowDragStart.emit(args);
                if (args.cancel) {
                    this.ghostElement.parentNode.removeChild(this.ghostElement);
                    this.ghostElement = null;
                    this._dragStarted = false;
                    this._clicked = false;
                    return;
                }
                this.row.dragging = true;
                this.row.grid.rowDragging = true;
                this.row.grid.markForCheck();
                this.subscription$ = rxjs.fromEvent(this.row.grid.document.defaultView, 'keydown').subscribe(function (ev) {
                    if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                        _this._lastDropArea = false;
                        _this.onPointerUp(event);
                    }
                });
            }
        };
        IgxRowDragDirective.prototype.onPointerUp = function (event) {
            var _this = this;
            if (!this._clicked) {
                return;
            }
            var args = {
                dragDirective: this,
                dragData: this.row,
                animation: false,
                owner: this.row.grid
            };
            this.zone.run(function () {
                _this.row.grid.onRowDragEnd.emit(args);
            });
            var dropArea = this._lastDropArea;
            _super.prototype.onPointerUp.call(this, event);
            if (!dropArea && this.ghostElement) {
                this.ghostElement.addEventListener('transitionend', this.transitionEndEvent, false);
            }
            else {
                this.endDragging();
            }
        };
        IgxRowDragDirective.prototype.createGhost = function (pageX, pageY) {
            this.row.grid.endEdit(true);
            this.row.grid.markForCheck();
            this.ghostContext = {
                $implicit: this.row.rowData,
                data: this.row.rowData,
                grid: this.row.grid
            };
            _super.prototype.createGhost.call(this, pageX, pageY, this.row.nativeElement);
            // check if there is an expander icon and create the ghost at the corresponding position
            if (this.isHierarchicalGrid) {
                var row = this.row;
                if (row.expander) {
                    var expanderWidth = row.expander.nativeElement.getBoundingClientRect().width;
                    this._ghostHostX += expanderWidth;
                }
            }
            var ghost = this.ghostElement;
            var gridRect = this.row.grid.nativeElement.getBoundingClientRect();
            var rowRect = this.row.nativeElement.getBoundingClientRect();
            ghost.style.overflow = 'hidden';
            ghost.style.width = gridRect.width + 'px';
            ghost.style.height = rowRect.height + 'px';
            this.renderer.addClass(ghost, ghostBackgroundClass);
            this.renderer.removeClass(ghost, rowSelectedClass);
            var ghostCells = ghost.getElementsByClassName(gridCellClass);
            for (var index = 0; index < ghostCells.length; index++) {
                this.renderer.removeClass(ghostCells[index], cellSelectedClass);
                this.renderer.removeClass(ghostCells[index], cellActiveClass);
            }
        };
        IgxRowDragDirective.prototype._unsubscribe = function () {
            if (this.subscription$ && !this.subscription$.closed) {
                this.subscription$.unsubscribe();
            }
        };
        IgxRowDragDirective.prototype.endDragging = function () {
            this.onTransitionEnd(null);
            this.row.dragging = false;
            this.row.grid.rowDragging = false;
            this.row.grid.markForCheck();
            this._unsubscribe();
        };
        Object.defineProperty(IgxRowDragDirective.prototype, "isHierarchicalGrid", {
            get: function () {
                return this.row.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input('igxRowDrag')
        ], IgxRowDragDirective.prototype, "data", null);
        IgxRowDragDirective = __decorate([
            core.Directive({
                selector: '[igxRowDrag]'
            })
        ], IgxRowDragDirective);
        return IgxRowDragDirective;
    }(IgxDragDirective));
    /**
     * @hidden
     */
    var IgxDragIndicatorIconDirective = /** @class */ (function () {
        function IgxDragIndicatorIconDirective() {
        }
        IgxDragIndicatorIconDirective = __decorate([
            core.Directive({
                selector: '[igxDragIndicatorIcon]'
            })
        ], IgxDragIndicatorIconDirective);
        return IgxDragIndicatorIconDirective;
    }());
    /**
     * @hidden
     */
    var IgxRowDragGhostDirective = /** @class */ (function () {
        function IgxRowDragGhostDirective(templateRef) {
            this.templateRef = templateRef;
        }
        IgxRowDragGhostDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxRowDragGhostDirective = __decorate([
            core.Directive({
                selector: '[igxRowDragGhost]'
            })
        ], IgxRowDragGhostDirective);
        return IgxRowDragGhostDirective;
    }());
    var IgxRowDragModule = /** @class */ (function () {
        function IgxRowDragModule() {
        }
        IgxRowDragModule = __decorate([
            core.NgModule({
                declarations: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
                entryComponents: [],
                exports: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
                imports: []
            })
        ], IgxRowDragModule);
        return IgxRowDragModule;
    }());

    var MINIMUM_COLUMN_WIDTH = 136;
    var FILTER_ROW_HEIGHT = 50;
    // By default row editing overlay outlet is inside grid body so that overlay is hidden below grid header when scrolling.
    // In cases when grid has 1-2 rows there isn't enough space in grid body and row editing overlay should be shown above header.
    // Default row editing overlay height is higher then row height that is why the case is valid also for row with 2 rows.
    // More accurate calculation is not possible, cause row editing overlay is still not shown and we don't know its height,
    // but in the same time we need to set row editing overlay outlet before opening the overlay itself.
    var MIN_ROW_EDITING_COUNT_THRESHOLD = 2;
    var IgxGridTransaction = new core.InjectionToken('IgxGridTransaction');
    var IgxGridBaseDirective = /** @class */ (function (_super) {
        __extends(IgxGridBaseDirective, _super);
        function IgxGridBaseDirective(selectionService, crudService, colResizingService, gridAPI, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this.selectionService = selectionService;
            _this.crudService = crudService;
            _this.colResizingService = colResizingService;
            _this.gridAPI = gridAPI;
            _this._transactions = _transactions;
            _this.elementRef = elementRef;
            _this.zone = zone;
            _this.document = document;
            _this.cdr = cdr;
            _this.resolver = resolver;
            _this.differs = differs;
            _this.viewRef = viewRef;
            _this.navigation = navigation;
            _this.filteringService = filteringService;
            _this.overlayService = overlayService;
            _this.summaryService = summaryService;
            _this._displayDensityOptions = _displayDensityOptions;
            _this._init = true;
            _this._cdrRequests = false;
            _this._cdrRequestRepaint = false;
            _this._resourceStrings = CurrentResourceStrings.GridResStrings;
            _this._emptyGridMessage = null;
            _this._emptyFilteredGridMessage = null;
            _this._isLoading = false;
            _this._locale = null;
            _this._destroyed = false;
            _this.overlayIDs = [];
            _this._advancedFilteringPositionSettings = {
                verticalDirection: exports.VerticalAlignment.Middle,
                horizontalDirection: exports.HorizontalAlignment.Center,
                horizontalStartPoint: exports.HorizontalAlignment.Center,
                verticalStartPoint: exports.VerticalAlignment.Middle
            };
            _this._advancedFilteringOverlaySettings = {
                closeOnOutsideClick: false,
                modal: false,
                positionStrategy: new ConnectedPositioningStrategy(_this._advancedFilteringPositionSettings),
            };
            /**
             * Gets/Sets whether to autogenerate the columns.
             * @remarks
             * The default value is false. When set to true, it will override all columns declared through code or in markup.
             * @example
             * ```html
             * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.autoGenerate = false;
            /**
             * Emitted after filtering is performed.
             * @remarks
             * Returns the filtering expressions tree of the column for which filtering was performed.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
             *              (filteringExpressionsTreeChange)="filteringExprTreeChange($event)"></igx-grid>
             * ```
            */
            _this.filteringExpressionsTreeChange = new core.EventEmitter();
            /**
             * Emitted after advanced filtering is performed.
             * @remarks
             * Returns the advanced filtering expressions tree.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
             *           (advancedFilteringExpressionsTreeChange)="advancedFilteringExprTreeChange($event)"></igx-grid>
             * ```
            */
            _this.advancedFilteringExpressionsTreeChange = new core.EventEmitter();
            /**
             *@hidden @internal
             */
            _this.pageChange = new core.EventEmitter();
            /**
             *@hidden @internal
             */
            _this.perPageChange = new core.EventEmitter();
            /**
             * @hidden
             * @internal
             */
            _this.rowDragging = false;
            /**
             * Gets/Sets the styling classes applied to all even `IgxGridRowComponent`s in the grid.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-even-class'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.evenRowCSS = 'igx-grid__tr--even';
            /**
             * Gets/Sets the styling classes applied to all odd `IgxGridRowComponent`s in the grid.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-odd-class'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.oddRowCSS = 'igx-grid__tr--odd';
            /**
             * Gets/Sets the title to be displayed in the built-in column hiding UI.
             * @example
             * ```html
             * <igx-grid [showToolbar]="true" [columnHiding]="true" columnHidingTitle="Column Hiding"></igx-grid>
             * ```
             */
            _this.columnHidingTitle = '';
            /**
             * Gets/Sets the title to be displayed in the UI of the column pinning.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [columnPinning]="'true" [columnPinningTitle]="'Column Hiding'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.columnPinningTitle = '';
            /**
             * Emitted when `IgxGridCellComponent` is clicked.
             * @remarks
             * Returns the `IgxGridCellComponent`.
             * @example
             * ```html
             * <igx-grid #grid (onCellClick)="onCellClick($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onCellClick = new core.EventEmitter();
            /**
             * Emitted when `IgxGridCellComponent` is selected.
             * @remarks
             *  Returns the `IgxGridCellComponent`.
             * @example
             * ```html
             * <igx-grid #grid (onSelection)="onCellSelect($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onSelection = new core.EventEmitter();
            /**
             *  Emitted when `IgxGridRowComponent` is selected.
             * @example
             * ```html
             * <igx-grid #grid (onRowSelectionChange)="onCellClickChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onRowSelectionChange = new core.EventEmitter();
            /**
             * Emitted when `IgxColumnComponent` is pinned.
             * @remarks
             * The index that the column is inserted at may be changed through the `insertAtIndex` property.
             * @example
             * ```typescript
             * public columnPinning(event) {
             *     if (event.column.field === "Name") {
             *       event.insertAtIndex = 0;
             *     }
             * }
             * ```
             */
            _this.onColumnPinning = new core.EventEmitter();
            /**
             * Emitted when editing and **not** submitting the value.
             * @remarks
             * (e.g. `Esc` key was pressed)
             * This event is cancelable.
             *@example
             * ```html
             * <igx-grid #grid3 (onCellEditCancel)="editCancel($event)" [data]="data" [primaryKey]="'ProductID'">
             * </igx-grid>
             * ```
             */
            _this.onCellEditCancel = new core.EventEmitter();
            /**
             * Emitted when cell enters edit mode.
             * @remarks
             * This event is cancelable.
             *@example
             * ```html
             * <igx-grid #grid3 (onCellEditEnter)="editStart($event)" [data]="data" [primaryKey]="'ProductID'">
             * </igx-grid>
             * ```
             */
            _this.onCellEditEnter = new core.EventEmitter();
            /**
             * Emitted when cell has been edited.
             * @remarks
             * Event is fired after editing is completed, when the cell is exiting edit mode.
             * This event is cancelable.
             * @example
             * ```html
             * <igx-grid #grid3 (onCellEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'">
             * </igx-grid>
             * ```
             */
            _this.onCellEdit = new core.EventEmitter();
            /**
             * Emitted when a row enters edit mode.
             * @remarks
             * Emitted when [rowEditable]="true".
             * This event is cancelable.
             *@example
             * ```html
             * <igx-grid #grid3 (onRowEditEnter)="editStart($event)" [primaryKey]="'ProductID'" [rowEditable]="true">
             * </igx-grid>
             * ```
             */
            _this.onRowEditEnter = new core.EventEmitter();
            /**
             * Emitted when exiting edit mode for a row.
             * @remarks
             * Emitted when [rowEditable]="true" & `endEdit(true)` is called.
             * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
             * performing paging operation, column resizing, pinning, moving or hitting  `Done`
             * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
             * This event is cancelable.
             *@example
             * ```html
             * <igx-grid #grid3 (onRowEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
             * </igx-grid>
             * ```
             */
            _this.onRowEdit = new core.EventEmitter();
            /**
             * Emitted when row editing is canceled.
             * @remarks
             * Emits when [rowEditable]="true" & `endEdit(false)` is called.
             * Emitted when changing hitting `Esc` key during cell editing and when click on the `Cancel` button
             * in the row editing overlay.
             * This event is cancelable.
             *@example
             * ```html
             * <igx-grid #grid3 (onRowEditCancel)="editCancel($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
             * </igx-grid>
             * ```
             */
            _this.onRowEditCancel = new core.EventEmitter();
            /**
             * Emitted when a column is initialized.
             * @remarks
             * Returns the column object.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [onColumnInit]="initColumns($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onColumnInit = new core.EventEmitter();
            /**
             * Emitted when sorting is performed through the UI.
             * @remarks
             * Returns the sorting expression.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSortingDone)="sortingDone($event)"></igx-grid>
             * ```
             */
            _this.onSortingDone = new core.EventEmitter();
            /**
             * Emitted when filtering is performed through the UI.
             * @remarks
             * Returns the filtering expressions tree of the column for which filtering was performed.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onFilteringDone)="filteringDone($event)"></igx-grid>
             * ```
             */
            _this.onFilteringDone = new core.EventEmitter();
            /**
             * Emitted when paging is performed.
             * @remarks
             * Returns an object consisting of the previous and next pages.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onPagingDone)="pagingDone($event)"></igx-grid>
             * ```
             */
            _this.onPagingDone = new core.EventEmitter();
            /**
             * Emitted when a row added through the API.
             * @remarks
             * Returns the data for the new `IgxGridRowComponent` object.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" (onRowAdded)="rowAdded($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onRowAdded = new core.EventEmitter();
            /**
             * Emitted when a row is deleted through API.
             * @remarks
             * Returns an `IRowDataEventArgs` object.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" (onRowDeleted)="rowDeleted($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onRowDeleted = new core.EventEmitter();
            /**
             * Emitted when a new chunk of data is loaded from virtualization.
             * @example
             * ```typescript
             *  <igx-grid #grid [data]="localData" [autoGenerate]="true" (onDataPreLoad)='handleDataPreloadEvent()'></igx-grid>
             * ```
             */
            _this.onDataPreLoad = new core.EventEmitter();
            /**
             * Emitted when column is resized.
             * @remarks
             * Returns the `IgxColumnComponent` object's old and new width.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" (onColumnResized)="resizing($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onColumnResized = new core.EventEmitter();
            /**
             * Emitted when a cell is right clicked.
             * @remarks
             * Returns the `IgxGridCellComponent` object.
             * ```html
             * <igx-grid #grid [data]="localData" (onContextMenu)="contextMenu($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onContextMenu = new core.EventEmitter();
            /**
             * Emitted when a cell is double clicked.
             * @remarks
             * Returns the `IgxGridCellComponent` object.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" (onDoubleClick)="dblClick($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onDoubleClick = new core.EventEmitter();
            /**
             * Emitted when column visibility is changed.
             * @remarks
             * Args: { column: any, newValue: boolean }
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnVisibilityChanged)="visibilityChanged($event)"></igx-grid>
             * ```
             */
            _this.onColumnVisibilityChanged = new core.EventEmitter();
            /**
             * Emitted when column moving starts.
             * @remarks
             * Returns the moved `IgxColumnComponent` object.
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingStart)="movingStart($event)"></igx-grid>
             * ```
             */
            _this.onColumnMovingStart = new core.EventEmitter();
            /**
             * Emitted during the column moving operation.
             * @remarks
             * Returns the source and target `IgxColumnComponent` objects. This event is cancelable.
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMoving)="moving($event)"></igx-grid>
             * ```
             */
            _this.onColumnMoving = new core.EventEmitter();
            /**
             * Emitted when column moving ends.
             * @remarks
             * Returns the source and target `IgxColumnComponent` objects.
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingEnd)="movingEnds($event)"></igx-grid>
             * ```
             */
            _this.onColumnMovingEnd = new core.EventEmitter();
            /**
             * Emitted when keydown is triggered over element inside grid's body.
             * @remarks
             * This event is fired only if the key combination is supported in the grid.
             * Return the target type, target object and the original event. This event is cancelable.
             * @example
             * ```html
             *  <igx-grid (onGridKeydown)="customKeydown($event)"></igx-grid>
             * ```
             */
            _this.onGridKeydown = new core.EventEmitter();
            /**
             * Emitted when start dragging a row.
             * @remarks
             * Return the dragged row.
             */
            _this.onRowDragStart = new core.EventEmitter();
            /**
             * Emitted when dropping a row.
             * @remarks
             * Return the dropped row.
             */
            _this.onRowDragEnd = new core.EventEmitter();
            /**
             * Emitted when a copy operation is executed.
             * @remarks
             * Fired only if copy behavior is enabled through the [`clipboardOptions`]{@link IgxGridBaseDirective#clipboardOptions}.
             */
            _this.onGridCopy = new core.EventEmitter();
            /**
             *@hidden @internal
             */
            _this.expansionStatesChange = new core.EventEmitter();
            /**
             * Emitted when the expanded state of a row gets changed.
             * @example
             * ```html
             * <igx-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onRowToggle = new core.EventEmitter();
            /**
             * @hidden @internal
             */
            _this.columnList = new core.QueryList();
            /**
             * @hidden @internal
            */
            _this.tmpOutlets = new core.QueryList();
            /**
            * The custom template, if any, that should be used when rendering a row expand indicator.
            */
            _this.rowExpandedIndicatorTemplate = null;
            /**
            * The custom template, if any, that should be used when rendering a row collapse indicator.
            */
            _this.rowCollapsedIndicatorTemplate = null;
            /**
            * The custom template, if any, that should be used when rendering a header expand indicator.
            */
            _this.headerExpandIndicatorTemplate = null;
            /**
            * The custom template, if any, that should be used when rendering a header collapse indicator.
            */
            _this.headerCollapseIndicatorTemplate = null;
            /**
             * @hidden @internal
             */
            _this.tabindex = 0;
            /**
             * @hidden @internal
             */
            _this.hostRole = 'grid';
            /**
             * Emitted before sorting is performed.
             * @remarks
             * Returns the sorting expressions.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [autoGenerate]="true" (sortingExpressionsChange)="sortingExprChange($event)"></igx-grid>
             * ```
            */
            _this.sortingExpressionsChange = new core.EventEmitter();
            /**
             * @hidden @internal
            */
            _this.columnsWithNoSetWidths = null;
            /* Toolbar related definitions */
            _this._showToolbar = false;
            _this._exportExcel = false;
            _this._exportCsv = false;
            _this._toolbarTitle = null;
            _this._exportText = null;
            _this._exportExcelText = null;
            _this._exportCsvText = null;
            _this._rowEditable = false;
            _this._filteredSortedData = null;
            /**
             * Provides access to the `IgxToolbarComponent`.
             * @example
             * ```typescript
             * const gridToolbar = this.grid.toolbar;
             * ```
             */
            _this.toolbar = null;
            _this.toolbarHtml = null;
            /**
             * Controls the copy behavior of the grid.
             */
            _this.clipboardOptions = {
                /**
                 * Enables/disables the copy behavior
                 */
                enabled: true,
                /**
                 * Include the columns headers in the clipboard output.
                 */
                copyHeaders: true,
                /**
                 * Apply the columns formatters (if any) on the data in the clipboard output.
                 */
                copyFormatters: true,
                /**
                 * The separator used for formatting the copy output. Defaults to `\t`.
                 */
                separator: '\t'
            };
            /**
             * Emitted when an export process is initiated by the user.
             * @example
             * ```typescript
             * toolbarExporting(event: IGridToolbarExportEventArgs){
             *     const toolbarExporting = event;
             * }
             * ```
             */
            _this.onToolbarExporting = new core.EventEmitter();
            /* End of toolbar related definitions */
            /**
             * Emitted when making a range selection.
             * @remarks
             * Range selection can be made either through drag selection or through keyboard selection.
             */
            _this.onRangeSelection = new core.EventEmitter();
            /**
             * @hidden @internal
             */
            _this.calcHeight = 0;
            /**
             * @hidden @internal
             */
            _this.chipsGoupingExpressions = [];
            /**
             * @hidden @internal
             */
            _this.disableTransitions = false;
            /**
             * @hidden @internal
             */
            _this.lastSearchInfo = {
                searchText: '',
                caseSensitive: false,
                exactMatch: false,
                activeMatchIndex: 0,
                matchInfoCache: []
            };
            /**
             * @hidden @internal
             */
            _this.columnWidthSetByUser = false;
            /**
             * @hidden
             */
            _this.destroy$ = new rxjs.Subject();
            /**
             * @hidden
             */
            _this._perPage = 15;
            /**
             * @hidden
             */
            _this._page = 0;
            /**
             * @hidden
             */
            _this._paging = false;
            /**
             * @hidden
             */
            _this._hideRowSelectors = false;
            /**
             * @hidden
             */
            _this._rowDrag = false;
            /**
             * @hidden
             */
            _this._pipeTrigger = 0;
            /**
             * @hidden
             */
            _this._filteringPipeTrigger = 0;
            /**
             * @hidden
             */
            _this._summaryPipeTrigger = 0;
            /**
             * @hidden
             */
            _this._columns = [];
            /**
             * @hidden
             */
            _this._pinnedColumns = [];
            /**
             * @hidden
             */
            _this._unpinnedColumns = [];
            /**
             * @hidden
             */
            _this._filteringExpressionsTree = new FilteringExpressionsTree(exports.FilteringLogic.And);
            /**
             * @hidden
             */
            _this._sortingExpressions = [];
            /**
             * @hidden
             */
            _this._maxLevelHeaderDepth = null;
            /**
             * @hidden
             */
            _this._columnHiding = false;
            /**
             * @hidden
             */
            _this._columnPinning = false;
            _this._allowFiltering = false;
            _this._allowAdvancedFiltering = false;
            _this._filterMode = exports.FilterMode.quickFilter;
            _this.observer = new ResizeObserver(function () { });
            _this.resizeNotify = new rxjs.Subject();
            _this._hiddenColumnsText = '';
            _this._pinnedColumnsText = '';
            _this._height = '100%';
            _this._width = '100%';
            _this._horizontalForOfs = [];
            _this._multiRowLayoutRowSize = 1;
            _this._expansionStates = new Map();
            _this._defaultExpandState = false;
            // Caches
            _this._totalWidth = NaN;
            _this._pinnedVisible = [];
            _this._unpinnedVisible = [];
            _this._pinnedWidth = NaN;
            _this._unpinnedWidth = NaN;
            _this._visibleColumns = [];
            _this._columnGroups = false;
            _this._autoGeneratedCols = [];
            _this._headerFeaturesWidth = NaN;
            _this._defaultTargetRecordNumber = 10;
            _this._summaryPosition = exports.GridSummaryPosition.bottom;
            _this._summaryCalculationMode = exports.GridSummaryCalculationMode.rootAndChildLevels;
            _this._cellSelectionMode = exports.GridSelectionMode.multiple;
            _this._rowSelectionMode = exports.GridSelectionMode.none;
            _this.rowEditPositioningStrategy = new RowEditPositionStrategy({
                horizontalDirection: exports.HorizontalAlignment.Right,
                verticalDirection: exports.VerticalAlignment.Bottom,
                horizontalStartPoint: exports.HorizontalAlignment.Left,
                verticalStartPoint: exports.VerticalAlignment.Bottom,
                closeAnimation: null
            });
            _this.rowEditSettings = {
                scrollStrategy: new AbsoluteScrollStrategy(),
                modal: false,
                closeOnOutsideClick: false,
                outlet: _this.rowOutletDirective,
                positionStrategy: _this.rowEditPositioningStrategy
            };
            _this.verticalScrollHandler = function (event) {
                _this.verticalScrollContainer.onScroll(event);
                if (isEdge()) {
                    _this.wheelHandler(false);
                }
                _this.disableTransitions = true;
                _this.zone.run(function () {
                    _this.zone.onStable.pipe(operators.first()).subscribe(function () {
                        _this.verticalScrollContainer.onChunkLoad.emit(_this.verticalScrollContainer.state);
                    });
                    if (_this.rowEditable) {
                        _this.changeRowEditingOverlayStateOnScroll(_this.rowInEditMode);
                    }
                });
                _this.disableTransitions = false;
                _this.hideOverlays();
            };
            _this.horizontalScrollHandler = function (event) {
                var scrollLeft = event.target.scrollLeft;
                if (isEdge()) {
                    _this.wheelHandler(true);
                }
                _this.headerContainer.onHScroll(scrollLeft);
                _this._horizontalForOfs.forEach(function (vfor) { return vfor.onHScroll(scrollLeft); });
                _this.cdr.markForCheck();
                _this.zone.run(function () {
                    _this.zone.onStable.pipe(operators.first()).subscribe(function () {
                        _this.parentVirtDir.onChunkLoad.emit(_this.headerContainer.state);
                    });
                });
                _this.hideOverlays();
            };
            _this.keydownHandler = function (event) {
                var key = event.key.toLowerCase();
                if ((isNavigationKey(key) && event.keyCode !== 32) || key === 'tab' || key === 'pagedown' || key === 'pageup') {
                    event.preventDefault();
                    if (key === 'pagedown') {
                        _this.verticalScrollContainer.scrollNextPage();
                        _this.nativeElement.focus();
                    }
                    else if (key === 'pageup') {
                        _this.verticalScrollContainer.scrollPrevPage();
                        _this.nativeElement.focus();
                    }
                }
            };
            /**
             * @hidden @internal
            */
            _this.scrollHandler = function (event) {
                _this.headerContainer.scrollPosition += event.target.scrollLeft;
                _this.verticalScrollContainer.scrollPosition += event.target.scrollTop;
                event.target.scrollLeft = 0;
                event.target.scrollTop = 0;
            };
            /**
             * @hidden @internal
             */
            _this.wheelHandler = function (isScroll) {
                if (isScroll === void 0) { isScroll = false; }
                if (_this.document.activeElement &&
                    // tslint:disable-next-line:no-bitwise
                    (_this.document.activeElement.compareDocumentPosition(_this.tbody.nativeElement) & Node.DOCUMENT_POSITION_CONTAINS ||
                        // tslint:disable-next-line:no-bitwise
                        (_this.document.activeElement.
                            compareDocumentPosition(_this.tfoot.nativeElement) & Node.DOCUMENT_POSITION_CONTAINS && isScroll))) {
                    _this.document.activeElement.blur();
                }
            };
            /**
             * @hidden
             */
            _this.rowEditingWheelHandler = function (event) {
                if (event.deltaY > 0) {
                    _this.verticalScrollContainer.scrollNext();
                }
                else {
                    _this.verticalScrollContainer.scrollPrev();
                }
            };
            _this.cdr.detach();
            return _this;
        }
        Object.defineProperty(IgxGridBaseDirective.prototype, "scrollWidth", {
            get: function () {
                return this._scrollWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "resourceStrings", {
            get: function () {
                return this._resourceStrings;
            },
            /**
             * Gets/Sets the resource strings.
             * @remarks
             * By default it uses EN resources.
            */
            set: function (value) {
                this._resourceStrings = Object.assign({}, this._resourceStrings, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filteringLogic", {
            /**
             * Gets/Sets the filtering logic of the `IgxGridComponent`.
             * @remarks
             * The default is AND.
             * @example
             * ```html
             * <igx-grid [data]="Data" [autoGenerate]="true" [filteringLogic]="filtering"></igx-grid>
             * ```
             */
            get: function () {
                return this._filteringExpressionsTree.operator;
            },
            set: function (value) {
                this._filteringExpressionsTree.operator = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filteringExpressionsTree", {
            /**
             * Gets/Sets the filtering state.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(filteringExpressionsTree)]="model.filteringExpressions"></igx-grid>
             * ```
             * @remarks
             * Supports two-way binding.
             */
            get: function () {
                return this._filteringExpressionsTree;
            },
            set: function (value) {
                if (value && value instanceof FilteringExpressionsTree) {
                    var val = value;
                    for (var index = 0; index < val.filteringOperands.length; index++) {
                        if (!(val.filteringOperands[index] instanceof FilteringExpressionsTree)) {
                            var newExpressionsTree = new FilteringExpressionsTree(exports.FilteringLogic.And, val.filteringOperands[index].fieldName);
                            newExpressionsTree.filteringOperands.push(val.filteringOperands[index]);
                            val.filteringOperands[index] = newExpressionsTree;
                        }
                    }
                    value.type = exports.FilteringExpressionsTreeType.Regular;
                    this._filteringExpressionsTree = value;
                    this._filteringPipeTrigger++;
                    this.filteringExpressionsTreeChange.emit(this._filteringExpressionsTree);
                    if (this.filteringService.isFilteringExpressionsTreeEmpty(this._filteringExpressionsTree) &&
                        !this.advancedFilteringExpressionsTree) {
                        this.filteredData = null;
                    }
                    this.filteringService.refreshExpressions();
                    this.selectionService.clearHeaderCBState();
                    this.summaryService.clearSummaryCache();
                    this.notifyChanges();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "advancedFilteringExpressionsTree", {
            /**
             * Gets/Sets the advanced filtering state.
             * @example
             * ```typescript
             * let advancedFilteringExpressionsTree = this.grid.advancedFilteringExpressionsTree;
             * this.grid.advancedFilteringExpressionsTree = logic;
             * ```
             */
            get: function () {
                return this._advancedFilteringExpressionsTree;
            },
            set: function (value) {
                var _this = this;
                if (value && value instanceof FilteringExpressionsTree) {
                    value.type = exports.FilteringExpressionsTreeType.Advanced;
                    this._advancedFilteringExpressionsTree = value;
                    this._filteringPipeTrigger++;
                }
                else {
                    this._advancedFilteringExpressionsTree = null;
                }
                this.advancedFilteringExpressionsTreeChange.emit(this._advancedFilteringExpressionsTree);
                if (this.filteringService.isFilteringExpressionsTreeEmpty(this._advancedFilteringExpressionsTree) &&
                    !this.advancedFilteringExpressionsTree) {
                    this.filteredData = null;
                }
                this.selectionService.clearHeaderCBState();
                this.summaryService.clearSummaryCache();
                this.notifyChanges();
                // Wait for the change detection to update filtered data through the pipes and then emit the event.
                requestAnimationFrame(function () { return _this.onFilteringDone.emit(_this._advancedFilteringExpressionsTree); });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "locale", {
            /**
             * Gets/Sets the locale.
             * @remarks
             * If not set, returns browser's language.
             */
            get: function () {
                if (this._locale) {
                    return this._locale;
                }
                else {
                    return 'en';
                }
            },
            set: function (value) {
                this._locale = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "paging", {
            /**
             * Gets/Sets whether the paging feature is enabled.
             * @remarks
             * The default state is disabled (false).
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [autoGenerate]="true" [paging]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._paging;
            },
            set: function (value) {
                this._paging = value;
                this._pipeTrigger++;
                this.notifyChanges(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "page", {
            /**
             * Gets/Sets the current page index.
            *@example
            * ```html
             * <igx-grid #grid [data]="Data" [paging]="true" [(page)]="model.page" [autoGenerate]="true"></igx-grid>
             * ```
             * @remarks
             * Supports two-way binding.
             */
            get: function () {
                return this._page;
            },
            set: function (val) {
                if (val === this._page || val < 0 || val > this.totalPages - 1) {
                    return;
                }
                this.selectionService.clear(true);
                this.onPagingDone.emit({ previous: this._page, current: val });
                this._page = val;
                this.pageChange.emit(this._page);
                this.navigateTo(0);
                this.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "perPage", {
            /**
             * Gets/Sets the number of visible items per page.
             * @remarks
             * The default is 15.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [paging]="true" [(perPage)]="model.perPage" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._perPage;
            },
            set: function (val) {
                if (val < 0) {
                    return;
                }
                this.selectionService.clear(true);
                this._perPage = val;
                this.perPageChange.emit(this._perPage);
                this.page = 0;
                this.endEdit(true);
                this.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnHiding", {
            /**
             * Gets/Sets whether the column hiding UI is enabled.
             * @remarks
             * By default it is disabled (false). In order for the UI to work, you need to enable the toolbar as shown in the example below.
             * @example
             * ```html
             * <igx-grid [data]="Data" [autoGenerate]="true" [showToolbar]="true" [columnHiding]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._columnHiding;
            },
            set: function (value) {
                if (this._columnHiding !== value) {
                    this._columnHiding = value;
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowSelectable", {
            get: function () {
                return this.isRowSelectable;
            },
            set: function (val) {
                this.rowSelection = val ? exports.GridSelectionMode.multiple : exports.GridSelectionMode.none;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hideRowSelectors", {
            /**
             * Gets/Sets if the row selectors are hidden.
             * @remarks
             *  By default row selectors are shown
            */
            get: function () {
                return this._hideRowSelectors;
            },
            set: function (value) {
                this._hideRowSelectors = value;
                this.notifyChanges(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowDraggable", {
            /**
             * Gets/Sets whether rows can be moved.
             * @example
             * ```html
             * <igx-grid #grid [rowDraggable]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._rowDrag && this.hasVisibleColumns;
            },
            set: function (val) {
                this._rowDrag = val;
                this.notifyChanges(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowEditable", {
            /**
            * Gets/Sets whether the rows are editable.
            * @remarks
            * By default it is set to false.
            * @example
            * ```html
            * <igx-grid #grid [showToolbar]="true" [rowEditable]="true" [primaryKey]="'ProductID'" [columnHiding]="true"></igx-grid>
            * ```
            */
            get: function () {
                return this._rowEditable;
            },
            set: function (val) {
                if (!this._init) {
                    this.refreshGridState();
                }
                this._rowEditable = val;
                this.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "height", {
            /**
             * Gets/Sets the height.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._height;
            },
            set: function (value) {
                if (this._height !== value) {
                    this._height = value;
                    this.nativeElement.style.height = value;
                    this.notifyChanges(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hostWidth", {
            /**
             * @hidden @internal
            */
            get: function () {
                return this._width || this._hostWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "width", {
            /**
             * Gets/Sets the width of the grid.
             * @example
             * ```typescript
             * let gridWidth = this.grid.width;
             * ```
             */
            get: function () {
                return this._width;
            },
            set: function (value) {
                if (this._width !== value) {
                    this._width = value;
                    this.nativeElement.style.width = value;
                    this.notifyChanges(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "headerWidth", {
            /**
             * Gets the width of the header.
             * @example
             * ```html
             * let gridHeaderWidth = this.grid.headerWidth;
             * ```
             */
            get: function () {
                return parseInt(this.width, 10) - 17;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowHeight", {
            /**
             * Gets/Sets the row height.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [showToolbar]="true" [rowHeight]="100" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._rowHeight ? this._rowHeight : this.defaultRowHeight;
            },
            set: function (value) {
                this._rowHeight = parseInt(value, 10);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnWidth", {
            /**
             * Gets/Sets the default width of the columns.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [showToolbar]="true" [columnWidth]="100" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._columnWidth;
            },
            set: function (value) {
                this._columnWidth = value;
                this.columnWidthSetByUser = true;
                this.notifyChanges(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "emptyGridMessage", {
            get: function () {
                return this._emptyGridMessage || this.resourceStrings.igx_grid_emptyGrid_message;
            },
            /**
             * Get/Sets the message displayed when there are no records.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            set: function (value) {
                this._emptyGridMessage = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isLoading", {
            get: function () {
                return this._isLoading;
            },
            /**
             * Gets/Sets whether the grid is going to show a loading indicator.
             *@example
             * ```html
             * <igx-grid #grid [data]="Data" [isLoading]="true" [autoGenerate]="true"></igx-grid>
             * ```
             */
            set: function (value) {
                var _this = this;
                if (this._isLoading !== value) {
                    this._isLoading = value;
                    this.evaluateLoadingState();
                }
                Promise.resolve().then(function () {
                    // wait for the current detection cycle to end before triggering a new one.
                    _this.notifyChanges();
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "emptyFilteredGridMessage", {
            get: function () {
                return this._emptyFilteredGridMessage || this.resourceStrings.igx_grid_emptyFilteredGrid_message;
            },
            /**
             * Gets/Sets the message displayed when there are no records and the grid is filtered.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            set: function (value) {
                this._emptyFilteredGridMessage = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columnPinning", {
            /**
             * Gets/Sets if the built-in column pinning UI should be shown in the toolbar.
             * @example
            * ```html
             * <igx-grid #grid [data]="localData" [columnPinning]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._columnPinning;
            },
            set: function (value) {
                if (this._columnPinning !== value) {
                    this._columnPinning = value;
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "allowFiltering", {
            /**
             * Gets/Sets if the filtering is enabled.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [allowFiltering]="true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._allowFiltering;
            },
            set: function (value) {
                if (this._allowFiltering !== value) {
                    this._allowFiltering = value;
                    this.filteringService.registerSVGIcons();
                    if (!this._init) {
                        this.calcGridHeadRow();
                    }
                    this.filteringService.isFilterRowVisible = false;
                    this.filteringService.filteredColumn = null;
                    this.notifyChanges(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "allowAdvancedFiltering", {
            /**
             * Gets/Sets a value indicating whether the advanced filtering is enabled.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [allowAdvancedFiltering]="true" [showToolbar]="true" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._allowAdvancedFiltering;
            },
            set: function (value) {
                if (this._allowAdvancedFiltering !== value) {
                    this._allowAdvancedFiltering = value;
                    this.filteringService.registerSVGIcons();
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filterMode", {
            /**
             * Gets/Sets the filter mode.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [filterMode]="'quickFilter'" [height]="'305px'" [autoGenerate]="true"></igx-grid>
             * ```
             * @remarks
             * By default it's set to FilterMode.quickFilter.
             */
            get: function () {
                return this._filterMode;
            },
            set: function (value) {
                this._filterMode = value;
                if (this.filteringService.isFilterRowVisible) {
                    this.filteringRow.close();
                }
                this.notifyChanges(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "summaryPosition", {
            /**
             * Gets/Sets the summary position.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" summaryPosition="top" [autoGenerate]="true"></igx-grid>
             * ```
             * @remarks
             * By default it is bottom.
             */
            get: function () {
                return this._summaryPosition;
            },
            set: function (value) {
                this._summaryPosition = value;
                this.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "summaryCalculationMode", {
            /**
             * Gets/Sets the summary calculation mode.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" summaryCalculationMode="rootLevelOnly" [autoGenerate]="true"></igx-grid>
             * ```
             * @remarks
             * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.
             */
            get: function () {
                return this._summaryCalculationMode;
            },
            set: function (value) {
                this._summaryCalculationMode = value;
                if (!this._init) {
                    this.endEdit(true);
                    this.summaryService.resetSummaryHeight();
                    this.notifyChanges(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filterStrategy", {
            /**
             * Gets/Sets the filtering strategy of the grid.
             * @example
             * ```html
             *  <igx-grid #grid [data]="localData" [filterStrategy]="filterStrategy"></igx-grid>
             * ```
             */
            get: function () {
                return this._filteringStrategy;
            },
            set: function (classRef) {
                this._filteringStrategy = classRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "sortStrategy", {
            /**
             * Gets/Sets the sorting strategy of the grid.
             * @example
             * ```html
             *  <igx-grid #grid [data]="localData" [sortStrategy]="sortStrategy"></igx-grid>
             * ```
             */
            get: function () {
                return this._sortingStrategy;
            },
            set: function (value) {
                this._sortingStrategy = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "headerGroupsList", {
            /**
             * A list of all `IgxGridHeaderGroupComponent`.
             * @example
             * ```typescript
             * const headerGroupsList = this.grid.headerGroupsList;
             * ```
             */
            get: function () {
                return this.headerGroups ? flatten(this.headerGroups.toArray()) : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "headerCellList", {
            /**
             * A list of all `IgxGridHeaderComponent`.
             * @example
             * ```typescript
             * const headers = this.grid.headerCellList;
             * ```
             */
            get: function () {
                return this.headerGroupsList.map(function (headerGroup) { return headerGroup.headerCell; }).filter(function (headerCell) { return headerCell; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filterCellList", {
            /**
             * A list of all `IgxGridFilteringCellComponent`.
             * @example
             * ```typescript
             * const filterCells = this.grid.filterCellList;
             * ```
             */
            get: function () {
                return this.headerGroupsList.map(function (headerGroup) { return headerGroup.filterCell; }).filter(function (filterCell) { return filterCell; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "summariesRowList", {
            /**
             * @hidden @internal
            */
            get: function () {
                var res = new core.QueryList();
                if (!this._summaryRowList) {
                    return res;
                }
                var sumList = this._summaryRowList.filter(function (item) {
                    return item.element.nativeElement.parentElement !== null;
                });
                res.reset(sumList);
                return res;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowList", {
            /**
             * A list of `IgxGridRowComponent`.
             * @example
             * ```typescript
             * const rowList = this.grid.rowList;
             * ```
             */
            get: function () {
                var res = new core.QueryList();
                if (!this._rowList) {
                    return res;
                }
                var rList = this._rowList
                    .filter(function (item) {
                    return item.element.nativeElement.parentElement !== null;
                })
                    .sort(function (a, b) {
                    return a.index - b.index;
                });
                res.reset(rList);
                return res;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "dataRowList", {
            /**
             * A list of currently rendered `IgxGridRowComponent`'s.
             * @example
             * ```typescript
             * const dataList = this.grid.dataRowList;
             * ```
             */
            get: function () {
                var res = new core.QueryList();
                if (!this._dataRowList) {
                    return res;
                }
                var rList = this._dataRowList.filter(function (item) {
                    return item.element.nativeElement.parentElement !== null;
                }).sort(function (a, b) {
                    return a.index - b.index;
                });
                res.reset(rList);
                return res;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "toolbarCustomContentTemplate", {
            /**
             * Returns the template which will be used by the toolbar to show custom content.
             * @example
             * ```typescript
             * let customContentTemplate = this.grid.toolbarCustomContentTemplate;
             * ```
            */
            get: function () {
                return this.toolbarCustomContentTemplates.first;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "headSelectorTemplate", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.headSelectorsTemplates && this.headSelectorsTemplates.first) {
                    return this.headSelectorsTemplates.first.templateRef;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowSelectorTemplate", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.rowSelectorsTemplates && this.rowSelectorsTemplates.first) {
                    return this.rowSelectorsTemplates.first.templateRef;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "outletDirective", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._outletDirective;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowOutletDirective", {
            /**
             * @hidden @internal
            */
            get: function () {
                return this.rowEditingOutletDirective;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "parentRowOutletDirective", {
            /**
             * @hidden @internal
            */
            get: function () {
                return this.outletDirective;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowEditContainer", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.rowEditCustom ? this.rowEditCustom : this.defaultRowEditTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "dragIndicatorIconTemplate", {
            /**
            * The custom template, if any, that should be used when rendering the row drag indicator icon
            */
            get: function () {
                return this._customDragIndicatorIconTemplate || this.dragIndicatorIconTemplates.first;
            },
            set: function (val) {
                this._customDragIndicatorIconTemplate = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowInEditMode", {
            /**
             * @hidden @internal
            */
            get: function () {
                var editRowState = this.crudService.row;
                return editRowState !== null ? this.rowList.find(function (e) { return e.rowID === editRowState.id; }) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "firstEditableColumnIndex", {
            /**
             * @hidden @internal
             */
            get: function () {
                var index = this.navigation.gridOrderedColumns.findIndex(function (e) { return e.editable; });
                return index !== -1 ? index : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "lastEditableColumnIndex", {
            /**
             * @hidden @internal
             */
            get: function () {
                var orderedColumns = this.navigation.gridOrderedColumns;
                var index = orderedColumns.reverse().findIndex(function (e) { return e.editable; });
                return index !== -1 ? orderedColumns.length - 1 - index : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowEditTabs", {
            /**
             * @hidden @internal
             * TODO: Nav service logic doesn't handle 0 results from this querylist
             */
            get: function () {
                return this.rowEditTabsCUSTOM.length ? this.rowEditTabsCUSTOM : this.rowEditTabsDEFAULT;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hostClass", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.getComponentDensityClass('igx-grid');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "bannerClass", {
            get: function () {
                var position = this.rowEditPositioningStrategy.isTop ? 'igx-banner__border-top' : 'igx-banner__border-bottom';
                return this.getComponentDensityClass('igx-banner') + " " + position;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pipeTrigger", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._pipeTrigger;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "filteringPipeTrigger", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._filteringPipeTrigger;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "summaryPipeTrigger", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._summaryPipeTrigger;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "sortingExpressions", {
            /**
             * Gets/Sets the sorting state.
             * @remarks
             * Supports two-way data binding.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(sortingExpressions)]="model.sortingExpressions"></igx-grid>
             * ```
             */
            get: function () {
                return this._sortingExpressions;
            },
            set: function (value) {
                this._sortingExpressions = cloneArray(value);
                this.sortingExpressionsChange.emit(this._sortingExpressions);
                this.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "maxLevelHeaderDepth", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this._maxLevelHeaderDepth === null) {
                    this._maxLevelHeaderDepth = this.hasColumnLayouts ?
                        this.columnList.reduce(function (acc, col) { return Math.max(acc, col.rowStart); }, 0) :
                        this.columnList.reduce(function (acc, col) { return Math.max(acc, col.level); }, 0);
                }
                return this._maxLevelHeaderDepth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hiddenColumnsCount", {
            /**
             * Gets the number of hidden columns.
             * @example
             * ```typescript
             * const hiddenCol = this.grid.hiddenColumnsCount;
             * ``
             */
            get: function () {
                return this.columnList.filter(function (col) { return col.columnGroup === false && col.hidden === true; }).length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hiddenColumnsText", {
            /**
             * Gets/Sets the text to be displayed inside the toggle button.
             * @remarks
             * Used for the built-in column hiding UI of the`IgxColumnComponent`.
             * @example
             * ```html
             * <igx-grid [columnHiding]="true" [showToolbar]="true" [hiddenColumnsText]="'Hidden Columns'"></igx-grid>
             * ```
             */
            get: function () {
                return this._hiddenColumnsText;
            },
            set: function (value) {
                this._hiddenColumnsText = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedColumnsText", {
            /**
             * Gets/Sets the text to be displayed inside the toggle button.
             * @remarks
             * Used for the built-in column pinning UI of the`IgxColumnComponent`.
             * @example
             * ```html
             * <igx-grid [pinnedColumnsText]="'PinnedCols Text" [data]="data" [width]="'100%'" [height]="'500px'"></igx-grid>
             * ```
             */
            get: function () {
                return this._pinnedColumnsText;
            },
            set: function (value) {
                this._pinnedColumnsText = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "transactions", {
            /**
             * Get transactions service for the grid.
             */
            get: function () {
                return this._transactions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "currentRowState", {
            /**
             * @hidden @internal
            */
            get: function () {
                return this._currentRowState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "showToolbar", {
            /**
             * Gets/Sets whether the toolbar is shown.
             * @example
             * ```html
             * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" ></igx-grid>
             * ```
             */
            get: function () {
                return this._showToolbar;
            },
            set: function (newValue) {
                if (this._showToolbar !== newValue) {
                    this._showToolbar = newValue;
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "toolbarTitle", {
            /**
             * Gets/Sets the toolbar's title.
             * @example
             * ```html
             * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [toolbarTitle]="'My Grid'"></igx-grid>
             * ```
             */
            get: function () {
                return this._toolbarTitle;
            },
            set: function (newValue) {
                if (this._toolbarTitle !== newValue) {
                    this._toolbarTitle = newValue;
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "exportExcel", {
            /**
             * Gets/Sets whether exporting to MS Excel is enabled or disabled.
             * @example
             * ```html
             * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportExcel]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this.getExportExcel();
            },
            set: function (newValue) {
                if (this._exportExcel !== newValue) {
                    this._exportExcel = newValue;
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "exportCsv", {
            /**
             * Gets/Sets whether the option for exporting to CSV is enabled or disabled.
             * ```html
             * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportCsv]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this.getExportCsv();
            },
            set: function (newValue) {
                if (this._exportCsv !== newValue) {
                    this._exportCsv = newValue;
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "exportText", {
            /**
             * Gets/Sets the textual content for the main export button.
             * @example
             * ```html
             * <igx-grid [data]="localData" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._exportText;
            },
            set: function (newValue) {
                if (this._exportText !== newValue) {
                    this._exportText = newValue;
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "exportExcelText", {
            /**
             * Gets/Sets the textual content for the MS Excel export button.
             * ```html
             * <igx-grid [exportExcelText]="'My Excel Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._exportExcelText;
            },
            set: function (newValue) {
                if (this._exportExcelText !== newValue) {
                    this._exportExcelText = newValue;
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "exportCsvText", {
            /**
             * Gets/Sets the textual content for the CSV export button.
             * @example
             * ```html
             * <igx-grid [exportCsvText]="'My Csv Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportExcel]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._exportCsvText;
            },
            set: function (newValue) {
                if (this._exportCsvText !== newValue) {
                    this._exportCsvText = newValue;
                    if (!this._init) {
                        this.notifyChanges(true);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "cellSelection", {
            /**
             * Gets/Sets cell selection mode.
             * @remarks
             * By default the cell selection mode is multiple
             * @param selectionMode: GridSelectionMode
            */
            get: function () {
                return this._cellSelectionMode;
            },
            set: function (selectionMode) {
                this._cellSelectionMode = selectionMode;
                if (this.gridAPI.grid) {
                    this.selectionService.clear(true);
                    this.notifyChanges();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowSelection", {
            /**
             * Gets/Sets row selection mode
             * @remarks
             * By default the row selection mode is none
             * @param selectionMode: GridSelectionMode
            */
            get: function () {
                return this._rowSelectionMode;
            },
            set: function (selectionMode) {
                this._rowSelectionMode = selectionMode;
                if (this.gridAPI.grid && this.columnList) {
                    this.selectionService.clearAllSelectedRows();
                    this.notifyChanges(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @hidden
        * @internal
        */
        IgxGridBaseDirective.prototype.isDetailRecord = function (rec) {
            return false;
        };
        /**
        * @hidden
        * @internal
        */
        IgxGridBaseDirective.prototype.isGroupByRecord = function (rec) {
            return false;
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasDetails", {
            /**
            * @hidden
            * @internal
            */
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "virtualizationState", {
            /**
             * Returns the state of the grid virtualization.
             * @remarks
             * Includes the start index and how many records are rendered.
             * @example
             * ```typescript
             * const gridVirtState = this.grid1.virtualizationState;
             * ```
             */
            get: function () {
                return this.verticalScrollContainer.state;
            },
            /**
             * @hidden
             */
            set: function (state) {
                this.verticalScrollContainer.state = state;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @hidden
        * @internal
        */
        IgxGridBaseDirective.prototype.hideOverlays = function () {
            var _this = this;
            this.overlayIDs.forEach(function (overlayID) {
                _this.overlayService.hide(overlayID);
                _this.overlayService.onClosed.pipe(operators.filter(function (o) { return o.id === overlayID; }), operators.takeUntil(_this.destroy$)).subscribe(function () {
                    _this.nativeElement.focus();
                });
            });
        };
        IgxGridBaseDirective.prototype._setupServices = function () {
            this.gridAPI.grid = this;
            this.crudService.grid = this;
            this.selectionService.grid = this;
            this.navigation.grid = this;
            this.filteringService.grid = this;
            this.summaryService.grid = this;
        };
        IgxGridBaseDirective.prototype._setupListeners = function () {
            var _this = this;
            var destructor = operators.takeUntil(this.destroy$);
            this.onRowAdded.pipe(destructor).subscribe(function (args) { return _this.refreshGridState(args); });
            this.onRowDeleted.pipe(destructor).subscribe(function (args) {
                _this.summaryService.deleteOperation = true;
                _this.summaryService.clearSummaryCache(args);
            });
            this.transactions.onStateUpdate.pipe(destructor).subscribe(function () {
                _this.selectionService.clearHeaderCBState();
                _this.summaryService.clearSummaryCache();
                _this._pipeTrigger++;
                _this.notifyChanges();
                if (_this.transactions.getAggregatedChanges(false).length === 0) {
                    // Needs better check, calling 'transactions.clear()' will also trigger this
                    if (_this.gridAPI.atInexistingPage()) {
                        _this.page--;
                    }
                }
            });
            this.resizeNotify.pipe(destructor, operators.filter(function () { return !_this._init; }), operators.throttleTime(100))
                .subscribe(function () {
                _this.zone.run(function () {
                    _this.notifyChanges(true);
                });
            });
            this.onPagingDone.pipe(destructor).subscribe(function () {
                _this.endEdit(true);
                _this.selectionService.clear(true);
            });
            this.onColumnMoving.pipe(destructor).subscribe(function () { return _this.endEdit(true); });
            this.onColumnResized.pipe(destructor).subscribe(function () { return _this.endEdit(true); });
            this.overlayService.onOpening.pipe(destructor).subscribe(function (event) {
                if (_this._advancedFilteringOverlayId === event.id) {
                    var instance = event.componentRef.instance;
                    if (instance) {
                        instance.initialize(_this, _this.overlayService, event.id);
                    }
                }
            });
            this.overlayService.onOpened.pipe(destructor).subscribe(function (event) {
                // do not hide the advanced filtering overlay on scroll
                if (_this._advancedFilteringOverlayId === event.id) {
                    var instance = event.componentRef.instance;
                    if (instance) {
                        instance.setAddButtonFocus();
                    }
                    return;
                }
                if (_this.overlayService.getOverlayById(event.id).settings.outlet === _this.outletDirective &&
                    _this.overlayIDs.indexOf(event.id) < 0) {
                    _this.overlayIDs.push(event.id);
                }
            });
            this.overlayService.onClosed.pipe(destructor, operators.filter(function () { return !_this._init; })).subscribe(function (event) {
                if (_this._advancedFilteringOverlayId === event.id) {
                    _this._advancedFilteringOverlayId = null;
                    return;
                }
                var ind = _this.overlayIDs.indexOf(event.id);
                if (ind !== -1) {
                    _this.overlayIDs.splice(ind, 1);
                }
            });
            this.verticalScrollContainer.onDataChanging.pipe(destructor, operators.filter(function () { return !_this._init; })).subscribe(function ($event) {
                var shouldRecalcSize = _this.isPercentHeight &&
                    (!_this.calcHeight || _this.calcHeight === _this.getDataBasedBodyHeight() ||
                        _this.calcHeight === _this.renderedRowHeight * _this._defaultTargetRecordNumber);
                if (shouldRecalcSize) {
                    _this.calculateGridHeight();
                    $event.containerSize = _this.calcHeight;
                }
                _this.evaluateLoadingState();
            });
            this.verticalScrollContainer.onScrollbarVisibilityChanged.pipe(destructor, operators.filter(function () { return !_this._init; })).subscribe(function () {
                // called to recalc all widths that may have changes as a result of
                // the vert. scrollbar showing/hiding
                _this.notifyChanges(true);
            });
            this.verticalScrollContainer.onContentSizeChange.pipe(destructor, operators.filter(function () { return !_this._init; })).subscribe(function ($event) {
                _this.calculateGridSizes(false);
            });
            this.onDensityChanged.pipe(destructor).subscribe(function () {
                _this._headerFeaturesWidth = NaN;
                _this.summaryService.summaryHeight = 0;
                _this.endEdit(true);
                _this.cdr.markForCheck();
            });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this._setupServices();
            this._setupListeners();
            this.columnListDiffer = this.differs.find([]).create(null);
            this.calcWidth = this.width && this.width.indexOf('%') === -1 ? parseInt(this.width, 10) : 0;
            this.shouldGenerate = this.autoGenerate;
            this._scrollWidth = this.getScrollWidth();
        };
        IgxGridBaseDirective.prototype.setupColumns = function () {
            var _this = this;
            if (this.autoGenerate) {
                this.autogenerateColumns();
            }
            this.initColumns(this.columnList, function (col) { return _this.onColumnInit.emit(col); });
            this.columnListDiffer.diff(this.columnList);
            this.columnList.changes
                .pipe(operators.takeUntil(this.destroy$))
                .subscribe(function (change) { _this.onColumnsChanged(change); });
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.resetColumnsCaches = function () {
            this.columnList.forEach(function (column) { return column.resetCaches(); });
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.resetForOfCache = function () {
            var firstVirtRow = this.dataRowList.first;
            if (firstVirtRow) {
                if (this._cdrRequests) {
                    firstVirtRow.virtDirRow.cdr.detectChanges();
                }
                firstVirtRow.virtDirRow.assumeMaster();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.resetColumnCollections = function () {
            this._visibleColumns.length = 0;
            this._pinnedVisible.length = 0;
            this._unpinnedVisible.length = 0;
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.resetCachedWidths = function () {
            this._unpinnedWidth = NaN;
            this._pinnedWidth = NaN;
            this._totalWidth = NaN;
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.resetCaches = function (recalcFeatureWidth) {
            if (recalcFeatureWidth === void 0) { recalcFeatureWidth = true; }
            if (recalcFeatureWidth) {
                this._headerFeaturesWidth = NaN;
            }
            this.resetForOfCache();
            this.resetColumnsCaches();
            this.resetColumnCollections();
            this.resetCachedWidths();
            this.hasVisibleColumns = undefined;
            this._columnGroups = this.columnList.some(function (col) { return col.columnGroup; });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.ngAfterContentInit = function () {
            this.setupColumns();
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype._setupRowObservers = function () {
            var _this = this;
            var elementFilter = function (item) { return _this.isDefined(item.nativeElement.parentElement); };
            var extractForOfs = rxjs.pipe(operators.map(function (collection) { return collection.filter(elementFilter).map(function (item) { return item.virtDirRow; }); }));
            var rowListObserver = extractForOfs(this._dataRowList.changes);
            var summaryRowObserver = extractForOfs(this._summaryRowList.changes);
            var resetHorizontalForOfs = function () {
                _this._horizontalForOfs = __spread(_this._dataRowList.filter(elementFilter).map(function (item) { return item.virtDirRow; }), _this._summaryRowList.filter(elementFilter).map(function (item) { return item.virtDirRow; }));
            };
            rowListObserver.pipe(operators.takeUntil(this.destroy$)).subscribe(resetHorizontalForOfs);
            summaryRowObserver.pipe(operators.takeUntil(this.destroy$)).subscribe(resetHorizontalForOfs);
            resetHorizontalForOfs();
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype._zoneBegoneListeners = function () {
            var _this = this;
            this.zone.runOutsideAngular(function () {
                _this.nativeElement.addEventListener('keydown', _this.keydownHandler);
                _this.verticalScrollContainer.getScroll().addEventListener('scroll', _this.verticalScrollHandler);
                _this.headerContainer.getScroll().addEventListener('scroll', _this.horizontalScrollHandler);
                _this.observer = new ResizeObserver(function () { return _this.resizeNotify.next(); });
                _this.observer.observe(_this.nativeElement);
            });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.initPinning();
            this.calculateGridSizes();
            this._init = false;
            this.cdr.reattach();
            this._setupRowObservers();
            this._zoneBegoneListeners();
            var vertScrDC = this.verticalScrollContainer.displayContainer;
            vertScrDC.addEventListener('scroll', this.scrollHandler);
            vertScrDC.addEventListener('wheel', function () { return _this.wheelHandler(); });
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.notifyChanges = function (repaint) {
            if (repaint === void 0) { repaint = false; }
            this._cdrRequests = true;
            this._cdrRequestRepaint = repaint;
            this.cdr.markForCheck();
        };
        IgxGridBaseDirective.prototype.resetNotifyChanges = function () {
            this._cdrRequestRepaint = false;
            this._cdrRequests = false;
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.ngDoCheck = function () {
            _super.prototype.ngDoCheck.call(this);
            if (this._init) {
                return;
            }
            if (this._cdrRequestRepaint) {
                this.resetNotifyChanges();
                this.calculateGridSizes();
                this.refreshSearch(true);
                return;
            }
            if (this._cdrRequests) {
                this.resetNotifyChanges();
                this.cdr.detectChanges();
            }
        };
        /**
         * @hidden
         * @internal
        */
        IgxGridBaseDirective.prototype.getDragGhostCustomTemplate = function () {
            if (this.dragGhostCustomTemplates && this.dragGhostCustomTemplates.first) {
                return this.dragGhostCustomTemplates.first;
            }
            return null;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.ngOnDestroy = function () {
            var _this = this;
            this.tmpOutlets.forEach(function (tmplOutlet) {
                tmplOutlet.cleanCache();
            });
            this.destroy$.next(true);
            this.destroy$.complete();
            this._destroyed = true;
            if (this._advancedFilteringOverlayId) {
                this.overlayService.hide(this._advancedFilteringOverlayId);
            }
            this.zone.runOutsideAngular(function () {
                _this.observer.disconnect();
                _this.nativeElement.removeEventListener('keydown', _this.keydownHandler);
                _this.verticalScrollContainer.getScroll().removeEventListener('scroll', _this.verticalScrollHandler);
                _this.headerContainer.getScroll().removeEventListener('scroll', _this.horizontalScrollHandler);
                var vertScrDC = _this.verticalScrollContainer.displayContainer;
                vertScrDC.removeEventListener('scroll', _this.scrollHandler);
                vertScrDC.removeEventListener('wheel', function () { return _this.wheelHandler(); });
            });
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.dataLoading = function (event) {
            this.onDataPreLoad.emit(event);
        };
        /**
         * Toggles the specified column's visibility.
         * @example
         * ```typescript
         * this.grid1.toggleColumnVisibility({
         *       column: this.grid1.columns[0],
         *       newValue: true
         * });
         * ```
         */
        IgxGridBaseDirective.prototype.toggleColumnVisibility = function (args) {
            var col = args.column ? this.columnList.find(function (c) { return c === args.column; }) : undefined;
            if (!col) {
                return;
            }
            col.hidden = args.newValue;
            this.onColumnVisibilityChanged.emit(args);
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "expansionStates", {
            /**
             * Gets/Sets a list of key-value pairs [row ID, expansion state].
             * @remarks
             * Includes only states that differ from the default one.
             * Supports two-way binding.
             * @example
             * ```html
             * <igx-grid #grid [data]="data" [(expansionStates)]="model.expansionStates">
             * </igx-grid>
             * ```
             */
            get: function () {
                return this._expansionStates;
            },
            set: function (value) {
                this._expansionStates = new Map(value);
                this.expansionStatesChange.emit(this._expansionStates);
                if (this.gridAPI.grid) {
                    this.cdr.detectChanges();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
          * Expands all rows.
          * @example
          * ```typescript
          * this.grid.expandAll();
          * ```
         */
        IgxGridBaseDirective.prototype.expandAll = function () {
            this._defaultExpandState = true;
            this.expansionStates = new Map();
        };
        /**
          * Collapses all rows.
          * @example
          * ```typescript
          * this.grid.collapseAll();
          * ```
         */
        IgxGridBaseDirective.prototype.collapseAll = function () {
            this._defaultExpandState = false;
            this.expansionStates = new Map();
        };
        /**
         * Expands the row by its id.
         * @remarks
         * ID is either the primaryKey value or the data record instance.
         * @example
         * ```typescript
         * this.grid.expandRow(rowID);
         * ```
         * @param rowID The row id - primaryKey value or the data record instance.
         */
        IgxGridBaseDirective.prototype.expandRow = function (rowID) {
            this.gridAPI.set_row_expansion_state(rowID, true);
        };
        /**
         * Collapses the row by its id.
         * @remarks
         * ID is either the primaryKey value or the data record instance.
         * @example
         * ```typescript
         * this.grid.collapseRow(rowID);
         * ```
         * @param rowID The row id - primaryKey value or the data record instance.
        */
        IgxGridBaseDirective.prototype.collapseRow = function (rowID) {
            this.gridAPI.set_row_expansion_state(rowID, false);
        };
        /**
         * Toggles the row by its id.
         * @remarks
         * ID is either the primaryKey value or the data record instance.
         * @example
         * ```typescript
         * this.grid.toggleRow(rowID);
         * ```
         * @param rowID The row id - primaryKey value or the data record instance.
        */
        IgxGridBaseDirective.prototype.toggleRow = function (rowID) {
            var rec = this.gridAPI.get_rec_by_id(rowID);
            var state = this.gridAPI.get_row_expansion_state(rec);
            this.gridAPI.set_row_expansion_state(rowID, !state);
        };
        /**
         * @hidden
         * @internal
        */
        IgxGridBaseDirective.prototype.getDefaultExpandState = function (rec) {
            return this._defaultExpandState;
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "nativeElement", {
            /**
             * Gets the native element.
             * @example
             * ```typescript
             * const nativeEl = this.grid.nativeElement.
             * ```
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "outlet", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.outletDirective;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "defaultRowHeight", {
            /**
             * Gets the default row height.
             * @example
             * ```typescript
             * const rowHeigh = this.grid.defaultRowHeight;
             * ```
             */
            get: function () {
                switch (this.displayDensity) {
                    case exports.DisplayDensity.cosy:
                        return 40;
                    case exports.DisplayDensity.compact:
                        return 32;
                    default:
                        return 50;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "defaultSummaryHeight", {
            /**
             * @hidden @internal
             */
            get: function () {
                switch (this.displayDensity) {
                    case exports.DisplayDensity.cosy:
                        return 30;
                    case exports.DisplayDensity.compact:
                        return 24;
                    default:
                        return 36;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "defaultHeaderGroupMinWidth", {
            /**
             * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.
             * @remarks
             * Used internally for restricting header group component width.
             * The values below depend on the header cell default right/left padding values.
             */
            get: function () {
                switch (this.displayDensity) {
                    case exports.DisplayDensity.cosy:
                        return 32;
                    case exports.DisplayDensity.compact:
                        return 24;
                    default:
                        return 48;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.paginatorClassName = function () {
            switch (this.displayDensity) {
                case exports.DisplayDensity.cosy:
                    return 'igx-paginator--cosy';
                case exports.DisplayDensity.compact:
                    return 'igx-paginator--compact';
                default:
                    return 'igx-paginator';
            }
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedWidth", {
            /**
             * Gets the current width of the container for the pinned `IgxColumnComponent`s.
             * @example
             * ```typescript
             * const pinnedWidth = this.grid.getPinnedWidth;
             * ```
             */
            get: function () {
                if (!isNaN(this._pinnedWidth)) {
                    return this._pinnedWidth;
                }
                this._pinnedWidth = this.getPinnedWidth();
                return this._pinnedWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "unpinnedWidth", {
            /**
             * Gets the current width of the container for the unpinned `IgxColumnComponent`s.
             * @example
             * ```typescript
             * const unpinnedWidth = this.grid.getUnpinnedWidth;
             * ```
             */
            get: function () {
                if (!isNaN(this._unpinnedWidth)) {
                    return this._unpinnedWidth;
                }
                this._unpinnedWidth = this.getUnpinnedWidth();
                return this._unpinnedWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isHorizontalScrollHidden", {
            /**
             * @hidden @internal
            */
            get: function () {
                var diff = this.unpinnedWidth - this.totalWidth;
                return this.width === null || diff >= 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
         */
        IgxGridBaseDirective.prototype.featureColumnsWidth = function (expander) {
            if (Number.isNaN(this._headerFeaturesWidth)) {
                var rowSelectArea = this.headerSelectorContainer ?
                    this.headerSelectorContainer.nativeElement.getBoundingClientRect().width : 0;
                var rowDragArea = this.rowDraggable && this.headerDragContainer ?
                    this.headerDragContainer.nativeElement.getBoundingClientRect().width : 0;
                var groupableArea = this.headerGroupContainer ?
                    this.headerGroupContainer.nativeElement.getBoundingClientRect().width : 0;
                var expanderWidth = expander ? expander.nativeElement.getBoundingClientRect().width : 0;
                this._headerFeaturesWidth = rowSelectArea + rowDragArea + groupableArea + expanderWidth;
            }
            return this._headerFeaturesWidth;
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "summariesMargin", {
            /**
             * @hidden @internal
            */
            get: function () {
                return this.featureColumnsWidth();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "columns", {
            /**
             * Gets an array of `IgxColumnComponent`s.
             * @example
             * ```typescript
             * const colums = this.grid.columns.
             * ```
             */
            get: function () {
                return this._columns;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "pinnedColumns", {
            /**
             * Gets an array of the pinned `IgxColumnComponent`s.
             * @example
             * ```typescript
             * const pinnedColumns = this.grid.pinnedColumns.
             * ```
             */
            get: function () {
                if (this._pinnedVisible.length) {
                    return this._pinnedVisible;
                }
                this._pinnedVisible = this._pinnedColumns.filter(function (col) { return !col.hidden; });
                return this._pinnedVisible;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "unpinnedColumns", {
            /**
             * Gets an array of unpinned `IgxColumnComponent`s.
             * @example
             * ```typescript
             * const unpinnedColumns = this.grid.unpinnedColumns.
             * ```
             */
            get: function () {
                if (this._unpinnedVisible.length) {
                    return this._unpinnedVisible;
                }
                this._unpinnedVisible = this._unpinnedColumns.filter(function (col) { return !col.hidden; });
                return this._unpinnedVisible;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the `width` to be set on `IgxGridHeaderGroupComponent`.
         */
        IgxGridBaseDirective.prototype.getHeaderGroupWidth = function (column) {
            if (this.hasColumnLayouts) {
                return '';
            }
            var colWidth = column.width;
            var minWidth = this.defaultHeaderGroupMinWidth;
            var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (!isPercentageWidth && parseInt(colWidth, 10) < minWidth) {
                return minWidth + 'px';
            }
            return colWidth;
        };
        /**
         * Returns the `IgxColumnComponent` by field name.
         * @example
         * ```typescript
         * const myCol = this.grid1.getColumnByName("ID");
         * ```
         * @param name
        */
        IgxGridBaseDirective.prototype.getColumnByName = function (name) {
            return this.columnList.find(function (col) { return col.field === name; });
        };
        /**
         * Returns the `IgxRowDirective` by index.
         * @example
         * ```typescript
         * const myRow = this.grid1.getRowByIndex(1);
         * ```
         * @param index
        */
        IgxGridBaseDirective.prototype.getRowByIndex = function (index) {
            return this.gridAPI.get_row_by_index(index);
        };
        /**
         * Returns `IgxGridRowComponent` object by the specified primary key .
         * @remarks
         * Requires that the `primaryKey` property is set.
         * @example
         * ```typescript
         * const myRow = this.grid1.getRowByKey("cell5");
         * ```
         * @param keyValue
        */
        IgxGridBaseDirective.prototype.getRowByKey = function (keyValue) {
            return this.gridAPI.get_row_by_key(keyValue);
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "visibleColumns", {
            /**
             * Returns an array of visible `IgxColumnComponent`s.
             * @example
             * ```typescript
             * const visibleColumns = this.grid.visibleColumns.
             * ```
             */
            get: function () {
                if (this._visibleColumns.length) {
                    return this._visibleColumns;
                }
                this._visibleColumns = this.columnList.filter(function (c) { return !c.hidden; });
                return this._visibleColumns;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the `IgxGridCellComponent` that matches the conditions.
         * @example
         * ```typescript
         * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
         * ```
         * @param rowIndex
         * @param columnField
        */
        IgxGridBaseDirective.prototype.getCellByColumn = function (rowIndex, columnField) {
            var columnId = this.columnList.map(function (column) { return column.field; }).indexOf(columnField);
            if (columnId !== -1) {
                return this.gridAPI.get_cell_by_index(rowIndex, columnId);
            }
        };
        /**
         * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
         * @remarks
         * Requires that the primaryKey property is set.
         * @example
         * ```typescript
         * grid.getCellByKey(1, 'index');
         * ```
         * @param rowSelector match any rowID
         * @param columnField
        */
        IgxGridBaseDirective.prototype.getCellByKey = function (rowSelector, columnField) {
            return this.gridAPI.get_cell_by_key(rowSelector, columnField);
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "totalPages", {
            /**
             * Gets the total number of pages.
             * @example
             * ```typescript
             * const totalPages = this.grid.totalPages;
             * ```
             */
            get: function () {
                if (this.pagingState) {
                    return this.pagingState.metadata.countPages;
                }
                return -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isFirstPage", {
            /**
             * Gets if the current page is the first page.
             * @example
             * ```typescript
             * const firstPage = this.grid.isFirstPage;
             * ```
             */
            get: function () {
                return this.page === 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Goes to the next page, if the grid is not already at the last page.
         * @example
         * ```typescript
         * this.grid1.nextPage();
         * ```
         */
        IgxGridBaseDirective.prototype.nextPage = function () {
            if (!this.isLastPage) {
                this.page += 1;
            }
        };
        /**
         * Goes to the previous page, if the grid is not already at the first page.
         * @example
         * ```typescript
         * this.grid1.previousPage();
         * ```
         */
        IgxGridBaseDirective.prototype.previousPage = function () {
            if (!this.isFirstPage) {
                this.page -= 1;
            }
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "totalRecords", {
            /**
             * Returns the total number of records.
             * @remarks
             * Only functions when paging is enabled.
             * @example
             * ```typescript
             * const totalRecords = this.grid.totalRecords;
             * ```
             */
            get: function () {
                if (this.pagingState) {
                    return this.pagingState.metadata.countRecords;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isLastPage", {
            /**
             * Returns if the current page is the last page.
             * @example
             * ```typescript
             * const lastPage = this.grid.isLastPage;
             * ```
             */
            get: function () {
                return this.page + 1 >= this.totalPages;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "totalWidth", {
            /**
             * Returns the total width of the `IgxGridComponent`.
             * @example
             * ```typescript
             * const gridWidth = this.grid.totalWidth;
             * ```
             */
            get: function () {
                if (!isNaN(this._totalWidth)) {
                    return this._totalWidth;
                }
                // Take only top level columns
                var cols = this.visibleColumns.filter(function (col) { return col.level === 0 && !col.pinned; });
                var totalWidth = 0;
                var i = 0;
                for (i; i < cols.length; i++) {
                    totalWidth += parseInt(cols[i].calcWidth, 10) || 0;
                }
                this._totalWidth = totalWidth;
                return totalWidth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "showRowSelectors", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.isRowSelectable && this.hasVisibleColumns && !this.hideRowSelectors;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "showDragIcons", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.rowDraggable && this.columns.length > this.hiddenColumnsCount;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._moveColumns = function (from, to, pos) {
            var list = this.columnList.toArray();
            var fromIndex = list.indexOf(from);
            var toIndex = list.indexOf(to);
            if (pos === DropPosition.BeforeDropTarget) {
                toIndex--;
                if (toIndex < 0) {
                    toIndex = 0;
                }
            }
            if (pos === DropPosition.AfterDropTarget) {
                toIndex++;
            }
            list.splice.apply(list, __spread([toIndex, 0], list.splice(fromIndex, 1)));
            var newList = this._resetColumnList(list);
            this.columnList.reset(newList);
            this.columnList.notifyOnChanges();
            this._columns = this.columnList.toArray();
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._resetColumnList = function (list) {
            if (!list) {
                list = this.columnList.toArray();
            }
            var newList = [];
            list.filter(function (c) { return c.level === 0; }).forEach(function (p) {
                newList.push(p);
                if (p.columnGroup) {
                    newList = newList.concat(p.allChildren);
                }
            });
            return newList;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._reorderColumns = function (from, to, position, columnCollection) {
            var dropIndex = columnCollection.indexOf(to);
            if (to.columnGroup) {
                dropIndex += to.allChildren.length;
            }
            if (position === DropPosition.BeforeDropTarget) {
                dropIndex--;
            }
            if (position === DropPosition.AfterDropTarget) {
                dropIndex++;
            }
            columnCollection.splice.apply(columnCollection, __spread([dropIndex, 0], columnCollection.splice(columnCollection.indexOf(from), 1)));
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._moveChildColumns = function (parent, from, to, pos) {
            var buffer = parent.children.toArray();
            var fromIndex = buffer.indexOf(from);
            var toIndex = buffer.indexOf(to);
            if (pos === DropPosition.BeforeDropTarget) {
                toIndex--;
            }
            if (pos === DropPosition.AfterDropTarget) {
                toIndex++;
            }
            buffer.splice.apply(buffer, __spread([toIndex, 0], buffer.splice(fromIndex, 1)));
            parent.children.reset(buffer);
        };
        /**
         * Moves a column to the specified drop target.
         * @example
         * ```typescript
         * grid.moveColumn(compName, persDetails);
         * ```
          */
        IgxGridBaseDirective.prototype.moveColumn = function (column, dropTarget, pos) {
            if (pos === void 0) { pos = DropPosition.None; }
            var position = pos;
            var fromIndex = column.visibleIndex;
            var toIndex = dropTarget.visibleIndex;
            if (pos === DropPosition.BeforeDropTarget && fromIndex < toIndex) {
                position = DropPosition.BeforeDropTarget;
            }
            else if (pos === DropPosition.AfterDropTarget && fromIndex > toIndex) {
                position = DropPosition.AfterDropTarget;
            }
            else {
                position = DropPosition.None;
            }
            if ((column.level !== dropTarget.level) ||
                (column.topLevelParent !== dropTarget.topLevelParent)) {
                return;
            }
            this.endEdit(true);
            if (column.level) {
                this._moveChildColumns(column.parent, column, dropTarget, position);
            }
            if (dropTarget.pinned && column.pinned) {
                this._reorderColumns(column, dropTarget, position, this._pinnedColumns);
            }
            if (dropTarget.pinned && !column.pinned) {
                column.pin();
                this._reorderColumns(column, dropTarget, position, this._pinnedColumns);
            }
            if (!dropTarget.pinned && column.pinned) {
                column.unpin();
                var list = [];
                if (this.pinnedColumns.indexOf(column) === -1 && this.pinnedColumns.indexOf(dropTarget) === -1) {
                    list = this._unpinnedColumns;
                }
                else {
                    list = this._pinnedColumns;
                }
                var fi = list.indexOf(column);
                var ti = list.indexOf(dropTarget);
                if (pos === DropPosition.BeforeDropTarget && fi < ti) {
                    position = DropPosition.BeforeDropTarget;
                }
                else if (pos === DropPosition.AfterDropTarget && fi > ti) {
                    position = DropPosition.AfterDropTarget;
                }
                else {
                    position = DropPosition.None;
                }
            }
            if (!dropTarget.pinned) {
                this._reorderColumns(column, dropTarget, position, this._unpinnedColumns);
            }
            this._moveColumns(column, dropTarget, position);
            this.notifyChanges();
            if (this.hasColumnLayouts) {
                this.columns.filter(function (x) { return x.columnLayout; }).forEach(function (x) { return x.populateVisibleIndexes(); });
            }
            var args = {
                source: column,
                target: dropTarget
            };
            this.onColumnMovingEnd.emit(args);
        };
        /**
         * Goes to the desired page index.
         * @example
         * ```typescript
         * this.grid1.paginate(1);
         * ```
         * @param val
        */
        IgxGridBaseDirective.prototype.paginate = function (val) {
            if (val < 0 || val > this.totalPages - 1) {
                return;
            }
            this.page = val;
        };
        /**
         * Manually marks the `IgxGridComponent` for change detection.
         * @example
         * ```typescript
         * this.grid1.markForCheck();
         * ```
         */
        IgxGridBaseDirective.prototype.markForCheck = function () {
            this.cdr.detectChanges();
        };
        /**
         * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
         * @example
         * ```typescript
         * this.grid1.addRow(record);
         * ```
         * @param data
        */
        IgxGridBaseDirective.prototype.addRow = function (data) {
            // commit pending states prior to adding a row
            this.endEdit(true);
            this.gridAPI.addRowToData(data);
            this.onRowAdded.emit({ data: data });
            this._pipeTrigger++;
            this.notifyChanges();
        };
        /**
         * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
         * @remarks
         * Requires that the `primaryKey` property is set.
         * The method accept rowSelector as a parameter, which is the rowID.
         * @example
         * ```typescript
         * this.grid1.deleteRow(0);
         * ```
         * @param rowSelector
        */
        IgxGridBaseDirective.prototype.deleteRow = function (rowSelector) {
            if (this.primaryKey !== undefined && this.primaryKey !== null) {
                this.deleteRowById(rowSelector);
            }
        };
        /** @hidden */
        IgxGridBaseDirective.prototype.deleteRowById = function (rowId) {
            this.gridAPI.deleteRowById(rowId);
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.deleteRowFromData = function (rowID, index) {
            //  if there is a row (index !== 0) delete it
            //  if there is a row in ADD or UPDATE state change it's state to DELETE
            if (index !== -1) {
                if (this.transactions.enabled) {
                    var transaction = { id: rowID, type: exports.TransactionType.DELETE, newValue: null };
                    this.transactions.add(transaction, this.data[index]);
                }
                else {
                    this.data.splice(index, 1);
                }
            }
            else {
                var state = this.transactions.getState(rowID);
                this.transactions.add({ id: rowID, type: exports.TransactionType.DELETE, newValue: null }, state && state.recordRef);
            }
        };
        /**
         * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
         * @remarks
         * Requires that the `primaryKey` property is set.
         * @example
         * ```typescript
         * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
         * ```
         * @param value the new value which is to be set.
         * @param rowSelector corresponds to rowID.
         * @param column corresponds to column field.
        */
        IgxGridBaseDirective.prototype.updateCell = function (value, rowSelector, column) {
            if (this.isDefined(this.primaryKey)) {
                var col = this.columnList.toArray().find(function (c) { return c.field === column; });
                if (col) {
                    // Simplify
                    var rowData = this.gridAPI.getRowData(rowSelector);
                    var index = this.gridAPI.get_row_index_in_data(rowSelector);
                    // If row passed is invalid
                    if (index < 0) {
                        return;
                    }
                    var id = {
                        rowID: rowSelector,
                        columnID: col.index,
                        rowIndex: index
                    };
                    var cell = new IgxCell(id, index, col, rowData[col.field], rowData[col.field], rowData);
                    var args = this.gridAPI.update_cell(cell, value);
                    if (this.crudService.cell && this.crudService.sameCell(cell)) {
                        if (args.cancel) {
                            return;
                        }
                        this.gridAPI.escape_editMode();
                    }
                    this.cdr.detectChanges();
                }
            }
        };
        /**
         * Updates the `IgxGridRowComponent`
         * @remarks
         * The row is specified by
         * rowSelector parameter and the data source record with the passed value.
         * This method will apply requested update only if primary key is specified in the grid.
         * @example
         * ```typescript
         * grid.updateRow({
         *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
         *   }, 1);
         * ```
         * @param value
         * @param rowSelector correspond to rowID
        */
        IgxGridBaseDirective.prototype.updateRow = function (value, rowSelector) {
            if (this.isDefined(this.primaryKey)) {
                var editableCell = this.crudService.cell;
                if (editableCell && editableCell.id.rowID === rowSelector) {
                    this.gridAPI.escape_editMode();
                }
                var row = new IgxRow(rowSelector, -1, this.gridAPI.getRowData(rowSelector));
                this.gridAPI.update_row(row, value);
                // TODO: fix for #5934 and probably break for #5763
                // consider adding of third optional boolean parameter in updateRow.
                // If developer set this parameter to true we should call notifyChanges(true), and
                // vise-versa if developer set it to false we should call notifyChanges(false).
                // The parameter should default to false
                this.notifyChanges();
            }
        };
        /**
         * Sort a single `IgxColumnComponent`.
         * @remarks
         * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
         * @example
         * ```typescript
         * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
         * ```
         */
        IgxGridBaseDirective.prototype.sort = function (expression) {
            var _this = this;
            this.endEdit(false);
            if (expression instanceof Array) {
                this.gridAPI.sort_multiple(expression);
            }
            else {
                this.gridAPI.sort(expression);
            }
            requestAnimationFrame(function () { return _this.onSortingDone.emit(expression); });
        };
        /**
         * Filters a single `IgxColumnComponent`.
         * @example
         * ```typescript
         * public filter(term) {
         *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
         * }
         * ```
         * @param name
         * @param value
         * @param conditionOrExpressionTree
         * @param ignoreCase
        */
        IgxGridBaseDirective.prototype.filter = function (name, value, conditionOrExpressionTree, ignoreCase) {
            this.filteringService.filter(name, value, conditionOrExpressionTree, ignoreCase);
        };
        /**
         * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
         * @example
         * ```typescript
         * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
         * ```
         * @param value
         * @param condition
         * @param ignoreCase
        */
        IgxGridBaseDirective.prototype.filterGlobal = function (value, condition, ignoreCase) {
            this.filteringService.filterGlobal(value, condition, ignoreCase);
        };
        /**
         * Enables summaries for the specified column and applies your customSummary.
         * @remarks
         * If you do not provide the customSummary, then the default summary for the column data type will be applied.
         * @example
         * ```typescript
         * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
         * ```
         * Enable summaries for the listed columns.
         * @example
         * ```typescript
         * grid.enableSummaries('ProductName');
         * ```
         * @param rest
        */
        IgxGridBaseDirective.prototype.enableSummaries = function () {
            var rest = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                rest[_i] = arguments[_i];
            }
            if (rest.length === 1 && Array.isArray(rest[0])) {
                this._multipleSummaries(rest[0], true);
            }
            else {
                this._summaries(rest[0], true, rest[1]);
            }
        };
        /**
         * Disable summaries for the specified column.
         * @example
         * ```typescript
         * grid.disableSummaries('ProductName');
         * ```
         *@remarks
         * Disable summaries for the listed columns.
         *@example
         * ```typescript
         * grid.disableSummaries([{ fieldName: 'ProductName' }]);
         * ```
         */
        IgxGridBaseDirective.prototype.disableSummaries = function () {
            var rest = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                rest[_i] = arguments[_i];
            }
            if (rest.length === 1 && Array.isArray(rest[0])) {
                this._disableMultipleSummaries(rest[0]);
            }
            else {
                this._summaries(rest[0], false);
            }
        };
        /**
         * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`.
         *@remarks
         Otherwise clears the filtering state of all `IgxColumnComponent`s.
         *@example
         * ```typescript
         * this.grid.clearFilter();
         * ```
         * @param name
        */
        IgxGridBaseDirective.prototype.clearFilter = function (name) {
            this.filteringService.clearFilter(name);
        };
        /**
         * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`.
         * @remarks
         * otherwise clears the sorting state of all `IgxColumnComponent`.
         * @example
         * ```typescript
         * this.grid.clearSort();
         * ```
         * @param name
        */
        IgxGridBaseDirective.prototype.clearSort = function (name) {
            if (!name) {
                this.sortingExpressions = [];
                return;
            }
            if (!this.gridAPI.get_column_by_name(name)) {
                return;
            }
            this.gridAPI.clear_sort(name);
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.refreshGridState = function (args) {
            this.endEdit(true);
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache(args);
        };
        // TODO: We have return values here. Move them to event args ??
        /**
         * Pins a column by field name.
         * @remarks
         * Returns whether the operation is successful.
         * @example
         * ```typescript
         * this.grid.pinColumn("ID");
         * ```
         * @param columnName
         * @param index
        */
        IgxGridBaseDirective.prototype.pinColumn = function (columnName, index) {
            var col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
            return col.pin(index);
        };
        /**
         * Unpins a column by field name. Returns whether the operation is successful.
         * @example
         * ```typescript
         * this.grid.pinColumn("ID");
         * ```
         * @param columnName
         * @param index
        */
        IgxGridBaseDirective.prototype.unpinColumn = function (columnName, index) {
            var col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
            return col.unpin(index);
        };
        /**
         * Recalculates grid width/height dimensions.
         * @remarks
         * Should be run when changing DOM elements dimentions manually that affect the grid's size.
         * @example
         * ```typescript
         * this.grid.reflow();
         * ```
         */
        IgxGridBaseDirective.prototype.reflow = function () {
            this.calculateGridSizes();
        };
        /**
         * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
         * @remarks
         * Returns how many times the grid contains the string.
         * @example
         * ```typescript
         * this.grid.findNext("financial");
         * ```
         * @param text the string to search.
         * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
         * @param exactMatch optionally, if the text should match the entire value  (defaults to false).
        */
        IgxGridBaseDirective.prototype.findNext = function (text, caseSensitive, exactMatch) {
            return this.find(text, 1, caseSensitive, exactMatch);
        };
        /**
         * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
         * @remarks
         * Returns how many times the grid contains the string.
         * @example
         * ```typescript
         * this.grid.findPrev("financial");
         * ```
         * @param text the string to search.
         * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
         * @param exactMatch optionally, if the text should match the entire value (defaults to false).
        */
        IgxGridBaseDirective.prototype.findPrev = function (text, caseSensitive, exactMatch) {
            return this.find(text, -1, caseSensitive, exactMatch);
        };
        /**
         * Reapplies the existing search.
         * @remarks
         * Returns how many times the grid contains the last search.
         * @example
         * ```typescript
         * this.grid.refreshSearch();
         * ```
         * @param updateActiveInfo
        */
        IgxGridBaseDirective.prototype.refreshSearch = function (updateActiveInfo) {
            var _this = this;
            if (this.lastSearchInfo.searchText) {
                this.rebuildMatchCache();
                if (updateActiveInfo) {
                    var activeInfo_1 = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);
                    this.lastSearchInfo.matchInfoCache.forEach(function (match, i) {
                        if (match.column === activeInfo_1.column &&
                            match.row === activeInfo_1.row &&
                            match.index === activeInfo_1.index) {
                            _this.lastSearchInfo.activeMatchIndex = i;
                        }
                    });
                }
                return this.find(this.lastSearchInfo.searchText, 0, this.lastSearchInfo.caseSensitive, this.lastSearchInfo.exactMatch, false);
            }
            else {
                return 0;
            }
        };
        /**
         * Removes all the highlights in the cell.
         * @example
         * ```typescript
         * this.grid.clearSearch();
         * ```
         */
        IgxGridBaseDirective.prototype.clearSearch = function () {
            this.lastSearchInfo = {
                searchText: '',
                caseSensitive: false,
                exactMatch: false,
                activeMatchIndex: 0,
                matchInfoCache: []
            };
            this.rowList.forEach(function (row) {
                if (row.cells) {
                    row.cells.forEach(function (c) {
                        c.clearHighlight();
                    });
                }
            });
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasSortableColumns", {
            /**
             * Returns if the `IgxGridComponent` has sortable columns.
             * @example
             * ```typescript
             * const sortableGrid = this.grid.hasSortableColumns;
             * ```
             */
            get: function () {
                return this.columnList.some(function (col) { return col.sortable; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasEditableColumns", {
            /**
             * Returns if the `IgxGridComponent` has editable columns.
             * @example
             * ```typescript
             * const editableGrid = this.grid.hasEditableColumns;
             * ```
             */
            get: function () {
                return this.columnList.some(function (col) { return col.editable; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasFilterableColumns", {
            /**
             * Returns if the `IgxGridComponent` has fiterable columns.
             * @example
             * ```typescript
             * const filterableGrid = this.grid.hasFilterableColumns;
             * ```
             */
            get: function () {
                return this.columnList.some(function (col) { return col.filterable; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasSummarizedColumns", {
            /**
             * Returns if the `IgxGridComponent` has summarized columns.
             * @example
             * ```typescript
             * const summarizedGrid = this.grid.hasSummarizedColumns;
             * ```
             */
            get: function () {
                return this.summaryService.hasSummarizedColumns;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rootSummariesEnabled", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.summaryCalculationMode !== exports.GridSummaryCalculationMode.childLevelsOnly;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasVisibleColumns", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this._hasVisibleColumns === undefined) {
                    return this.columnList ? this.columnList.some(function (c) { return !c.hidden; }) : false;
                }
                return this._hasVisibleColumns;
            },
            set: function (value) {
                this._hasVisibleColumns = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasMovableColumns", {
            /**
             * Returns if the `IgxGridComponent` has moveable columns.
             * @example
             * ```typescript
             * const movableGrid = this.grid.hasMovableColumns;
             * ```
             */
            get: function () {
                return this.columnList && this.columnList.some(function (col) { return col.movable; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasColumnGroups", {
            /**
             * Returns if the `IgxGridComponent` has column groups.
             * @example
             * ```typescript
             * const groupGrid = this.grid.hasColumnGroups;
             * ```
             */
            get: function () {
                return this._columnGroups;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "hasColumnLayouts", {
            /**
             * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.
             * @example
             * ```typescript
             * const layoutGrid = this.grid.hasColumnLayouts;
             * ```
             */
            get: function () {
                return !!this.columnList.some(function (col) { return col.columnLayout; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "selectedCells", {
            /**
             * Returns an array of the selected `IgxGridCellComponent`s.
             * @example
             * ```typescript
             * const selectedCells = this.grid.selectedCells;
             * ```
             */
            get: function () {
                if (this.dataRowList) {
                    return this.dataRowList.map(function (row) { return row.cells.filter(function (cell) { return cell.selected; }); })
                        .reduce(function (a, b) { return a.concat(b); }, []);
                }
                return [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "multiRowLayoutRowSize", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._multiRowLayoutRowSize;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowBasedHeight", {
            /**
             * @hidden
             */
            get: function () {
                return this.dataLength * this.rowHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isPercentWidth", {
            /**
             * @hidden
             */
            get: function () {
                return this.width && this.width.indexOf('%') !== -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isPercentHeight", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this._height && this._height.indexOf('%') !== -1;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * Sets columns defaultWidth property
         */
        IgxGridBaseDirective.prototype._derivePossibleWidth = function () {
            var _this = this;
            if (!this.columnWidthSetByUser) {
                this._columnWidth = this.width !== null ? this.getPossibleColumnWidth() : MINIMUM_COLUMN_WIDTH + 'px';
            }
            this.columnList.forEach(function (column) {
                if (_this.hasColumnLayouts && parseInt(_this._columnWidth, 10)) {
                    var columnWidthCombined = parseInt(_this._columnWidth, 10) * (column.colEnd ? column.colEnd - column.colStart : 1);
                    column.defaultWidth = columnWidthCombined + 'px';
                }
                else {
                    column.defaultWidth = _this._columnWidth;
                    column.resetCaches();
                }
            });
            this.resetCachedWidths();
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "defaultTargetBodyHeight", {
            /**
             * @hidden
             */
            get: function () {
                var allItems = this.dataLength;
                return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "renderedRowHeight", {
            /**
             * @hidden @internal
             * The rowHeight input is bound to min-height css prop of rows that adds a 1px border in all cases
             */
            get: function () {
                return this.rowHeight + 1;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.calcGridHeadRow = function () {
            if (this.maxLevelHeaderDepth) {
                this._baseFontSize = parseFloat(getComputedStyle(this.document.documentElement).getPropertyValue('font-size'));
                var minSize = (this.maxLevelHeaderDepth + 1) * this.defaultRowHeight / this._baseFontSize;
                if (this._allowFiltering && this._filterMode === exports.FilterMode.quickFilter) {
                    minSize += (FILTER_ROW_HEIGHT + 1) / this._baseFontSize;
                }
                this.theadRow.nativeElement.style.minHeight = minSize + "rem";
            }
        };
        /**
         * @hidden
         * Sets TBODY height i.e. this.calcHeight
         */
        IgxGridBaseDirective.prototype.calculateGridHeight = function () {
            this.calcGridHeadRow();
            this.summariesHeight = 0;
            if (this.hasSummarizedColumns && this.rootSummariesEnabled) {
                this.summariesHeight = this.summaryService.calcMaxSummaryHeight();
            }
            this.calcHeight = this._calculateGridBodyHeight();
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getGroupAreaHeight = function () {
            return 0;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getToolbarHeight = function () {
            var toolbarHeight = 0;
            if (this.showToolbar && this.toolbarHtml != null) {
                toolbarHeight = this.toolbarHtml.nativeElement.firstElementChild ?
                    this.toolbarHtml.nativeElement.offsetHeight : 0;
            }
            return toolbarHeight;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getPagingHeight = function () {
            var pagingHeight = 0;
            if (this.paging && this.footer) {
                pagingHeight = this.footer.nativeElement.firstElementChild ?
                    this.footer.nativeElement.offsetHeight : 0;
            }
            return pagingHeight;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getFilterCellHeight = function () {
            var headerGroupNativeEl = (this.headerGroupsList.length !== 0) ?
                this.headerGroupsList[0].element.nativeElement : null;
            var filterCellNativeEl = (headerGroupNativeEl) ?
                headerGroupNativeEl.querySelector('igx-grid-filtering-cell') : null;
            return (filterCellNativeEl) ? filterCellNativeEl.offsetHeight : 0;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._calculateGridBodyHeight = function () {
            if (!this._height) {
                return null;
            }
            var actualTheadRow = (!this.allowFiltering || (this.allowFiltering && this.filterMode !== exports.FilterMode.quickFilter)) ?
                this.theadRow.nativeElement.offsetHeight - this.getFilterCellHeight() :
                this.theadRow.nativeElement.offsetHeight;
            var footerHeight = this.summariesHeight || this.tfoot.nativeElement.offsetHeight - this.tfoot.nativeElement.clientHeight;
            var toolbarHeight = this.getToolbarHeight();
            var pagingHeight = this.getPagingHeight();
            var groupAreaHeight = this.getGroupAreaHeight();
            var renderedHeight = toolbarHeight + actualTheadRow +
                footerHeight + pagingHeight + groupAreaHeight +
                this.scr.nativeElement.clientHeight;
            var computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('height');
            var gridHeight = 0;
            if (this.isPercentHeight) {
                var autoSize = this._shouldAutoSize(renderedHeight);
                if (autoSize || computed.indexOf('%') !== -1) {
                    var bodyHeight = this.getDataBasedBodyHeight();
                    return bodyHeight > 0 ? bodyHeight : null;
                }
                gridHeight = parseInt(computed, 10);
            }
            else {
                gridHeight = parseInt(this._height, 10);
            }
            var height = Math.abs(gridHeight - renderedHeight);
            if (height === 0 || isNaN(gridHeight)) {
                var bodyHeight = this.defaultTargetBodyHeight;
                return bodyHeight > 0 ? bodyHeight : null;
            }
            return height;
        };
        IgxGridBaseDirective.prototype.checkContainerSizeChange = function () {
            var origHeight = this.nativeElement.parentElement.offsetHeight;
            this.nativeElement.style.display = 'none';
            var height = this.nativeElement.parentElement.offsetHeight;
            this.nativeElement.style.display = '';
            return origHeight !== height;
        };
        IgxGridBaseDirective.prototype._shouldAutoSize = function (renderedHeight) {
            this.tbody.nativeElement.style.display = 'none';
            var res = !this.nativeElement.parentElement ||
                this.nativeElement.parentElement.clientHeight === 0 ||
                this.nativeElement.parentElement.clientHeight === renderedHeight;
            if (!isChromium()) {
                // If grid causes the parent container to extend (for example when container is flex)
                // we should always auto-size since the actual size of the container will continuously change as the grid renders elements.
                res = this.checkContainerSizeChange();
            }
            this.tbody.nativeElement.style.display = '';
            return res;
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "outerWidth", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.hasVerticalSroll() ? this.calcWidth + this.scrollWidth : this.calcWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         * Gets the visible content height that includes header + tbody + footer.
         */
        IgxGridBaseDirective.prototype.getVisibleContentHeight = function () {
            var height = this.theadRow.nativeElement.clientHeight + this.tbody.nativeElement.clientHeight;
            if (this.hasSummarizedColumns) {
                height += this.tfoot.nativeElement.clientHeight;
            }
            return height;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.getPossibleColumnWidth = function (baseWidth) {
            if (baseWidth === void 0) { baseWidth = null; }
            var computedWidth;
            if (baseWidth !== null) {
                computedWidth = baseWidth;
            }
            else {
                computedWidth = this.calcWidth ||
                    parseInt(this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width'), 10);
            }
            computedWidth -= this.featureColumnsWidth();
            var visibleChildColumns = this.visibleColumns.filter(function (c) { return !c.columnGroup; });
            // Column layouts related
            var visibleCols = [];
            var columnBlocks = this.visibleColumns.filter(function (c) { return c.columnGroup; });
            var colsPerBlock = columnBlocks.map(function (block) { return block.getInitialChildColumnSizes(block.children); });
            var combinedBlocksSize = colsPerBlock.reduce(function (acc, item) { return acc + item.length; }, 0);
            colsPerBlock.forEach(function (blockCols) { return visibleCols = visibleCols.concat(blockCols); });
            //
            var columnsWithSetWidths = this.hasColumnLayouts ?
                visibleCols.filter(function (c) { return c.widthSetByUser; }) :
                visibleChildColumns.filter(function (c) { return c.widthSetByUser; });
            var columnsToSize = this.hasColumnLayouts ?
                combinedBlocksSize - columnsWithSetWidths.length :
                visibleChildColumns.length - columnsWithSetWidths.length;
            var sumExistingWidths = columnsWithSetWidths
                .reduce(function (prev, curr) {
                var colWidth = curr.width;
                var widthValue = parseInt(colWidth, 10);
                var currWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1 ?
                    widthValue / 100 * computedWidth :
                    widthValue;
                return prev + currWidth;
            }, 0);
            // When all columns are hidden, return 0px width
            if (!sumExistingWidths && !columnsToSize) {
                return '0px';
            }
            var columnWidth = Math.floor(!Number.isFinite(sumExistingWidths) ?
                Math.max(computedWidth / columnsToSize, MINIMUM_COLUMN_WIDTH) :
                Math.max((computedWidth - sumExistingWidths) / columnsToSize, MINIMUM_COLUMN_WIDTH));
            return columnWidth + 'px';
        };
        /**
         * @hidden
         * Sets grid width i.e. this.calcWidth
         */
        IgxGridBaseDirective.prototype.calculateGridWidth = function () {
            var width;
            var computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width');
            if (this.isPercentWidth) {
                /* width in %*/
                width = computed.indexOf('%') === -1 ? parseInt(computed, 10) : null;
            }
            else {
                width = parseInt(this.width, 10);
            }
            if (!width && this.nativeElement) {
                width = this.nativeElement.offsetWidth;
            }
            if (this.width === null || !width) {
                width = this.getColumnWidthSum();
            }
            if (this.hasVerticalSroll() && this.width !== null) {
                width -= this.scrollWidth;
            }
            if ((Number.isFinite(width) || width === null) && width !== this.calcWidth) {
                this.calcWidth = width;
            }
            this._derivePossibleWidth();
        };
        IgxGridBaseDirective.prototype.getColumnWidthSum = function () {
            var colSum = 0;
            var cols = this.hasColumnLayouts ?
                this.visibleColumns.filter(function (x) { return x.columnLayout; }) : this.visibleColumns.filter(function (x) { return !x.columnGroup; });
            cols.forEach(function (item) {
                var isWidthInPercent = item.width && typeof item.width === 'string' && item.width.indexOf('%') !== -1;
                if (isWidthInPercent) {
                    item.width = item.calcWidth || MINIMUM_COLUMN_WIDTH + 'px';
                }
                colSum += parseInt((item.width || item.defaultWidth), 10) || MINIMUM_COLUMN_WIDTH;
            });
            if (!colSum) {
                return null;
            }
            this.cdr.detectChanges();
            colSum += this.featureColumnsWidth();
            return colSum;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.hasVerticalSroll = function () {
            if (this._init) {
                return false;
            }
            var isScrollable = this.verticalScrollContainer ? this.verticalScrollContainer.isScrollable() : false;
            return !!(this.calcWidth && this.dataView &&
                this.dataView.length > 0 &&
                isScrollable);
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.getDataBasedBodyHeight = function () {
            return !this.data || (this.data.length < this._defaultTargetRecordNumber) ?
                0 : this.defaultTargetBodyHeight;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.onColumnsChanged = function (change) {
            var _this = this;
            var diff = this.columnListDiffer.diff(change);
            if (this.autoGenerate && this.columnList.length === 0 && this._autoGeneratedCols.length > 0) {
                // In Ivy if there are nested conditional templates the content children are re-evaluated
                // hence autogenerated columns are cleared and need to be reset.
                this.columnList.reset(this._autoGeneratedCols);
                return;
            }
            if (diff) {
                var added_1 = false;
                var removed_1 = false;
                this.initColumns(this.columnList);
                diff.forEachAddedItem(function (record) {
                    _this.onColumnInit.emit(record.item);
                    added_1 = true;
                });
                diff.forEachRemovedItem(function (record) {
                    var isColumnGroup = record.item instanceof IgxColumnGroupComponent;
                    if (!isColumnGroup) {
                        // Clear Grouping
                        _this.gridAPI.clear_groupby(record.item.field);
                        // Clear Filtering
                        _this.gridAPI.clear_filter(record.item.field);
                        // Close filter row
                        if (_this.filteringService.isFilterRowVisible
                            && _this.filteringService.filteredColumn
                            && _this.filteringService.filteredColumn.field === record.item.field) {
                            _this.filteringRow.close();
                        }
                        // Clear Sorting
                        _this.gridAPI.clear_sort(record.item.field);
                    }
                    removed_1 = true;
                });
                this.resetCaches();
                if (added_1 || removed_1) {
                    this.summaryService.clearSummaryCache();
                    Promise.resolve().then(function () {
                        // `onColumnsChanged` can be executed midway a current detectChange cycle and markForCheck will be ignored then.
                        // This ensures that we will wait for the current cycle to end so we can trigger a new one and ngDoCheck to fire.
                        _this.notifyChanges(true);
                    });
                }
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.calculateGridSizes = function (recalcFeatureWidth) {
            var _this = this;
            if (recalcFeatureWidth === void 0) { recalcFeatureWidth = true; }
            /*
                TODO: (R.K.) This layered lasagne should be refactored
                ASAP. The reason I have to reset the caches so many times is because
                after teach `detectChanges` call they are filled with invalid
                state. Of course all of this happens midway through the grid
                sizing process which of course, uses values from the caches, thus resulting
                in a broken layout.
            */
            this.resetCaches(recalcFeatureWidth);
            this.cdr.detectChanges();
            var hasScroll = this.hasVerticalSroll();
            this.calculateGridWidth();
            this.resetCaches(recalcFeatureWidth);
            this.cdr.detectChanges();
            this.calculateGridHeight();
            if (this.rowEditable) {
                this.repositionRowEditingOverlay(this.rowInEditMode);
            }
            if (this.filteringService.isFilterRowVisible) {
                this.filteringRow.resetChipsArea();
            }
            this.cdr.detectChanges();
            // in case scrollbar has appeared recalc to size correctly.
            if (hasScroll !== this.hasVerticalSroll()) {
                this.calculateGridWidth();
                this.cdr.detectChanges();
            }
            if (this.zone.isStable) {
                this.zone.run(function () {
                    _this._applyWidthHostBinding();
                    _this.cdr.detectChanges();
                });
            }
            else {
                this.zone.onStable.pipe(operators.first()).subscribe(function () {
                    _this.zone.run(function () {
                        _this._applyWidthHostBinding();
                    });
                });
            }
            this.resetCaches(recalcFeatureWidth);
        };
        IgxGridBaseDirective.prototype._applyWidthHostBinding = function () {
            var width = this._width;
            if (width === null) {
                var currentWidth = this.calcWidth;
                if (this.hasVerticalSroll()) {
                    currentWidth += this.scrollWidth;
                }
                width = currentWidth + 'px';
                this.resetCaches();
            }
            this._hostWidth = width;
            this.cdr.markForCheck();
        };
        /**
         * Gets calculated width of the pinned area.
         * @example
         * ```typescript
         * const pinnedWidth = this.grid.getPinnedWidth();
         * ```
         * @param takeHidden If we should take into account the hidden columns in the pinned area.
        */
        IgxGridBaseDirective.prototype.getPinnedWidth = function (takeHidden) {
            var e_1, _a;
            if (takeHidden === void 0) { takeHidden = false; }
            var fc = takeHidden ? this._pinnedColumns : this.pinnedColumns;
            var sum = 0;
            try {
                for (var fc_1 = __values(fc), fc_1_1 = fc_1.next(); !fc_1_1.done; fc_1_1 = fc_1.next()) {
                    var col = fc_1_1.value;
                    if (col.level === 0) {
                        sum += parseInt(col.calcWidth, 10);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (fc_1_1 && !fc_1_1.done && (_a = fc_1.return)) _a.call(fc_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            sum += this.featureColumnsWidth();
            return sum;
        };
        /**
         * @hidden
         * Gets calculated width of the unpinned area
         * @param takeHidden If we should take into account the hidden columns in the pinned area.
        */
        IgxGridBaseDirective.prototype.getUnpinnedWidth = function (takeHidden) {
            if (takeHidden === void 0) { takeHidden = false; }
            var width = this.isPercentWidth ?
                this.calcWidth :
                parseInt(this.width, 10) || parseInt(this.hostWidth, 10) || this.calcWidth;
            if (this.hasVerticalSroll() && !this.isPercentWidth) {
                width -= this.scrollWidth;
            }
            return width - this.getPinnedWidth(takeHidden);
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._summaries = function (fieldName, hasSummary, summaryOperand) {
            var column = this.gridAPI.get_column_by_name(fieldName);
            if (column) {
                column.hasSummary = hasSummary;
                if (summaryOperand) {
                    if (this.rootSummariesEnabled) {
                        this.summaryService.retriggerRootPipe++;
                    }
                    column.summaries = summaryOperand;
                }
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._multipleSummaries = function (expressions, hasSummary) {
            var _this = this;
            expressions.forEach(function (element) {
                _this._summaries(element.fieldName, hasSummary, element.customSummary);
            });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype._disableMultipleSummaries = function (expressions) {
            var _this = this;
            expressions.forEach(function (column) {
                var columnName = column && column.fieldName ? column.fieldName : column;
                _this._summaries(columnName, false);
            });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.resolveDataTypes = function (rec) {
            if (typeof rec === 'number') {
                return exports.DataType.Number;
            }
            else if (typeof rec === 'boolean') {
                return exports.DataType.Boolean;
            }
            else if (typeof rec === 'object' && rec instanceof Date) {
                return exports.DataType.Date;
            }
            return exports.DataType.String;
        };
        IgxGridBaseDirective.prototype.getScrollWidth = function () {
            var div = document.createElement('div');
            var style = div.style;
            style.width = '100px';
            style.height = '100px';
            style.position = 'absolute';
            style.top = '-10000px';
            style.top = '-10000px';
            style.overflow = 'scroll';
            document.body.appendChild(div);
            var scrollWidth = div.offsetWidth - div.clientWidth;
            document.body.removeChild(div);
            return scrollWidth;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.autogenerateColumns = function () {
            var _this = this;
            var data = this.gridAPI.get_data();
            var factory = this.resolver.resolveComponentFactory(IgxColumnComponent);
            var fields = this.generateDataFields(data);
            var columns = [];
            fields.forEach(function (field) {
                var ref = factory.create(_this.viewRef.injector);
                ref.instance.field = field;
                ref.instance.dataType = _this.resolveDataTypes(data[0][field]);
                ref.changeDetectorRef.detectChanges();
                columns.push(ref.instance);
            });
            this._autoGeneratedCols = columns;
            this.columnList.reset(columns);
            if (data && data.length > 0) {
                this.shouldGenerate = false;
            }
        };
        IgxGridBaseDirective.prototype.generateDataFields = function (data) {
            return Object.keys(data && data.length !== 0 ? data[0] : []);
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.onlyTopLevel = function (arr) {
            return arr.filter(function (c) { return c.level === 0; });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.initColumns = function (collection, cb) {
            var _this = this;
            if (cb === void 0) { cb = null; }
            this._columnGroups = this.columnList.some(function (col) { return col.columnGroup; });
            if (this.hasColumnLayouts) {
                // Set overall row layout size
                this.columnList.forEach(function (col) {
                    if (col.columnLayout) {
                        var layoutSize = col.children ?
                            col.children.reduce(function (acc, val) { return Math.max(val.rowStart + val.gridRowSpan - 1, acc); }, 1) :
                            1;
                        _this._multiRowLayoutRowSize = Math.max(layoutSize, _this._multiRowLayoutRowSize);
                    }
                });
            }
            if (this.hasColumnLayouts && this.hasColumnGroups) {
                // invalid configuration - multi-row and column groups
                // remove column groups
                var columnLayoutColumns = this.columnList.filter(function (col) { return col.columnLayout || col.columnLayoutChild; });
                this.columnList.reset(columnLayoutColumns);
            }
            this._maxLevelHeaderDepth = null;
            this._columns = this.columnList.toArray();
            collection.forEach(function (column) {
                column.defaultWidth = _this.columnWidthSetByUser ? _this._columnWidth : column.defaultWidth ? column.defaultWidth : '';
                if (cb) {
                    cb(column);
                }
            });
            this.reinitPinStates();
            if (this.hasColumnLayouts) {
                collection.forEach(function (column) {
                    column.populateVisibleIndexes();
                });
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.reinitPinStates = function () {
            var _this = this;
            this._pinnedColumns = (this.hasColumnGroups) ? this.columnList.filter(function (c) { return c.pinned; }) :
                this.columnList.filter(function (c) { return c.pinned; }).sort(function (a, b) { return _this._pinnedColumns.indexOf(a) - _this._pinnedColumns.indexOf(b); });
            this._unpinnedColumns = this.hasColumnGroups ? this.columnList.filter(function (c) { return !c.pinned; }) :
                this.columnList.filter(function (c) { return !c.pinned; })
                    .sort(function (a, b) { return _this._unpinnedColumns.indexOf(a) - _this._unpinnedColumns.indexOf(b); });
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.isColumnGrouped = function (fieldName) {
            return false;
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.onHeaderSelectorClick = function (event) {
            if (!this.isMultiRowSelectionEnabled) {
                return;
            }
            this.selectionService.areAllRowSelected() ?
                this.selectionService.clearRowSelection(event) : this.selectionService.selectAllRows(event);
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "headSelectorBaseAriaLabel", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this._filteringExpressionsTree.filteringOperands.length > 0) {
                    return this.selectionService.areAllRowSelected() ? 'Deselect all filtered' : 'Select all filtered';
                }
                return this.selectionService.areAllRowSelected() ? 'Deselect all' : 'Select all';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "totalRowsCountAfterFilter", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                if (this.data) {
                    return this.selectionService.allData.length;
                }
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "dataView", {
            /**
             * Returns the currently transformed paged/filtered/sorted/grouped data, displayed in the grid.
             * @example
             * ```typescript
             *      const dataView = this.grid.dataView;
             * ```
             */
            get: function () {
                return this.verticalScrollContainer.igxForOf;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Get current selection state.
         * @example
         * Returns an array with selected rows' IDs (primaryKey or rowData)
         * ```typescript
         * const selectedRows = this.grid.selectedRows();
         * ```
         */
        IgxGridBaseDirective.prototype.selectedRows = function () {
            return this.selectionService.getSelectedRows();
        };
        /**
         * Select specified rows by ID.
         * @example
         * ```typescript
         * this.grid.selectRows([1,2,5], true);
         * ```
         * @param rowIDs
         * @param clearCurrentSelection if true clears the current selection
        */
        IgxGridBaseDirective.prototype.selectRows = function (rowIDs, clearCurrentSelection) {
            this.selectionService.selectRowsWithNoEvent(rowIDs, clearCurrentSelection);
            this.notifyChanges();
        };
        /**
         * Deselect specified rows by ID.
         * @example
         * ```typescript
         * this.grid.deselectRows([1,2,5]);
         * ```
         * @param rowIDs
        */
        IgxGridBaseDirective.prototype.deselectRows = function (rowIDs) {
            this.selectionService.deselectRowsWithNoEvent(rowIDs);
            this.notifyChanges();
        };
        /**
         * Selects all rows
         * @remarks
         * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
         * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
         * @example
         * ```typescript
         * this.grid.selectAllRows();
         * this.grid.selectAllRows(false);
         * ```
         * @param onlyFilterData
         */
        IgxGridBaseDirective.prototype.selectAllRows = function (onlyFilterData) {
            var _this = this;
            if (onlyFilterData === void 0) { onlyFilterData = true; }
            var data = onlyFilterData && this.filteredData ? this.filteredData : this.gridAPI.get_all_data(true);
            var rowIDs = this.selectionService.getRowIDs(data).filter(function (rID) { return !_this.gridAPI.row_deleted_transaction(rID); });
            this.selectRows(rowIDs);
        };
        /**
         * Deselects all rows
         * @remarks
         * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
         * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
         * @example
         * ```typescript
         * this.grid.deselectAllRows();
         * ```
         * @param onlyFilterData
         */
        IgxGridBaseDirective.prototype.deselectAllRows = function (onlyFilterData) {
            if (onlyFilterData === void 0) { onlyFilterData = true; }
            if (onlyFilterData && this.filteredData && this.filteredData.length > 0) {
                this.deselectRows(this.selectionService.getRowIDs(this.filteredData));
            }
            else {
                this.selectionService.clearAllSelectedRows();
                this.notifyChanges();
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.clearCellSelection = function () {
            this.selectionService.clear(true);
            this.notifyChanges();
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.dragScroll = function (dir) {
            var scrollDelta = 48;
            var horizontal = this.headerContainer.getScroll();
            var vertical = this.verticalScrollContainer.getScroll();
            switch (dir) {
                case DragScrollDirection.LEFT:
                    horizontal.scrollLeft -= scrollDelta;
                    break;
                case DragScrollDirection.RIGHT:
                    horizontal.scrollLeft += scrollDelta;
                    break;
                case DragScrollDirection.TOP:
                    vertical.scrollTop -= scrollDelta;
                    break;
                case DragScrollDirection.BOTTOM:
                    vertical.scrollTop += scrollDelta;
                    break;
                case DragScrollDirection.BOTTOMLEFT:
                    horizontal.scrollLeft -= scrollDelta;
                    vertical.scrollTop += scrollDelta;
                    break;
                case DragScrollDirection.BOTTOMRIGHT:
                    horizontal.scrollLeft += scrollDelta;
                    vertical.scrollTop += scrollDelta;
                    break;
                case DragScrollDirection.TOPLEFT:
                    horizontal.scrollLeft -= scrollDelta;
                    vertical.scrollTop -= scrollDelta;
                    break;
                case DragScrollDirection.TOPRIGHT:
                    horizontal.scrollLeft += scrollDelta;
                    vertical.scrollTop -= scrollDelta;
                    break;
                default:
                    return;
            }
            this.wheelHandler();
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.isDefined = function (arg) {
            return arg !== undefined && arg !== null;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.selectRange = function (arg) {
            var _this = this;
            if (!this.isDefined(arg)) {
                this.clearCellSelection();
                return;
            }
            if (arg instanceof Array) {
                arg.forEach(function (range) { return _this.setSelection(range); });
            }
            else {
                this.setSelection(arg);
            }
            this.notifyChanges();
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.columnToVisibleIndex = function (field) {
            var visibleColumns = this.visibleColumns;
            if (typeof field === 'number') {
                return field;
            }
            return visibleColumns.find(function (column) { return column.field === field; }).visibleIndex;
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.setSelection = function (range) {
            var startNode = { row: range.rowStart, column: this.columnToVisibleIndex(range.columnStart) };
            var endNode = { row: range.rowEnd, column: this.columnToVisibleIndex(range.columnEnd) };
            this.selectionService.pointerState.node = startNode;
            this.selectionService.selectRange(endNode, this.selectionService.pointerState);
            this.selectionService.addRangeMeta(endNode, this.selectionService.pointerState);
            this.selectionService.initPointerState();
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.getSelectedRanges = function () {
            return this.selectionService.ranges;
        };
        IgxGridBaseDirective.prototype.extractDataFromSelection = function (source, formatters, headers) {
            var e_2, _a;
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            var columnsArray;
            var record = {};
            var selectedData = [];
            var activeEl = this.selectionService.activeElement;
            var selectionMap = Array.from(this.selectionService.selection)
                .filter(function (tuple) { return tuple[0] < source.length; });
            if (this.cellSelection === exports.GridSelectionMode.single && activeEl) {
                selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);
            }
            var _loop_1 = function (row, set) {
                var e_3, _a;
                if (!source[row] || source[row].detailsData !== undefined) {
                    return "continue";
                }
                var temp = Array.from(set);
                try {
                    for (var temp_1 = (e_3 = void 0, __values(temp)), temp_1_1 = temp_1.next(); !temp_1_1.done; temp_1_1 = temp_1.next()) {
                        var each = temp_1_1.value;
                        columnsArray = this_1.getSelectableColumnsAt(each);
                        columnsArray.forEach(function (col) {
                            if (col) {
                                var key = headers ? col.header || col.field : col.field;
                                record[key] = formatters && col.formatter ? col.formatter(source[row][col.field])
                                    : source[row][col.field];
                            }
                        });
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (temp_1_1 && !temp_1_1.done && (_a = temp_1.return)) _a.call(temp_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                if (Object.keys(record).length) {
                    selectedData.push(record);
                }
                record = {};
            };
            var this_1 = this;
            try {
                for (var selectionMap_1 = __values(selectionMap), selectionMap_1_1 = selectionMap_1.next(); !selectionMap_1_1.done; selectionMap_1_1 = selectionMap_1.next()) {
                    var _b = __read(selectionMap_1_1.value, 2), row = _b[0], set = _b[1];
                    _loop_1(row, set);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (selectionMap_1_1 && !selectionMap_1_1.done && (_a = selectionMap_1.return)) _a.call(selectionMap_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return selectedData;
        };
        IgxGridBaseDirective.prototype.getSelectableColumnsAt = function (index) {
            if (this.hasColumnLayouts) {
                var visibleLayoutColumns = this.visibleColumns
                    .filter(function (col) { return col.columnLayout; })
                    .sort(function (a, b) { return a.visibleIndex - b.visibleIndex; });
                var colLayout = visibleLayoutColumns[index];
                return colLayout ? colLayout.children.toArray() : [];
            }
            else {
                var visibleColumns = this.visibleColumns
                    .filter(function (col) { return !col.columnGroup; })
                    .sort(function (a, b) { return a.visibleIndex - b.visibleIndex; });
                return [visibleColumns[index]];
            }
        };
        /**
         *
         * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.
         * @remarks
         * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
         * If `headers` is enabled, it will use the column header (if any) instead of the column field.
         */
        IgxGridBaseDirective.prototype.getSelectedData = function (formatters, headers) {
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            var source = this.dataView;
            return this.extractDataFromSelection(source, formatters, headers);
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.copyHandlerIE = function () {
            if (isIE()) {
                this.copyHandler(null, true);
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxGridBaseDirective.prototype.copyHandler = function (event, ie11) {
            if (ie11 === void 0) { ie11 = false; }
            if (!this.clipboardOptions.enabled || this.crudService.inEditMode) {
                return;
            }
            var data = this.getSelectedData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
            var ev = { data: data, cancel: false };
            this.onGridCopy.emit(ev);
            if (ev.cancel) {
                return;
            }
            var transformer = new CharSeparatedValueData(ev.data, this.clipboardOptions.separator);
            var result = transformer.prepareData();
            if (!this.clipboardOptions.copyHeaders) {
                result = result.substring(result.indexOf('\n') + 1);
            }
            if (ie11) {
                window.clipboardData.setData('Text', result);
                return;
            }
            event.preventDefault();
            /* Necessary for the hiearachical case but will probably have to
               change how getSelectedData is propagated in the hiearachical grid
            */
            event.stopPropagation();
            event.clipboardData.setData('text/plain', result);
        };
        /**Navigates to a posution in the grid based on provided `rowindex` and `visibleColumnIndex`.
         * @remarks
         * Also can execute a custom logic over the target element,
         * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
         * @example
         * ```typescript
         *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
         * ```
         */
        IgxGridBaseDirective.prototype.navigateTo = function (rowIndex, visibleColIndex, cb) {
            var _this = this;
            if (visibleColIndex === void 0) { visibleColIndex = -1; }
            if (cb === void 0) { cb = null; }
            if (rowIndex < 0 || rowIndex > this.dataView.length - 1
                || (visibleColIndex !== -1 && this.columnList.map(function (col) { return col.visibleIndex; }).indexOf(visibleColIndex) === -1)) {
                return;
            }
            this.wheelHandler();
            if (this.dataView.slice(rowIndex, rowIndex + 1).find(function (rec) { return rec.expression || rec.childGridsData; })) {
                visibleColIndex = -1;
            }
            var shouldScrollVertically = this.navigation.shouldPerformVerticalScroll(rowIndex, visibleColIndex);
            var shouldScrollHorizontally = visibleColIndex !== -1 && !this.navigation.isColumnFullyVisible(visibleColIndex);
            if (shouldScrollVertically) {
                this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, function () { _this.navigateTo(rowIndex, visibleColIndex, cb); });
            }
            else if (shouldScrollHorizontally) {
                this.navigation.performHorizontalScrollToCell(rowIndex, visibleColIndex, false, function () { _this.navigateTo(rowIndex, visibleColIndex, cb); });
            }
            else {
                this.executeCallback(rowIndex, visibleColIndex, cb);
            }
        };
        /**
        * Returns `ICellPosition` which defines the next cell,
        * according to the current position, that match specific criteria.
        * @remarks
        * You can pass callback function as a third parameter of `getPreviousCell` method.
        * The callback function accepts IgxColumnComponent as a param
        * @example
        * ```typescript
        *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
        * ```
        */
        IgxGridBaseDirective.prototype.getNextCell = function (currRowIndex, curVisibleColIndex, callback) {
            if (callback === void 0) { callback = null; }
            var columns = this.columnList.filter(function (col) { return !col.columnGroup && col.visibleIndex >= 0; });
            if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            var colIndexes = callback ? columns.filter(function (col) { return callback(col); }).map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return a - b; }) :
                columns.map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return a - b; });
            var nextCellIndex = colIndexes.find(function (index) { return index > curVisibleColIndex; });
            if (this.dataView.slice(currRowIndex, currRowIndex + 1)
                .find(function (rec) { return !rec.expression && !rec.summaries && !rec.childGridsData; }) && nextCellIndex !== undefined) {
                return { rowIndex: currRowIndex, visibleColumnIndex: nextCellIndex };
            }
            else {
                if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex) === currRowIndex) {
                    return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
                }
                else {
                    return { rowIndex: this.getNextDataRowIndex(currRowIndex), visibleColumnIndex: colIndexes[0] };
                }
            }
        };
        /**
        * Returns `ICellPosition` which defines the previous cell,
        * according to the current position, that match specific criteria.
        * @remarks
        * You can pass callback function as a third parameter of `getPreviousCell` method.
        * The callback function accepts IgxColumnComponent as a param
        * @example
        * ```typescript
        *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
        * ```
        */
        IgxGridBaseDirective.prototype.getPreviousCell = function (currRowIndex, curVisibleColIndex, callback) {
            if (callback === void 0) { callback = null; }
            var columns = this.columnList.filter(function (col) { return !col.columnGroup && col.visibleIndex >= 0; });
            if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            var colIndexes = callback ? columns.filter(function (col) { return callback(col); }).map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return b - a; }) :
                columns.map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return b - a; });
            var prevCellIndex = colIndexes.find(function (index) { return index < curVisibleColIndex; });
            if (this.dataView.slice(currRowIndex, currRowIndex + 1)
                .find(function (rec) { return !rec.expression && !rec.summaries && !rec.childGridsData; }) && prevCellIndex !== undefined) {
                return { rowIndex: currRowIndex, visibleColumnIndex: prevCellIndex };
            }
            else {
                if (colIndexes.length === 0 || this.getPrevDataRowIndex(currRowIndex) === currRowIndex) {
                    return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
                }
                else {
                    return { rowIndex: this.getPrevDataRowIndex(currRowIndex), visibleColumnIndex: colIndexes[0] };
                }
            }
        };
        IgxGridBaseDirective.prototype.executeCallback = function (rowIndex, visibleColIndex, cb) {
            if (visibleColIndex === void 0) { visibleColIndex = -1; }
            if (cb === void 0) { cb = null; }
            if (!cb) {
                return;
            }
            var targetType, target;
            var row = this.summariesRowList.filter(function (s) { return s.index !== 0; }).concat(this.rowList.toArray()).find(function (r) { return r.index === rowIndex; });
            if (!row) {
                return;
            }
            switch (row.nativeElement.tagName.toLowerCase()) {
                case 'igx-grid-groupby-row':
                    targetType = exports.GridKeydownTargetType.groupRow;
                    target = row;
                    break;
                case 'igx-grid-summary-row':
                    targetType = exports.GridKeydownTargetType.summaryCell;
                    target = visibleColIndex !== -1 ?
                        row.summaryCells.find(function (c) { return c.visibleColumnIndex === visibleColIndex; }) : row.summaryCells.first;
                    break;
                case 'igx-child-grid-row':
                    targetType = exports.GridKeydownTargetType.hierarchicalRow;
                    target = row;
                    break;
                default:
                    targetType = exports.GridKeydownTargetType.dataCell;
                    target = visibleColIndex !== -1 ? row.cells.find(function (c) { return c.visibleColumnIndex === visibleColIndex; }) : row.cells.first;
                    break;
            }
            var args = { targetType: targetType, target: target };
            cb(args);
        };
        IgxGridBaseDirective.prototype.getPrevDataRowIndex = function (currentRowIndex) {
            if (currentRowIndex <= 0) {
                return currentRowIndex;
            }
            var prevRow = this.dataView.slice(0, currentRowIndex).reverse()
                .find(function (rec) { return !rec.expression && !rec.summaries && !rec.childGridsData; });
            return prevRow ? this.dataView.indexOf(prevRow) : currentRowIndex;
        };
        IgxGridBaseDirective.prototype.getNextDataRowIndex = function (currentRowIndex) {
            if (currentRowIndex === this.dataView.length) {
                return currentRowIndex;
            }
            var nextRow = this.dataView.slice(currentRowIndex + 1, this.dataView.length)
                .find(function (rec) { return !rec.expression && !rec.summaries && !rec.childGridsData; });
            return nextRow ? this.dataView.indexOf(nextRow) : currentRowIndex;
        };
        IgxGridBaseDirective.prototype.isValidPosition = function (rowIndex, colIndex) {
            var rows = this.summariesRowList.filter(function (s) { return s.index !== 0; }).concat(this.rowList.toArray()).length;
            var cols = this.columnList.filter(function (col) { return !col.columnGroup && col.visibleIndex >= 0 && !col.hidden; }).length;
            if (rows < 1 || cols < 1) {
                return false;
            }
            if (rowIndex > -1 && rowIndex < this.dataView.length &&
                colIndex > -1 && colIndex < cols) {
                return true;
            }
            return false;
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.trackColumnChanges = function (index, col) {
            return col.field + col._calcWidth;
        };
        IgxGridBaseDirective.prototype.find = function (text, increment, caseSensitive, exactMatch, scroll) {
            if (!this.rowList) {
                return 0;
            }
            this.endEdit(false);
            if (!text) {
                this.clearSearch();
                return 0;
            }
            var caseSensitiveResolved = caseSensitive ? true : false;
            var exactMatchResolved = exactMatch ? true : false;
            var rebuildCache = false;
            if (this.lastSearchInfo.searchText !== text ||
                this.lastSearchInfo.caseSensitive !== caseSensitiveResolved ||
                this.lastSearchInfo.exactMatch !== exactMatchResolved) {
                this.lastSearchInfo = {
                    searchText: text,
                    activeMatchIndex: 0,
                    caseSensitive: caseSensitiveResolved,
                    exactMatch: exactMatchResolved,
                    matchInfoCache: []
                };
                rebuildCache = true;
            }
            else {
                this.lastSearchInfo.activeMatchIndex += increment;
            }
            if (rebuildCache) {
                this.rowList.forEach(function (row) {
                    if (row.cells) {
                        row.cells.forEach(function (c) {
                            c.highlightText(text, caseSensitiveResolved, exactMatchResolved);
                        });
                    }
                });
                this.rebuildMatchCache();
            }
            if (this.lastSearchInfo.activeMatchIndex >= this.lastSearchInfo.matchInfoCache.length) {
                this.lastSearchInfo.activeMatchIndex = 0;
            }
            else if (this.lastSearchInfo.activeMatchIndex < 0) {
                this.lastSearchInfo.activeMatchIndex = this.lastSearchInfo.matchInfoCache.length - 1;
            }
            if (this.lastSearchInfo.matchInfoCache.length) {
                var matchInfo = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex];
                this.lastSearchInfo = __assign({}, this.lastSearchInfo);
                if (scroll !== false) {
                    this.scrollTo(matchInfo.row, matchInfo.column);
                }
                IgxTextHighlightDirective.setActiveHighlight(this.id, {
                    column: matchInfo.column,
                    row: matchInfo.row,
                    index: matchInfo.index,
                });
            }
            else {
                IgxTextHighlightDirective.clearActiveHighlight(this.id);
            }
            return this.lastSearchInfo.matchInfoCache.length;
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "filteredSortedData", {
            /**
             * Returns an array containing the filtered sorted data.
             * @example
             * ```typescript
             * const filteredSortedData = this.grid1.filteredSortedData;
             * ```
            */
            get: function () {
                return this._filteredSortedData;
            },
            set: function (value) {
                this._filteredSortedData = value;
                this.refreshSearch(true);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.initPinning = function () {
            var currentPinnedWidth = 0;
            var pinnedColumns = [];
            var unpinnedColumns = [];
            this.calculateGridWidth();
            this.resetCaches();
            // When a column is a group or is inside a group, pin all related.
            this._pinnedColumns.forEach(function (col) {
                if (col.parent) {
                    col.parent.pinned = true;
                }
                if (col.columnGroup) {
                    col.children.forEach(function (child) { return child.pinned = true; });
                }
            });
            // Make sure we don't exceed unpinned area min width and get pinned and unpinned col collections.
            // We take into account top level columns (top level groups and non groups).
            // If top level is unpinned the pinning handles all children to be unpinned as well.
            for (var i = 0; i < this._columns.length; i++) {
                if (this._columns[i].pinned && !this._columns[i].parent) {
                    // Pinned column. Check if with it the unpinned min width is exceeded.
                    var colWidth = parseInt(this._columns[i].width, 10);
                    currentPinnedWidth += colWidth;
                    pinnedColumns.push(this._columns[i]);
                }
                else if (this._columns[i].pinned && this._columns[i].parent) {
                    if (this._columns[i].topLevelParent.pinned) {
                        pinnedColumns.push(this._columns[i]);
                    }
                    else {
                        this._columns[i].pinned = false;
                        unpinnedColumns.push(this._columns[i]);
                    }
                }
                else {
                    unpinnedColumns.push(this._columns[i]);
                }
            }
            // Assign the applicaple collections.
            this._pinnedColumns = pinnedColumns;
            this._unpinnedColumns = unpinnedColumns;
            this.notifyChanges();
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.scrollTo = function (row, column, inCollection) {
            var _this = this;
            if (inCollection === void 0) { inCollection = this.filteredSortedData; }
            var delayScrolling = false;
            if (this.paging && typeof (row) !== 'number') {
                var rowIndex = inCollection.indexOf(row);
                var page = Math.floor(rowIndex / this.perPage);
                if (this.page !== page) {
                    delayScrolling = true;
                    this.page = page;
                }
            }
            if (delayScrolling) {
                this.verticalScrollContainer.onDataChanged.pipe(operators.first()).subscribe(function () {
                    _this.scrollDirective(_this.verticalScrollContainer, typeof (row) === 'number' ? row : _this.dataView.indexOf(row));
                });
            }
            else {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.dataView.indexOf(row));
            }
            this.scrollToHorizontally(column);
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.scrollToHorizontally = function (column) {
            var columnIndex = typeof column === 'number' ? column : this.getColumnByName(column).visibleIndex;
            var scrollRow = this.rowList.find(function (r) { return r.virtDirRow; });
            var virtDir = scrollRow ? scrollRow.virtDirRow : null;
            if (this.pinnedColumns.length) {
                if (columnIndex >= this.pinnedColumns.length) {
                    columnIndex -= this.pinnedColumns.length;
                    this.scrollDirective(virtDir, columnIndex);
                }
            }
            else {
                this.scrollDirective(virtDir, columnIndex);
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.scrollDirective = function (directive, goal) {
            if (!directive) {
                return;
            }
            directive.scrollTo(goal);
        };
        IgxGridBaseDirective.prototype.rebuildMatchCache = function () {
            var _this = this;
            this.lastSearchInfo.matchInfoCache = [];
            var caseSensitive = this.lastSearchInfo.caseSensitive;
            var exactMatch = this.lastSearchInfo.exactMatch;
            var searchText = caseSensitive ? this.lastSearchInfo.searchText : this.lastSearchInfo.searchText.toLowerCase();
            var data = this.filteredSortedData;
            var columnItems = this.visibleColumns.filter(function (c) { return !c.columnGroup; }).sort(function (c1, c2) { return c1.visibleIndex - c2.visibleIndex; });
            var numberPipe = new IgxDecimalPipeComponent(this.locale);
            var datePipe = new IgxDatePipeComponent(this.locale);
            data.forEach(function (dataRow) {
                columnItems.forEach(function (c) {
                    var value = c.formatter ? c.formatter(dataRow[c.field]) :
                        c.dataType === 'number' ? numberPipe.transform(dataRow[c.field], _this.locale) :
                            c.dataType === 'date' ? datePipe.transform(dataRow[c.field], _this.locale)
                                : dataRow[c.field];
                    if (value !== undefined && value !== null && c.searchable) {
                        var searchValue = caseSensitive ? String(value) : String(value).toLowerCase();
                        if (exactMatch) {
                            if (searchValue === searchText) {
                                _this.lastSearchInfo.matchInfoCache.push({
                                    row: dataRow,
                                    column: c.field,
                                    index: 0,
                                });
                            }
                        }
                        else {
                            var occurenceIndex = 0;
                            var searchIndex = searchValue.indexOf(searchText);
                            while (searchIndex !== -1) {
                                _this.lastSearchInfo.matchInfoCache.push({
                                    row: dataRow,
                                    column: c.field,
                                    index: occurenceIndex++,
                                });
                                searchValue = searchValue.substring(searchIndex + searchText.length);
                                searchIndex = searchValue.indexOf(searchText);
                            }
                        }
                    }
                });
            });
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.isExpandedGroup = function (_group) {
            return undefined;
        };
        IgxGridBaseDirective.prototype.changeRowEditingOverlayStateOnScroll = function (row) {
            if (!this.rowEditable || !this.rowEditingOverlay || this.rowEditingOverlay.collapsed) {
                return;
            }
            if (!row) {
                this.toggleRowEditingOverlay(false);
            }
            else {
                this.repositionRowEditingOverlay(row);
            }
        };
        /**
         * Should be called when data and/or isLoading input changes so that the overlay can be
         * hidden/shown based on the current value of shouldOverlayLoading
         */
        IgxGridBaseDirective.prototype.evaluateLoadingState = function () {
            if (this.shouldOverlayLoading) {
                // a new overlay should be shown
                var overlaySettings = {
                    outlet: this.loadingOutlet,
                    closeOnOutsideClick: false,
                    positionStrategy: new ContainerPositionStrategy()
                };
                if (!this._loadingId) {
                    this._loadingId = this.overlayService.attach(this.loadingOverlay, overlaySettings);
                    this.overlayService.show(this._loadingId, overlaySettings);
                }
            }
            else {
                if (this._loadingId) {
                    this.overlayService.hide(this._loadingId);
                    this._loadingId = null;
                }
            }
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.openRowOverlay = function (id) {
            this.configureRowEditingOverlay(id, this.rowList.length <= MIN_ROW_EDITING_COUNT_THRESHOLD);
            this.rowEditingOverlay.open(this.rowEditSettings);
            this.rowEditPositioningStrategy.isTopInitialPosition = this.rowEditPositioningStrategy.isTop;
            this.rowEditingOverlay.element.addEventListener('wheel', this.rowEditingWheelHandler);
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.closeRowEditingOverlay = function () {
            this.rowEditingOverlay.element.removeEventListener('wheel', this.rowEditingWheelHandler);
            this.rowEditPositioningStrategy.isTopInitialPosition = null;
            this.rowEditingOverlay.close();
            this.rowEditingOverlay.element.parentElement.style.display = '';
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.toggleRowEditingOverlay = function (show) {
            var rowStyle = this.rowEditingOverlay.element.style;
            if (show) {
                rowStyle.display = 'block';
            }
            else {
                rowStyle.display = 'none';
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.repositionRowEditingOverlay = function (row) {
            if (row && !this.rowEditingOverlay.collapsed) {
                var rowStyle = this.rowEditingOverlay.element.parentElement.style;
                if (row) {
                    rowStyle.display = '';
                    this.configureRowEditingOverlay(row.rowID);
                    this.rowEditingOverlay.reposition();
                }
                else {
                    rowStyle.display = 'none';
                }
            }
        };
        IgxGridBaseDirective.prototype.configureRowEditingOverlay = function (rowID, useOuter) {
            if (useOuter === void 0) { useOuter = false; }
            this.rowEditSettings.outlet = useOuter ? this.parentRowOutletDirective : this.rowOutletDirective;
            this.rowEditPositioningStrategy.settings.container = this.tbody.nativeElement;
            var targetRow = this.gridAPI.get_row_by_key(rowID);
            if (!targetRow) {
                return;
            }
            this.rowEditPositioningStrategy.settings.target = targetRow.element.nativeElement;
            this.toggleRowEditingOverlay(true);
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "rowChangesCount", {
            /**
             * @hidden @internal
            */
            get: function () {
                if (!this.crudService.row) {
                    return 0;
                }
                var rowChanges = this.transactions.getAggregatedValue(this.crudService.row.id, false);
                return rowChanges ? Object.keys(rowChanges).length : 0;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridBaseDirective.prototype.writeToData = function (rowIndex, value) {
            mergeObjects(this.gridAPI.get_all_data()[rowIndex], value);
        };
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.endRowTransaction = function (commit, row) {
            row.newData = this.transactions.getAggregatedValue(row.id, true);
            var args = row.createEditEventArgs();
            if (!commit) {
                this.onRowEditCancel.emit(args);
                this.transactions.endPending(false);
            }
            else {
                args = this.gridAPI.update_row(row, row.newData);
            }
            if (args.cancel) {
                this.transactions.startPending();
                return;
            }
            this.crudService.endRowEdit();
            this.closeRowEditingOverlay();
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.gridOutletKeyboardHandler = function (event) {
            // TODO: This should be removed after grid keyboard refactoring
            // call stopPropagation for keydown event for the outlet not to propagate event to the grid
            event.stopPropagation();
        };
        // TODO: Refactor
        /**
         * Finishes the row transactions on the current row.
         * @remarks
         * If `commit === true`, passes them from the pending state to the data (or transaction service)
         * @example
         * ```html
         * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
         * ```
         * @param commit
         */
        IgxGridBaseDirective.prototype.endEdit = function (commit, event) {
            if (commit === void 0) { commit = true; }
            var row = this.crudService.row;
            var cell = this.crudService.cell;
            // TODO: Merge the crudService with wht BaseAPI service
            if (!row && !cell) {
                return;
            }
            commit ? this.gridAPI.submit_value() : this.gridAPI.escape_editMode();
            if (!this.rowEditable || this.rowEditingOverlay && this.rowEditingOverlay.collapsed || !row) {
                return;
            }
            this.endRowTransaction(commit, row);
            var activeCell = this.selectionService.activeElement;
            if (event && activeCell) {
                var rowIndex = activeCell.row;
                var visibleColIndex = activeCell.layout ? activeCell.layout.columnVisibleIndex : activeCell.column;
                this.navigateTo(rowIndex, visibleColIndex, function (c) {
                    if (c.targetType === exports.GridKeydownTargetType.dataCell && c.target) {
                        c.target.nativeElement.focus();
                    }
                });
            }
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "dataWithAddedInTransactionRows", {
            /**
             * @hidden @internal
             */
            get: function () {
                var result = cloneArray(this.gridAPI.get_all_data());
                if (this.transactions.enabled) {
                    result.push.apply(result, __spread(this.transactions.getAggregatedChanges(true)
                        .filter(function (t) { return t.type === exports.TransactionType.ADD; })
                        .map(function (t) { return t.newValue; })));
                }
                return result;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "dataLength", {
            /**
             * @hidden @internal
            */
            get: function () {
                return this.transactions.enabled ? this.dataWithAddedInTransactionRows.length : this.gridAPI.get_all_data().length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridBaseDirective.prototype.hasHorizontalScroll = function () {
            return this.totalWidth - this.unpinnedWidth > 0;
        };
        IgxGridBaseDirective.prototype._restoreVirtState = function (row) {
            // check virtualization state of data record added from cache
            // in case state is no longer valid - update it.
            var rowForOf = row.virtDirRow;
            var gridScrLeft = rowForOf.getScroll().scrollLeft;
            var left = -parseInt(rowForOf.dc.instance._viewContainer.element.nativeElement.style.left, 10);
            var actualScrollLeft = left + rowForOf.getColumnScrollLeft(rowForOf.state.startIndex);
            if (gridScrLeft !== actualScrollLeft) {
                rowForOf.onHScroll(gridScrLeft);
                rowForOf.cdr.detectChanges();
            }
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getExportExcel = function () {
            return this._exportExcel;
        };
        /**
         * @hidden
         */
        IgxGridBaseDirective.prototype.getExportCsv = function () {
            return this._exportCsv;
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "shouldOverlayLoading", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.isLoading && this.data && this.data.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.isSummaryRow = function (rowData) {
            return rowData.summaries && (rowData.summaries instanceof Map);
        };
        Object.defineProperty(IgxGridBaseDirective.prototype, "isMultiRowSelectionEnabled", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.rowSelection === exports.GridSelectionMode.multiple;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isRowSelectable", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.rowSelection !== exports.GridSelectionMode.none;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridBaseDirective.prototype, "isCellSelectable", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.cellSelection !== exports.GridSelectionMode.none;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.viewDetachHandler = function (args) {
            var context = args.view.context;
            if (context['templateID'] === 'dataRow') {
                // some browsers (like FireFox and Edge) do not trigger onBlur when the focused element is detached from DOM
                // hence we need to trigger it manually when cell is detached.
                var row = this.getRowByIndex(context.index);
                var focusedCell = row && row.cells ? row.cells.find(function (x) { return x.focused; }) : false;
                if (focusedCell) {
                    focusedCell.onBlur();
                }
            }
        };
        /**
         * @hidden @internal
        */
        IgxGridBaseDirective.prototype.cachedViewLoaded = function (args) {
            var _this = this;
            if (this.hasHorizontalScroll()) {
                var tmplId_1 = args.context.templateID;
                var index_1 = args.context.index;
                args.view.detectChanges();
                this.zone.onStable.pipe(operators.first()).subscribe(function () {
                    var row = tmplId_1 === 'dataRow' ? _this.getRowByIndex(index_1) : null;
                    var summaryRow = tmplId_1 === 'summaryRow' ? _this.summariesRowList.find(function (sr) { return sr.dataRowIndex === index_1; }) : null;
                    if (row && row instanceof IgxRowDirective) {
                        _this._restoreVirtState(row);
                    }
                    else if (summaryRow) {
                        _this._restoreVirtState(summaryRow);
                    }
                });
            }
        };
        /**
         * Opens the advanced filtering dialog.
         */
        IgxGridBaseDirective.prototype.openAdvancedFilteringDialog = function () {
            if (!this._advancedFilteringOverlayId) {
                this._advancedFilteringOverlaySettings.positionStrategy.settings.target =
                    this.rootGrid ? this.rootGrid.nativeElement : this.nativeElement;
                this._advancedFilteringOverlaySettings.outlet = this.outletDirective;
                this._advancedFilteringOverlayId = this.overlayService.attach(IgxAdvancedFilteringDialogComponent, this._advancedFilteringOverlaySettings, {
                    injector: this.viewRef.injector,
                    componentFactoryResolver: this.resolver
                });
                this.overlayService.show(this._advancedFilteringOverlayId, this._advancedFilteringOverlaySettings);
            }
        };
        /**
         * Closes the advanced filtering dialog.
         * @param applyChanges indicates whether the changes should be applied
         */
        IgxGridBaseDirective.prototype.closeAdvancedFilteringDialog = function (applyChanges) {
            if (this._advancedFilteringOverlayId) {
                var advancedFilteringOverlay = this.overlayService.getOverlayById(this._advancedFilteringOverlayId);
                var advancedFilteringDialog = advancedFilteringOverlay.componentRef.instance;
                if (applyChanges) {
                    advancedFilteringDialog.applyChanges();
                }
                advancedFilteringDialog.closeDialog();
            }
        };
        IgxGridBaseDirective.ctorParameters = function () { return [
            { type: IgxGridSelectionService },
            { type: IgxGridCRUDService },
            { type: IgxColumnResizingService },
            { type: GridBaseAPIService },
            { type: undefined, decorators: [{ type: core.Inject, args: [IgxGridTransaction,] }] },
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.ChangeDetectorRef },
            { type: core.ComponentFactoryResolver },
            { type: core.IterableDiffers },
            { type: core.ViewContainerRef },
            { type: IgxGridNavigationService },
            { type: IgxFilteringService },
            { type: IgxOverlayService, decorators: [{ type: core.Inject, args: [IgxOverlayService,] }] },
            { type: IgxGridSummaryService },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.ViewChild('defaultExpandedTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridBaseDirective.prototype, "defaultExpandedTemplate", void 0);
        __decorate([
            core.ViewChild('defaultCollapsedTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridBaseDirective.prototype, "defaultCollapsedTemplate", void 0);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "resourceStrings", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "autoGenerate", void 0);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "emptyGridTemplate", void 0);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "loadingGridTemplate", void 0);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "filteringLogic", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "filteringExpressionsTree", null);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "filteringExpressionsTreeChange", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "advancedFilteringExpressionsTreeChange", void 0);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "advancedFilteringExpressionsTree", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "locale", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "paging", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "page", null);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "pageChange", void 0);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "perPage", null);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "perPageChange", void 0);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "paginationTemplate", void 0);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "columnHiding", null);
        __decorate([
            DeprecateProperty('rowSelectable property is deprecated. Use rowSelection property instead.'),
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "rowSelectable", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "hideRowSelectors", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "rowDraggable", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "rowEditable", null);
        __decorate([
            WatchChanges(),
            core.HostBinding('style.height'),
            core.Input()
        ], IgxGridBaseDirective.prototype, "height", null);
        __decorate([
            core.HostBinding('style.width')
        ], IgxGridBaseDirective.prototype, "hostWidth", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "width", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "evenRowCSS", void 0);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "oddRowCSS", void 0);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "rowHeight", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "columnWidth", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "primaryKey", void 0);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "emptyGridMessage", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "isLoading", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "emptyFilteredGridMessage", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "columnHidingTitle", void 0);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "columnPinning", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "columnPinningTitle", void 0);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "allowFiltering", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "allowAdvancedFiltering", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "filterMode", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "summaryPosition", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "summaryCalculationMode", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "filterStrategy", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "sortStrategy", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "uniqueColumnValuesStrategy", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onCellClick", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onSelection", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onRowSelectionChange", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onColumnPinning", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onCellEditCancel", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onCellEditEnter", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onCellEdit", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onRowEditEnter", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onRowEdit", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onRowEditCancel", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onColumnInit", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onSortingDone", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onFilteringDone", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onPagingDone", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onRowAdded", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onRowDeleted", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onDataPreLoad", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onColumnResized", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onContextMenu", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onDoubleClick", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onColumnVisibilityChanged", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onColumnMovingStart", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onColumnMoving", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onColumnMovingEnd", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onGridKeydown", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onRowDragStart", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onRowDragEnd", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onGridCopy", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "expansionStatesChange", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onRowToggle", void 0);
        __decorate([
            core.ViewChild(IgxGridColumnResizerComponent)
        ], IgxGridBaseDirective.prototype, "resizeLine", void 0);
        __decorate([
            core.ViewChild('loadingOverlay', { static: true })
        ], IgxGridBaseDirective.prototype, "loadingOverlay", void 0);
        __decorate([
            core.ViewChild('igxLoadingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true })
        ], IgxGridBaseDirective.prototype, "loadingOutlet", void 0);
        __decorate([
            core.ContentChildren(IgxColumnComponent, { read: IgxColumnComponent, descendants: true })
        ], IgxGridBaseDirective.prototype, "columnList", void 0);
        __decorate([
            core.ContentChild(IgxExcelStyleSortingTemplateDirective, { read: IgxExcelStyleSortingTemplateDirective })
        ], IgxGridBaseDirective.prototype, "excelStyleSortingTemplateDirective", void 0);
        __decorate([
            core.ContentChild(IgxExcelStyleMovingTemplateDirective, { read: IgxExcelStyleMovingTemplateDirective })
        ], IgxGridBaseDirective.prototype, "excelStyleMovingTemplateDirective", void 0);
        __decorate([
            core.ContentChild(IgxExcelStyleHidingTemplateDirective, { read: IgxExcelStyleHidingTemplateDirective })
        ], IgxGridBaseDirective.prototype, "excelStyleHidingTemplateDirective", void 0);
        __decorate([
            core.ContentChild(IgxExcelStylePinningTemplateDirective, { read: IgxExcelStylePinningTemplateDirective })
        ], IgxGridBaseDirective.prototype, "excelStylePinningTemplateDirective", void 0);
        __decorate([
            core.ContentChild(IgxExcelStyleLoadingValuesTemplateDirective, { read: IgxExcelStyleLoadingValuesTemplateDirective, static: true })
        ], IgxGridBaseDirective.prototype, "excelStyleLoadingValuesTemplateDirective", void 0);
        __decorate([
            core.ViewChildren(IgxGridHeaderGroupComponent, { read: IgxGridHeaderGroupComponent })
        ], IgxGridBaseDirective.prototype, "headerGroups", void 0);
        __decorate([
            core.ViewChildren('row')
        ], IgxGridBaseDirective.prototype, "_rowList", void 0);
        __decorate([
            core.ViewChildren('summaryRow', { read: IgxSummaryRowComponent })
        ], IgxGridBaseDirective.prototype, "_summaryRowList", void 0);
        __decorate([
            core.ViewChildren(IgxRowDirective, { read: IgxRowDirective })
        ], IgxGridBaseDirective.prototype, "_dataRowList", void 0);
        __decorate([
            core.ViewChild('emptyFilteredGrid', { read: core.TemplateRef, static: true })
        ], IgxGridBaseDirective.prototype, "emptyFilteredGridTemplate", void 0);
        __decorate([
            core.ViewChild('defaultEmptyGrid', { read: core.TemplateRef, static: true })
        ], IgxGridBaseDirective.prototype, "emptyGridDefaultTemplate", void 0);
        __decorate([
            core.ViewChild('defaultLoadingGrid', { read: core.TemplateRef, static: true })
        ], IgxGridBaseDirective.prototype, "loadingGridDefaultTemplate", void 0);
        __decorate([
            core.ViewChild('scrollContainer', { read: IgxGridForOfDirective, static: true })
        ], IgxGridBaseDirective.prototype, "parentVirtDir", void 0);
        __decorate([
            core.ContentChildren(IgxGridToolbarCustomContentDirective, { read: IgxGridToolbarCustomContentDirective, descendants: false })
        ], IgxGridBaseDirective.prototype, "toolbarCustomContentTemplates", void 0);
        __decorate([
            core.ContentChildren(IgxHeadSelectorDirective, { read: IgxHeadSelectorDirective, descendants: false })
        ], IgxGridBaseDirective.prototype, "headSelectorsTemplates", void 0);
        __decorate([
            core.ContentChildren(IgxRowSelectorDirective, { read: IgxRowSelectorDirective, descendants: false })
        ], IgxGridBaseDirective.prototype, "rowSelectorsTemplates", void 0);
        __decorate([
            core.ContentChildren(IgxRowDragGhostDirective, { read: core.TemplateRef, descendants: false })
        ], IgxGridBaseDirective.prototype, "dragGhostCustomTemplates", void 0);
        __decorate([
            core.ViewChild('verticalScrollContainer', { read: IgxGridForOfDirective, static: true })
        ], IgxGridBaseDirective.prototype, "verticalScrollContainer", void 0);
        __decorate([
            core.ViewChild('verticalScrollHolder', { read: IgxGridForOfDirective, static: true })
        ], IgxGridBaseDirective.prototype, "verticalScroll", void 0);
        __decorate([
            core.ViewChild('scr', { read: core.ElementRef, static: true })
        ], IgxGridBaseDirective.prototype, "scr", void 0);
        __decorate([
            core.ViewChild('footer', { read: core.ElementRef })
        ], IgxGridBaseDirective.prototype, "footer", void 0);
        __decorate([
            core.ViewChild('hContainer', { read: IgxGridForOfDirective, static: true })
        ], IgxGridBaseDirective.prototype, "headerContainer", void 0);
        __decorate([
            core.ViewChild('headerSelectorContainer')
        ], IgxGridBaseDirective.prototype, "headerSelectorContainer", void 0);
        __decorate([
            core.ViewChild('headerDragContainer')
        ], IgxGridBaseDirective.prototype, "headerDragContainer", void 0);
        __decorate([
            core.ViewChild('headerGroupContainer')
        ], IgxGridBaseDirective.prototype, "headerGroupContainer", void 0);
        __decorate([
            core.ViewChild('filteringRow', { read: IgxGridFilteringRowComponent })
        ], IgxGridBaseDirective.prototype, "filteringRow", void 0);
        __decorate([
            core.ViewChild('theadRow', { static: true })
        ], IgxGridBaseDirective.prototype, "theadRow", void 0);
        __decorate([
            core.ViewChild('tbody', { static: true })
        ], IgxGridBaseDirective.prototype, "tbody", void 0);
        __decorate([
            core.ViewChild('tfoot', { static: true })
        ], IgxGridBaseDirective.prototype, "tfoot", void 0);
        __decorate([
            core.ViewChild('igxFilteringOverlayOutlet', { read: IgxOverlayOutletDirective, static: true })
        ], IgxGridBaseDirective.prototype, "_outletDirective", void 0);
        __decorate([
            core.ViewChild('igxRowEditingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true })
        ], IgxGridBaseDirective.prototype, "rowEditingOutletDirective", void 0);
        __decorate([
            core.ViewChildren(IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective })
        ], IgxGridBaseDirective.prototype, "tmpOutlets", void 0);
        __decorate([
            core.ViewChild('dragIndicatorIconBase', { read: core.TemplateRef, static: true })
        ], IgxGridBaseDirective.prototype, "dragIndicatorIconBase", void 0);
        __decorate([
            core.ViewChild('defaultRowEditTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridBaseDirective.prototype, "defaultRowEditTemplate", void 0);
        __decorate([
            core.ContentChild(IgxRowEditTemplateDirective, { read: core.TemplateRef })
        ], IgxGridBaseDirective.prototype, "rowEditCustom", void 0);
        __decorate([
            core.ContentChild(IgxRowEditTextDirective, { read: core.TemplateRef })
        ], IgxGridBaseDirective.prototype, "rowEditText", void 0);
        __decorate([
            core.ContentChild(IgxRowEditActionsDirective, { read: core.TemplateRef })
        ], IgxGridBaseDirective.prototype, "rowEditActions", void 0);
        __decorate([
            core.ContentChild(IgxRowExpandedIndicatorDirective, { read: core.TemplateRef })
        ], IgxGridBaseDirective.prototype, "rowExpandedIndicatorTemplate", void 0);
        __decorate([
            core.ContentChild(IgxRowCollapsedIndicatorDirective, { read: core.TemplateRef })
        ], IgxGridBaseDirective.prototype, "rowCollapsedIndicatorTemplate", void 0);
        __decorate([
            core.ContentChild(IgxHeaderExpandIndicatorDirective, { read: core.TemplateRef })
        ], IgxGridBaseDirective.prototype, "headerExpandIndicatorTemplate", void 0);
        __decorate([
            core.ContentChild(IgxHeaderCollapseIndicatorDirective, { read: core.TemplateRef })
        ], IgxGridBaseDirective.prototype, "headerCollapseIndicatorTemplate", void 0);
        __decorate([
            core.ContentChildren(IgxDragIndicatorIconDirective, { read: core.TemplateRef, descendants: false })
        ], IgxGridBaseDirective.prototype, "dragIndicatorIconTemplates", void 0);
        __decorate([
            core.ViewChildren(IgxRowEditTabStopDirective)
        ], IgxGridBaseDirective.prototype, "rowEditTabsDEFAULT", void 0);
        __decorate([
            core.ContentChildren(IgxRowEditTabStopDirective)
        ], IgxGridBaseDirective.prototype, "rowEditTabsCUSTOM", void 0);
        __decorate([
            core.ViewChild(IgxToggleDirective)
        ], IgxGridBaseDirective.prototype, "rowEditingOverlay", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxGridBaseDirective.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('attr.class')
        ], IgxGridBaseDirective.prototype, "hostClass", null);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxGridBaseDirective.prototype, "hostRole", void 0);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "sortingExpressions", null);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "sortingExpressionsChange", void 0);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "hiddenColumnsText", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "pinnedColumnsText", null);
        __decorate([
            core.ViewChild('toolbar', { read: IgxGridToolbarComponent })
        ], IgxGridBaseDirective.prototype, "toolbar", void 0);
        __decorate([
            core.ViewChild('toolbar', { read: core.ElementRef })
        ], IgxGridBaseDirective.prototype, "toolbarHtml", void 0);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "showToolbar", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "toolbarTitle", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "exportExcel", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "exportCsv", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "exportText", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "exportExcelText", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "exportCsvText", null);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "clipboardOptions", void 0);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "cellSelection", null);
        __decorate([
            WatchChanges(),
            core.Input()
        ], IgxGridBaseDirective.prototype, "rowSelection", null);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onToolbarExporting", void 0);
        __decorate([
            core.Output()
        ], IgxGridBaseDirective.prototype, "onRangeSelection", void 0);
        __decorate([
            core.Input()
        ], IgxGridBaseDirective.prototype, "expansionStates", null);
        IgxGridBaseDirective = __decorate([
            core.Directive({
                selector: '[igxGridBaseComponent]'
            }),
            __param(4, core.Inject(IgxGridTransaction)),
            __param(7, core.Inject(common.DOCUMENT)),
            __param(14, core.Inject(IgxOverlayService)),
            __param(16, core.Optional()), __param(16, core.Inject(DisplayDensityToken))
        ], IgxGridBaseDirective);
        return IgxGridBaseDirective;
    }(DisplayDensityBase));

    var IgxGridAPIService = /** @class */ (function (_super) {
        __extends(IgxGridAPIService, _super);
        function IgxGridAPIService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxGridAPIService.prototype.groupBy = function (expression) {
            var groupingState = cloneArray(this.grid.groupingExpressions);
            var sortingState = cloneArray(this.grid.sortingExpressions);
            this.prepare_sorting_expression([sortingState, groupingState], expression);
            this.grid.groupingExpressions = groupingState;
            this.arrange_sorting_expressions();
        };
        IgxGridAPIService.prototype.groupBy_multiple = function (expressions) {
            var e_1, _a;
            var groupingState = cloneArray(this.grid.groupingExpressions);
            var sortingState = cloneArray(this.grid.sortingExpressions);
            try {
                for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
                    var each = expressions_1_1.value;
                    this.prepare_sorting_expression([sortingState, groupingState], each);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return)) _a.call(expressions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.grid.groupingExpressions = groupingState;
            this.arrange_sorting_expressions();
        };
        IgxGridAPIService.prototype.clear_groupby = function (name) {
            var e_2, _a;
            var _this = this;
            var groupingState = cloneArray(this.grid.groupingExpressions);
            var sortingState = cloneArray(this.grid.sortingExpressions);
            if (name) {
                var names_1 = typeof name === 'string' ? [name] : name;
                var groupedCols = groupingState.filter(function (state) { return names_1.indexOf(state.fieldName) < 0; });
                var newSortingExpr = sortingState.filter(function (state) { return names_1.indexOf(state.fieldName) < 0; });
                this.grid.groupingExpressions = groupedCols;
                this.grid.sortingExpressions = newSortingExpr;
                names_1.forEach(function (colName) {
                    var grExprIndex = groupingState.findIndex(function (exp) { return exp.fieldName === colName; });
                    var grpExpandState = _this.grid.groupingExpansionState;
                    /* remove expansion states related to the cleared group
                    and all with deeper hierarchy than the cleared group */
                    _this.grid.groupingExpansionState = grpExpandState
                        .filter(function (val) {
                        return val.hierarchy && val.hierarchy.length <= grExprIndex;
                    });
                });
            }
            else {
                // clear all
                this.grid.groupingExpressions = [];
                this.grid.groupingExpansionState = [];
                var _loop_1 = function (grExpr) {
                    var sortExprIndex = sortingState.findIndex(function (exp) { return exp.fieldName === grExpr.fieldName; });
                    if (sortExprIndex > -1) {
                        sortingState.splice(sortExprIndex, 1);
                    }
                };
                try {
                    for (var groupingState_1 = __values(groupingState), groupingState_1_1 = groupingState_1.next(); !groupingState_1_1.done; groupingState_1_1 = groupingState_1.next()) {
                        var grExpr = groupingState_1_1.value;
                        _loop_1(grExpr);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (groupingState_1_1 && !groupingState_1_1.done && (_a = groupingState_1.return)) _a.call(groupingState_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                this.grid.sortingExpressions = sortingState;
            }
        };
        IgxGridAPIService.prototype.groupBy_get_expanded_for_group = function (groupRow) {
            var grState = this.grid.groupingExpansionState;
            var hierarchy = DataUtil.getHierarchy(groupRow);
            return grState.find(function (state) {
                return DataUtil.isHierarchyMatch(state.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy);
            });
        };
        IgxGridAPIService.prototype.groupBy_is_row_in_group = function (groupRow, rowID) {
            var grid = this.grid;
            var rowInGroup = false;
            groupRow.records.forEach(function (row) {
                if (grid.primaryKey ? row[grid.primaryKey] === rowID : row === rowID) {
                    rowInGroup = true;
                }
            });
            return rowInGroup;
        };
        IgxGridAPIService.prototype.groupBy_toggle_group = function (groupRow) {
            var grid = this.grid;
            if (grid.crudService.isInEditMode) {
                grid.endEdit(true);
            }
            var expansionState = grid.groupingExpansionState;
            var state = this.groupBy_get_expanded_for_group(groupRow);
            if (state) {
                state.expanded = !state.expanded;
            }
            else {
                expansionState.push({
                    expanded: !grid.groupsExpanded,
                    hierarchy: DataUtil.getHierarchy(groupRow)
                });
            }
            this.grid.groupingExpansionState = __spread(expansionState);
            if (grid.rowEditable) {
                grid.repositionRowEditingOverlay(grid.rowInEditMode);
            }
        };
        IgxGridAPIService.prototype.groupBy_fully_expand_group = function (groupRow) {
            var state = this.groupBy_get_expanded_for_group(groupRow);
            var expanded = state ? state.expanded : this.grid.groupsExpanded;
            if (!expanded) {
                this.groupBy_toggle_group(groupRow);
            }
            if (groupRow.groupParent) {
                this.groupBy_fully_expand_group(groupRow.groupParent);
            }
        };
        IgxGridAPIService.prototype.remove_grouping_expression = function (fieldName) {
            var groupingExpressions = this.grid.groupingExpressions;
            var index = groupingExpressions.findIndex(function (expr) { return expr.fieldName === fieldName; });
            if (index !== -1) {
                groupingExpressions.splice(index, 1);
            }
        };
        IgxGridAPIService.prototype.arrange_sorting_expressions = function () {
            var groupingState = this.grid.groupingExpressions;
            this.grid.sortingExpressions.sort(function (a, b) {
                var groupExprA = groupingState.find(function (expr) { return expr.fieldName === a.fieldName; });
                var groupExprB = groupingState.find(function (expr) { return expr.fieldName === b.fieldName; });
                if (groupExprA && groupExprB) {
                    return groupingState.indexOf(groupExprA) > groupingState.indexOf(groupExprB) ? 1 : -1;
                }
                else if (groupExprA) {
                    return -1;
                }
                else if (groupExprB) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
        };
        IgxGridAPIService.prototype.get_groupBy_record_id = function (gRow) {
            var recordId = '{ ';
            var hierrarchy = DataUtil.getHierarchy(gRow);
            for (var i = 0; i < hierrarchy.length; i++) {
                var groupByKey = hierrarchy[i];
                recordId += "'" + groupByKey.fieldName + "': '" + groupByKey.value + "'";
                if (i < hierrarchy.length - 1) {
                    recordId += ', ';
                }
            }
            recordId += ' }';
            return recordId;
        };
        IgxGridAPIService = __decorate([
            core.Injectable()
        ], IgxGridAPIService);
        return IgxGridAPIService;
    }(GridBaseAPIService));

    var NavigationDirection;
    (function (NavigationDirection) {
        NavigationDirection["horizontal"] = "horizontal";
        NavigationDirection["vertical"] = "vertical";
    })(NavigationDirection || (NavigationDirection = {}));
    /** @hidden */
    var IgxGridMRLNavigationService = /** @class */ (function (_super) {
        __extends(IgxGridMRLNavigationService, _super);
        function IgxGridMRLNavigationService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @hidden
         * @internal
         */
        IgxGridMRLNavigationService.prototype.setStartNavigationCell = function (colStart, rowStart, dir) {
            this.startNavigationCell = {
                colStart: colStart,
                rowStart: rowStart,
                direction: dir
            };
        };
        IgxGridMRLNavigationService.prototype.applyNavigationCell = function (colStart, rowStart, navDirection) {
            var oppositeDir = navDirection === NavigationDirection.vertical ?
                NavigationDirection.horizontal : NavigationDirection.vertical;
            if (this.startNavigationCell && this.startNavigationCell.direction !== navDirection) {
                this.startNavigationCell.direction = oppositeDir;
            }
            else {
                this.setStartNavigationCell(colStart, rowStart, oppositeDir);
            }
            return navDirection === NavigationDirection.vertical ?
                this.startNavigationCell.colStart : this.startNavigationCell.rowStart;
        };
        IgxGridMRLNavigationService.prototype.navigateUp = function (rowElement, selectedNode) {
            this.focusCellUpFromLayout(rowElement, selectedNode);
        };
        IgxGridMRLNavigationService.prototype.navigateDown = function (rowElement, selectedNode) {
            this.focusCellDownFromLayout(rowElement, selectedNode);
        };
        IgxGridMRLNavigationService.prototype.isColumnRightEdgeVisible = function (visibleColumnIndex) {
            var column = this.grid.columnList.filter(function (c) { return !c.columnGroup; }).find(function (col) { return col.visibleIndex === visibleColumnIndex; });
            var forOfDir = this.grid.headerContainer;
            var horizontalScroll = forOfDir.getScroll();
            if (!horizontalScroll.clientWidth || (column && column.pinned)) {
                return true;
            }
            else if (column) {
                if (this.isParentColumnFullyVisible(column)) {
                    return true;
                }
                var scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
                return this.displayContainerWidth >= scrollPos.rightScroll - this.displayContainerScrollLeft &&
                    this.displayContainerScrollLeft <= scrollPos.leftScroll;
            }
            return false;
        };
        IgxGridMRLNavigationService.prototype.isParentColumnFullyVisible = function (parent) {
            var forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.headerContainer;
            var horizontalScroll = forOfDir.getScroll();
            if (!horizontalScroll.clientWidth || parent.pinned) {
                return true;
            }
            var index = forOfDir.igxForOf.indexOf(parent);
            return this.displayContainerWidth >= forOfDir.getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft &&
                this.displayContainerScrollLeft <= forOfDir.getColumnScrollLeft(index);
        };
        IgxGridMRLNavigationService.prototype.isColumnLeftEdgeVisible = function (visibleColumnIndex) {
            var forOfDir = this.grid.headerContainer;
            var horizontalScroll = forOfDir.getScroll();
            var column = this.grid.columnList.filter(function (c) { return !c.columnGroup; }).find(function (col) { return col.visibleIndex === visibleColumnIndex; });
            if (!horizontalScroll.clientWidth || column.pinned) {
                return true;
            }
            if (this.isParentColumnFullyVisible(column)) {
                return true;
            }
            var scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
            return this.displayContainerScrollLeft <= scrollPos.leftScroll;
        };
        IgxGridMRLNavigationService.prototype.onKeydownArrowRight = function (element, selectedNode) {
            this.focusNextCellFromLayout(element, selectedNode);
        };
        IgxGridMRLNavigationService.prototype.onKeydownArrowLeft = function (element, selectedNode) {
            this.focusPrevCellFromLayout(element, selectedNode);
        };
        Object.defineProperty(IgxGridMRLNavigationService.prototype, "gridOrderedColumns", {
            get: function () {
                return __spread(this.grid.pinnedColumns, this.grid.unpinnedColumns).filter(function (c) { return !c.columnGroup; })
                    .sort(function (a, b) { return a.visibleIndex - b.visibleIndex; });
            },
            enumerable: true,
            configurable: true
        });
        IgxGridMRLNavigationService.prototype.performTab = function (currentRowEl, selectedNode) {
            var visibleColumnIndex = selectedNode.layout ? selectedNode.layout.columnVisibleIndex : 0;
            var nextElementColumn = this.grid.columns.find(function (x) { return !x.columnGroup && x.visibleIndex === visibleColumnIndex + 1; });
            var rowIndex = selectedNode.row;
            var row = this.grid.getRowByIndex(rowIndex);
            this._moveFocusToCell(currentRowEl, nextElementColumn, row, selectedNode, 'next');
            if (nextElementColumn) {
                this.setStartNavigationCell(nextElementColumn.colStart, nextElementColumn.rowStart, null);
            }
        };
        IgxGridMRLNavigationService.prototype._moveFocusToCell = function (currentRowEl, nextElementColumn, row, selectedNode, dir) {
            var _this = this;
            if (nextElementColumn && row.cells) {
                var nextCell_1 = row.cells.find(function (currCell) { return currCell.column === nextElementColumn; });
                var isVisible = this.isColumnRightEdgeVisible(nextElementColumn.visibleIndex);
                if (!nextCell_1 || !isVisible) {
                    this.grid.nativeElement.focus({ preventScroll: true });
                    var cb = function () {
                        nextCell_1 = row.cells.find(function (currCell) { return currCell.column === nextElementColumn; });
                        if (_this.grid.rowEditable && _this.isRowInEditMode(row.index)) {
                            if (dir === 'next') {
                                _this.moveNextEditable(row.index, selectedNode.layout.columnVisibleIndex);
                            }
                            else {
                                _this.movePreviousEditable(row.index, selectedNode.layout.columnVisibleIndex);
                            }
                            return;
                        }
                        _this._focusCell(nextCell_1.nativeElement);
                    };
                    this.performHorizontalScrollToCell(row.index, nextElementColumn.visibleIndex, false, cb);
                }
                else {
                    if (this.grid.rowEditable && this.isRowInEditMode(row.index)) {
                        if (dir === 'next') {
                            this.moveNextEditable(row.index, selectedNode.layout.columnVisibleIndex);
                        }
                        else {
                            this.movePreviousEditable(row.index, selectedNode.layout.columnVisibleIndex);
                        }
                        return;
                    }
                    this._focusCell(nextCell_1.nativeElement);
                }
            }
            else {
                // end of layout reached
                if (this.isRowInEditMode(row.index)) {
                    //  TODO: make gridAPI visible for internal use and remove cast to any
                    this.grid.gridAPI.submit_value();
                    if (dir === 'next') {
                        this.grid.rowEditTabs.first.element.nativeElement.focus();
                    }
                    else {
                        this.grid.rowEditTabs.last.element.nativeElement.focus();
                    }
                    return;
                }
                if (dir === 'next') {
                    _super.prototype.navigateDown.call(this, currentRowEl, { row: row.index, column: 0 });
                }
                else {
                    var lastVisibleIndex_1 = 0;
                    this.grid.unpinnedColumns.forEach(function (col) {
                        lastVisibleIndex_1 = Math.max(lastVisibleIndex_1, col.visibleIndex);
                    });
                    _super.prototype.navigateUp.call(this, currentRowEl, { row: row.index, column: lastVisibleIndex_1 });
                }
            }
        };
        IgxGridMRLNavigationService.prototype.performShiftTabKey = function (currentRowEl, selectedNode) {
            var visibleColumnIndex = selectedNode.layout ? selectedNode.layout.columnVisibleIndex : 0;
            var rowIndex = selectedNode.row;
            var row = this.grid.getRowByIndex(rowIndex);
            var prevElementColumn = this.grid.columns.find(function (x) { return !x.columnGroup && x.visibleIndex === visibleColumnIndex - 1 && !x.hidden; });
            this._moveFocusToCell(currentRowEl, prevElementColumn, row, selectedNode, 'prev');
            if (prevElementColumn) {
                this.setStartNavigationCell(prevElementColumn.colStart, prevElementColumn.rowStart, null);
            }
        };
        IgxGridMRLNavigationService.prototype.focusCellUpFromLayout = function (rowElement, selectedNode) {
            var _this = this;
            var isNonDataRow = rowElement.tagName.toLowerCase() === 'igx-grid-groupby-row' || this._isDetailRecordAt(selectedNode.row);
            var currentRowStart = selectedNode.layout ? selectedNode.layout.rowStart : 1;
            var currentColStart = this.applyNavigationCell(selectedNode.layout ? selectedNode.layout.colStart : 1, currentRowStart, NavigationDirection.vertical);
            var parentIndex = selectedNode.column;
            var columnLayout = this.grid.columns.find(function (x) { return x.columnLayout && x.visibleIndex === parentIndex; });
            var movePrev;
            // check if element up is from the same layout
            var upperElementColumn = columnLayout.children.find(function (c) {
                return (c.rowEnd === currentRowStart || c.rowStart + c.gridRowSpan === currentRowStart) &&
                    c.colStart <= currentColStart &&
                    (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan);
            });
            if (isNonDataRow || !upperElementColumn) {
                // no prev row in current row layout, go to next row last rowstart
                var layoutRowEnd_1 = this.grid.multiRowLayoutRowSize + 1;
                upperElementColumn = columnLayout.children.find(function (c) {
                    return (c.rowEnd === layoutRowEnd_1 || c.rowStart + c.gridRowSpan === layoutRowEnd_1) &&
                        c.colStart <= currentColStart &&
                        (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan);
                });
                movePrev = true;
            }
            var rowIndex = movePrev ? selectedNode.row - 1 : selectedNode.row;
            if (rowIndex < 0) {
                // end of rows reached.
                return;
            }
            var prevRow;
            var cb = function () {
                prevRow = _this.grid.getRowByIndex(rowIndex);
                if (prevRow && prevRow.cells) {
                    _this._focusCell(upperElementColumn.cells.find(function (c) { return c.rowIndex === prevRow.index; }).nativeElement);
                }
                else if (prevRow) {
                    prevRow.nativeElement.focus({ preventScroll: true });
                }
                else {
                    var prevElem = _this.getRowByIndex(rowIndex, '');
                    prevElem.focus({ preventScroll: true });
                }
            };
            if (this.shouldPerformVerticalScroll(rowIndex, upperElementColumn.visibleIndex)) {
                this.grid.nativeElement.focus({ preventScroll: true });
                this.performVerticalScrollToCell(rowIndex, upperElementColumn.visibleIndex, cb);
            }
            else {
                cb();
            }
        };
        IgxGridMRLNavigationService.prototype.focusCellDownFromLayout = function (rowElement, selectedNode) {
            var _this = this;
            var isNonDataRow = rowElement.tagName.toLowerCase() === 'igx-grid-groupby-row' || this._isDetailRecordAt(selectedNode.row);
            var parentIndex = selectedNode.column;
            var columnLayout = this.grid.columns.find(function (x) { return x.columnLayout && x.visibleIndex === parentIndex; });
            var currentRowEnd = selectedNode.layout ? selectedNode.layout.rowEnd || selectedNode.layout.rowStart + 1 : 2;
            var currentColStart = this.applyNavigationCell(selectedNode.layout ? selectedNode.layout.colStart : 1, selectedNode.layout ? selectedNode.layout.rowStart : 1, NavigationDirection.vertical);
            var moveNext;
            // check if element down is from the same layout
            var nextElementColumn = columnLayout.children.find(function (c) { return c.rowStart === currentRowEnd &&
                c.colStart <= currentColStart &&
                (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan); });
            if (isNonDataRow || !nextElementColumn) {
                // no next row in current row layout, go to next row first rowstart
                nextElementColumn = columnLayout.children.find(function (c) { return c.rowStart === 1 &&
                    c.colStart <= currentColStart &&
                    (currentColStart < c.colEnd || currentColStart < c.colStart + c.gridColumnSpan); });
                moveNext = true;
            }
            var rowIndex = moveNext ? selectedNode.row + 1 : selectedNode.row;
            if (rowIndex > this.grid.dataView.length - 1) {
                // end of rows reached.
                return;
            }
            var nextRow;
            var cb = function () {
                nextRow = _this.grid.getRowByIndex(rowIndex);
                if (nextRow && nextRow.cells) {
                    _this._focusCell(nextElementColumn.cells.find(function (c) { return c.rowIndex === nextRow.index; }).nativeElement);
                }
                else if (nextRow) {
                    nextRow.nativeElement.focus({ preventScroll: true });
                }
                else {
                    var nextElem = _this.getRowByIndex(rowIndex, '');
                    nextElem.focus({ preventScroll: true });
                }
            };
            if (this.shouldPerformVerticalScroll(rowIndex, nextElementColumn.visibleIndex)) {
                this.grid.nativeElement.focus({ preventScroll: true });
                this.performVerticalScrollToCell(rowIndex, nextElementColumn.visibleIndex, cb);
            }
            else {
                cb();
            }
        };
        IgxGridMRLNavigationService.prototype.focusNextCellFromLayout = function (cellElement, selectedNode) {
            var _this = this;
            var parentIndex = selectedNode.column;
            var columnLayout = this.grid.columns.find(function (x) { return x.columnLayout && x.visibleIndex === parentIndex; });
            var currentColEnd = selectedNode.layout.colEnd || selectedNode.layout.colStart + 1;
            var currentRowStart = this.applyNavigationCell(selectedNode.layout.colStart, selectedNode.layout.rowStart, NavigationDirection.horizontal);
            var rowIndex = selectedNode.row;
            // check if next element is from the same layout
            var nextElementColumn = columnLayout.children.find(function (c) { return c.colStart === currentColEnd &&
                c.rowStart <= currentRowStart &&
                (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan); });
            if (!nextElementColumn) {
                // no next column in current layout, search for next layout
                columnLayout = this.grid.columns.find(function (c) { return c.columnLayout && !c.hidden && c.visibleIndex === columnLayout.visibleIndex + 1; });
                if (!columnLayout) {
                    // reached the end
                    return null;
                }
                // next element is from the next layout
                nextElementColumn = columnLayout.children.find(function (c) { return c.colStart === 1 &&
                    c.rowStart <= currentRowStart &&
                    (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan); });
            }
            var cb = function () {
                var nextElement = nextElementColumn.cells.find(function (c) { return c.rowIndex === rowIndex; }).nativeElement;
                _this._focusCell(nextElement);
            };
            if (!this.isColumnRightEdgeVisible(nextElementColumn.visibleIndex)) {
                this.grid.nativeElement.focus({ preventScroll: true });
                this.performHorizontalScrollToCell(rowIndex, nextElementColumn.visibleIndex, false, cb);
            }
            else {
                cb();
            }
        };
        IgxGridMRLNavigationService.prototype.focusPrevCellFromLayout = function (cellElement, selectedNode) {
            var _this = this;
            var parentIndex = selectedNode.column;
            var columnLayout = this.grid.columns.find(function (x) { return x.columnLayout && x.visibleIndex === parentIndex; });
            var currentColStart = selectedNode.layout.colStart;
            var currentRowStart = this.applyNavigationCell(currentColStart, selectedNode.layout.rowStart, NavigationDirection.horizontal);
            var rowIndex = selectedNode.row;
            // check previous element is from the same layout
            var prevElementColumn = columnLayout.children
                .find(function (c) { return (c.colEnd === currentColStart || c.colStart + c.gridColumnSpan === currentColStart) &&
                c.rowStart <= currentRowStart &&
                (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan); });
            if (!prevElementColumn) {
                // no prev column in current layout, seacrh for prev layout
                columnLayout = this.grid.columns.find(function (c) { return c.columnLayout && !c.hidden && c.visibleIndex === columnLayout.visibleIndex - 1; });
                if (!columnLayout) {
                    // reached the end
                    return null;
                }
                var layoutSize_1 = columnLayout.getInitialChildColumnSizes(columnLayout.children).length;
                // first element is from the next layout
                prevElementColumn = columnLayout.children
                    .find(function (c) { return (c.colEnd === layoutSize_1 + 1 || c.colStart + c.gridColumnSpan === layoutSize_1 + 1) &&
                    c.rowStart <= currentRowStart &&
                    (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan); });
            }
            var cb = function () {
                var prevElement = prevElementColumn.cells.find(function (c) { return c.rowIndex === rowIndex; }).nativeElement;
                _this._focusCell(prevElement);
            };
            if (!this.isColumnLeftEdgeVisible(prevElementColumn.visibleIndex)) {
                this.grid.nativeElement.focus({ preventScroll: true });
                this.performHorizontalScrollToCell(rowIndex, prevElementColumn.visibleIndex, false, cb);
            }
            else {
                cb();
            }
        };
        IgxGridMRLNavigationService.prototype.onKeydownEnd = function (rowIndex, isSummary, cellRowStart) {
            var _this = this;
            if (isSummary === void 0) { isSummary = false; }
            var layouts = this.grid.columns.filter(function (c) { return c.columnLayout && !c.hidden; }).sort(function (a, b) { return a.visibleIndex - b.visibleIndex; });
            var lastLayout = layouts[layouts.length - 1];
            var lastLayoutChildren = lastLayout.children;
            var layoutSize = lastLayout.getInitialChildColumnSizes(lastLayoutChildren).length;
            var currentRowStart = this.applyNavigationCell(this.startNavigationCell ? this.startNavigationCell.colStart : 1, cellRowStart || this.grid.multiRowLayoutRowSize, NavigationDirection.horizontal);
            var nextElementColumn = lastLayout.children.find(function (c) {
                return (c.colEnd === layoutSize + 1 || c.colStart + c.gridColumnSpan === layoutSize + 1) &&
                    c.rowStart <= currentRowStart &&
                    (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan);
            });
            var indexInLayout = lastLayoutChildren.toArray().indexOf(nextElementColumn);
            var rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
            var rowElement = rowList.find(function (row) { return row.index === rowIndex; });
            if (!rowElement) {
                return;
            }
            rowElement = rowElement.nativeElement;
            if (!this.isColumnRightEdgeVisible(nextElementColumn.visibleIndex)) {
                this.grid.nativeElement.focus({ preventScroll: true });
                var cb = function () {
                    var allBlocks = rowElement.querySelectorAll(_this.getColumnLayoutSelector());
                    var cell = allBlocks[allBlocks.length - 1].children[indexInLayout];
                    _this._focusCell(cell);
                };
                this.performHorizontalScrollToCell(rowIndex, nextElementColumn.visibleIndex, false, cb);
                return;
            }
            else {
                var allBlocks = rowElement.querySelectorAll(this.getColumnLayoutSelector());
                var cell = allBlocks[allBlocks.length - 1].children[indexInLayout];
                this._focusCell(cell);
            }
        };
        IgxGridMRLNavigationService.prototype.onKeydownHome = function (rowIndex, isSummary, cellRowStart) {
            var _this = this;
            if (isSummary === void 0) { isSummary = false; }
            if (cellRowStart === void 0) { cellRowStart = 1; }
            var firstLayout = this.grid.columns.filter(function (c) { return c.columnLayout && !c.hidden; })[0];
            var lastLayoutChildren = firstLayout.children.toArray();
            var currentRowStart = this.applyNavigationCell(this.startNavigationCell ? this.startNavigationCell.colStart : 1, cellRowStart, NavigationDirection.horizontal);
            var nextElementColumn = firstLayout.children.find(function (c) {
                return c.colStart === 1 &&
                    c.rowStart <= currentRowStart &&
                    (currentRowStart < c.rowEnd || currentRowStart < c.rowStart + c.gridRowSpan);
            });
            var indexInLayout = lastLayoutChildren.indexOf(nextElementColumn);
            var rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
            var rowElement = rowList.find(function (row) { return row.index === rowIndex; });
            if (!rowElement) {
                return;
            }
            rowElement = rowElement.nativeElement;
            if (!this.isColumnLeftEdgeVisible(nextElementColumn.visibleIndex)) {
                this.grid.nativeElement.focus({ preventScroll: true });
                var cb = function () {
                    var allBlocks = rowElement.querySelectorAll(_this.getColumnLayoutSelector());
                    var cell = allBlocks[0].children[indexInLayout];
                    _this._focusCell(cell);
                };
                this.performHorizontalScrollToCell(rowIndex, nextElementColumn.visibleIndex, false, cb);
                return;
            }
            else {
                var allBlocks = rowElement.querySelectorAll(this.getColumnLayoutSelector());
                var cell = allBlocks[0].children[indexInLayout];
                this._focusCell(cell);
            }
        };
        IgxGridMRLNavigationService.prototype.getColumnLayoutSelector = function () {
            return '.igx-grid__mrl-block';
        };
        IgxGridMRLNavigationService.prototype.getChildColumnScrollPositions = function (visibleColIndex) {
            var forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.headerContainer;
            var targetCol = this.getColunmByVisibleIndex(visibleColIndex);
            var parent = targetCol.parent;
            var parentVIndex = forOfDir.igxForOf.indexOf(parent);
            var leftScroll = forOfDir.getColumnScrollLeft(parentVIndex), rightScroll = 0;
            // caculate offset from parent based on target column colStart and colEnd and the resolved child column sizes.
            var childSizes = parent.getFilledChildColumnSizes(parent.children);
            var colStart = targetCol.colStart || 1;
            var colEnd = targetCol.colEnd || colStart + 1;
            for (var i = 1; i < colStart; i++) {
                leftScroll += parseInt(childSizes[i - 1], 10);
            }
            rightScroll += leftScroll;
            for (var j = colStart; j < colEnd; j++) {
                rightScroll += parseInt(childSizes[j - 1], 10);
            }
            return { leftScroll: leftScroll, rightScroll: rightScroll };
        };
        IgxGridMRLNavigationService.prototype.getColunmByVisibleIndex = function (visibleColIndex) {
            visibleColIndex = visibleColIndex < 0 ? 0 : visibleColIndex;
            return this.grid.columnList.find(function (col) { return !col.columnLayout && col.visibleIndex === visibleColIndex; });
        };
        IgxGridMRLNavigationService.prototype.shouldPerformVerticalScroll = function (rowIndex, visibleColumnIndex) {
            if (this._isGroupRecordAt(rowIndex) || this._isDetailRecordAt(rowIndex)) {
                return _super.prototype.shouldPerformVerticalScroll.call(this, rowIndex, visibleColumnIndex);
            }
            if (!_super.prototype.shouldPerformVerticalScroll.call(this, rowIndex, visibleColumnIndex)) {
                return false;
            }
            var targetRow = this.grid.summariesRowList.filter(function (s) { return s.index !== 0; })
                .concat(this.grid.rowList.toArray()).find(function (r) { return r.index === rowIndex; });
            var scrollTop = Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);
            var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
            var scrollPos = this.getVerticalScrollPositions(rowIndex, visibleColumnIndex);
            if (!targetRow || targetRow.nativeElement.offsetTop + scrollPos.topOffset < Math.abs(this.verticalDCTopOffset)
                || containerHeight && containerHeight < scrollPos.rowBottom - scrollTop) {
                return true;
            }
            else {
                return false;
            }
        };
        Object.defineProperty(IgxGridMRLNavigationService.prototype, "verticalDCTopOffset", {
            get: function () {
                return parseInt(this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            },
            enumerable: true,
            configurable: true
        });
        IgxGridMRLNavigationService.prototype._isGroupRecordAt = function (rowIndex) {
            var record = this.grid.dataView[rowIndex];
            return record.records && record.records.length;
        };
        IgxGridMRLNavigationService.prototype._isDetailRecordAt = function (rowIndex) {
            var record = this.grid.dataView[rowIndex];
            return this.grid.isDetailRecord(record);
        };
        IgxGridMRLNavigationService.prototype.performVerticalScrollToCell = function (rowIndex, visibleColumnIndex, cb) {
            if (this._isGroupRecordAt(rowIndex) || this._isDetailRecordAt(rowIndex)) {
                return _super.prototype.performVerticalScrollToCell.call(this, rowIndex, visibleColumnIndex, cb);
            }
            var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
            var scrollTop = Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);
            var scrollPos = this.getVerticalScrollPositions(rowIndex, visibleColumnIndex);
            var targetRow = this.grid.summariesRowList.filter(function (s) { return s.index !== 0; })
                .concat(this.grid.rowList.toArray()).find(function (r) { return r.index === rowIndex; });
            var isPrevious = (scrollTop > scrollPos.rowTop) && (!targetRow ||
                targetRow.nativeElement.offsetTop + scrollPos.topOffset < Math.abs(this.verticalDCTopOffset));
            var scrollAmount = isPrevious ? scrollPos.rowTop : Math.abs(scrollTop + containerHeight - scrollPos.rowBottom);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(operators.first()).subscribe(function () {
                cb();
            });
            if (isPrevious) {
                this.grid.verticalScrollContainer.scrollPosition = scrollAmount;
            }
            else {
                this.grid.verticalScrollContainer.addScrollTop(scrollAmount);
            }
        };
        IgxGridMRLNavigationService.prototype.getVerticalScrollPositions = function (rowIndex, visibleColIndex) {
            var targetCol = this.getColunmByVisibleIndex(visibleColIndex);
            var topOffset = (targetCol.rowStart - 1) * this.grid.defaultRowHeight;
            var rowTop = this.grid.verticalScrollContainer.sizesCache[rowIndex] + topOffset;
            var rowBottom = rowTop + (this.grid.defaultRowHeight * targetCol.gridRowSpan);
            return { rowTop: rowTop, rowBottom: rowBottom, topOffset: topOffset };
        };
        IgxGridMRLNavigationService.prototype.performHorizontalScrollToCell = function (rowIndex, visibleColumnIndex, isSummary, cb) {
            var _this = this;
            if (isSummary === void 0) { isSummary = false; }
            var scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
            var hScroll = this.horizontalScroll(rowIndex);
            this.grid.parentVirtDir.onChunkLoad
                .pipe(operators.first())
                .subscribe(function () {
                if (cb) {
                    cb();
                }
                else {
                    _this._focusCell(_this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary));
                }
            });
            var isPrevItem = hScroll.getScroll().scrollLeft > scrollPos.leftScroll;
            var containerSize = parseInt(hScroll.igxForContainerSize, 10);
            var nextScroll = isPrevItem ? scrollPos.leftScroll : scrollPos.rightScroll - containerSize;
            hScroll.scrollPosition = nextScroll;
        };
        IgxGridMRLNavigationService.prototype._focusCell = function (cellElem) {
            // in case of variable row heights in mrl grid make sure cell is really in view after it has been rendered.
            var gridBoundingClientRect = this.grid.tbody.nativeElement.getBoundingClientRect();
            var diffTop = cellElem.getBoundingClientRect().top - gridBoundingClientRect.top;
            var diffBottom = cellElem.getBoundingClientRect().bottom - gridBoundingClientRect.bottom;
            if (diffTop < 0) {
                // cell is above grid top - not visible
                this.grid.nativeElement.focus({ preventScroll: true });
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(operators.first())
                    .subscribe(function () {
                    cellElem.focus({ preventScroll: true });
                });
                this.grid.verticalScrollContainer.addScrollTop(diffTop);
            }
            else if (diffBottom > 0) {
                // cell is below grid bottom - not visible
                this.grid.nativeElement.focus({ preventScroll: true });
                this.grid.verticalScrollContainer.onChunkLoad
                    .pipe(operators.first())
                    .subscribe(function () {
                    cellElem.focus({ preventScroll: true });
                });
                this.grid.verticalScrollContainer.addScrollTop(diffBottom);
            }
            else {
                // cell is visible
                cellElem.focus({ preventScroll: true });
            }
        };
        IgxGridMRLNavigationService.prototype.goToFirstCell = function () {
            this.startNavigationCell = null;
            _super.prototype.goToFirstCell.call(this);
        };
        IgxGridMRLNavigationService.prototype.goToLastCell = function () {
            this.startNavigationCell = null;
            _super.prototype.goToLastCell.call(this);
        };
        IgxGridMRLNavigationService = __decorate([
            core.Injectable()
        ], IgxGridMRLNavigationService);
        return IgxGridMRLNavigationService;
    }(IgxGridNavigationService));

    var NEXT_ID$m = 0;
    /**
     * Grid provides a way to present and manipulate tabular data.
     *@igxModule IgxGridModule
     *@igxGroup Grids & Lists
     *@igxKeywords grid, table
     *@igxTheme igx-grid-theme
     *@remarks
     * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
     * has been bound, it can be manipulated through filtering, sorting & editing operations.
     *@example
     * ```html
     * <igx-grid [data]="employeeData" autoGenerate="false">
     *   <igx-column field="first" header="First Name"></igx-column>
     *   <igx-column field="last" header="Last Name"></igx-column>
     *   <igx-column field="role" header="Role"></igx-column>
     * </igx-grid>
     * ```
     */
    var IgxGridComponent = /** @class */ (function (_super) {
        __extends(IgxGridComponent, _super);
        function IgxGridComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._id = "igx-grid-" + NEXT_ID$m++;
            /**
             * @hidden
             */
            _this._groupingExpressions = [];
            /**
             * @hidden
             */
            _this._groupingExpandState = [];
            _this._hideGroupedColumns = false;
            _this._dropAreaMessage = null;
            _this._filteredData = null;
            _this.childDetailTemplates = new Map();
            /**
             *@hidden
             */
            _this.groupingExpressionsChange = new core.EventEmitter();
            /**
            *@hidden @internal
            */
            _this.groupingExpansionStateChange = new core.EventEmitter();
            /**
             * Gets/Sets whether created groups are rendered expanded or collapsed.
             * @remarks
             * The default rendered state is expanded.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.groupsExpanded = true;
            /**
             * Gets the hierarchical representation of the group by records.
             * @example
             * ```typescript
             * let groupRecords = this.grid.groupsRecords;
             * ```
             */
            _this.groupsRecords = [];
            /**
             * Emitted when columns are grouped/ungrouped.
             * @remarks
             * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
             * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
             * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
             * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
             * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
             * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
             * columns.
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
             * ```
             */
            _this.onGroupingDone = new core.EventEmitter();
            /**
            * @hidden @internal
            */
            _this.detailTemplate = null;
            /**
             *@hidden @internal
             */
            _this._focusIn = new core.EventEmitter();
            return _this;
        }
        IgxGridComponent_1 = IgxGridComponent;
        Object.defineProperty(IgxGridComponent.prototype, "id", {
            /**
             * Gets/Sets the value of the `id` attribute.
             * @remarks
             * If not provided it will be automatically generated.
             * @example
             * ```html
             * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "data", {
            /**
             * Gets/Sets the array of data that populates the `IgxGridComponent`.
             * @example
             * ```html
             * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
             * ```
            */
            get: function () {
                return this._data;
            },
            set: function (value) {
                this._data = value || [];
                this.summaryService.clearSummaryCache();
                if (this.shouldGenerate) {
                    this.setupColumns();
                }
                this.cdr.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "filteredData", {
            /**
             * Gets/Sets an array of objects containing the filtered data.
             * @example
             * ```typescript
             * let filteredData = this.grid.filteredData;
             * this.grid.filteredData = [...];
             * ```
             */
            get: function () {
                return this._filteredData;
            },
            set: function (value) {
                this._filteredData = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "totalItemCount", {
            get: function () {
                return this.verticalScrollContainer.totalItemCount;
            },
            /**
             * Gets/Sets the total number of records in the data source.
             * @remarks
             * This property is required for remote grid virtualization to function when it is bound to remote data.
             * @example
             * ```typescript
             * const itemCount = this.grid1.totalItemCount;
             * this.grid1.totalItemCount = 55;
             * ```
             */
            set: function (count) {
                this.verticalScrollContainer.totalItemCount = count;
                this.cdr.detectChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "_gridAPI", {
            get: function () {
                return this.gridAPI;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupingExpressions", {
            /**
             * Gets/Sets the group by state.
             * @example
             * ```typescript
             * let groupByState = this.grid.groupingExpressions;
             * this.grid.groupingExpressions = [...];
             * ```
             * @remarks
             * Supports two-way data binding.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpressions)]="model.groupingExpressions"></igx-grid>
             * ```
             */
            get: function () {
                return this._groupingExpressions;
            },
            set: function (value) {
                var _this = this;
                if (value && value.length > 10) {
                    throw Error('Maximum amount of grouped columns is 10.');
                }
                var oldExpressions = this.groupingExpressions;
                var newExpressions = value;
                this._groupingExpressions = cloneArray(value);
                this.groupingExpressionsChange.emit(this._groupingExpressions);
                this.chipsGoupingExpressions = cloneArray(value);
                if (this._gridAPI.grid) {
                    /* grouping should work in conjunction with sorting
                    and without overriding separate sorting expressions */
                    this._applyGrouping();
                    this._gridAPI.arrange_sorting_expressions();
                    this.notifyChanges();
                }
                else {
                    // setter called before grid is registered in grid API service
                    this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
                }
                if (!this._init && JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
                    var groupedCols_1 = [];
                    var ungroupedCols_1 = [];
                    var groupedColsArr = newExpressions.filter(function (obj) {
                        return !oldExpressions.some(function (obj2) {
                            return obj.fieldName === obj2.fieldName;
                        });
                    });
                    groupedColsArr.forEach(function (elem) {
                        groupedCols_1.push(_this.getColumnByName(elem.fieldName));
                    }, this);
                    var ungroupedColsArr = oldExpressions.filter(function (obj) {
                        return !newExpressions.some(function (obj2) {
                            return obj.fieldName === obj2.fieldName;
                        });
                    });
                    ungroupedColsArr.forEach(function (elem) {
                        ungroupedCols_1.push(_this.getColumnByName(elem.fieldName));
                    }, this);
                    this.notifyChanges();
                    var groupingDoneArgs = {
                        expressions: newExpressions,
                        groupedColumns: groupedCols_1,
                        ungroupedColumns: ungroupedCols_1
                    };
                    this.onGroupingDone.emit(groupingDoneArgs);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupingExpansionState", {
            /**
             * Gets/Sets a list of expansion states for group rows.
             * @remarks
             * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
             * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
             * Supports two-way data binding.
             * @example
             * ```html
             * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpansionState)]="model.groupingExpansionState"></igx-grid>
             * ```
             */
            get: function () {
                return this._groupingExpandState;
            },
            set: function (value) {
                if (value !== this._groupingExpandState) {
                    this.groupingExpansionStateChange.emit(value);
                }
                this._groupingExpandState = value;
                if (this.gridAPI.grid) {
                    this.cdr.detectChanges();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "hideGroupedColumns", {
            /**
             * Gets/Sets whether the grouped columns should be hidden.
             * @remarks
             * The default value is "false"
             * @example
             * ```html
             * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
             * ```
             */
            get: function () {
                return this._hideGroupedColumns;
            },
            set: function (value) {
                if (value) {
                    this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
                }
                else {
                    this.groupingDiffer = null;
                }
                if (this.columnList && this.groupingExpressions) {
                    this._setGroupColsVisibility(value);
                }
                this._hideGroupedColumns = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "dropAreaMessage", {
            get: function () {
                return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
            },
            /**
             * Gets/Sets the message displayed inside the GroupBy drop area where columns can be dragged on.
             * @remarks
             * The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
             * @example
             * ```html
             * <igx-grid dropAreaMessage="Drop here to group!">
             *      <igx-column [groupable]="true" field="ID"></igx-column>
             * </igx-grid>
             * ```
             */
            set: function (value) {
                this._dropAreaMessage = value;
                this.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupsRowList", {
            /**
             * Gets the list of group rows.
             * @example
             * ```typescript
             * const groupList = this.grid.groupsRowList;
             * ```
             */
            get: function () {
                var res = new core.QueryList();
                if (!this._groupsRowList) {
                    return res;
                }
                var rList = this._groupsRowList.filter(function (item) {
                    return item.element.nativeElement.parentElement !== null;
                }).sort(function (item1, item2) { return item1.index - item2.index; });
                res.reset(rList);
                return res;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridComponent.prototype.onFocusIn = function () {
            this._focusIn.emit();
        };
        /**
         *@hidden @internal
        */
        IgxGridComponent.prototype.getDetailsContext = function (rowData, index) {
            return {
                $implicit: rowData,
                index: index
            };
        };
        /**
        *@hidden @internal
        */
        IgxGridComponent.prototype.preventContainerScroll = function (evt) {
            var _this = this;
            if (evt.target.scrollTop !== 0 && this.hasDetails) {
                var activeElem_1 = document.activeElement;
                this.verticalScrollContainer.addScrollTop(evt.target.scrollTop);
                evt.target.scrollTop = 0;
                this.verticalScrollContainer.onChunkLoad.pipe(operators.first()).subscribe(function () {
                    var active = _this.selectionService.activeElement;
                    var currRow = _this.navigation.getRowByIndex(active.row, '');
                    // check if the focused element was a child of the details view
                    if (_this.isDetailRecord(active.row) && currRow && currRow.contains(activeElem_1)) {
                        // Some browsers (like Edge/IE) lose focus after scrolling even when the element was in the DOM.
                        activeElem_1.focus({ preventScroll: true });
                        return;
                    }
                    var nextCellTarget = _this.navigation.getCellElementByVisibleIndex(active.row, active.column);
                    var nextRowTarget = _this.navigation.getRowByIndex(active.row + 1, '');
                    if (nextCellTarget) {
                        nextCellTarget.focus({ preventScroll: true });
                    }
                    else if (nextRowTarget) {
                        nextRowTarget.focus({ preventScroll: true });
                    }
                });
            }
        };
        /**
        *@hidden @internal
        */
        IgxGridComponent.prototype.trackChanges = function (index, rec) {
            if (rec.detailsData !== undefined) {
                return rec.detailsData;
            }
            return rec;
        };
        /**
        *@hidden @internal
        */
        IgxGridComponent.prototype.detailsViewFocused = function (container, rowIndex) {
            this.selectionService.activeElement = {
                row: rowIndex,
                column: this.selectionService.activeElement ? this.selectionService.activeElement.column : 0
            };
        };
        /**
        *@hidden @internal
        */
        IgxGridComponent.prototype.detailsKeyboardHandler = function (event, rowIndex, container) {
            var _this = this;
            var colIndex = this.selectionService.activeElement ? this.selectionService.activeElement.column : 0;
            var shift = event.shiftKey;
            var ctrl = event.ctrlKey;
            var key = event.key.toLowerCase();
            var target = event.target;
            if (key === 'tab') {
                event.stopPropagation();
                var lastColIndex_1 = this.unpinnedColumns[this.unpinnedColumns.length - 1].visibleIndex;
                if (shift && target === container) {
                    // shift + tab from details to data row
                    event.preventDefault();
                    this.navigateTo(rowIndex - 1, lastColIndex_1, function (args) { return args.target.nativeElement.focus(); });
                }
                else if (!shift) {
                    // when the next element is focused via tab check if it is an element outside the details view
                    // if so we have exited the details view and focus should move to the first cell in the next row
                    this._focusIn.pipe(operators.first()).subscribe(function () {
                        if (!container.contains(document.activeElement)) {
                            _this.navigation.performTab(container, { row: rowIndex, column: lastColIndex_1 });
                        }
                    });
                }
            }
            else if (key === 'arrowup' && !ctrl && target === container) {
                this.navigation.navigateUp(container, { row: rowIndex, column: colIndex });
            }
            else if (key === 'arrowup' && ctrl && target === container) {
                this.navigation.navigateTop(colIndex);
            }
            else if (key === 'arrowdown' && !ctrl && target === container) {
                this.navigation.navigateDown(container, { row: rowIndex, column: colIndex });
            }
            else if (key === 'arrowdown' && ctrl && target === container) {
                this.navigation.navigateBottom(colIndex);
            }
        };
        Object.defineProperty(IgxGridComponent.prototype, "hasDetails", {
            /**
            *@hidden @internal
            */
            get: function () {
                return !!this.gridDetailsTemplate;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @hidden @internal
        */
        IgxGridComponent.prototype.getRowTemplate = function (rowData) {
            if (this.isGroupByRecord(rowData)) {
                return this.defaultGroupTemplate;
            }
            else if (this.isSummaryRow(rowData)) {
                return this.summaryTemplate;
            }
            else if (this.hasDetails && this.isDetailRecord(rowData)) {
                return this.detailTemplateContainer;
            }
            else {
                return this.recordTemplate;
            }
        };
        /**
        * @hidden @internal
        */
        IgxGridComponent.prototype.isDetailRecord = function (record) {
            return record.detailsData !== undefined;
        };
        Object.defineProperty(IgxGridComponent.prototype, "groupAreaHostClass", {
            /**
             * @hidden @internal
             */
            get: function () {
                return this.getComponentDensityClass('igx-drop-area');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupRowTemplate", {
            /**
             * Gets/Sets the template reference for the group row.
             * @example
             * ```
             * const groupRowTemplate = this.grid.groupRowTemplate;
             * this.grid.groupRowTemplate = myRowTemplate;
             * ```
             */
            get: function () {
                return this._groupRowTemplate;
            },
            set: function (template) {
                this._groupRowTemplate = template;
                this.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridComponent.prototype, "groupAreaTemplate", {
            /**
             * Gets/Sets the template reference of the `IgxGridComponent`'s group area.
             * @example
             * ```typescript
             * const groupAreaTemplate = this.grid.groupAreaTemplate;
             * this.grid.groupAreaTemplate = myAreaTemplate.
             * ```
             */
            get: function () {
                return this._groupAreaTemplate;
            },
            set: function (template) {
                this._groupAreaTemplate = template;
                this.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
         * @remarks
         * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
         * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
         * @example
         * ```typescript
         * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
         * this.grid.groupBy([
                { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
                { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
                { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
            ]);
         * ```
         */
        IgxGridComponent.prototype.groupBy = function (expression) {
            if (this.checkIfNoColumnField(expression)) {
                return;
            }
            this.endEdit(true);
            if (expression instanceof Array) {
                this._gridAPI.groupBy_multiple(expression);
            }
            else {
                this._gridAPI.groupBy(expression);
            }
            this.notifyChanges(true);
        };
        /**
         * Clears grouping for particular column, array of columns or all columns.
         * @remarks
         * Clears all grouping in the grid, if no parameter is passed.
         * If a parameter is provided, clears grouping for a particular column or an array of columns.
         * @example
         * ```typescript
         * this.grid.clearGrouping(); //clears all grouping
         * this.grid.clearGrouping("ID"); //ungroups a single column
         * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
         * ```
         *@param name Name of column or array of column names to be ungrouped.
         */
        IgxGridComponent.prototype.clearGrouping = function (name) {
            this._gridAPI.clear_groupby(name);
            this.notifyChanges(true);
        };
        /**
         * Returns if a group is expanded or not.
         * @param group The group record.
         * @example
         * ```typescript
         * public groupRow: IGroupByRecord;
         * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
         * ```
         */
        IgxGridComponent.prototype.isExpandedGroup = function (group) {
            var state = this._getStateForGroupRow(group);
            return state ? state.expanded : this.groupsExpanded;
        };
        /**
         * Toggles the expansion state of a group.
         * @param groupRow The group record to toggle.
         * @example
         * ```typescript
         * public groupRow: IGroupByRecord;
         * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
         * ```
         */
        IgxGridComponent.prototype.toggleGroup = function (groupRow) {
            this._toggleGroup(groupRow);
            this.notifyChanges();
        };
        /**
         * Expands the specified group and all of its parent groups.
         * @param groupRow The group record to fully expand.
         * @example
         * ```typescript
         * public groupRow: IGroupByRecord;
         * this.grid.fullyExpandGroup(this.groupRow);
         * ```
         */
        IgxGridComponent.prototype.fullyExpandGroup = function (groupRow) {
            this._fullyExpandGroup(groupRow);
            this.notifyChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.isGroupByRecord = function (record) {
            // return record.records instance of GroupedRecords fails under Webpack
            return record.records && record.records.length;
        };
        /**
         * Toggles the expansion state of all group rows recursively.
         * @example
         * ```typescript
         * this.grid.toggleAllGroupRows;
         * ```
         */
        IgxGridComponent.prototype.toggleAllGroupRows = function () {
            this.groupingExpansionState = [];
            this.groupsExpanded = !this.groupsExpanded;
            this.notifyChanges();
        };
        Object.defineProperty(IgxGridComponent.prototype, "hasGroupableColumns", {
            /**
             * Returns if the `IgxGridComponent` has groupable columns.
             * @example
             * ```typescript
             * const groupableGrid = this.grid.hasGroupableColumns;
             * ```
             */
            get: function () {
                return this.columnList.some(function (col) { return col.groupable && !col.columnGroup; });
            },
            enumerable: true,
            configurable: true
        });
        IgxGridComponent.prototype._setGroupColsVisibility = function (value) {
            var _this = this;
            if (this.columnList.length > 0 && !this.hasColumnLayouts) {
                this.groupingExpressions.forEach(function (expr) {
                    var col = _this.getColumnByName(expr.fieldName);
                    col.hidden = value;
                });
            }
        };
        Object.defineProperty(IgxGridComponent.prototype, "dropAreaVisible", {
            /**
             * Gets if the grid's group by drop area is visible.
             * @example
             * ```typescript
             * const dropVisible = this.grid.dropAreaVisible;
             * ```
             */
            get: function () {
                return (this.draggedColumn && this.draggedColumn.groupable) ||
                    !this.chipsGoupingExpressions.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype._getStateForGroupRow = function (groupRow) {
            return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
        };
        /**
         * @hidden
         */
        IgxGridComponent.prototype._toggleGroup = function (groupRow) {
            this._gridAPI.groupBy_toggle_group(groupRow);
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype._fullyExpandGroup = function (groupRow) {
            this._gridAPI.groupBy_fully_expand_group(groupRow);
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype._applyGrouping = function () {
            this._gridAPI.sort_multiple(this._groupingExpressions);
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.isColumnGrouped = function (fieldName) {
            return this.groupingExpressions.find(function (exp) { return exp.fieldName === fieldName; }) ? true : false;
        };
        /**
        * @hidden @internal
        */
        IgxGridComponent.prototype.getContext = function (rowData, rowIndex) {
            if (this.isDetailRecord(rowData)) {
                var cachedData = this.childDetailTemplates.get(rowData.detailsData);
                var rowID = this.primaryKey ? rowData.detailsData[this.primaryKey] : this.data.indexOf(rowData.detailsData);
                if (cachedData) {
                    var view = cachedData.view;
                    var tmlpOutlet = cachedData.owner;
                    return {
                        $implicit: rowData.detailsData,
                        moveView: view,
                        owner: tmlpOutlet,
                        index: this.dataView.indexOf(rowData),
                        templateID: 'detailRow-' + rowID
                    };
                }
                else {
                    // child rows contain unique grids, hence should have unique templates
                    return {
                        $implicit: rowData.detailsData,
                        templateID: 'detailRow-' + rowID,
                        index: this.dataView.indexOf(rowData)
                    };
                }
            }
            return {
                $implicit: rowData,
                index: rowIndex,
                templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
            };
        };
        /**
        * @hidden @internal
        */
        IgxGridComponent.prototype.viewCreatedHandler = function (args) {
            if (args.context.templateID.indexOf('detailRow') !== -1) {
                this.childDetailTemplates.set(args.context.$implicit, args);
            }
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.viewMovedHandler = function (args) {
            if (args.context.templateID.indexOf('detailRow') !== -1) {
                // view was moved, update owner in cache
                var key = args.context.$implicit;
                var cachedData = this.childDetailTemplates.get(key);
                cachedData.owner = args.owner;
            }
        };
        Object.defineProperty(IgxGridComponent.prototype, "template", {
            /**
            * @hidden @internal
            */
            get: function () {
                if (this.filteredData && this.filteredData.length === 0) {
                    return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
                }
                if (this.isLoading && (!this.data || this.dataLength === 0)) {
                    return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
                }
                if (this.dataLength === 0) {
                    return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.onChipRemoved = function (event) {
            this.clearGrouping(event.owner.id);
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.chipsOrderChanged = function (event) {
            var newGrouping = [];
            var _loop_1 = function (i) {
                var expr = this_1.groupingExpressions.filter(function (item) {
                    return item.fieldName === event.chipsArray[i].id;
                })[0];
                if (!this_1.getColumnByName(expr.fieldName).groupable) {
                    return { value: void 0 };
                }
                newGrouping.push(expr);
            };
            var this_1 = this;
            for (var i = 0; i < event.chipsArray.length; i++) {
                var state_1 = _loop_1(i);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            this.groupingExpansionState = [];
            this.chipsGoupingExpressions = newGrouping;
            if (event.originalEvent instanceof KeyboardEvent) {
                // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
                this.groupingExpressions = this.chipsGoupingExpressions;
            }
            this.notifyChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.chipsMovingEnded = function () {
            this.groupingExpressions = this.chipsGoupingExpressions;
            this.notifyChanges();
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.onChipClicked = function (event) {
            var sortingExpr = this.sortingExpressions;
            var columnExpr = sortingExpr.find(function (expr) { return expr.fieldName === event.owner.id; });
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.notifyChanges();
        };
        /**
         *@hidden @internal
         */
        IgxGridComponent.prototype.onChipKeyDown = function (event) {
            if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
                var sortingExpr = this.sortingExpressions;
                var columnExpr = sortingExpr.find(function (expr) { return expr.fieldName === event.owner.id; });
                columnExpr.dir = 3 - columnExpr.dir;
                this.sort(columnExpr);
                this.notifyChanges();
            }
        };
        Object.defineProperty(IgxGridComponent.prototype, "defaultTargetBodyHeight", {
            /**
             * @hidden @internal
             */
            get: function () {
                var allItems = this.totalItemCount || this.dataLength;
                return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.getGroupAreaHeight = function () {
            return this.groupArea ? this.groupArea.nativeElement.offsetHeight : 0;
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.scrollTo = function (row, column) {
            if (this.groupingExpressions && this.groupingExpressions.length
                && typeof (row) !== 'number') {
                var rowIndex = this.groupingResult.indexOf(row);
                var groupByRecord = this.groupingMetadata[rowIndex];
                if (groupByRecord) {
                    this._fullyExpandGroup(groupByRecord);
                }
            }
            _super.prototype.scrollTo.call(this, row, column, this.groupingFlatResult);
        };
        Object.defineProperty(IgxGridComponent.prototype, "dropAreaTemplateResolved", {
            /**
            * @hidden @internal
            */
            get: function () {
                if (this.dropAreaTemplate) {
                    return this.dropAreaTemplate;
                }
                else {
                    return this.defaultDropAreaTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.getGroupByChipTitle = function (expression) {
            var column = this.getColumnByName(expression.fieldName);
            return (column && column.header) || expression.fieldName;
        };
        Object.defineProperty(IgxGridComponent.prototype, "iconTemplate", {
            /**
             * @hidden @internal
             */
            get: function () {
                if (this.groupsExpanded) {
                    return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
                }
                else {
                    return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.getColumnGroupable = function (fieldName) {
            var column = this.getColumnByName(fieldName);
            return column && column.groupable;
        };
        /**
         * @hidden @internal
         */
        IgxGridComponent.prototype.ngAfterContentInit = function () {
            _super.prototype.ngAfterContentInit.call(this);
            if (this.allowFiltering && this.hasColumnLayouts) {
                this.filterMode = exports.FilterMode.excelStyleFilter;
            }
            if (this.groupTemplate) {
                this._groupRowTemplate = this.groupTemplate.template;
            }
            if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
                this._setGroupColsVisibility(this.hideGroupedColumns);
            }
            this._setupNavigationService();
        };
        /**
        * @hidden @internal
        */
        IgxGridComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            this.verticalScrollContainer.onBeforeViewDestroyed.pipe(operators.takeUntil(this.destroy$)).subscribe(function (view) {
                var rowData = view.context.$implicit;
                if (_this.isDetailRecord(rowData)) {
                    var cachedData = _this.childDetailTemplates.get(rowData.detailsData);
                    if (cachedData) {
                        var tmlpOutlet = cachedData.owner;
                        tmlpOutlet._viewContainerRef.detach(0);
                    }
                }
            });
        };
        /**
        * @hidden @internal
        */
        IgxGridComponent.prototype.ngOnInit = function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            this.onGroupingDone.pipe(operators.takeUntil(this.destroy$)).subscribe(function (args) {
                _this.endEdit(true);
                _this.summaryService.updateSummaryCache(args);
                _this._headerFeaturesWidth = NaN;
            });
        };
        /**
        * @hidden @internal
        */
        IgxGridComponent.prototype.ngDoCheck = function () {
            var _this = this;
            if (this.groupingDiffer && this.columnList && !this.hasColumnLayouts) {
                var changes = this.groupingDiffer.diff(this.groupingExpressions);
                if (changes && this.columnList.length > 0) {
                    changes.forEachAddedItem(function (rec) {
                        var col = _this.getColumnByName(rec.item.fieldName);
                        col.hidden = true;
                    });
                    changes.forEachRemovedItem(function (rec) {
                        var col = _this.getColumnByName(rec.item.fieldName);
                        col.hidden = false;
                    });
                }
            }
            _super.prototype.ngDoCheck.call(this);
        };
        /**
         * @inheritdoc
         */
        IgxGridComponent.prototype.getSelectedData = function (formatters, headers) {
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            if (this.groupingExpressions.length) {
                var source_1 = [];
                var process = function (record) {
                    if (record.expression || record.summaries) {
                        source_1.push(null);
                        return;
                    }
                    source_1.push(record);
                };
                this.dataView.forEach(process);
                return this.extractDataFromSelection(source_1, formatters, headers);
            }
            else {
                return _super.prototype.getSelectedData.call(this, formatters, headers);
            }
        };
        IgxGridComponent.prototype._setupNavigationService = function () {
            if (this.hasColumnLayouts) {
                this.navigation = new IgxGridMRLNavigationService();
                this.navigation.grid = this;
            }
        };
        IgxGridComponent.prototype.checkIfNoColumnField = function (expression) {
            var e_1, _a;
            if (expression instanceof Array) {
                try {
                    for (var expression_1 = __values(expression), expression_1_1 = expression_1.next(); !expression_1_1.done; expression_1_1 = expression_1.next()) {
                        var singleExpression = expression_1_1.value;
                        if (!singleExpression.fieldName) {
                            return true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (expression_1_1 && !expression_1_1.done && (_a = expression_1.return)) _a.call(expression_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return false;
            }
            return !expression.fieldName;
        };
        var IgxGridComponent_1;
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxGridComponent.prototype, "id", null);
        __decorate([
            core.Input()
        ], IgxGridComponent.prototype, "data", null);
        __decorate([
            core.Input()
        ], IgxGridComponent.prototype, "groupingExpressions", null);
        __decorate([
            core.Output()
        ], IgxGridComponent.prototype, "groupingExpressionsChange", void 0);
        __decorate([
            core.Input()
        ], IgxGridComponent.prototype, "groupingExpansionState", null);
        __decorate([
            core.Output()
        ], IgxGridComponent.prototype, "groupingExpansionStateChange", void 0);
        __decorate([
            core.Input()
        ], IgxGridComponent.prototype, "groupsExpanded", void 0);
        __decorate([
            core.Input()
        ], IgxGridComponent.prototype, "hideGroupedColumns", null);
        __decorate([
            core.Input()
        ], IgxGridComponent.prototype, "dropAreaMessage", null);
        __decorate([
            core.Input()
        ], IgxGridComponent.prototype, "dropAreaTemplate", void 0);
        __decorate([
            core.Output()
        ], IgxGridComponent.prototype, "onGroupingDone", void 0);
        __decorate([
            core.ContentChild(IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective })
        ], IgxGridComponent.prototype, "groupTemplate", void 0);
        __decorate([
            core.ContentChild(IgxGridDetailTemplateDirective, { read: IgxGridDetailTemplateDirective, static: false })
        ], IgxGridComponent.prototype, "gridDetailsTemplate", void 0);
        __decorate([
            core.ViewChildren(IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent })
        ], IgxGridComponent.prototype, "_groupsRowList", void 0);
        __decorate([
            core.ViewChild('defaultDropArea', { read: core.TemplateRef, static: true })
        ], IgxGridComponent.prototype, "defaultDropAreaTemplate", void 0);
        __decorate([
            core.ViewChild('groupArea')
        ], IgxGridComponent.prototype, "groupArea", void 0);
        __decorate([
            core.ViewChild('record_template', { read: core.TemplateRef, static: true })
        ], IgxGridComponent.prototype, "recordTemplate", void 0);
        __decorate([
            core.ViewChild('detail_template_container', { read: core.TemplateRef, static: true })
        ], IgxGridComponent.prototype, "detailTemplateContainer", void 0);
        __decorate([
            core.ContentChild(IgxGridDetailTemplateDirective, { read: core.TemplateRef, static: false })
        ], IgxGridComponent.prototype, "detailTemplate", void 0);
        __decorate([
            core.ViewChild('group_template', { read: core.TemplateRef, static: true })
        ], IgxGridComponent.prototype, "defaultGroupTemplate", void 0);
        __decorate([
            core.ViewChild('summary_template', { read: core.TemplateRef, static: true })
        ], IgxGridComponent.prototype, "summaryTemplate", void 0);
        __decorate([
            core.Output()
        ], IgxGridComponent.prototype, "_focusIn", void 0);
        __decorate([
            core.HostListener('focusin')
        ], IgxGridComponent.prototype, "onFocusIn", null);
        IgxGridComponent = IgxGridComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                providers: [
                    IgxGridNavigationService,
                    IgxGridSummaryService,
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: core.forwardRef(function () { return IgxGridComponent_1; }) },
                    IgxFilteringService,
                    IgxColumnResizingService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService,
                    IgxRowIslandAPIService
                ],
                selector: 'igx-grid',
                template: "<igx-grid-toolbar [style.max-width.px]='outerWidth' [style.flex-basis.px]=\"outerWidth\" role=\"rowgroup\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div [style.flex-basis.px]='outerWidth' class=\"igx-grid__grouparea\"\n    *ngIf=\"groupingExpressions.length > 0 || hasGroupableColumns\" #groupArea>\n    <igx-chips-area (onReorder)=\"chipsOrderChanged($event)\" (onMoveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [attr.title]=\"getGroupByChipTitle(expr)\"\n                [removable]=\"getColumnGroupable(expr.fieldName)\"\n                [draggable]=\"getColumnGroupable(expr.fieldName)\" [displayDensity]=\"displayDensity\"\n                (onKeyDown)=\"onChipKeyDown($event)\" (onRemove)=\"onChipRemoved($event)\"\n                (onClick)=\"getColumnGroupable(expr.fieldName) ? onChipClicked($event): null\"\n                [disabled]='!getColumnGroupable(expr.fieldName)'>\n                <span>{{ getGroupByChipTitle(expr) }}</span>\n                <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\">arrow_forward\n                </igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\"\n            [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" [class.igx-grid__tr--mrl]='hasColumnLayouts' role=\"rowgroup\"\n    [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"pinnedWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"\n                    [ngClass]=\"{\n                    'igx-grid__header-indentation--no-border': isRowSelectable || rowDraggable\n                }\" #headerGroupContainer  (click)=\"toggleAllGroupRows()\">\n\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !isRowSelectable\n                }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\" (scroll)='preventContainerScroll($event)'\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth || null' #tbody>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\n        | gridDetails:hasDetails:expansionStates:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight'\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='getRowTemplate(rowData)'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)'\n                (onBeforeViewDetach)='viewDetachHandler($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-template #record_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #group_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" #row>\n            </igx-grid-groupby-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-template #detail_template_container let-rowIndex=\"index\" let-rowData>\n            <div detail='true' style=\"overflow:auto;width: 100%;\" (focusin)='detailsViewFocused(detailsContainer, rowIndex)' tabindex=\"0\" #detailsContainer (keydown)='detailsKeyboardHandler($event, rowIndex, detailsContainer)' [attr.data-rowindex]='rowIndex'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true\n            }\">\n                <div class=\"igx-grid__hierarchical-indent\" style='display:flex;'>\n                        <ng-container *ngIf=\"this.groupingExpressions.length > 0\">\n                                <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"></div>\n                        </ng-container>\n                        <ng-template\n                    [ngTemplateOutlet]='detailTemplate'\n                    [ngTemplateOutletContext]='getDetailsContext(rowData, rowIndex)'>\n                    </ng-template>\n                </div>\n            </div>\n        </ng-template>\n\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon fontSet=\"material\" class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n   [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_less</igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n    [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_more</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n"
            })
        ], IgxGridComponent);
        return IgxGridComponent;
    }(IgxGridBaseDirective));

    var COLUMNS = 'columns';
    var FILTERING = 'filtering';
    var ADVANCED_FILTERING = 'advancedFiltering';
    var SORTING = 'sorting';
    var GROUPBY = 'groupBy';
    var PAGING = 'paging';
    var ROW_SELECTION = 'rowSelection';
    var CELL_SELECTION = 'cellSelection';
    var IgxGridStateDirective = /** @class */ (function () {
        /**
         * @hidden
         */
        function IgxGridStateDirective(grid, resolver, viewRef) {
            this.grid = grid;
            this.resolver = resolver;
            this.viewRef = viewRef;
            this._options = {
                columns: true,
                filtering: true,
                advancedFiltering: true,
                sorting: true,
                groupBy: true,
                paging: true,
                cellSelection: true,
                rowSelection: true
            };
        }
        Object.defineProperty(IgxGridStateDirective.prototype, "options", {
            /**
             *  An object with options determining if a certain feature state should be saved.
             *
             * ```html
             * <igx-grid [igxGridState]="options"></igx-grid>
             * ```
             * ```typescript
             * public options = {selection: false, advancedFiltering: false};
             * ```
             */
            get: function () {
                return this._options;
            },
            set: function (value) {
                Object.assign(this._options, value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Gets the state of a feature or states of all grid features, unless a certain feature is disabled through the `options` property.
         * @param `serialize` determines whether the returned object will be serialized to JSON string. Default value is false.
         * @param `feature` string or array of strings determining the features which state to retrieve. If skipped, returns all.
         * @returns Returns the serialized to JSON string IGridState object, or the non-serialized IGridState object.
         * ```html
         * <igx-grid [igxGridState]="options"></igx-grid>
         * ```
         * ```typescript
         * @ViewChild(IgxGridStateDirective, { static: true }) public state;
         * let state =  this.state.getState();
         * ```
         */
        IgxGridStateDirective.prototype.getState = function (serialize, feature) {
            var _this = this;
            if (serialize === void 0) { serialize = true; }
            var state;
            if (feature) {
                state = {};
                if (Array.isArray(feature)) {
                    feature.forEach(function (f) {
                        state = Object.assign(state, _this.getGridFeature(f));
                    });
                }
                else {
                    state = this.getGridFeature(feature);
                }
            }
            else {
                state = this.getAllGridFeatures();
            }
            if (serialize) {
                state = JSON.stringify(state, this.stringifyCallback);
                return state;
            }
            else {
                return state;
            }
        };
        /**
         * Restores grid features' state based on the IGridState object passed as an argument.
         * @param IGridState object to restore state from.
         * @returns
         * ```html
         * <igx-grid [igxGridState]="options"></igx-grid>
         * ```
         * ```typescript
         * @ViewChild(IgxGridStateDirective, { static: true }) public state;
         * this.state.setState(gridState);
         * ```
         */
        IgxGridStateDirective.prototype.setState = function (state) {
            if (typeof state === 'string') {
                state = JSON.parse(state);
            }
            this.state = state;
            this.restoreGridState();
            this.grid.cdr.detectChanges();
        };
        /**
         * The method that calls corresponding methods to restore feature from this.state object.
         */
        IgxGridStateDirective.prototype.restoreGridState = function () {
            var e_1, _a;
            try {
                for (var _b = __values(Object.keys(this.state)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (this.state[key]) {
                        this.restoreFeature(key, this.state[key]);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * Restores the state of a feature.
         */
        IgxGridStateDirective.prototype.restoreFeature = function (feature, state) {
            switch (feature) {
                case COLUMNS: {
                    this.restoreColumns(state);
                    break;
                }
                case FILTERING: {
                    this.restoreFiltering(state);
                    break;
                }
                case ADVANCED_FILTERING: {
                    this.restoreAdvancedFiltering(state);
                    break;
                }
                case SORTING: {
                    this.restoreSorting(state);
                    break;
                }
                case GROUPBY: {
                    this.restoreGroupBy(state);
                    break;
                }
                case PAGING: {
                    this.restorePaging(state);
                    break;
                }
                case ROW_SELECTION: {
                    this.restoreRowSelection(state);
                    break;
                }
                case CELL_SELECTION: {
                    this.restoreCellSelection(state);
                    break;
                }
            }
        };
        /**
         * Returns an object containing all grid features state.
         */
        IgxGridStateDirective.prototype.getAllGridFeatures = function () {
            var e_2, _a;
            var gridState = {};
            try {
                for (var _b = __values(Object.keys(this.options)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (this.options[key]) {
                        var feature = this.getGridFeature(key);
                        gridState = Object.assign(gridState, feature);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            gridState = Object.assign({}, gridState);
            return gridState;
        };
        /**
         * Restores an object containing the state for a grid feature.
         * `serialize` param determines whether the returned object will be serialized to a JSON string. Default value is false.,
         */
        IgxGridStateDirective.prototype.getGridFeature = function (feature) {
            var state = {};
            switch (feature) {
                case COLUMNS: {
                    Object.assign(state, this.getColumns());
                    break;
                }
                case FILTERING: {
                    Object.assign(state, this.getFiltering());
                    break;
                }
                case ADVANCED_FILTERING: {
                    Object.assign(state, this.getAdvancedFiltering());
                    break;
                }
                case SORTING: {
                    Object.assign(state, this.getSorting());
                    break;
                }
                case GROUPBY: {
                    Object.assign(state, this.getGroupBy());
                    break;
                }
                case PAGING: {
                    Object.assign(state, this.getPaging());
                    break;
                }
                case ROW_SELECTION: {
                    Object.assign(state, this.getRowSelection());
                    break;
                }
                case CELL_SELECTION: {
                    Object.assign(state, this.getCellSelection());
                    break;
                }
            }
            return state;
        };
        /**
         * Helper method that creates a new array with the current grid columns.
         */
        IgxGridStateDirective.prototype.getColumns = function () {
            var gridColumns = this.grid.columns.sort(this.sortByVisibleIndex).map(function (c) {
                return {
                    pinned: c.pinned,
                    sortable: c.sortable,
                    filterable: c.filterable,
                    editable: c.editable,
                    sortingIgnoreCase: c.sortingIgnoreCase,
                    filteringIgnoreCase: c.filteringIgnoreCase,
                    headerClasses: c.headerClasses,
                    headerGroupClasses: c.headerGroupClasses,
                    maxWidth: c.maxWidth,
                    groupable: c.groupable,
                    movable: c.movable,
                    hidden: c.hidden,
                    dataType: c.dataType,
                    hasSummary: c.hasSummary,
                    field: c.field,
                    width: c.width,
                    header: c.header,
                    resizable: c.resizable,
                    searchable: c.searchable
                };
            });
            return { columns: gridColumns };
        };
        IgxGridStateDirective.prototype.getFiltering = function () {
            var filteringState = this.grid.filteringExpressionsTree;
            return { filtering: filteringState };
        };
        IgxGridStateDirective.prototype.getAdvancedFiltering = function () {
            var advancedFiltering = this.grid.advancedFilteringExpressionsTree;
            return { advancedFiltering: advancedFiltering };
        };
        IgxGridStateDirective.prototype.getPaging = function () {
            var pagingState = this.grid.pagingState;
            return { paging: pagingState };
        };
        IgxGridStateDirective.prototype.getSorting = function () {
            var sortingState = this.grid.sortingExpressions;
            sortingState.forEach(function (s) {
                delete s.strategy;
            });
            return { sorting: sortingState };
        };
        IgxGridStateDirective.prototype.getGroupBy = function () {
            var groupingExpressions = this.grid.groupingExpressions;
            groupingExpressions.forEach(function (expr) {
                delete expr.strategy;
            });
            var expansionState = this.grid.groupingExpansionState;
            var groupsExpanded = this.grid.groupsExpanded;
            return { groupBy: { expressions: groupingExpressions, expansion: expansionState, defaultExpanded: groupsExpanded } };
        };
        IgxGridStateDirective.prototype.getRowSelection = function () {
            var selection = this.grid.selectedRows();
            return { rowSelection: selection };
        };
        IgxGridStateDirective.prototype.getCellSelection = function () {
            var selection = this.grid.getSelectedRanges().map(function (range) {
                return { rowStart: range.rowStart, rowEnd: range.rowEnd, columnStart: range.columnStart, columnEnd: range.columnEnd };
            });
            return { cellSelection: selection };
        };
        /**
         * Restores the grid columns by modifying the `columnList` collection of the grid.
         */
        IgxGridStateDirective.prototype.restoreColumns = function (columnsState) {
            var _this = this;
            var newColumns = [];
            var factory = this.resolver.resolveComponentFactory(IgxColumnComponent);
            columnsState.forEach(function (colState) {
                var ref = factory.create(_this.viewRef.injector);
                Object.assign(ref.instance, colState);
                ref.changeDetectorRef.detectChanges();
                newColumns.push(ref.instance);
            });
            this.grid.columnList.reset(newColumns);
            this.grid.columnList.notifyOnChanges();
        };
        IgxGridStateDirective.prototype.sortByVisibleIndex = function (colA, colB) {
            var a = colA.visibleIndex, b = colB.visibleIndex;
            return a > b ? 1 : a < b ? -1 : 0;
        };
        /**
         * Restores the grid filtering state, i.e. sets the `filteringExpressionsTree` property value.
         */
        IgxGridStateDirective.prototype.restoreFiltering = function (state) {
            var filterTree = this.createExpressionsTreeFromObject(state);
            this.grid.filteringExpressionsTree = filterTree;
        };
        /**
         * Restores the grid advanced filtering state, i.e. sets the `advancedFilteringExpressionsTree` property value.
         */
        IgxGridStateDirective.prototype.restoreAdvancedFiltering = function (state) {
            var advFilterTree = this.createExpressionsTreeFromObject(state);
            this.grid.advancedFilteringExpressionsTree = advFilterTree;
        };
        /**
         * Restores the grid sorting state, i.e. sets the `sortingExpressions` property value.
         */
        IgxGridStateDirective.prototype.restoreSorting = function (state) {
            this.grid.sortingExpressions = state;
        };
        /**
         * Restores the grid grouping state, i.e. sets the `groupbyExpressions` property value.
         */
        IgxGridStateDirective.prototype.restoreGroupBy = function (state) {
            this.grid.groupingExpressions = state.expressions;
            if (this.grid.groupsExpanded !== state.defaultExpanded) {
                this.grid.toggleAllGroupRows();
            }
            else {
                this.grid.groupingExpansionState = state.expansion;
            }
        };
        /**
         * Restores the grid paging state, i.e. sets the `perPage` property value and paginate to index.
         */
        IgxGridStateDirective.prototype.restorePaging = function (state) {
            if (this.grid.perPage !== state.recordsPerPage) {
                this.grid.perPage = state.recordsPerPage;
                this.grid.cdr.detectChanges();
            }
            this.grid.page = state.index;
        };
        IgxGridStateDirective.prototype.restoreRowSelection = function (state) {
            this.grid.selectRows(state);
        };
        IgxGridStateDirective.prototype.restoreCellSelection = function (state) {
            var _this = this;
            state.forEach(function (r) {
                var range = { rowStart: r.rowStart, rowEnd: r.rowEnd, columnStart: r.columnStart, columnEnd: r.columnEnd };
                _this.grid.selectRange(range);
            });
        };
        /**
         * This method builds a FilteringExpressionsTree from a provided object.
         */
        IgxGridStateDirective.prototype.createExpressionsTreeFromObject = function (exprTreeObject) {
            var e_3, _a;
            if (!exprTreeObject || !exprTreeObject.filteringOperands) {
                return null;
            }
            var expressionsTree = new FilteringExpressionsTree(exprTreeObject.operator, exprTreeObject.fieldName);
            var _loop_1 = function (item) {
                // Check if item is an expressions tree or a single expression.
                if (item.filteringOperands) {
                    var subTree = this_1.createExpressionsTreeFromObject(item);
                    expressionsTree.filteringOperands.push(subTree);
                }
                else {
                    var expr_1 = item;
                    var dataType = void 0;
                    if (this_1.grid.columnList.length > 0) {
                        dataType = this_1.grid.columnList.find(function (c) { return c.field === expr_1.fieldName; }).dataType;
                    }
                    else {
                        dataType = this_1.state[COLUMNS].find(function (c) { return c.field === expr_1.fieldName; }).dataType;
                    }
                    // when ESF, values are stored in Set.
                    // First those values are converted to an array before returning string in the stringifyCallback
                    // now we need to convert those back to Set
                    if (Array.isArray(expr_1.searchVal)) {
                        expr_1.searchVal = new Set(expr_1.searchVal);
                    }
                    else {
                        expr_1.searchVal = (dataType === 'date') ? new Date(Date.parse(expr_1.searchVal)) : expr_1.searchVal;
                    }
                    expr_1.condition = this_1.generateFilteringCondition(dataType, expr_1.condition.name);
                    expressionsTree.filteringOperands.push(expr_1);
                }
            };
            var this_1 = this;
            try {
                for (var _b = __values(exprTreeObject.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    _loop_1(item);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return expressionsTree;
        };
        /**
         * Returns the filtering logic function for a given dataType and condition (contains, greaterThan, etc.)
         */
        IgxGridStateDirective.prototype.generateFilteringCondition = function (dataType, name) {
            var filters;
            switch (dataType) {
                case exports.DataType.Boolean:
                    filters = IgxBooleanFilteringOperand.instance();
                    break;
                case exports.DataType.Number:
                    filters = IgxNumberFilteringOperand.instance();
                    break;
                case exports.DataType.Date:
                    filters = IgxDateFilteringOperand.instance();
                    break;
                case exports.DataType.String:
                default:
                    filters = IgxStringFilteringOperand.instance();
                    break;
            }
            return filters.condition(name);
        };
        IgxGridStateDirective.prototype.stringifyCallback = function (key, val) {
            if (key === 'searchVal' && val instanceof Set) {
                return Array.from(val);
            }
            return val;
        };
        IgxGridStateDirective.ctorParameters = function () { return [
            { type: IgxGridComponent, decorators: [{ type: core.Host }, { type: core.Optional }] },
            { type: core.ComponentFactoryResolver },
            { type: core.ViewContainerRef }
        ]; };
        __decorate([
            core.Input('igxGridState')
        ], IgxGridStateDirective.prototype, "options", null);
        IgxGridStateDirective = __decorate([
            core.Directive({
                selector: '[igxGridState]'
            }),
            __param(0, core.Host()), __param(0, core.Optional())
        ], IgxGridStateDirective);
        return IgxGridStateDirective;
    }());
    /**
     * @hidden
     */
    var IgxGridStateModule = /** @class */ (function () {
        function IgxGridStateModule() {
        }
        IgxGridStateModule = __decorate([
            core.NgModule({
                declarations: [IgxGridStateDirective],
                exports: [IgxGridStateDirective]
            })
        ], IgxGridStateModule);
        return IgxGridStateModule;
    }());

    var IgxGridSharedModules = /** @class */ (function () {
        function IgxGridSharedModules() {
        }
        IgxGridSharedModules = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    forms.FormsModule,
                    IgxButtonModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxFocusModule,
                    IgxToggleModule,
                    IgxForOfModule,
                    IgxTemplateOutletModule,
                    IgxTextHighlightModule,
                    IgxTextSelectionModule,
                    IgxCheckboxModule,
                    IgxBadgeModule,
                    IgxChipsModule,
                    IgxDragDropModule,
                    IgxDropDownModule,
                    IgxButtonGroupModule,
                    IgxProgressBarModule,
                    IgxSelectModule,
                    IgxGridStateModule
                ],
                exports: [
                    common.CommonModule,
                    forms.FormsModule,
                    IgxButtonModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxFocusModule,
                    IgxToggleModule,
                    IgxForOfModule,
                    IgxTemplateOutletModule,
                    IgxTextHighlightModule,
                    IgxGridStateModule,
                    IgxTextSelectionModule,
                    IgxCheckboxModule,
                    IgxBadgeModule,
                    IgxChipsModule,
                    IgxDragDropModule,
                    IgxDropDownModule,
                    IgxButtonGroupModule,
                    IgxProgressBarModule,
                    IgxSelectModule
                ]
            })
        ], IgxGridSharedModules);
        return IgxGridSharedModules;
    }());

    var IgxColumnHidingModule = /** @class */ (function () {
        function IgxColumnHidingModule() {
        }
        IgxColumnHidingModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxColumnHidingComponent,
                    IgxColumnHidingItemDirective
                ],
                imports: [
                    IgxGridSharedModules
                ],
                exports: [
                    IgxColumnHidingComponent
                ],
            })
        ], IgxColumnHidingModule);
        return IgxColumnHidingModule;
    }());

    var IgxGridFooterComponent = /** @class */ (function () {
        function IgxGridFooterComponent() {
        }
        IgxGridFooterComponent = __decorate([
            core.Component({
                selector: 'igx-grid-footer',
                template: '<ng-content></ng-content>'
            })
        ], IgxGridFooterComponent);
        return IgxGridFooterComponent;
    }());

    var IgxPaginatorComponent = /** @class */ (function (_super) {
        __extends(IgxPaginatorComponent, _super);
        function IgxPaginatorComponent(_displayDensityOptions) {
            var _this = _super.call(this, _displayDensityOptions) || this;
            _this._displayDensityOptions = _displayDensityOptions;
            _this._page = 0;
            _this.defaultSelectValues = [5, 10, 15, 25, 50, 100, 500];
            _this._perPage = 15;
            /**
            * An @Input property that sets if the pager in the paginator should be enabled.
            * ```html
            * <igx-paginator [pagerEnabled]="true"></igx-paginator>
            * ```
            * @memberof IgxPaginatorComponent
            */
            _this.pagerEnabled = true;
            /**
            * An @Input property that sets if the pager in the paginator should be hidden.
            * ```html
            * <igx-paginator [pagerHidden]="true"></igx-paginator>
            * ```
            * @memberof IgxPaginatorComponent
            */
            _this.pagerHidden = false;
            /**
            * An @Input property that sets if the dropdown in the paginator should be enabled.
            * ```html
            * <igx-paginator [dropdownEnabled]="true"></igx-paginator>
            * ```
            * @memberof IgxPaginatorComponent
            */
            _this.dropdownEnabled = true;
            /**
            * An @Input property that sets if the dropdown in the paginator should be hidden.
            * ```html
            * <igx-paginator [dropdownHidden]="true"></igx-paginator>
            * ```
            * @memberof IgxPaginatorComponent
            */
            _this.dropdownHidden = false;
            /**
            * An @Input property, sets number of label of the select.
            * The default is 'Items per page' localized string.
            * ```html
            * <igx-paginator label="My custom label"></igx-paginator>
            * ```
            * @memberof IgxPaginatorComponent
            */
            _this.selectLabel = CurrentResourceStrings.PaginatorResStrings.igx_paginator_label;
            /**
             *An event that is emitted when the select in the `IgxPaginatorComponent` changes its value.
            */
            _this.perPageChange = new core.EventEmitter();
            /**
             *An event that is emitted when the paginating is used.
            */
            _this.pageChange = new core.EventEmitter();
            return _this;
        }
        Object.defineProperty(IgxPaginatorComponent.prototype, "classCosy", {
            /**
             * Sets the class of the IgxPaginatorComponent based
             * on the provided displayDensity.
             */
            get: function () {
                return this.displayDensity === exports.DisplayDensity.cosy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "classCompact", {
            get: function () {
                return this.displayDensity === exports.DisplayDensity.compact;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "classComfortable", {
            get: function () {
                return this.displayDensity === exports.DisplayDensity.comfortable;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "page", {
            /**
           * An @Input property, sets current page of the `IgxPaginatorComponent`.
           * The default is 0.
           * ```typescript
           * let page = this.paginator.page;
           * ```
           * @memberof IgxPaginatorComponent
           */
            get: function () {
                return this._page;
            },
            set: function (value) {
                this._page = value;
                this.pageChange.emit(this._page);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "perPage", {
            /**
           * An @Input property, sets number of visible items per page in the `IgxPaginatorComponent`.
           * The default is 15.
           * ```typescript
           * let itemsPerPage = this.paginator.perPage;
           * ```
           * @memberof IgxPaginatorComponent
           */
            get: function () {
                return this._perPage;
            },
            set: function (value) {
                this._perPage = Number(value);
                this.perPageChange.emit(this._perPage);
                this._selectOptions = this.sortUniqueOptions(this.defaultSelectValues, this._perPage);
                this.totalPages = Math.ceil(this.totalRecords / this._perPage);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "totalRecords", {
            /**
            * An @Input property that sets the total records.
            * ```typescript
            * let totalRecords = this.paginator.totalRecords;
            * ```
            * @memberof IgxPaginatorComponent
            */
            get: function () {
                return this._totalRecords;
            },
            set: function (value) {
                this._totalRecords = value;
                this.totalPages = Math.ceil(this.totalRecords / this.perPage);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "selectOptions", {
            /**
            * An @Input property that sets custom options in the select of the paginator
            * ```typescript
            * let options = this.paginator.selectOptions;
            * ```
            * @memberof IgxPaginatorComponent
            */
            get: function () {
                return this._selectOptions;
            },
            set: function (value) {
                this._selectOptions = this.sortUniqueOptions(value, this._perPage);
                this.defaultSelectValues = __spread(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "isLastPage", {
            /**
             * Returns if the current page is the last page.
             * ```typescript
             * const lastPage = this.paginator.isLastPage;
             * ```
             */
            get: function () {
                return this.page + 1 >= this.totalPages;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxPaginatorComponent.prototype, "isFirstPage", {
            /**
             * Returns if the current page is the first page.
             * ```typescript
             * const lastPage = this.paginator.isFirstPage;
             * ```
             */
            get: function () {
                return this.page === 0;
            },
            enumerable: true,
            configurable: true
        });
        IgxPaginatorComponent.prototype.sortUniqueOptions = function (values, newOption) {
            return Array.from(new Set(__spread(values, [newOption]))).sort(function (a, b) { return a - b; });
        };
        /**
         * Sets DisplayDensity for the <select> inside the paginator
         * @hidden
         */
        IgxPaginatorComponent.prototype.paginatorSelectDisplayDensity = function () {
            if (this.displayDensity === exports.DisplayDensity.comfortable) {
                return exports.DisplayDensity.cosy;
            }
            return exports.DisplayDensity.compact;
        };
        /**
         * Goes to the next page of the `IgxPaginatorComponent`, if the paginator is not already at the last page.
         * ```typescript
         * this.paginator.nextPage();
         * ```
         * @memberof IgxPaginatorComponent
         */
        IgxPaginatorComponent.prototype.nextPage = function () {
            if (!this.isLastPage) {
                this.page += 1;
            }
        };
        /**
         * Goes to the previous page of the `IgxPaginatorComponent`, if the paginator is not already at the first page.
         * ```typescript
         * this.paginator.previousPage();
         * ```
         * @memberof IgxPaginatorComponent
         */
        IgxPaginatorComponent.prototype.previousPage = function () {
            if (!this.isFirstPage) {
                this.page -= 1;
            }
        };
        /**
         * Goes to the desired page index.
         * ```typescript
         * this.pagiantor.paginate(1);
         * ```
         * @param val
         * @memberof IgxPaginatorComponent
         */
        IgxPaginatorComponent.prototype.paginate = function (val) {
            if (val < 0 || val > this.totalPages - 1) {
                return;
            }
            this.page = val;
        };
        IgxPaginatorComponent.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.HostBinding('class.igx-paginator--cosy')
        ], IgxPaginatorComponent.prototype, "classCosy", null);
        __decorate([
            core.HostBinding('class.igx-paginator--compact')
        ], IgxPaginatorComponent.prototype, "classCompact", null);
        __decorate([
            core.HostBinding('class.igx-paginator')
        ], IgxPaginatorComponent.prototype, "classComfortable", null);
        __decorate([
            core.Input()
        ], IgxPaginatorComponent.prototype, "page", null);
        __decorate([
            core.Input()
        ], IgxPaginatorComponent.prototype, "perPage", null);
        __decorate([
            core.Input()
        ], IgxPaginatorComponent.prototype, "totalRecords", null);
        __decorate([
            core.Input()
        ], IgxPaginatorComponent.prototype, "selectOptions", null);
        __decorate([
            core.Input()
        ], IgxPaginatorComponent.prototype, "pagerEnabled", void 0);
        __decorate([
            core.Input()
        ], IgxPaginatorComponent.prototype, "pagerHidden", void 0);
        __decorate([
            core.Input()
        ], IgxPaginatorComponent.prototype, "dropdownEnabled", void 0);
        __decorate([
            core.Input()
        ], IgxPaginatorComponent.prototype, "dropdownHidden", void 0);
        __decorate([
            core.Input()
        ], IgxPaginatorComponent.prototype, "selectLabel", void 0);
        __decorate([
            core.Output()
        ], IgxPaginatorComponent.prototype, "perPageChange", void 0);
        __decorate([
            core.Output()
        ], IgxPaginatorComponent.prototype, "pageChange", void 0);
        IgxPaginatorComponent = __decorate([
            core.Component({
                selector: 'igx-paginator',
                template: "<div class=\"igx-paginator__select\" [hidden]=\"dropdownHidden\">\n    <label class=\"igx-paginator__label\">{{ selectLabel }}</label>\n    <div class=\"igx-paginator__select-input\">\n        <igx-select [(ngModel)]=\"perPage\" [displayDensity]=\"paginatorSelectDisplayDensity()\" type=\"border\"\n            [disabled]=\"!dropdownEnabled\">\n            <igx-select-item [value]=\"val\" *ngFor=\"let val of selectOptions\">\n                {{val}}\n            </igx-select-item>\n        </igx-select>\n    </div>\n</div>\n<div class=\"igx-paginator__pager\" [hidden]=\"pagerHidden\">\n    <button [disabled]=\"isFirstPage || !pagerEnabled ? true: false\" (click)=\"paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [disabled]=\"isFirstPage || !pagerEnabled ? true: false\" (click)=\"previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <div class='igx-paginator__pager-text'>\n        <span>{{ page + 1 }}</span>\n        <span>&nbsp;of&nbsp;</span>\n        <span>{{ totalPages }}</span>\n    </div>\n    <button [disabled]=\"isLastPage || !pagerEnabled ? true: false\" (click)=\"nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n    <button [disabled]=\"isLastPage || !pagerEnabled ? true: false\" (click)=\"paginate(totalPages - 1)\" igxButton=\"icon\" igxRipple\n        igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n</div>\n"
            }),
            __param(0, core.Optional()), __param(0, core.Inject(DisplayDensityToken))
        ], IgxPaginatorComponent);
        return IgxPaginatorComponent;
    }(DisplayDensityBase));
    var IgxPaginatorModule = /** @class */ (function () {
        function IgxPaginatorModule() {
        }
        IgxPaginatorModule = __decorate([
            core.NgModule({
                declarations: [IgxPaginatorComponent],
                exports: [IgxPaginatorComponent],
                imports: [common.CommonModule, IgxSelectModule, forms.FormsModule, IgxIconModule, IgxButtonModule, IgxRippleModule]
            })
        ], IgxPaginatorModule);
        return IgxPaginatorModule;
    }());

    var IgxGridPipesModule = /** @class */ (function () {
        function IgxGridPipesModule() {
        }
        IgxGridPipesModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxDatePipeComponent,
                    IgxDecimalPipeComponent,
                    IgxGridFilterConditionPipe,
                    IgxGridTransactionPipe,
                    IgxGridNotGroupedPipe,
                    IgxGridTopLevelColumns,
                    IgxGridCellStylesPipe,
                    IgxGridCellStyleClassesPipe,
                    IgxGridPaginatorOptionsPipe,
                    IgxHasVisibleColumnsPipe
                ],
                exports: [
                    IgxDatePipeComponent,
                    IgxDecimalPipeComponent,
                    IgxGridFilterConditionPipe,
                    IgxGridTransactionPipe,
                    IgxGridNotGroupedPipe,
                    IgxGridTopLevelColumns,
                    IgxGridCellStylesPipe,
                    IgxGridCellStyleClassesPipe,
                    IgxGridPaginatorOptionsPipe,
                    IgxHasVisibleColumnsPipe
                ],
                imports: [
                    common.CommonModule
                ]
            })
        ], IgxGridPipesModule);
        return IgxGridPipesModule;
    }());

    /**
     * @hidden
     */
    var IgxExcelStyleColumnMovingComponent = /** @class */ (function () {
        function IgxExcelStyleColumnMovingComponent() {
        }
        Object.defineProperty(IgxExcelStyleColumnMovingComponent.prototype, "visibleColumns", {
            get: function () {
                return this.grid.visibleColumns.filter(function (col) { return !(col instanceof IgxColumnGroupComponent); });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleColumnMovingComponent.prototype, "canNotMoveLeft", {
            get: function () {
                return this.column.visibleIndex === 0 ||
                    (this.grid.unpinnedColumns.indexOf(this.column) === 0 && this.column.disablePinning) ||
                    (this.grid.unpinnedColumns.indexOf(this.column) === 0 && !this.isColumnPinnable) ||
                    (this.column.level !== 0 && !this.findColumn(0, this.visibleColumns));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxExcelStyleColumnMovingComponent.prototype, "canNotMoveRight", {
            get: function () {
                return this.column.visibleIndex === this.visibleColumns.length - 1 ||
                    (this.column.level !== 0 && !this.findColumn(1, this.visibleColumns));
            },
            enumerable: true,
            configurable: true
        });
        IgxExcelStyleColumnMovingComponent.prototype.onMoveButtonClicked = function (moveDirection) {
            var targetColumn;
            if (this.column.pinned) {
                if (this.column.isLastPinned && moveDirection === 1) {
                    targetColumn = this.grid.unpinnedColumns[0];
                    moveDirection = 0;
                }
                else {
                    targetColumn = this.findColumn(moveDirection, this.grid.pinnedColumns);
                }
            }
            else if (this.grid.unpinnedColumns.indexOf(this.column) === 0 && moveDirection === 0) {
                targetColumn = this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1];
                if (targetColumn.parent) {
                    targetColumn = targetColumn.topLevelParent;
                }
                moveDirection = 1;
            }
            else {
                targetColumn = this.findColumn(moveDirection, this.grid.unpinnedColumns);
            }
            this.grid.moveColumn(this.column, targetColumn, moveDirection);
        };
        IgxExcelStyleColumnMovingComponent.prototype.findColumn = function (moveDirection, columns) {
            var index = columns.indexOf(this.column);
            if (moveDirection === 0) {
                while (index > 0) {
                    index--;
                    if (columns[index].level === this.column.level && columns[index].parent === this.column.parent) {
                        return columns[index];
                    }
                }
            }
            else {
                while (index < columns.length - 1) {
                    index++;
                    if (columns[index].level === this.column.level && columns[index].parent === this.column.parent) {
                        return columns[index];
                    }
                }
            }
        };
        __decorate([
            core.Input()
        ], IgxExcelStyleColumnMovingComponent.prototype, "column", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleColumnMovingComponent.prototype, "grid", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleColumnMovingComponent.prototype, "displayDensity", void 0);
        __decorate([
            core.Input()
        ], IgxExcelStyleColumnMovingComponent.prototype, "isColumnPinnable", void 0);
        IgxExcelStyleColumnMovingComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-column-moving',
                template: "<header>\n    {{ grid.resourceStrings.igx_grid_excel_filter_moving_header }}\n</header>\n<section class=\"igx-excel-filter__move-buttons\">\n    <button [displayDensity]=\"displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveLeft\"\n        (click)=\"onMoveButtonClicked(0)\">\n        <igx-icon>arrow_back</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_moving_left_short:\n            grid.resourceStrings.igx_grid_excel_filter_moving_left }}\n        </span>\n    </button>\n    <button [displayDensity]=\"displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveRight\"\n        (click)=\"onMoveButtonClicked(1)\">\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_moving_right_short:\n            grid.resourceStrings.igx_grid_excel_filter_moving_right }}\n        </span>\n        <igx-icon>arrow_forwards</igx-icon>\n    </button>\n</section>\n"
            })
        ], IgxExcelStyleColumnMovingComponent);
        return IgxExcelStyleColumnMovingComponent;
    }());

    /**
     * @hidden
     */
    var IgxExcelStyleSearchFilterPipe = /** @class */ (function () {
        function IgxExcelStyleSearchFilterPipe() {
        }
        IgxExcelStyleSearchFilterPipe.prototype.transform = function (items, searchText) {
            if (!items || !items.length) {
                return [];
            }
            if (!searchText) {
                return items;
            }
            searchText = searchText.toLowerCase();
            var result = items.filter(function (it, i) { return (i === 0 && it.isSpecial) ||
                (it.value !== null && it.value !== undefined) &&
                    it.value.toString().toLowerCase().indexOf(searchText) > -1; });
            // If 'result' contains the 'Select All' item and at least one more - we use it, otherwise we use an empty array.
            return result.length > 1 ? result : [];
        };
        IgxExcelStyleSearchFilterPipe = __decorate([
            core.Pipe({
                name: 'excelStyleSearchFilter'
            })
        ], IgxExcelStyleSearchFilterPipe);
        return IgxExcelStyleSearchFilterPipe;
    }());

    /**
     * @hidden
     */
    var IgxGridExcelStyleFilteringModule = /** @class */ (function () {
        function IgxGridExcelStyleFilteringModule() {
        }
        IgxGridExcelStyleFilteringModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxGridExcelStyleFilteringComponent,
                    IgxExcelStyleSortingComponent,
                    IgxExcelStyleColumnMovingComponent,
                    IgxExcelStyleSearchComponent,
                    IgxExcelStyleCustomDialogComponent,
                    IgxExcelStyleDefaultExpressionComponent,
                    IgxExcelStyleDateExpressionComponent,
                    IgxExcelStyleSortingTemplateDirective,
                    IgxExcelStyleHidingTemplateDirective,
                    IgxExcelStyleMovingTemplateDirective,
                    IgxExcelStylePinningTemplateDirective,
                    IgxExcelStyleLoadingValuesTemplateDirective,
                    IgxExcelStyleSearchFilterPipe
                ],
                exports: [
                    IgxGridExcelStyleFilteringComponent,
                    IgxExcelStyleSortingTemplateDirective,
                    IgxExcelStyleHidingTemplateDirective,
                    IgxExcelStyleMovingTemplateDirective,
                    IgxExcelStylePinningTemplateDirective,
                    IgxExcelStyleLoadingValuesTemplateDirective,
                    IgxExcelStyleDateExpressionComponent
                ],
                imports: [
                    common.CommonModule,
                    forms.FormsModule,
                    IgxGridPipesModule,
                    IgxButtonModule,
                    IgxButtonGroupModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxDropDownModule,
                    IgxForOfModule,
                    IgxCheckboxModule,
                    IgxFilterModule,
                    IgxToggleModule,
                    IgxListModule,
                    IgxProgressBarModule
                ],
                entryComponents: [
                    IgxGridExcelStyleFilteringComponent
                ],
                providers: [
                    IgxSelectionAPIService
                ]
            })
        ], IgxGridExcelStyleFilteringModule);
        return IgxGridExcelStyleFilteringModule;
    }());

    var IgxGridSelectionModule = /** @class */ (function () {
        function IgxGridSelectionModule() {
        }
        IgxGridSelectionModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxRowSelectorDirective,
                    IgxHeadSelectorDirective,
                    IgxGridDragSelectDirective
                ],
                exports: [
                    IgxRowSelectorDirective,
                    IgxHeadSelectorDirective,
                    IgxGridDragSelectDirective
                ]
            })
        ], IgxGridSelectionModule);
        return IgxGridSelectionModule;
    }());

    /**
     * @hidden
     * @internal
     */
    var IgxResizeHandleDirective = /** @class */ (function () {
        function IgxResizeHandleDirective(zone, element, colResizingService) {
            this.zone = zone;
            this.element = element;
            this.colResizingService = colResizingService;
            /**
             * @hidden
             */
            this._dblClick = false;
            /**
             * @hidden
             */
            this.destroy$ = new rxjs.Subject();
            this.DEBOUNCE_TIME = 200;
        }
        /**
         * @hidden
         */
        IgxResizeHandleDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next(true);
            this.destroy$.complete();
        };
        /**
         * @hidden
         */
        IgxResizeHandleDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (!this.column.columnGroup && this.column.resizable) {
                this.zone.runOutsideAngular(function () {
                    rxjs.fromEvent(_this.element.nativeElement, 'mousedown').pipe(operators.debounceTime(_this.DEBOUNCE_TIME), operators.takeUntil(_this.destroy$)).subscribe(function (event) {
                        if (_this._dblClick) {
                            _this._dblClick = false;
                            return;
                        }
                        if (event.button === 0) {
                            _this._onResizeAreaMouseDown(event);
                            _this.column.grid.resizeLine.resizer.onMousedown(event);
                        }
                    });
                });
                rxjs.fromEvent(this.element.nativeElement, 'mouseup').pipe(operators.debounceTime(this.DEBOUNCE_TIME), operators.takeUntil(this.destroy$)).subscribe(function () {
                    _this.colResizingService.isColumnResizing = false;
                    _this.colResizingService.showResizer = false;
                    _this.column.grid.cdr.detectChanges();
                });
            }
        };
        /**
         * @hidden
         */
        IgxResizeHandleDirective.prototype.onMouseOver = function () {
            this.colResizingService.resizeCursor = 'col-resize';
        };
        /**
         * @hidden
         */
        IgxResizeHandleDirective.prototype.onDoubleClick = function () {
            this._dblClick = true;
            this.colResizingService.column = this.column;
            this.colResizingService.autosizeColumnOnDblClick();
        };
        /**
         * @hidden
         */
        IgxResizeHandleDirective.prototype._onResizeAreaMouseDown = function (event) {
            this.colResizingService.column = this.column;
            this.colResizingService.isColumnResizing = true;
            this.colResizingService.startResizePos = event.clientX;
            this.colResizingService.showResizer = true;
            this.column.grid.cdr.detectChanges();
        };
        IgxResizeHandleDirective.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: core.ElementRef },
            { type: IgxColumnResizingService }
        ]; };
        __decorate([
            core.Input('igxResizeHandle')
        ], IgxResizeHandleDirective.prototype, "column", void 0);
        __decorate([
            core.HostListener('mouseover')
        ], IgxResizeHandleDirective.prototype, "onMouseOver", null);
        __decorate([
            core.HostListener('dblclick')
        ], IgxResizeHandleDirective.prototype, "onDoubleClick", null);
        IgxResizeHandleDirective = __decorate([
            core.Directive({
                selector: '[igxResizeHandle]'
            })
        ], IgxResizeHandleDirective);
        return IgxResizeHandleDirective;
    }());

    var IgxGridResizingModule = /** @class */ (function () {
        function IgxGridResizingModule() {
        }
        IgxGridResizingModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxGridColumnResizerComponent,
                    IgxResizeHandleDirective,
                    IgxColumnResizerDirective
                ],
                imports: [
                    common.CommonModule
                ],
                exports: [
                    IgxGridColumnResizerComponent,
                    IgxResizeHandleDirective,
                    IgxColumnResizerDirective
                ],
                providers: [
                    IgxColumnResizingService
                ]
            })
        ], IgxGridResizingModule);
        return IgxGridResizingModule;
    }());

    var IgxColumnMovingDropDirective = /** @class */ (function (_super) {
        __extends(IgxColumnMovingDropDirective, _super);
        function IgxColumnMovingDropDirective(elementRef, renderer, zone, cms) {
            var _this = _super.call(this, elementRef, renderer, zone) || this;
            _this.elementRef = elementRef;
            _this.renderer = renderer;
            _this.zone = zone;
            _this.cms = cms;
            _this._dropIndicator = null;
            _this._lastDropIndicator = null;
            _this._dragLeave = new rxjs.Subject();
            _this._dropIndicatorClass = 'igx-grid__th-drop-indicator--active';
            return _this;
        }
        Object.defineProperty(IgxColumnMovingDropDirective.prototype, "data", {
            set: function (val) {
                if (val instanceof IgxColumnComponent) {
                    this._column = val;
                }
                if (val instanceof IgxGridForOfDirective) {
                    this._hVirtDir = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDropDirective.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDropDirective.prototype, "isDropTarget", {
            get: function () {
                return this._column && this._column.grid.hasMovableColumns && this.cms.column.movable &&
                    ((!this._column.pinned && this.cms.column.disablePinning) || !this.cms.column.disablePinning);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnMovingDropDirective.prototype, "horizontalScroll", {
            get: function () {
                if (this._hVirtDir) {
                    return this._hVirtDir;
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxColumnMovingDropDirective.prototype.ngOnDestroy = function () {
            this._dragLeave.next(true);
            this._dragLeave.complete();
        };
        IgxColumnMovingDropDirective.prototype.onDragOver = function (event) {
            var drag = event.detail.owner;
            if (!(drag instanceof IgxColumnMovingDragDirective)) {
                return;
            }
            if (this.isDropTarget &&
                this.cms.column !== this.column &&
                this.cms.column.level === this.column.level &&
                this.cms.column.parent === this.column.parent) {
                if (this._lastDropIndicator) {
                    this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
                }
                var clientRect = this.elementRef.nativeElement.getBoundingClientRect();
                var pos = clientRect.left + clientRect.width / 2;
                var parent_1 = this.elementRef.nativeElement.parentElement;
                if (event.detail.pageX < pos) {
                    this._dropPos = DropPosition.BeforeDropTarget;
                    this._lastDropIndicator = this._dropIndicator = parent_1.firstElementChild;
                }
                else {
                    this._dropPos = DropPosition.AfterDropTarget;
                    this._lastDropIndicator = this._dropIndicator = parent_1.lastElementChild;
                }
                if (this.cms.icon.innerText !== 'block') {
                    this.renderer.addClass(this._dropIndicator, this._dropIndicatorClass);
                }
            }
        };
        IgxColumnMovingDropDirective.prototype.onDragEnter = function (event) {
            var _this = this;
            var drag = event.detail.owner;
            if (!(drag instanceof IgxColumnMovingDragDirective)) {
                return;
            }
            if (this.column && this.cms.column.grid.id !== this.column.grid.id) {
                this.cms.icon.innerText = 'block';
                return;
            }
            if (this.isDropTarget &&
                this.cms.column !== this.column &&
                this.cms.column.level === this.column.level &&
                this.cms.column.parent === this.column.parent) {
                if (!this.column.pinned || (this.column.pinned && this.cms.column.pinned)) {
                    this.cms.icon.innerText = 'swap_horiz';
                }
                this.cms.icon.innerText = 'lock';
            }
            else {
                this.cms.icon.innerText = 'block';
            }
            if (this.horizontalScroll) {
                this.cms.icon.innerText = event.target.id === 'right' ? 'arrow_forward' : 'arrow_back';
                rxjs.interval(100).pipe(operators.takeUntil(this._dragLeave)).subscribe(function () {
                    _this.cms.column.grid.wheelHandler();
                    event.target.id === 'right' ? _this.horizontalScroll.scrollPosition += 15 :
                        _this.horizontalScroll.scrollPosition -= 15;
                });
            }
        };
        IgxColumnMovingDropDirective.prototype.onDragLeave = function (event) {
            var drag = event.detail.owner;
            if (!(drag instanceof IgxColumnMovingDragDirective)) {
                return;
            }
            this.cms.icon.innerText = 'block';
            if (this._dropIndicator) {
                this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
            }
            if (this.horizontalScroll) {
                this._dragLeave.next(true);
            }
        };
        IgxColumnMovingDropDirective.prototype.onDragDrop = function (event) {
            event.preventDefault();
            var drag = event.detail.owner;
            if (!(drag instanceof IgxColumnMovingDragDirective)) {
                return;
            }
            if (this.column && (this.cms.column.grid.id !== this.column.grid.id)) {
                return;
            }
            if (this.horizontalScroll) {
                this._dragLeave.next(true);
            }
            if (this.isDropTarget) {
                var args = {
                    source: this.cms.column,
                    target: this.column
                };
                this.column.grid.moveColumn(this.cms.column, this.column, this._dropPos);
                this.column.grid.draggedColumn = null;
                this.column.grid.cdr.detectChanges();
            }
        };
        IgxColumnMovingDropDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: core.NgZone },
            { type: IgxColumnMovingService }
        ]; };
        __decorate([
            core.Input('igxColumnMovingDrop')
        ], IgxColumnMovingDropDirective.prototype, "data", null);
        IgxColumnMovingDropDirective = __decorate([
            core.Directive({
                selector: '[igxColumnMovingDrop]'
            })
        ], IgxColumnMovingDropDirective);
        return IgxColumnMovingDropDirective;
    }(IgxDropDirective));

    var IgxColumnMovingModule = /** @class */ (function () {
        function IgxColumnMovingModule() {
        }
        IgxColumnMovingModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxColumnMovingDropDirective,
                    IgxColumnMovingDragDirective
                ],
                exports: [
                    IgxColumnMovingDropDirective,
                    IgxColumnMovingDragDirective
                ]
            })
        ], IgxColumnMovingModule);
        return IgxColumnMovingModule;
    }());

    var IgxSummaryDataPipe = /** @class */ (function () {
        function IgxSummaryDataPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxSummaryDataPipe.prototype.transform = function (id, trigger) {
            if (trigger === void 0) { trigger = 0; }
            var summaryService = this.gridAPI.grid.summaryService;
            return summaryService.calculateSummaries(summaryService.rootSummaryID, this.gridAPI.get_summary_data());
        };
        IgxSummaryDataPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxSummaryDataPipe = __decorate([
            core.Pipe({
                name: 'igxGridSummaryDataPipe',
                pure: true
            })
        ], IgxSummaryDataPipe);
        return IgxSummaryDataPipe;
    }());

    var IgxGridSummaryModule = /** @class */ (function () {
        function IgxGridSummaryModule() {
        }
        IgxGridSummaryModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxSummaryCellComponent,
                    IgxSummaryRowComponent,
                    IgxSummaryDataPipe
                ],
                imports: [
                    IgxGridPipesModule,
                    IgxGridSharedModules
                ],
                exports: [
                    IgxSummaryCellComponent,
                    IgxSummaryRowComponent,
                    IgxSummaryDataPipe
                ]
            })
        ], IgxGridSummaryModule);
        return IgxGridSummaryModule;
    }());

    var IgxColumnPinningModule = /** @class */ (function () {
        function IgxColumnPinningModule() {
        }
        IgxColumnPinningModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxColumnPinningItemDirective,
                    IgxColumnPinningComponent
                ],
                imports: [
                    IgxGridSharedModules
                ],
                exports: [
                    IgxColumnPinningComponent
                ]
            })
        ], IgxColumnPinningModule);
        return IgxColumnPinningModule;
    }());

    var IgxGridToolbarModule = /** @class */ (function () {
        function IgxGridToolbarModule() {
        }
        IgxGridToolbarModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxGridToolbarComponent,
                    IgxGridToolbarCustomContentDirective
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxColumnHidingModule,
                    IgxColumnPinningModule
                ],
                exports: [
                    IgxGridToolbarComponent,
                    IgxGridToolbarCustomContentDirective
                ]
            })
        ], IgxGridToolbarModule);
        return IgxGridToolbarModule;
    }());

    var IgxColumnLayoutComponent = /** @class */ (function (_super) {
        __extends(IgxColumnLayoutComponent, _super);
        function IgxColumnLayoutComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.childrenVisibleIndexes = [];
            return _this;
        }
        IgxColumnLayoutComponent_1 = IgxColumnLayoutComponent;
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "width", {
            /**
             * Gets the width of the column layout.
             * ```typescript
             * let columnGroupWidth = this.columnGroup.width;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                var width = this.getFilledChildColumnSizes(this.children).reduce(function (acc, val) { return acc + parseInt(val, 10); }, 0);
                return width;
            },
            set: function (val) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "columnLayout", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxColumnLayoutComponent.prototype.getCalcWidth = function () {
            var borderWidth = 0;
            if (this.headerGroup && this.headerGroup.hasLastPinnedChildColumn) {
                var headerStyles = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement.children[0]);
                borderWidth = parseInt(headerStyles.borderRightWidth, 10);
            }
            return _super.prototype.getCalcWidth.call(this) + borderWidth;
        };
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "visibleIndex", {
            /**
             * Gets the column visible index.
             * If the column is not visible, returns `-1`.
             * ```typescript
             * let visibleColumnIndex =  this.column.visibleIndex;
             * ```
             * @memberof IgxColumnComponent
             */
            get: function () {
                if (!isNaN(this._vIndex)) {
                    return this._vIndex;
                }
                var unpinnedColumns = this.grid.unpinnedColumns.filter(function (c) { return c.columnLayout && !c.hidden; });
                var pinnedColumns = this.grid.pinnedColumns.filter(function (c) { return c.columnLayout && !c.hidden; });
                var vIndex = -1;
                if (!this.pinned) {
                    var indexInCollection = unpinnedColumns.indexOf(this);
                    vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
                }
                else {
                    vIndex = pinnedColumns.indexOf(this);
                }
                this._vIndex = vIndex;
                return vIndex;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "hidden", {
            /*
             * Gets whether the column layout is hidden.
             * ```typescript
             * let isHidden = this.columnGroup.hidden;
             * ```
             * @memberof IgxColumnGroupComponent
             */
            get: function () {
                return this._hidden;
            },
            /**
             * Sets the column layout hidden property.
             * ```typescript
             * <igx-column-layout [hidden] = "true"></igx-column->
             * ```
             * @memberof IgxColumnGroupComponent
             */
            set: function (value) {
                this._hidden = value;
                this.children.forEach(function (child) { return child.hidden = value; });
                if (this.grid && this.grid.columns && this.grid.columns.length > 0) {
                    // reset indexes in case columns are hidden/shown runtime
                    this.grid.columns.filter(function (x) { return x.columnGroup; }).forEach(function (x) { return x.populateVisibleIndexes(); });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
        */
        IgxColumnLayoutComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            _super.prototype.ngAfterContentInit.call(this);
            if (!this.hidden) {
                this.hidden = this.allChildren.some(function (x) { return x.hidden; });
            }
            else {
                this.children.forEach(function (child) { return child.hidden = _this.hidden; });
            }
            this.children.forEach(function (child) {
                child.movable = false;
            });
        };
        Object.defineProperty(IgxColumnLayoutComponent.prototype, "hasLastPinnedChildColumn", {
            /*
             * Gets whether the group contains the last pinned child column of the column layout.
             * ```typescript
             * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
             * ```
             * @memberof IgxColumnLayoutComponent
             */
            get: function () {
                return this.children.some(function (child) { return child.isLastPinned; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
        */
        IgxColumnLayoutComponent.prototype.populateVisibleIndexes = function () {
            var _this = this;
            this.childrenVisibleIndexes = [];
            var grid = this.gridAPI.grid;
            var columns = grid && grid.pinnedColumns && grid.unpinnedColumns ? grid.pinnedColumns.concat(grid.unpinnedColumns) : [];
            var orderedCols = columns
                .filter(function (x) { return !x.columnGroup && !x.hidden; })
                .sort(function (a, b) { return a.rowStart - b.rowStart || columns.indexOf(a.parent) - columns.indexOf(b.parent) || a.colStart - b.colStart; });
            this.children.forEach(function (child) {
                var rs = child.rowStart || 1;
                var vIndex = 0;
                // filter out all cols with larger rowStart
                var cols = orderedCols.filter(function (c) {
                    return !c.columnGroup && (c.rowStart || 1) <= rs;
                });
                vIndex = cols.indexOf(child);
                _this.childrenVisibleIndexes.push({ column: child, index: vIndex });
            });
        };
        var IgxColumnLayoutComponent_1;
        __decorate([
            core.Input()
        ], IgxColumnLayoutComponent.prototype, "hidden", null);
        IgxColumnLayoutComponent = IgxColumnLayoutComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: core.forwardRef(function () { return IgxColumnLayoutComponent_1; }) }],
                selector: 'igx-column-layout',
                template: ""
            })
        ], IgxColumnLayoutComponent);
        return IgxColumnLayoutComponent;
    }(IgxColumnGroupComponent));

    var IgxGridColumnModule = /** @class */ (function () {
        function IgxGridColumnModule() {
        }
        IgxGridColumnModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxFilterCellTemplateDirective,
                    IgxCellTemplateDirective,
                    IgxCellHeaderTemplateDirective,
                    IgxCellFooterTemplateDirective,
                    IgxCellEditorTemplateDirective,
                    IgxCollapsibleIndicatorTemplateDirective,
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ],
                entryComponents: [
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ],
                exports: [
                    IgxFilterCellTemplateDirective,
                    IgxCellTemplateDirective,
                    IgxCellHeaderTemplateDirective,
                    IgxCellFooterTemplateDirective,
                    IgxCellEditorTemplateDirective,
                    IgxCollapsibleIndicatorTemplateDirective,
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ]
            })
        ], IgxGridColumnModule);
        return IgxGridColumnModule;
    }());

    var IgxGridFilteringModule = /** @class */ (function () {
        function IgxGridFilteringModule() {
        }
        IgxGridFilteringModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxGridFilteringCellComponent,
                    IgxGridFilteringRowComponent
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxGridPipesModule
                ],
                exports: [
                    IgxGridFilteringCellComponent,
                    IgxGridFilteringRowComponent
                ]
            })
        ], IgxGridFilteringModule);
        return IgxGridFilteringModule;
    }());

    var IgxGridHeadersModule = /** @class */ (function () {
        function IgxGridHeadersModule() {
        }
        IgxGridHeadersModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxGridHeaderComponent,
                    IgxGridHeaderGroupComponent
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxGridFilteringModule,
                    IgxColumnMovingModule,
                    IgxGridResizingModule
                ],
                exports: [
                    IgxGridHeaderComponent,
                    IgxGridHeaderGroupComponent
                ]
            })
        ], IgxGridHeadersModule);
        return IgxGridHeadersModule;
    }());

    /**
     * @hidden
     */
    var IgxGridCommonModule = /** @class */ (function () {
        function IgxGridCommonModule() {
        }
        IgxGridCommonModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxGridBaseDirective,
                    IgxRowDirective,
                    IgxGridCellComponent,
                    IgxRowEditTemplateDirective,
                    IgxRowEditActionsDirective,
                    IgxRowEditTextDirective,
                    IgxRowEditTabStopDirective,
                    IgxGridBodyDirective,
                    IgxGridFooterComponent,
                    IgxAdvancedFilteringDialogComponent
                ],
                entryComponents: [
                    IgxAdvancedFilteringDialogComponent
                ],
                exports: [
                    IgxGridCellComponent,
                    IgxRowEditTemplateDirective,
                    IgxRowEditActionsDirective,
                    IgxRowEditTextDirective,
                    IgxRowEditTabStopDirective,
                    IgxGridBodyDirective,
                    IgxColumnHidingModule,
                    IgxColumnPinningModule,
                    IgxGridColumnModule,
                    IgxGridHeadersModule,
                    IgxGridPipesModule,
                    IgxGridFilteringModule,
                    IgxGridExcelStyleFilteringModule,
                    IgxRowDragModule,
                    IgxPaginatorModule,
                    IgxGridFooterComponent,
                    IgxGridResizingModule,
                    IgxColumnMovingModule,
                    IgxGridSelectionModule,
                    IgxGridSummaryModule,
                    IgxGridToolbarModule,
                    IgxAdvancedFilteringDialogComponent,
                    IgxGridSharedModules
                ],
                imports: [
                    IgxGridColumnModule,
                    IgxGridHeadersModule,
                    IgxColumnMovingModule,
                    IgxGridResizingModule,
                    IgxColumnPinningModule,
                    IgxGridSelectionModule,
                    IgxGridSummaryModule,
                    IgxGridToolbarModule,
                    IgxColumnHidingModule,
                    IgxGridPipesModule,
                    IgxGridFilteringModule,
                    IgxGridExcelStyleFilteringModule,
                    IgxRowDragModule,
                    IgxPaginatorModule,
                    IgxGridSharedModules
                ],
                providers: [
                    { provide: IgxGridTransaction, useClass: IgxBaseTransactionService }
                ]
            })
        ], IgxGridCommonModule);
        return IgxGridCommonModule;
    }());

    /**
     *@hidden
     */
    var IgxGridSortingPipe = /** @class */ (function () {
        function IgxGridSortingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridSortingPipe.prototype.transform = function (collection, expressions, sorting, id, pipeTrigger) {
            var grid = this.gridAPI.grid;
            var result;
            if (!expressions.length) {
                result = collection;
            }
            else {
                result = DataUtil.sort(cloneArray(collection), expressions, sorting);
            }
            grid.filteredSortedData = result;
            return result;
        };
        IgxGridSortingPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxGridSortingPipe = __decorate([
            core.Pipe({
                name: 'gridSort',
                pure: true
            })
        ], IgxGridSortingPipe);
        return IgxGridSortingPipe;
    }());
    /**
     *@hidden
     */
    var IgxGridGroupingPipe = /** @class */ (function () {
        function IgxGridGroupingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridGroupingPipe.prototype.transform = function (collection, expression, expansion, defaultExpanded, id, groupsRecords, pipeTrigger) {
            var state = { expressions: [], expansion: [], defaultExpanded: defaultExpanded };
            var grid = this.gridAPI.grid;
            state.expressions = grid.groupingExpressions;
            var result;
            var fullResult = { data: [], metadata: [] };
            if (!state.expressions.length) {
                // empty the array without changing reference
                groupsRecords.splice(0, groupsRecords.length);
                result = {
                    data: collection,
                    metadata: collection
                };
            }
            else {
                state.expansion = grid.groupingExpansionState;
                state.defaultExpanded = grid.groupsExpanded;
                result = DataUtil.group(cloneArray(collection), state, grid, groupsRecords, fullResult);
            }
            grid.groupingFlatResult = result.data;
            grid.groupingResult = fullResult.data;
            grid.groupingMetadata = fullResult.metadata;
            return result;
        };
        IgxGridGroupingPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxGridGroupingPipe = __decorate([
            core.Pipe({
                name: 'gridGroupBy',
                pure: true
            })
        ], IgxGridGroupingPipe);
        return IgxGridGroupingPipe;
    }());
    /**
     *@hidden
     */
    var IgxGridPagingPipe = /** @class */ (function () {
        function IgxGridPagingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridPagingPipe.prototype.transform = function (collection, page, perPage, id, pipeTrigger) {
            if (page === void 0) { page = 0; }
            if (perPage === void 0) { perPage = 15; }
            if (!this.gridAPI.grid.paging) {
                return collection;
            }
            var state = {
                index: page,
                recordsPerPage: perPage
            };
            DataUtil.correctPagingState(state, collection.data.length);
            var result = {
                data: DataUtil.page(cloneArray(collection.data), state),
                metadata: DataUtil.page(cloneArray(collection.metadata), state)
            };
            if (this.gridAPI.grid.page !== state.index) {
                this.gridAPI.grid.page = state.index;
            }
            this.gridAPI.grid.pagingState = state;
            return result;
        };
        IgxGridPagingPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxGridPagingPipe = __decorate([
            core.Pipe({
                name: 'gridPaging',
                pure: true
            })
        ], IgxGridPagingPipe);
        return IgxGridPagingPipe;
    }());
    /**
     *@hidden
     */
    var IgxGridFilteringPipe = /** @class */ (function () {
        function IgxGridFilteringPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridFilteringPipe.prototype.transform = function (collection, expressionsTree, filterStrategy, advancedExpressionsTree, id, pipeTrigger, filteringPipeTrigger) {
            var grid = this.gridAPI.grid;
            var state = {
                expressionsTree: expressionsTree,
                strategy: filterStrategy,
                advancedExpressionsTree: advancedExpressionsTree
            };
            if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
                return collection;
            }
            var result = DataUtil.filter(cloneArray(collection), state);
            grid.filteredData = result;
            return result;
        };
        IgxGridFilteringPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxGridFilteringPipe = __decorate([
            core.Pipe({
                name: 'gridFiltering',
                pure: true
            })
        ], IgxGridFilteringPipe);
        return IgxGridFilteringPipe;
    }());

    var IgxGridRowComponent = /** @class */ (function (_super) {
        __extends(IgxGridRowComponent, _super);
        // R.K. TODO: Remove
        function IgxGridRowComponent(gridAPI, crudService, selectionService, element, cdr) {
            var _this = 
            // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
            _super.call(this, gridAPI, crudService, selectionService, element, cdr) || this;
            _this.gridAPI = gridAPI;
            _this.crudService = crudService;
            _this.selectionService = selectionService;
            _this.element = element;
            _this.cdr = cdr;
            return _this;
        }
        IgxGridRowComponent_1 = IgxGridRowComponent;
        Object.defineProperty(IgxGridRowComponent.prototype, "cells", {
            get: function () {
                var res = new core.QueryList();
                if (!this._cells) {
                    return res;
                }
                var cList = this._cells.toArray().sort(function (item1, item2) { return item1.column.visibleIndex - item2.column.visibleIndex; });
                res.reset(cList);
                return res;
            },
            set: function (cells) {
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxGridRowComponent.prototype, "hasColumnLayouts", {
            get: function () {
                return this.grid.hasColumnLayouts;
            },
            enumerable: true,
            configurable: true
        });
        IgxGridRowComponent.prototype.getContext = function (col, row) {
            return {
                $implicit: col,
                row: row
            };
        };
        Object.defineProperty(IgxGridRowComponent.prototype, "expanded", {
            get: function () {
                return this.gridAPI.get_row_expansion_state(this.rowData);
            },
            enumerable: true,
            configurable: true
        });
        var IgxGridRowComponent_1;
        IgxGridRowComponent.ctorParameters = function () { return [
            { type: GridBaseAPIService },
            { type: IgxGridCRUDService },
            { type: IgxGridSelectionService },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.ViewChildren('cell')
        ], IgxGridRowComponent.prototype, "_cells", void 0);
        __decorate([
            core.HostBinding('class.igx-grid__tr--mrl')
        ], IgxGridRowComponent.prototype, "hasColumnLayouts", null);
        IgxGridRowComponent = IgxGridRowComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-row',
                template: "<ng-container *ngIf=\"grid.groupingExpressions.length > 0\">\n    <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{grid.groupingExpressions.length}}\"></div>\n</ng-container>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"this.showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n         <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n                <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n    </ng-template>\n</ng-container>\n\n<ng-container *ngIf=\"grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <div *ngFor=\"let col of pinnedColumns | igxTopLevel\" class=\"igx-grid__mrl-block\"\n        [class.igx-grid__td--pinned-last]=\"col.hasLastPinnedChildColumn\"\n        [ngStyle]=\"{\n            'grid-template-rows':col.getGridTemplate(true, false),\n            'grid-template-columns':col.getGridTemplate(false, false),\n            'z-index': col.pinned ? 1 : null,\n            '-ms-grid-rows':col.getGridTemplate(true, true),\n            '-ms-grid-columns':col.getGridTemplate(false, true)\n        }\">\n            <ng-template ngFor let-col [ngForOf]=\"col.children\">\n                    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails? mrlExpandableCellTemplate : mrlCellTemplate; context: getContext(col, this)\"></ng-container>\n            </ng-template>\n        </div>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <div class=\"igx-grid__mrl-block\" [ngStyle]=\"{\n            'grid-template-rows':col.getGridTemplate(true, false),\n            'grid-template-columns':col.getGridTemplate(false, false),\n            '-ms-grid-rows':col.getGridTemplate(true, true),\n            '-ms-grid-columns':col.getGridTemplate(false, true)\n        }\">\n            <ng-template ngFor let-col [ngForOf]=\"col.children\">\n                    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? mrlExpandableCellTemplate : mrlCellTemplate; context: getContext(col, this)\"></ng-container>\n            </ng-template>\n        </div>\n    </ng-template>\n</ng-container>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [checked]=\"selected\"\n            [readonly]=\"true\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<ng-template #cellTemplate let-col>\n        <igx-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" #cell>\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #expandableCellTemplate let-col>\n    <igx-expandable-grid-cell\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [expanded]=\"expanded\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" #cell>\n    </igx-expandable-grid-cell>\n</ng-template>\n\n<ng-template #mrlCellTemplate let-col>\n    <igx-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [style.-ms-grid-row-span]=\"col.gridRowSpan\"\n        [style.-ms-grid-column-span]=\"col.girdColumnSpan\"\n        [style.grid-row-end]=\"col.rowEnd\"\n        [style.grid-column-end]=\"col.colEnd\"\n        [style.-ms-grid-row]=\"col.rowStart\"\n        [style.grid-row-start]=\"col.rowStart\"\n        [style.-ms-grid-column]=\"col.colStart\"\n        [style.grid-column-start]=\"col.colStart\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" #cell>\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #mrlExpandableCellTemplate let-col>\n    <igx-expandable-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [expanded]=\"expanded\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [style.-ms-grid-row-span]=\"col.gridRowSpan\"\n        [style.-ms-grid-column-span]=\"col.girdColumnSpan\"\n        [style.grid-row-end]=\"col.rowEnd\"\n        [style.grid-column-end]=\"col.colEnd\"\n        [style.-ms-grid-row]=\"col.rowStart\"\n        [style.grid-row-start]=\"col.rowStart\"\n        [style.-ms-grid-column]=\"col.colStart\"\n        [style.grid-column-start]=\"col.colStart\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\" #cell>\n    </igx-expandable-grid-cell>\n</ng-template>\n",
                providers: [{ provide: IgxRowDirective, useExisting: core.forwardRef(function () { return IgxGridRowComponent_1; }) }]
            })
        ], IgxGridRowComponent);
        return IgxGridRowComponent;
    }(IgxRowDirective));

    /** @hidden */
    var IgxGridSummaryPipe = /** @class */ (function () {
        function IgxGridSummaryPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridSummaryPipe.prototype.transform = function (collection, hasSummary, summaryCalculationMode, summaryPosition, id, pipeTrigger, summaryPipeTrigger) {
            if (!collection.data || !hasSummary || summaryCalculationMode === exports.GridSummaryCalculationMode.rootLevelOnly) {
                return collection.data;
            }
            return this.addSummaryRows(id, collection, summaryPosition);
        };
        IgxGridSummaryPipe.prototype.addSummaryRows = function (gridId, collection, summaryPosition) {
            var _a;
            var recordsWithSummary = [];
            var lastChildMap = new Map();
            var grid = this.gridAPI.grid;
            var maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
            if (collection.metadata.length && !grid.isGroupByRecord(collection.data[0]) &&
                grid.isGroupByRecord(collection.metadata[0]) && summaryPosition === exports.GridSummaryPosition.bottom) {
                var groups = [];
                groups.push(collection.metadata[0]);
                while (groups[groups.length - 1].groupParent) {
                    groups.push(groups[groups.length - 1].groupParent);
                }
                groups.reverse();
                groups.forEach(function (g) { return g.skip = true; });
                (_a = collection.data).splice.apply(_a, __spread([0, 0], groups));
            }
            for (var i = 0; i < collection.data.length; i++) {
                var record = collection.data[i];
                var skipAdd = false;
                var recordId = void 0;
                var groupByRecord = null;
                if (grid.isGroupByRecord(record)) {
                    skipAdd = !!record.skip;
                    record.skip = null;
                    groupByRecord = record;
                    recordId = this.gridAPI.get_groupBy_record_id(groupByRecord);
                }
                else {
                    recordId = this.gridAPI.get_row_id(record);
                }
                if (!skipAdd) {
                    recordsWithSummary.push(record);
                }
                if (summaryPosition === exports.GridSummaryPosition.bottom && lastChildMap.has(recordId)) {
                    var groupRecords = lastChildMap.get(recordId);
                    for (var j = 0; j < groupRecords.length; j++) {
                        var groupRecord = groupRecords[j];
                        var groupRecordId = this.gridAPI.get_groupBy_record_id(groupRecord);
                        var records = this.removeDeletedRecord(grid, groupRecord.records.slice());
                        var summaries = grid.summaryService.calculateSummaries(groupRecordId, records);
                        var summaryRecord = {
                            summaries: summaries,
                            max: maxSummaryHeight
                        };
                        recordsWithSummary.push(summaryRecord);
                    }
                }
                if (groupByRecord === null || !grid.isExpandedGroup(groupByRecord)) {
                    continue;
                }
                if (summaryPosition === exports.GridSummaryPosition.top) {
                    var records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
                    var summaries = grid.summaryService.calculateSummaries(recordId, records);
                    var summaryRecord = {
                        summaries: summaries,
                        max: maxSummaryHeight
                    };
                    recordsWithSummary.push(summaryRecord);
                }
                else if (summaryPosition === exports.GridSummaryPosition.bottom) {
                    var lastChild = groupByRecord;
                    while (lastChild.groups && lastChild.groups.length > 0 && grid.isExpandedGroup(lastChild)) {
                        lastChild = lastChild.groups[lastChild.groups.length - 1];
                    }
                    var lastChildId = void 0;
                    if (grid.isExpandedGroup(lastChild)) {
                        lastChildId = this.gridAPI.get_row_id(lastChild.records[lastChild.records.length - 1]);
                    }
                    else {
                        lastChildId = this.gridAPI.get_groupBy_record_id(lastChild);
                    }
                    var groupRecords = lastChildMap.get(lastChildId);
                    if (!groupRecords) {
                        groupRecords = [];
                        lastChildMap.set(lastChildId, groupRecords);
                    }
                    groupRecords.unshift(groupByRecord);
                }
            }
            return recordsWithSummary;
        };
        IgxGridSummaryPipe.prototype.removeDeletedRecord = function (grid, data) {
            if (!grid.transactions.enabled) {
                return data;
            }
            var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === 'delete'; }).map(function (t) { return t.id; });
            deletedRows.forEach(function (rowID) {
                var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
                var index = tempData.indexOf(rowID);
                if (index !== -1) {
                    data.splice(index, 1);
                }
            });
            return data;
        };
        IgxGridSummaryPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxGridSummaryPipe = __decorate([
            core.Pipe({
                name: 'gridSummary',
                pure: true
            })
        ], IgxGridSummaryPipe);
        return IgxGridSummaryPipe;
    }());

    /** @hidden */
    var IgxGridDetailsPipe = /** @class */ (function () {
        function IgxGridDetailsPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridDetailsPipe.prototype.transform = function (collection, hasDetails, expansionStates, pipeTrigger) {
            if (!hasDetails) {
                return collection;
            }
            var res = this.addDetailRows(collection, expansionStates);
            return res;
        };
        IgxGridDetailsPipe.prototype.addDetailRows = function (collection, expansionStates) {
            var _this = this;
            var result = [];
            collection.forEach(function (v) {
                result.push(v);
                if (!_this.gridAPI.grid.isGroupByRecord(v) && !_this.gridAPI.grid.isSummaryRow(v) &&
                    _this.gridAPI.get_row_expansion_state(v)) {
                    var detailsObj = { detailsData: v };
                    result.push(detailsObj);
                }
            });
            return result;
        };
        IgxGridDetailsPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxGridDetailsPipe = __decorate([
            core.Pipe({
                name: 'gridDetails',
                pure: true
            })
        ], IgxGridDetailsPipe);
        return IgxGridDetailsPipe;
    }());

    var IgxGridExpandableCellComponent = /** @class */ (function (_super) {
        __extends(IgxGridExpandableCellComponent, _super);
        function IgxGridExpandableCellComponent(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
            var _this = _super.call(this, selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil) || this;
            _this.zone = zone;
            _this.document = document;
            _this.platformUtil = platformUtil;
            /**
             * @hidden
            */
            _this.expanded = false;
            return _this;
        }
        /**
         * @hidden
         */
        IgxGridExpandableCellComponent.prototype.toggle = function (event) {
            event.stopPropagation();
            var expansionState = this.gridAPI.get_row_expansion_state(this.row.rowData);
            this.gridAPI.set_row_expansion_state(this.row.rowID, !expansionState, event);
        };
        /**
         * @hidden
         */
        IgxGridExpandableCellComponent.prototype.onIndicatorFocus = function () {
            this.gridAPI.submit_value();
            this.nativeElement.focus();
        };
        /**
         * @hidden
         */
        IgxGridExpandableCellComponent.prototype.calculateSizeToFit = function (range) {
            var indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
            var indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
            var indicatorMargin = parseFloat(indicatorStyle.marginRight);
            var leftPadding = 0;
            if (this.indentationDiv) {
                var indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
                leftPadding = parseFloat(indentationStyle.paddingLeft);
            }
            var largestWidth = Math.max.apply(Math, __spread(Array.from(this.nativeElement.children)
                .map(function (child) { return getNodeSizeViaRange(range, child); })));
            return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
        };
        Object.defineProperty(IgxGridExpandableCellComponent.prototype, "iconTemplate", {
            /**
             * @hidden
            */
            get: function () {
                if (this.expanded) {
                    return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
                }
                else {
                    return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxGridExpandableCellComponent.ctorParameters = function () { return [
            { type: IgxGridSelectionService },
            { type: IgxGridCRUDService },
            { type: GridBaseAPIService },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: HammerGesturesManager },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: PlatformUtil }
        ]; };
        __decorate([
            core.Input()
        ], IgxGridExpandableCellComponent.prototype, "expanded", void 0);
        __decorate([
            core.ViewChild('indicator', { read: core.ElementRef })
        ], IgxGridExpandableCellComponent.prototype, "indicator", void 0);
        __decorate([
            core.ViewChild('indentationDiv', { read: core.ElementRef })
        ], IgxGridExpandableCellComponent.prototype, "indentationDiv", void 0);
        __decorate([
            core.ViewChild('defaultExpandedTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridExpandableCellComponent.prototype, "defaultExpandedTemplate", void 0);
        __decorate([
            core.ViewChild('defaultCollapsedTemplate', { read: core.TemplateRef, static: true })
        ], IgxGridExpandableCellComponent.prototype, "defaultCollapsedTemplate", void 0);
        IgxGridExpandableCellComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                selector: 'igx-expandable-grid-cell',
                template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!editMode\">\n    <div #indicator\n         class=\"igx-grid__tree-grouping-indicator\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\" tabindex=\"-1\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
                providers: [HammerGesturesManager]
            }),
            __param(7, core.Inject(common.DOCUMENT))
        ], IgxGridExpandableCellComponent);
        return IgxGridExpandableCellComponent;
    }(IgxGridCellComponent));

    /**
     * @hidden
     */
    var IgxGridModule = /** @class */ (function () {
        function IgxGridModule() {
        }
        IgxGridModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxGridComponent,
                    IgxGridRowComponent,
                    IgxGridGroupByRowComponent,
                    IgxGroupByRowTemplateDirective,
                    IgxGridDetailTemplateDirective,
                    IgxRowExpandedIndicatorDirective,
                    IgxRowCollapsedIndicatorDirective,
                    IgxHeaderExpandIndicatorDirective,
                    IgxHeaderCollapseIndicatorDirective,
                    IgxGroupAreaDropDirective,
                    IgxGridGroupingPipe,
                    IgxGridPagingPipe,
                    IgxGridSortingPipe,
                    IgxGridFilteringPipe,
                    IgxGridSummaryPipe,
                    IgxGridDetailsPipe,
                    IgxGridExpandableCellComponent
                ],
                exports: [
                    IgxGridComponent,
                    IgxGridExpandableCellComponent,
                    IgxGridGroupByRowComponent,
                    IgxGridRowComponent,
                    IgxGroupByRowTemplateDirective,
                    IgxGridDetailTemplateDirective,
                    IgxRowExpandedIndicatorDirective,
                    IgxRowCollapsedIndicatorDirective,
                    IgxHeaderExpandIndicatorDirective,
                    IgxHeaderCollapseIndicatorDirective,
                    IgxGroupAreaDropDirective,
                    IgxGridGroupingPipe,
                    IgxGridPagingPipe,
                    IgxGridSortingPipe,
                    IgxGridFilteringPipe,
                    IgxGridSummaryPipe,
                    IgxGridDetailsPipe,
                    IgxGridCommonModule
                ],
                imports: [
                    IgxGridCommonModule,
                ]
            })
        ], IgxGridModule);
        return IgxGridModule;
    }());

    var IgxTreeGridAPIService = /** @class */ (function (_super) {
        __extends(IgxTreeGridAPIService, _super);
        function IgxTreeGridAPIService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxTreeGridAPIService.prototype.get_all_data = function (transactions) {
            var grid = this.grid;
            var data = transactions ? grid.dataWithAddedInTransactionRows : grid.flatData;
            return data ? data : [];
        };
        IgxTreeGridAPIService.prototype.get_summary_data = function () {
            var grid = this.grid;
            var data = grid.processedRootRecords.filter(function (row) { return row.isFilteredOutParent === undefined || row.isFilteredOutParent === false; })
                .map(function (rec) { return rec.data; });
            if (grid.transactions.enabled) {
                var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === exports.TransactionType.DELETE; }).map(function (t) { return t.id; });
                deletedRows.forEach(function (rowID) {
                    var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
                    var index = tempData.indexOf(rowID);
                    if (index !== -1) {
                        data.splice(index, 1);
                    }
                });
            }
            return data;
        };
        IgxTreeGridAPIService.prototype.allow_expansion_state_change = function (rowID, expanded) {
            var grid = this.grid;
            var row = grid.records.get(rowID);
            if (row.expanded === expanded ||
                ((!row.children || !row.children.length) && (!grid.loadChildrenOnDemand ||
                    (grid.hasChildrenKey && !row.data[grid.hasChildrenKey])))) {
                return false;
            }
            return true;
        };
        IgxTreeGridAPIService.prototype.expand_path_to_record = function (record) {
            var grid = this.grid;
            var expandedStates = grid.expansionStates;
            while (record.parent) {
                record = record.parent;
                var expanded = this.get_row_expansion_state(record);
                if (!expanded) {
                    expandedStates.set(record.rowID, true);
                }
            }
            grid.expansionStates = expandedStates;
            if (grid.rowEditable) {
                grid.endEdit(true);
            }
        };
        IgxTreeGridAPIService.prototype.get_row_expansion_state = function (record) {
            var grid = this.grid;
            var states = grid.expansionStates;
            var expanded = states.get(record.rowID);
            if (expanded !== undefined) {
                return expanded;
            }
            else {
                return record.children && record.children.length && record.level < grid.expansionDepth;
            }
        };
        IgxTreeGridAPIService.prototype.update_row_in_array = function (value, rowID, index) {
            var grid = this.grid;
            if (grid.primaryKey && grid.foreignKey) {
                _super.prototype.update_row_in_array.call(this, value, rowID, index);
            }
            else {
                var record = grid.records.get(rowID);
                var childData = record.parent ? record.parent.data[grid.childDataKey] : grid.data;
                index = grid.primaryKey ? childData.map(function (c) { return c[grid.primaryKey]; }).indexOf(rowID) :
                    childData.indexOf(rowID);
                childData[index] = value;
            }
        };
        IgxTreeGridAPIService.prototype.should_apply_number_style = function (column) {
            return column.dataType === exports.DataType.Number && column.visibleIndex !== 0;
        };
        IgxTreeGridAPIService.prototype.deleteRowById = function (rowID) {
            var treeGrid = this.grid;
            var flatDataWithCascadeOnDeleteAndTransactions = treeGrid.primaryKey &&
                treeGrid.foreignKey &&
                treeGrid.cascadeOnDelete &&
                treeGrid.transactions.enabled;
            if (flatDataWithCascadeOnDeleteAndTransactions) {
                treeGrid.transactions.startPending();
            }
            _super.prototype.deleteRowById.call(this, rowID);
            if (flatDataWithCascadeOnDeleteAndTransactions) {
                treeGrid.transactions.endPending(true);
            }
        };
        IgxTreeGridAPIService.prototype.deleteRowFromData = function (rowID, index) {
            var treeGrid = this.grid;
            var record = treeGrid.records.get(rowID);
            if (treeGrid.primaryKey && treeGrid.foreignKey) {
                index = treeGrid.primaryKey ?
                    treeGrid.data.map(function (c) { return c[treeGrid.primaryKey]; }).indexOf(rowID) :
                    treeGrid.data.indexOf(rowID);
                _super.prototype.deleteRowFromData.call(this, rowID, index);
                if (treeGrid.cascadeOnDelete) {
                    if (record && record.children && record.children.length > 0) {
                        for (var i = 0; i < record.children.length; i++) {
                            var child = record.children[i];
                            _super.prototype.deleteRowById.call(this, child.rowID);
                        }
                    }
                }
            }
            else {
                var collection = record.parent ? record.parent.data[treeGrid.childDataKey] : treeGrid.data;
                index = treeGrid.primaryKey ?
                    collection.map(function (c) { return c[treeGrid.primaryKey]; }).indexOf(rowID) :
                    collection.indexOf(rowID);
                var selectedChildren = [];
                this.get_selected_children(record, selectedChildren);
                if (selectedChildren.length > 0) {
                    treeGrid.deselectRows(selectedChildren);
                }
                if (treeGrid.transactions.enabled) {
                    var path = treeGrid.generateRowPath(rowID);
                    treeGrid.transactions.add({
                        id: rowID,
                        type: exports.TransactionType.DELETE,
                        newValue: null,
                        path: path
                    }, collection[index]);
                }
                else {
                    collection.splice(index, 1);
                }
            }
        };
        /**
         * Updates related row of provided grid's data source with provided new row value
         * @param grid Grid to update data for
         * @param rowID ID of the row to update
         * @param rowValueInDataSource Initial value of the row as it is in data source
         * @param rowCurrentValue Current value of the row as it is with applied previous transactions
         * @param rowNewValue New value of the row
         */
        IgxTreeGridAPIService.prototype.updateData = function (grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
            if (grid.transactions.enabled) {
                var path = grid.generateRowPath(rowID);
                var transaction = {
                    id: rowID,
                    type: exports.TransactionType.UPDATE,
                    newValue: rowNewValue,
                    path: path
                };
                grid.transactions.add(transaction, rowCurrentValue);
            }
            else {
                mergeObjects(rowValueInDataSource, rowNewValue);
            }
        };
        IgxTreeGridAPIService.prototype.get_selected_children = function (record, selectedRowIDs) {
            var e_1, _a;
            var grid = this.grid;
            if (!record.children || record.children.length === 0) {
                return;
            }
            try {
                for (var _b = __values(record.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    if (grid.selectionService.isRowSelected(child.rowID)) {
                        selectedRowIDs.push(child.rowID);
                    }
                    this.get_selected_children(child, selectedRowIDs);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        IgxTreeGridAPIService.prototype.row_deleted_transaction = function (rowID) {
            return this.row_deleted_parent(rowID) || _super.prototype.row_deleted_transaction.call(this, rowID);
        };
        IgxTreeGridAPIService.prototype.get_rec_by_id = function (rowID) {
            return this.grid.records.get(rowID);
        };
        IgxTreeGridAPIService.prototype.row_deleted_parent = function (rowID) {
            var grid = this.grid;
            if (!grid) {
                return false;
            }
            if ((grid.cascadeOnDelete && grid.foreignKey) || grid.childDataKey) {
                var node = grid.records.get(rowID);
                while (node) {
                    var state = grid.transactions.getState(node.rowID);
                    if (state && state.type === exports.TransactionType.DELETE) {
                        return true;
                    }
                    node = node.parent;
                }
            }
            return false;
        };
        IgxTreeGridAPIService = __decorate([
            core.Injectable()
        ], IgxTreeGridAPIService);
        return IgxTreeGridAPIService;
    }(GridBaseAPIService));

    var IgxTreeGridNavigationService = /** @class */ (function (_super) {
        __extends(IgxTreeGridNavigationService, _super);
        function IgxTreeGridNavigationService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxTreeGridNavigationService.prototype.getCellSelector = function (visibleIndex, isSummary) {
            if (isSummary === void 0) { isSummary = false; }
            if (isSummary) {
                return 'igx-grid-summary-cell';
            }
            if (visibleIndex === 0) {
                return 'igx-tree-grid-cell';
            }
            return 'igx-grid-cell';
        };
        IgxTreeGridNavigationService.prototype.getRowSelector = function () {
            return 'igx-tree-grid-row';
        };
        IgxTreeGridNavigationService = __decorate([
            core.Injectable()
        ], IgxTreeGridNavigationService);
        return IgxTreeGridNavigationService;
    }(IgxGridNavigationService));

    /**
     * @hidden
     */
    var IgxRowLoadingIndicatorTemplateDirective = /** @class */ (function () {
        function IgxRowLoadingIndicatorTemplateDirective(template) {
            this.template = template;
        }
        IgxRowLoadingIndicatorTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxRowLoadingIndicatorTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxRowLoadingIndicator]'
            })
        ], IgxRowLoadingIndicatorTemplateDirective);
        return IgxRowLoadingIndicatorTemplateDirective;
    }());

    var NEXT_ID$n = 0;
    /**
     * **Ignite UI for Angular Tree Grid** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
     *
     * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
     * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
     *
     * Example:
     * ```html
     * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
     *   <igx-column field="first" header="First Name"></igx-column>
     *   <igx-column field="last" header="Last Name"></igx-column>
     *   <igx-column field="role" header="Role"></igx-column>
     * </igx-tree-grid>
     * ```
     */
    var IgxTreeGridComponent = /** @class */ (function (_super) {
        __extends(IgxTreeGridComponent, _super);
        function IgxTreeGridComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._id = "igx-tree-grid-" + NEXT_ID$n++;
            /**
             * Returns a map of all `ITreeGridRecord`s.
             * ```typescript
             * // gets the record with primaryKey=2
             * const states = this.grid.records.get(2);
             * ```
             * @memberof IgxTreeGridComponent
             */
            _this.records = new Map();
            /**
             * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
             * ```typescript
             * // gets the processed record with primaryKey=2
             * const states = this.grid.processedRecords.get(2);
             * ```
             * @memberof IgxTreeGridComponent
             */
            _this.processedRecords = new Map();
            /**
             * An @Input property indicating whether child records should be deleted when their parent gets deleted.
             * By default it is set to true and deletes all children along with the parent.
             * ```html
             * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
             * </igx-tree-grid>
             * ```
             * @memberof IgxTreeGridComponent
             */
            _this.cascadeOnDelete = true;
            _this._expansionDepth = Infinity;
            /**
             * @hidden
             */
            _this.loadingRows = new Set();
            _this._filteredData = null;
            return _this;
        }
        IgxTreeGridComponent_1 = IgxTreeGridComponent;
        Object.defineProperty(IgxTreeGridComponent.prototype, "id", {
            /**
             * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
             * ```html
             * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
             * ```
             * @memberof IgxTreeGridComponent
             */
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "data", {
            /**
             * An @Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
             * ```html
             * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
             * ```
             * @memberof IgxTreeGridComponent
             */
            get: function () {
                return this._data;
            },
            set: function (value) {
                this._data = value || [];
                this.summaryService.clearSummaryCache();
                if (this.shouldGenerate) {
                    this.setupColumns();
                }
                this.cdr.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "filteredData", {
            /**
             * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
             * ```typescript
             * let filteredData = this.grid.filteredData;
             * ```
             * @memberof IgxTreeGridComponent
             */
            get: function () {
                return this._filteredData;
            },
            /**
             * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
             * ```typescript
             * this.grid.filteredData = [{
             *       ID: 1,
             *       Name: "A"
             * }];
             * ```
             * @memberof IgxTreeGridComponent
             */
            set: function (value) {
                this._filteredData = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "transactions", {
            /**
             * Get transactions service for the grid.
             * @experimental @hidden
             */
            get: function () {
                return this._transactions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "expansionDepth", {
            /**
             * An @Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
             * set to `Infinity` which means all levels would be expanded.
             * ```html
             * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
             * ```
             * @memberof IgxTreeGridComponent
             */
            get: function () {
                return this._expansionDepth;
            },
            set: function (value) {
                this._expansionDepth = value;
                this.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "rowLoadingIndicatorTemplate", {
            /**
             * An @Input property that provides a template for the row loading indicator when load on demand is enabled.
             * ```html
             * <ng-template #rowLoadingTemplate>
             *     <igx-icon fontSet="material">loop</igx-icon>
             * </ng-template>
             *
             * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
             *                [loadChildrenOnDemand]="loadChildren"
             *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
             * </igx-tree-grid>
             * ```
             * @memberof IgxTreeGridComponent
             */
            get: function () {
                return this._rowLoadingIndicatorTemplate;
            },
            set: function (value) {
                this._rowLoadingIndicatorTemplate = value;
                this.notifyChanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridComponent.prototype, "_gridAPI", {
            // Kind of stupid
            get: function () {
                return this.gridAPI;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTreeGridComponent.prototype.ngOnInit = function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            this.onRowToggle.pipe(operators.takeUntil(this.destroy$)).subscribe(function (args) {
                _this.loadChildrenOnRowExpansion(args);
            });
        };
        IgxTreeGridComponent.prototype.ngDoCheck = function () {
            _super.prototype.ngDoCheck.call(this);
        };
        /**
         * @hidden
         */
        IgxTreeGridComponent.prototype.ngAfterContentInit = function () {
            if (this.rowLoadingTemplate) {
                this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
            }
            _super.prototype.ngAfterContentInit.call(this);
        };
        IgxTreeGridComponent.prototype.loadChildrenOnRowExpansion = function (args) {
            var _this = this;
            if (this.loadChildrenOnDemand) {
                var parentID_1 = args.rowID;
                if (args.expanded && !this._expansionStates.has(parentID_1)) {
                    this.loadingRows.add(parentID_1);
                    this.loadChildrenOnDemand(parentID_1, function (children) {
                        _this.loadingRows.delete(parentID_1);
                        _this.addChildRows(children, parentID_1);
                        _this.notifyChanges();
                        requestAnimationFrame(function () {
                            var cellID = _this.selectionService.activeElement;
                            if (cellID) {
                                var cell = _this._gridAPI.get_cell_by_index(cellID.row, cellID.column);
                                if (cell) {
                                    cell.nativeElement.focus();
                                }
                            }
                        });
                    });
                }
            }
        };
        IgxTreeGridComponent.prototype.addChildRows = function (children, parentID) {
            var e_1, _a, _b;
            var _this = this;
            if (this.primaryKey && this.foreignKey) {
                try {
                    for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                        var child = children_1_1.value;
                        child[this.foreignKey] = parentID;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                (_b = this.data).push.apply(_b, __spread(children));
            }
            else if (this.childDataKey) {
                var parent_1 = this.records.get(parentID);
                var parentData = parent_1.data;
                if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                    var path = [];
                    while (parent_1) {
                        path.push(parent_1.rowID);
                        parent_1 = parent_1.parent;
                    }
                    var collection = this.data;
                    var record = void 0;
                    var _loop_1 = function (i) {
                        var pid = path[i];
                        record = collection.find(function (r) { return r[_this.primaryKey] === pid; });
                        if (!record) {
                            return "break";
                        }
                        collection = record[this_1.childDataKey];
                    };
                    var this_1 = this;
                    for (var i = path.length - 1; i >= 0; i--) {
                        var state_1 = _loop_1(i);
                        if (state_1 === "break")
                            break;
                    }
                    if (record) {
                        parentData = record;
                    }
                }
                parentData[this.childDataKey] = children;
            }
            this.selectionService.clearHeaderCBState();
            this._pipeTrigger++;
        };
        IgxTreeGridComponent.prototype.cloneMap = function (mapIn) {
            var mapCloned = new Map();
            mapIn.forEach(function (value, key, mapObj) {
                mapCloned.set(key, value);
            });
            return mapCloned;
        };
        IgxTreeGridComponent.prototype.getDefaultExpandState = function (record) {
            return record.children && record.children.length && record.level < this.expansionDepth;
        };
        /**
         * Expands all rows.
         * ```typescript
         * this.grid.expandAll();
         * ```
         * @memberof IgxTreeGridComponent
         */
        IgxTreeGridComponent.prototype.expandAll = function () {
            this._expansionDepth = Infinity;
            this.expansionStates = new Map();
        };
        /**
         * Collapses all rows.
         * ```typescript
         * this.grid.collapseAll();
         * ```
         * @memberof IgxTreeGridComponent
         */
        IgxTreeGridComponent.prototype.collapseAll = function () {
            this._expansionDepth = 0;
            this.expansionStates = new Map();
        };
        /**
         * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
         * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
         * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
         * ```typescript
         * const record = {
         *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
         *     Name: this.newRecord
         * };
         * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
         * ```
         * @param data
         * @param parentRowID
         * @memberof IgxTreeGridComponent
         */
        IgxTreeGridComponent.prototype.addRow = function (data, parentRowID) {
            if (parentRowID !== undefined && parentRowID !== null) {
                _super.prototype.endEdit.call(this, true);
                var state = this.transactions.getState(parentRowID);
                // we should not allow adding of rows as child of deleted row
                if (state && state.type === exports.TransactionType.DELETE) {
                    throw Error("Cannot add child row to deleted parent row");
                }
                var parentRecord = this.records.get(parentRowID);
                if (!parentRecord) {
                    throw Error('Invalid parent row ID!');
                }
                this.summaryService.clearSummaryCache({ rowID: parentRecord.rowID });
                if (this.primaryKey && this.foreignKey) {
                    data[this.foreignKey] = parentRowID;
                    _super.prototype.addRow.call(this, data);
                }
                else {
                    var parentData = parentRecord.data;
                    var childKey = this.childDataKey;
                    if (this.transactions.enabled) {
                        var rowId = this.primaryKey ? data[this.primaryKey] : data;
                        var path = [];
                        path.push.apply(path, __spread(this.generateRowPath(parentRowID)));
                        path.push(parentRowID);
                        this.transactions.add({
                            id: rowId,
                            path: path,
                            newValue: data,
                            type: exports.TransactionType.ADD
                        }, null);
                    }
                    else {
                        if (!parentData[childKey]) {
                            parentData[childKey] = [];
                        }
                        parentData[childKey].push(data);
                    }
                    this.onRowAdded.emit({ data: data });
                    this._pipeTrigger++;
                    this.notifyChanges();
                }
            }
            else {
                if (this.primaryKey && this.foreignKey) {
                    var rowID = data[this.foreignKey];
                    this.summaryService.clearSummaryCache({ rowID: rowID });
                }
                _super.prototype.addRow.call(this, data);
            }
        };
        /** @hidden */
        IgxTreeGridComponent.prototype.deleteRowById = function (rowId) {
            //  if this is flat self-referencing data, and CascadeOnDelete is set to true
            //  and if we have transactions we should start pending transaction. This allows
            //  us in case of delete action to delete all child rows as single undo action
            this._gridAPI.deleteRowById(rowId);
        };
        /** @hidden */
        IgxTreeGridComponent.prototype.generateRowPath = function (rowId) {
            var path = [];
            var record = this.records.get(rowId);
            while (record.parent) {
                path.push(record.parent.rowID);
                record = record.parent;
            }
            return path.reverse();
        };
        /**
         * @hidden @internal
         */
        IgxTreeGridComponent.prototype.getDataBasedBodyHeight = function () {
            return !this.flatData || (this.flatData.length < this._defaultTargetRecordNumber) ?
                0 : this.defaultTargetBodyHeight;
        };
        /**
         * @hidden
         */
        IgxTreeGridComponent.prototype.scrollTo = function (row, column) {
            var _this = this;
            var delayScrolling = false;
            var record;
            if (typeof (row) !== 'number') {
                var rowData = row;
                var rowID = this._gridAPI.get_row_id(rowData);
                record = this.processedRecords.get(rowID);
                this._gridAPI.expand_path_to_record(record);
                if (this.paging) {
                    var rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                    var page = Math.floor(rowIndex / this.perPage);
                    if (this.page !== page) {
                        delayScrolling = true;
                        this.page = page;
                    }
                }
            }
            if (delayScrolling) {
                this.verticalScrollContainer.onDataChanged.pipe(operators.first()).subscribe(function () {
                    _this.scrollDirective(_this.verticalScrollContainer, typeof (row) === 'number' ? row : _this.dataView.indexOf(record));
                });
            }
            else {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.dataView.indexOf(record));
            }
            this.scrollToHorizontally(column);
        };
        /**
        * @hidden
        */
        IgxTreeGridComponent.prototype.getContext = function (rowData, rowIndex) {
            return {
                $implicit: rowData,
                index: rowIndex,
                templateID: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
            };
        };
        /**
         * @inheritdoc
         */
        IgxTreeGridComponent.prototype.getSelectedData = function (formatters, headers) {
            if (formatters === void 0) { formatters = false; }
            if (headers === void 0) { headers = false; }
            var source = [];
            var process = function (record) {
                if (record.summaries) {
                    source.push(null);
                    return;
                }
                source.push(record.data);
            };
            this.dataView.forEach(process);
            return this.extractDataFromSelection(source, formatters, headers);
        };
        Object.defineProperty(IgxTreeGridComponent.prototype, "template", {
            /**
            * @hidden
            */
            get: function () {
                if (this.filteredData && this.filteredData.length === 0) {
                    return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
                }
                if (this.isLoading && (!this.data || this.dataLength === 0)) {
                    return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
                }
                if (this.dataLength === 0) {
                    return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxTreeGridComponent.prototype.writeToData = function (rowIndex, value) {
            mergeObjects(this.flatData[rowIndex], value);
        };
        /**
         * @hidden
        */
        IgxTreeGridComponent.prototype.initColumns = function (collection, cb) {
            if (cb === void 0) { cb = null; }
            if (this.hasColumnLayouts) {
                // invalid configuration - tree grid should not allow column layouts
                // remove column layouts
                var nonColumnLayoutColumns = this.columnList.filter(function (col) { return !col.columnLayout && !col.columnLayoutChild; });
                this.columnList.reset(nonColumnLayoutColumns);
            }
            _super.prototype.initColumns.call(this, collection, cb);
        };
        var IgxTreeGridComponent_1;
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxTreeGridComponent.prototype, "id", null);
        __decorate([
            core.Input()
        ], IgxTreeGridComponent.prototype, "data", null);
        __decorate([
            core.Input()
        ], IgxTreeGridComponent.prototype, "childDataKey", void 0);
        __decorate([
            core.Input()
        ], IgxTreeGridComponent.prototype, "foreignKey", void 0);
        __decorate([
            core.Input()
        ], IgxTreeGridComponent.prototype, "hasChildrenKey", void 0);
        __decorate([
            core.Input()
        ], IgxTreeGridComponent.prototype, "cascadeOnDelete", void 0);
        __decorate([
            core.Input()
        ], IgxTreeGridComponent.prototype, "expansionDepth", null);
        __decorate([
            core.ContentChild(IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective })
        ], IgxTreeGridComponent.prototype, "rowLoadingTemplate", void 0);
        __decorate([
            core.Input()
        ], IgxTreeGridComponent.prototype, "rowLoadingIndicatorTemplate", null);
        __decorate([
            core.Input()
        ], IgxTreeGridComponent.prototype, "loadChildrenOnDemand", void 0);
        __decorate([
            core.ViewChild('dragIndicatorIconBase', { read: core.TemplateRef, static: true })
        ], IgxTreeGridComponent.prototype, "dragIndicatorIconBase", void 0);
        IgxTreeGridComponent = IgxTreeGridComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-tree-grid',
                template: "<igx-grid-toolbar role=\"rowgroup\" [style.max-width.px]='outerWidth' [style.flex-basis.px]='outerWidth' *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]=\"'calcPixelWidth'\" #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)'\n        (wheel)=\"wheelHandler()\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData\n            [igxGridForOf]=\"data\n        | treeGridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:id:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:sortStrategy:id:pipeTrigger\n        | treeGridFlattening:id:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:page:perPage:id:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\" let-rowIndex=\"index\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer\n            (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #record_template>\n                <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" #row>\n                </igx-tree-grid-row>\n            </ng-template>\n            <ng-template #summary_template>\n                <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                    [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                    class=\"igx-grid__summaries--body\" #summaryRow>\n                </igx-grid-summary-row>\n            </ng-template>\n\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onBeforeViewDetach)='viewDetachHandler($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"processedExpandedFlatData.length\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [readonly]=\"true\"\n            disableRipple=\"true\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n",
                providers: [
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    IgxGridSummaryService,
                    { provide: IgxGridNavigationService, useClass: IgxTreeGridNavigationService },
                    { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: core.forwardRef(function () { return IgxTreeGridComponent_1; }) },
                    IgxFilteringService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService,
                    IgxRowIslandAPIService
                ]
            })
        ], IgxTreeGridComponent);
        return IgxTreeGridComponent;
    }(IgxGridBaseDirective));

    var IgxTreeGridRowComponent = /** @class */ (function (_super) {
        __extends(IgxTreeGridRowComponent, _super);
        function IgxTreeGridRowComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxTreeGridRowComponent_1 = IgxTreeGridRowComponent;
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "treeRow", {
            /**
             * The `ITreeGridRecord` passed to the row component.
             *
             * ```typescript
             * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
             * const treeRow = row.treeRow;
             * ```
             */
            get: function () {
                return this._treeRow;
            },
            set: function (value) {
                if (this._treeRow !== value) {
                    this._treeRow = value;
                    this.rowData = this._treeRow.data;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "expanded", {
            /**
             * Returns a value indicating whether the row component is expanded.
             *
             * ```typescript
             * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
             * const expanded = row.expanded;
             * ```
             */
            get: function () {
                return this._treeRow.expanded;
            },
            /**
             * Sets a value indicating whether the row component is expanded.
             *
             * ```typescript
             * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
             * row.expanded = true;
             * ```
             */
            set: function (value) {
                this.gridAPI.set_row_expansion_state(this._treeRow.rowID, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "viewIndex", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                return this.index + this.grid.page * this.grid.perPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTreeGridRowComponent.prototype, "showIndicator", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid.loadChildrenOnDemand ?
                    this.grid.expansionStates.has(this.rowID) ?
                        this.treeRow.children && this.treeRow.children.length :
                        this.grid.hasChildrenKey ?
                            this.rowData[this.grid.hasChildrenKey] :
                            true :
                    this.treeRow.children && this.treeRow.children.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTreeGridRowComponent.prototype.resolveClasses = function () {
            var classes = _super.prototype.resolveClasses.call(this);
            var filteredClass = this.treeRow.isFilteredOutParent ? 'igx-grid__tr--filtered' : '';
            return classes + " " + filteredClass;
        };
        /**
         * @hidden
         */
        IgxTreeGridRowComponent.prototype.ngDoCheck = function () {
            this.isLoading = this.grid.loadChildrenOnDemand ? this.grid.loadingRows.has(this.rowID) : false;
            _super.prototype.ngDoCheck.call(this);
        };
        var IgxTreeGridRowComponent_1;
        __decorate([
            core.ViewChildren('treeCell')
        ], IgxTreeGridRowComponent.prototype, "cells", void 0);
        __decorate([
            core.Input()
        ], IgxTreeGridRowComponent.prototype, "treeRow", null);
        __decorate([
            core.HostBinding('attr.aria-expanded')
        ], IgxTreeGridRowComponent.prototype, "expanded", null);
        IgxTreeGridRowComponent = IgxTreeGridRowComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                selector: 'igx-tree-grid-row',
                template: "<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"pinnedColumns.length > 0\">\n    <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n        <ng-template #cellTemplate>\n            <igx-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [style.min-width]=\"col.width\"\n                [style.max-width]=\"col.width\"\n                [style.flex-basis]=\"col.width\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData[col.field]\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [lastSearchInfo]=\"grid.lastSearchInfo\"\n                [cellSelectionMode]=\"grid.cellSelection\" #treeCell>\n            </igx-grid-cell>\n            </ng-template>\n        <ng-template #treeCellTemplate>\n            <igx-tree-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [level]=\"treeRow.level\"\n                [expanded]=\"treeRow.expanded\"\n                [showIndicator]=\"showIndicator\"\n                [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [style.min-width]=\"col.width\"\n                [style.max-width]=\"col.width\"\n                [style.flex-basis]=\"col.width\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData[col.field]\"\n                [isLoading]=\"isLoading\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [lastSearchInfo]=\"grid.lastSearchInfo\"\n                [cellSelectionMode]=\"grid.cellSelection\"  #treeCell>\n            </igx-tree-grid-cell>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n    </ng-template>\n</ng-container>\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]=\"'calcPixelWidth'\" [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <ng-template #cellTemplate>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [cellSelectionMode]=\"grid.cellSelection\"  #treeCell>\n        </igx-grid-cell>\n    </ng-template>\n    <ng-template #treeCellTemplate>\n        <igx-tree-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [level]=\"treeRow.level\"\n            [expanded]=\"treeRow.expanded\"\n            [showIndicator]=\"showIndicator\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [isLoading]=\"isLoading\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [cellSelectionMode]=\"grid.cellSelection\"  #treeCell>\n        </igx-tree-grid-cell>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n</ng-template>\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n",
                providers: [{ provide: IgxRowDirective, useExisting: core.forwardRef(function () { return IgxTreeGridRowComponent_1; }) }]
            })
        ], IgxTreeGridRowComponent);
        return IgxTreeGridRowComponent;
    }(IgxRowDirective));

    /**
     *@hidden
     */
    var IgxTreeGridHierarchizingPipe = /** @class */ (function () {
        function IgxTreeGridHierarchizingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridHierarchizingPipe.prototype.transform = function (collection, primaryKey, foreignKey, childDataKey, id, pipeTrigger) {
            var grid = this.gridAPI.grid;
            var hierarchicalRecords = [];
            var treeGridRecordsMap = new Map();
            var flatData = [];
            if (primaryKey && foreignKey) {
                hierarchicalRecords = this.hierarchizeFlatData(id, collection, primaryKey, foreignKey, treeGridRecordsMap, flatData);
            }
            else if (childDataKey) {
                hierarchicalRecords = this.hierarchizeRecursive(id, collection, primaryKey, childDataKey, undefined, flatData, 0, treeGridRecordsMap);
            }
            grid.flatData = flatData;
            grid.records = treeGridRecordsMap;
            grid.rootRecords = hierarchicalRecords;
            return hierarchicalRecords;
        };
        IgxTreeGridHierarchizingPipe.prototype.getRowID = function (primaryKey, rowData) {
            return primaryKey ? rowData[primaryKey] : rowData;
        };
        IgxTreeGridHierarchizingPipe.prototype.hierarchizeFlatData = function (id, collection, primaryKey, foreignKey, map, flatData) {
            var _this = this;
            var result = [];
            var missingParentRecords = [];
            collection.forEach(function (row) {
                var record = {
                    rowID: _this.getRowID(primaryKey, row),
                    data: row,
                    children: []
                };
                var parent = map.get(row[foreignKey]);
                if (parent) {
                    record.parent = parent;
                    parent.children.push(record);
                }
                else {
                    missingParentRecords.push(record);
                }
                map.set(row[primaryKey], record);
            });
            missingParentRecords.forEach(function (record) {
                var parent = map.get(record.data[foreignKey]);
                if (parent) {
                    record.parent = parent;
                    parent.children.push(record);
                }
                else {
                    result.push(record);
                }
            });
            this.setIndentationLevels(id, result, 0, flatData);
            return result;
        };
        IgxTreeGridHierarchizingPipe.prototype.setIndentationLevels = function (id, collection, indentationLevel, flatData) {
            for (var i = 0; i < collection.length; i++) {
                var record = collection[i];
                record.level = indentationLevel;
                record.expanded = this.gridAPI.get_row_expansion_state(record);
                flatData.push(record.data);
                if (record.children && record.children.length > 0) {
                    this.setIndentationLevels(id, record.children, indentationLevel + 1, flatData);
                }
            }
        };
        IgxTreeGridHierarchizingPipe.prototype.hierarchizeRecursive = function (id, collection, primaryKey, childDataKey, parent, flatData, indentationLevel, map) {
            var result = [];
            for (var i = 0; i < collection.length; i++) {
                var item = collection[i];
                var record = {
                    rowID: this.getRowID(primaryKey, item),
                    data: item,
                    parent: parent,
                    level: indentationLevel
                };
                record.expanded = this.gridAPI.get_row_expansion_state(record);
                flatData.push(item);
                map.set(record.rowID, record);
                record.children = item[childDataKey] ?
                    this.hierarchizeRecursive(id, item[childDataKey], primaryKey, childDataKey, record, flatData, indentationLevel + 1, map) :
                    undefined;
                result.push(record);
            }
            return result;
        };
        IgxTreeGridHierarchizingPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxTreeGridHierarchizingPipe = __decorate([
            core.Pipe({
                name: 'treeGridHierarchizing',
                pure: true
            })
        ], IgxTreeGridHierarchizingPipe);
        return IgxTreeGridHierarchizingPipe;
    }());
    /**
     *@hidden
     */
    var IgxTreeGridFlatteningPipe = /** @class */ (function () {
        function IgxTreeGridFlatteningPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridFlatteningPipe.prototype.transform = function (collection, id, expandedLevels, expandedStates, pipeTrigger) {
            var grid = this.gridAPI.grid;
            var data = [];
            grid.processedRootRecords = collection;
            grid.processedRecords = new Map();
            this.getFlatDataRecursive(collection, data, expandedLevels, expandedStates, id, true);
            grid.processedExpandedFlatData = data.map(function (r) { return r.data; });
            return data;
        };
        IgxTreeGridFlatteningPipe.prototype.getFlatDataRecursive = function (collection, data, expandedLevels, expandedStates, gridID, parentExpanded) {
            if (!collection || !collection.length) {
                return;
            }
            var grid = this.gridAPI.grid;
            for (var i = 0; i < collection.length; i++) {
                var hierarchicalRecord = collection[i];
                if (parentExpanded) {
                    data.push(hierarchicalRecord);
                }
                hierarchicalRecord.expanded = this.gridAPI.get_row_expansion_state(hierarchicalRecord);
                this.updateNonProcessedRecordExpansion(grid, hierarchicalRecord);
                grid.processedRecords.set(hierarchicalRecord.rowID, hierarchicalRecord);
                this.getFlatDataRecursive(hierarchicalRecord.children, data, expandedLevels, expandedStates, gridID, parentExpanded && hierarchicalRecord.expanded);
            }
        };
        IgxTreeGridFlatteningPipe.prototype.updateNonProcessedRecordExpansion = function (grid, record) {
            var rec = grid.records.get(record.rowID);
            rec.expanded = record.expanded;
        };
        IgxTreeGridFlatteningPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxTreeGridFlatteningPipe = __decorate([
            core.Pipe({
                name: 'treeGridFlattening',
                pure: true
            })
        ], IgxTreeGridFlatteningPipe);
        return IgxTreeGridFlatteningPipe;
    }());
    /** @hidden */
    var IgxTreeGridSortingPipe = /** @class */ (function () {
        function IgxTreeGridSortingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridSortingPipe.prototype.transform = function (hierarchicalData, expressions, sorting, id, pipeTrigger) {
            var grid = this.gridAPI.grid;
            var result;
            if (!expressions.length) {
                result = hierarchicalData;
            }
            else {
                result = DataUtil.treeGridSort(hierarchicalData, expressions, sorting);
            }
            var filteredSortedData = [];
            this.flattenTreeGridRecords(result, filteredSortedData);
            grid.filteredSortedData = filteredSortedData;
            return result;
        };
        IgxTreeGridSortingPipe.prototype.flattenTreeGridRecords = function (records, flatData) {
            var e_1, _a;
            if (records && records.length) {
                try {
                    for (var records_1 = __values(records), records_1_1 = records_1.next(); !records_1_1.done; records_1_1 = records_1.next()) {
                        var record = records_1_1.value;
                        flatData.push(record.data);
                        this.flattenTreeGridRecords(record.children, flatData);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (records_1_1 && !records_1_1.done && (_a = records_1.return)) _a.call(records_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        };
        IgxTreeGridSortingPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxTreeGridSortingPipe = __decorate([
            core.Pipe({
                name: 'treeGridSorting',
                pure: true
            })
        ], IgxTreeGridSortingPipe);
        return IgxTreeGridSortingPipe;
    }());
    /** @hidden */
    var IgxTreeGridPagingPipe = /** @class */ (function () {
        function IgxTreeGridPagingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridPagingPipe.prototype.transform = function (collection, page, perPage, id, pipeTrigger) {
            if (page === void 0) { page = 0; }
            if (perPage === void 0) { perPage = 15; }
            var grid = this.gridAPI.grid;
            if (!grid.paging) {
                return collection;
            }
            var len = collection.length;
            var totalPages = Math.ceil(len / perPage);
            var state = {
                index: (totalPages > 0 && page >= totalPages) ? totalPages - 1 : page,
                recordsPerPage: perPage
            };
            var result = DataUtil.page(cloneArray(collection), state);
            grid.pagingState = state;
            grid._page = state.index;
            return result;
        };
        IgxTreeGridPagingPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxTreeGridPagingPipe = __decorate([
            core.Pipe({
                name: 'treeGridPaging',
                pure: true
            })
        ], IgxTreeGridPagingPipe);
        return IgxTreeGridPagingPipe;
    }());
    /** @hidden */
    var IgxTreeGridTransactionPipe = /** @class */ (function () {
        function IgxTreeGridTransactionPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridTransactionPipe.prototype.transform = function (collection, id, pipeTrigger) {
            var grid = this.gridAPI.grid;
            if (grid.transactions.enabled) {
                var aggregatedChanges = grid.transactions.getAggregatedChanges(true);
                if (aggregatedChanges.length > 0) {
                    var primaryKey = grid.primaryKey;
                    if (!primaryKey) {
                        return collection;
                    }
                    var foreignKey = grid.foreignKey;
                    var childDataKey = grid.childDataKey;
                    if (foreignKey) {
                        var flatDataClone = cloneArray(collection);
                        return DataUtil.mergeTransactions(flatDataClone, aggregatedChanges, grid.primaryKey);
                    }
                    else if (childDataKey) {
                        var hierarchicalDataClone = cloneHierarchicalArray(collection, childDataKey);
                        return DataUtil.mergeHierarchicalTransactions(hierarchicalDataClone, aggregatedChanges, childDataKey, grid.primaryKey);
                    }
                }
            }
            return collection;
        };
        IgxTreeGridTransactionPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxTreeGridTransactionPipe = __decorate([
            core.Pipe({
                name: 'treeGridTransaction',
                pure: true
            })
        ], IgxTreeGridTransactionPipe);
        return IgxTreeGridTransactionPipe;
    }());

    var IgxTreeGridCellComponent = /** @class */ (function (_super) {
        __extends(IgxTreeGridCellComponent, _super);
        function IgxTreeGridCellComponent(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
            var _this = _super.call(this, selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) || this;
            _this.zone = zone;
            _this.document = document;
            _this.platformUtil = platformUtil;
            /**
             * @hidden
             */
            _this.level = 0;
            /**
             * @hidden
             */
            _this.showIndicator = false;
            _this.treeGridAPI = gridAPI;
            return _this;
        }
        /**
         * @hidden
         */
        IgxTreeGridCellComponent.prototype.toggle = function (event) {
            event.stopPropagation();
            this.treeGridAPI.set_row_expansion_state(this.row.rowID, !this.row.expanded, event);
        };
        /**
         * @hidden
         */
        IgxTreeGridCellComponent.prototype.onLoadingDblClick = function (event) {
            event.stopPropagation();
        };
        IgxTreeGridCellComponent.ctorParameters = function () { return [
            { type: IgxGridSelectionService },
            { type: IgxGridCRUDService },
            { type: GridBaseAPIService },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: HammerGesturesManager },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: PlatformUtil }
        ]; };
        __decorate([
            core.Input()
        ], IgxTreeGridCellComponent.prototype, "level", void 0);
        __decorate([
            core.Input()
        ], IgxTreeGridCellComponent.prototype, "showIndicator", void 0);
        __decorate([
            core.Input()
        ], IgxTreeGridCellComponent.prototype, "isLoading", void 0);
        IgxTreeGridCellComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                selector: 'igx-tree-grid-cell',
                template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!editMode\">\n    <ng-container *ngIf=\"level > 0\">\n        <div #indentationDiv class=\"igx-grid__tree-cell--padding-level-{{level}}\"></div>\n    </ng-container>\n    <div #indicator\n         *ngIf=\"!isLoading\"\n         class=\"igx-grid__tree-grouping-indicator\"\n         [ngStyle]=\"{'visibility': showIndicator ? 'visible' : 'hidden'}\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\" tabindex=\"-1\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n    <div *ngIf=\"isLoading\"\n         (dblclick)=\"onLoadingDblClick($event)\"\n         class=\"igx-grid__tree-loading-indicator\">\n        <ng-container *ngTemplateOutlet=\"grid.rowLoadingIndicatorTemplate ? grid.rowLoadingIndicatorTemplate : defaultLoadingIndicatorTemplate\">\n        </ng-container>\n    </div>\n    <ng-template #defaultLoadingIndicatorTemplate>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </ng-template>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
                providers: [HammerGesturesManager]
            }),
            __param(7, core.Inject(common.DOCUMENT))
        ], IgxTreeGridCellComponent);
        return IgxTreeGridCellComponent;
    }(IgxGridExpandableCellComponent));

    /** @hidden */
    var IgxTreeGridSummaryPipe = /** @class */ (function () {
        function IgxTreeGridSummaryPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxTreeGridSummaryPipe.prototype.transform = function (flatData, hasSummary, summaryCalculationMode, summaryPosition, id, pipeTrigger, summaryPipeTrigger) {
            var grid = this.gridAPI.grid;
            if (!flatData || !hasSummary || summaryCalculationMode === exports.GridSummaryCalculationMode.rootLevelOnly) {
                return flatData;
            }
            return this.addSummaryRows(grid, flatData, summaryPosition);
        };
        IgxTreeGridSummaryPipe.prototype.addSummaryRows = function (grid, collection, summaryPosition) {
            var recordsWithSummary = [];
            var maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
            for (var i = 0; i < collection.length; i++) {
                var record = collection[i];
                recordsWithSummary.push(record);
                var isExpanded = record.children && record.children.length > 0 && record.expanded;
                if (summaryPosition === exports.GridSummaryPosition.bottom && !isExpanded) {
                    var childRecord = record;
                    var parent_1 = record.parent;
                    while (parent_1) {
                        var children = parent_1.children;
                        if (children[children.length - 1] === childRecord) {
                            var childData = children.filter(function (r) { return !r.isFilteredOutParent; }).map(function (r) { return r.data; });
                            childData = this.removeDeletedRecord(grid, parent_1.rowID, childData);
                            var summaries = grid.summaryService.calculateSummaries(parent_1.rowID, childData);
                            var summaryRecord = {
                                summaries: summaries,
                                max: maxSummaryHeight,
                                cellIndentation: parent_1.level + 1
                            };
                            recordsWithSummary.push(summaryRecord);
                            childRecord = parent_1;
                            parent_1 = childRecord.parent;
                        }
                        else {
                            break;
                        }
                    }
                }
                else if (summaryPosition === exports.GridSummaryPosition.top && isExpanded) {
                    var childData = record.children.filter(function (r) { return !r.isFilteredOutParent; }).map(function (r) { return r.data; });
                    childData = this.removeDeletedRecord(grid, record.rowID, childData);
                    var summaries = grid.summaryService.calculateSummaries(record.rowID, childData);
                    var summaryRecord = {
                        summaries: summaries,
                        max: maxSummaryHeight,
                        cellIndentation: record.level + 1
                    };
                    recordsWithSummary.push(summaryRecord);
                }
            }
            return recordsWithSummary;
        };
        IgxTreeGridSummaryPipe.prototype.removeDeletedRecord = function (grid, rowId, data) {
            if (!grid.transactions.enabled || !grid.cascadeOnDelete) {
                return data;
            }
            var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === 'delete'; }).map(function (t) { return t.id; });
            var row = grid.records.get(rowId);
            if (!row && deletedRows.lenght === 0) {
                return [];
            }
            row = row.children ? row : row.parent;
            while (row) {
                rowId = row.rowID;
                if (deletedRows.indexOf(rowId) !== -1) {
                    return [];
                }
                row = row.parent;
            }
            deletedRows.forEach(function (rowID) {
                var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
                var index = tempData.indexOf(rowID);
                if (index !== -1) {
                    data.splice(index, 1);
                }
            });
            return data;
        };
        IgxTreeGridSummaryPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxTreeGridSummaryPipe = __decorate([
            core.Pipe({
                name: 'treeGridSummary',
                pure: true
            })
        ], IgxTreeGridSummaryPipe);
        return IgxTreeGridSummaryPipe;
    }());

    /**
     * @hidden
     */
    var IgxTreeGridModule = /** @class */ (function () {
        function IgxTreeGridModule() {
        }
        IgxTreeGridModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxTreeGridComponent,
                    IgxTreeGridRowComponent,
                    IgxTreeGridCellComponent,
                    IgxTreeGridHierarchizingPipe,
                    IgxTreeGridFlatteningPipe,
                    IgxTreeGridSortingPipe,
                    IgxTreeGridFilteringPipe,
                    IgxTreeGridPagingPipe,
                    IgxTreeGridTransactionPipe,
                    IgxTreeGridSummaryPipe,
                    IgxRowLoadingIndicatorTemplateDirective
                ],
                exports: [
                    IgxTreeGridComponent,
                    IgxTreeGridRowComponent,
                    IgxTreeGridCellComponent,
                    IgxRowLoadingIndicatorTemplateDirective,
                    IgxGridCommonModule
                ],
                imports: [
                    IgxGridCommonModule,
                ]
            })
        ], IgxTreeGridModule);
        return IgxTreeGridModule;
    }());

    var IgxHierarchicalGridNavigationService = /** @class */ (function (_super) {
        __extends(IgxHierarchicalGridNavigationService, _super);
        function IgxHierarchicalGridNavigationService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxHierarchicalGridNavigationService.prototype.getCellSelector = function (visibleIndex, isSummary) {
            if (isSummary === void 0) { isSummary = false; }
            return isSummary ? 'igx-grid-summary-cell' : 'igx-hierarchical-grid-cell';
        };
        IgxHierarchicalGridNavigationService.prototype.getRowSelector = function () {
            return 'igx-hierarchical-grid-row';
        };
        IgxHierarchicalGridNavigationService.prototype.getRowByIndex = function (index) {
            var row = _super.prototype.getRowByIndex.call(this, index);
            return row;
        };
        IgxHierarchicalGridNavigationService.prototype.getChildContainer = function (grid) {
            var currGrid = grid || this.grid;
            return currGrid.nativeElement.parentNode.parentNode.parentNode;
        };
        IgxHierarchicalGridNavigationService.prototype.getChildGridRowContainer = function (grid) {
            var currGrid = grid || this.grid;
            return currGrid.nativeElement.parentNode.parentNode;
        };
        IgxHierarchicalGridNavigationService.prototype.getChildGrid = function (childGridID, grid) {
            var cgrid = grid.hgridAPI.getChildGrids(true).filter(function (g) { return g.id === childGridID; })[0];
            return cgrid;
        };
        IgxHierarchicalGridNavigationService.prototype._isScrolledToBottom = function (grid) {
            var scrollTop = grid.verticalScrollContainer.scrollPosition;
            var scrollHeight = grid.verticalScrollContainer.getScroll().scrollHeight;
            return scrollHeight === 0 || Math.round(scrollTop + grid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        };
        IgxHierarchicalGridNavigationService.prototype.getIsChildAtIndex = function (index) {
            return this.grid.isChildGridRecord(this.grid.dataView[index]);
        };
        IgxHierarchicalGridNavigationService.prototype.getCellElementByVisibleIndex = function (rowIndex, visibleColumnIndex, isSummary) {
            if (isSummary === void 0) { isSummary = false; }
            var cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
            if (isSummary) {
                var summaryRow = this.grid.summariesRowList.toArray()[0].nativeElement;
                return summaryRow.querySelector(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
            }
            var row = this.getRowByIndex(rowIndex);
            return row.querySelector(cellSelector + "[data-rowindex=\"" + rowIndex + "\"][data-visibleIndex=\"" + visibleColumnIndex + "\"]");
        };
        IgxHierarchicalGridNavigationService.prototype.navigateUp = function (rowElement, selectedNode) {
            var _this = this;
            if (selectedNode.isSummaryRow) {
                return;
            }
            var prevElem = rowElement.previousElementSibling;
            var visibleColumnIndex = selectedNode.column;
            var currentRowIndex = selectedNode.row;
            if (prevElem) {
                var nodeName = prevElem.children[0].nodeName.toLowerCase();
                var isElemChildGrid = nodeName.toLowerCase() === 'igx-child-grid-row';
                if (isElemChildGrid) {
                    this.focusPrevChild(prevElem, visibleColumnIndex, this.grid);
                }
                else {
                    if (this.grid.parent !== null) {
                        // currently navigating in child grid
                        this._navigateUpInChild(rowElement, currentRowIndex, visibleColumnIndex);
                    }
                    else {
                        _super.prototype.navigateUp.call(this, rowElement, selectedNode);
                    }
                }
            }
            else if (currentRowIndex !== 0) {
                // handle scenario when prev item is child grid but is not yet in view
                var isPrevChildGrid = this.getIsChildAtIndex(currentRowIndex - 1);
                if (!isPrevChildGrid) {
                    _super.prototype.navigateUp.call(this, rowElement, selectedNode);
                }
                else {
                    this.scrollGrid(this.grid, -rowElement.offsetHeight, function () {
                        rowElement = _this.getRowByIndex(currentRowIndex);
                        _this.navigateUp(rowElement, selectedNode);
                    });
                }
            }
            else if (this.grid.parent !== null &&
                currentRowIndex === 0) {
                // move to prev row in sibling layout or parent
                this.focusPrev(visibleColumnIndex);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.navigateDown = function (rowElement, selectedNode) {
            if (selectedNode.isSummaryRow) {
                return;
            }
            var nextElem = rowElement.nextElementSibling;
            var visibleColumnIndex = selectedNode.column;
            var currentRowIndex = selectedNode.row;
            if (nextElem) {
                // next elem is in DOM
                var nodeName = nextElem.children[0].nodeName.toLowerCase();
                var isNextElemChildGrid = nodeName.toLowerCase() === 'igx-child-grid-row';
                if (isNextElemChildGrid) {
                    this.focusNextChild(nextElem, visibleColumnIndex, this.grid);
                }
                else {
                    if (this.grid.parent !== null) {
                        // currently navigating in child grid
                        this._navigateDownInChild(rowElement, currentRowIndex, visibleColumnIndex);
                    }
                    else {
                        _super.prototype.navigateDown.call(this, rowElement, selectedNode);
                    }
                }
            }
            else if (currentRowIndex !== this.grid.dataView.length - 1) {
                // scroll next in view
                _super.prototype.navigateDown.call(this, rowElement, selectedNode);
            }
            else if (this.grid.parent !== null &&
                currentRowIndex === this.grid.dataView.length - 1) {
                // move to next row in sibling layout or in parent
                this.focusNext(visibleColumnIndex);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.navigateTop = function (visibleColumnIndex) {
            var _this = this;
            if (this.grid.parent !== null) {
                // navigating in child
                var childContainer = this.grid.nativeElement.parentNode.parentNode;
                var diff = childContainer.getBoundingClientRect().top - this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top;
                var topIsVisible = diff >= 0;
                var scrollable = this.getNextScrollable(this.grid);
                if (!topIsVisible) {
                    this.scrollGrid(scrollable.grid, diff, function () { return _super.prototype.navigateTop.call(_this, visibleColumnIndex); });
                }
                else {
                    _super.prototype.navigateTop.call(this, visibleColumnIndex);
                }
            }
            else {
                _super.prototype.navigateTop.call(this, visibleColumnIndex);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.navigateBottom = function (visibleColumnIndex) {
            var _this = this;
            // handle scenario where last index is child grid
            // in that case focus cell in last data row
            var lastIndex = this.grid.dataView.length - 1;
            if (this.getIsChildAtIndex(lastIndex)) {
                var targetIndex_1 = lastIndex - 1;
                var scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex_1, true);
                var verticalScrollTop = this.grid.verticalScrollContainer.scrollPosition;
                var cellSelector_1 = this.getCellSelector(visibleColumnIndex);
                if (verticalScrollTop === scrTopPosition) {
                    var cells = this.getRowByIndex(targetIndex_1).querySelectorAll(cellSelector_1 + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                    cells[cells.length - 1].focus();
                }
                else {
                    this.scrollGrid(this.grid, scrTopPosition - verticalScrollTop, function () {
                        var cells = _this.getRowByIndex(targetIndex_1).querySelectorAll(cellSelector_1 + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                        if (cells.length > 0) {
                            cells[cells.length - 1].focus();
                        }
                    });
                }
            }
            else if (this.grid.parent !== null) {
                var childContainer = this.grid.nativeElement.parentNode.parentNode;
                var diff = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;
                var endIsVisible = diff < 0;
                var scrollable = this.getNextScrollableDown(this.grid);
                if (!endIsVisible) {
                    this.scrollGrid(scrollable.grid, diff, function () { return _super.prototype.navigateBottom.call(_this, visibleColumnIndex); });
                }
                else {
                    _super.prototype.navigateBottom.call(this, visibleColumnIndex);
                }
            }
            else {
                _super.prototype.navigateBottom.call(this, visibleColumnIndex);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.goToLastCell = function () {
            var _this = this;
            // handle scenario where last index is child grid
            // in that case focus last cell in last data row
            var lastIndex = this.grid.dataView.length - 1;
            if (this.getIsChildAtIndex(lastIndex)) {
                var targetIndex_2 = lastIndex - 1;
                var scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex_2, true);
                var verticalScrollTop = this.grid.verticalScrollContainer.scrollPosition;
                if (verticalScrollTop === scrTopPosition) {
                    this.onKeydownEnd(targetIndex_2);
                }
                else {
                    this.scrollGrid(this.grid, scrTopPosition - verticalScrollTop, function () {
                        _this.onKeydownEnd(targetIndex_2);
                    });
                }
            }
            else {
                _super.prototype.goToLastCell.call(this);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.onKeydownEnd = function (rowIndex, isSummary) {
            var _this = this;
            if (isSummary === void 0) { isSummary = false; }
            if (this.grid.parent && !isSummary) {
                // handle scenario where last child row might not be in view
                // parent should scroll to child grid end
                var childContainer = this.grid.nativeElement.parentNode.parentNode;
                var diffBottom = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.nativeElement.getBoundingClientRect().bottom;
                var row = this.grid.getRowByIndex(rowIndex).element.nativeElement;
                var rowBottom = row.getBoundingClientRect().bottom;
                var rowIsVisible = rowBottom <= this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;
                var gridTop = this._getMaxTop(this.grid);
                var diffTop = row.getBoundingClientRect().bottom -
                    row.offsetHeight - gridTop;
                var endIsVisible = diffBottom <= 0;
                var topVisible = diffTop >= 0;
                if (!endIsVisible && !rowIsVisible) {
                    this.scrollGrid(this.grid.parent, diffBottom, function () { return _super.prototype.onKeydownEnd.call(_this, rowIndex); });
                }
                else if (!topVisible) {
                    var scrGrid = this.grid.verticalScrollContainer.scrollPosition !== 0 ? this.grid :
                        this.getNextScrollable(this.grid).grid;
                    var topGrid = scrGrid.tbody.nativeElement.getBoundingClientRect().top >
                        this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top ? scrGrid : this.grid.rootGrid;
                    this.scrollGrid(topGrid, diffTop, function () { return _super.prototype.onKeydownEnd.call(_this, rowIndex); });
                }
                else {
                    _super.prototype.onKeydownEnd.call(this, rowIndex, isSummary);
                }
            }
            else {
                _super.prototype.onKeydownEnd.call(this, rowIndex, isSummary);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.goToFirstCell = function () {
            var _this = this;
            var verticalScroll = this.grid.verticalScrollContainer.getScroll();
            var horizontalScroll = this.grid.dataRowList.first.virtDirRow.getScroll();
            if (verticalScroll.scrollTop === 0 && this.grid.parent) {
                // scroll parent so that current child is in view
                if (!horizontalScroll.clientWidth || parseInt(horizontalScroll.scrollLeft, 10) <= 1 || this.grid.pinnedColumns.length) {
                    this.navigateTop(0);
                }
                else {
                    this.horizontalScroll(this.grid.dataRowList.first.index).scrollTo(0);
                    this.grid.parentVirtDir.onChunkLoad
                        .pipe(operators.first())
                        .subscribe(function () {
                        _this.navigateTop(0);
                    });
                }
            }
            else {
                _super.prototype.goToFirstCell.call(this);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.performTab = function (currentRowEl, selectedNode) {
            var _this = this;
            if (this.grid.rowInEditMode) {
                _super.prototype.performTab.call(this, currentRowEl, selectedNode);
                return;
            }
            var rowIndex = selectedNode.row;
            var visibleColumnIndex = selectedNode.column;
            var isSummaryRow = selectedNode.isSummaryRow;
            var summaryRows = this.grid.summariesRowList.toArray();
            var hasSummaries = summaryRows.length > 0;
            var isLastDataRow = rowIndex === this.grid.dataView.length - 1;
            var nextIsDataRow = this.grid.dataRowList.find(function (row) { return row.index === rowIndex + 1; });
            var isLastColumn = this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex;
            var isLastSummaryRow = hasSummaries && isSummaryRow;
            var nextIndex = rowIndex + 1;
            var virt = this.grid.verticalScrollContainer;
            var isNextChild = nextIndex <= virt.igxForOf.length - 1 &&
                this.grid.isChildGridRecord(virt.igxForOf[nextIndex]);
            if (!nextIsDataRow && !(isLastDataRow && hasSummaries) && isLastColumn && !isSummaryRow) {
                // navigating in child, next is not summary
                var childContainer = this.getChildGridRowContainer();
                var nextIsSiblingChild = this.grid.parent ? !!childContainer.nextElementSibling : false;
                if (nextIsSiblingChild) {
                    this.focusNextChildDOMElem(childContainer, this.grid.parent);
                }
                else if (isNextChild) {
                    var isInView = virt.state.startIndex + virt.state.chunkSize > nextIndex;
                    if (!isInView) {
                        this.scrollGrid(this.grid, 'next', function () {
                            _this.focusNextChildDOMElem(currentRowEl, _this.grid);
                        });
                    }
                    else {
                        this.focusNextChildDOMElem(currentRowEl, this.grid);
                    }
                }
                else if (this.grid.parent && this.grid.parent.summariesRowList.length > 0) {
                    this._navigateToNextParentRow(currentRowEl);
                }
                else {
                    this.navigateDown(currentRowEl, { row: rowIndex, column: 0 });
                }
            }
            else if (isLastSummaryRow && isLastColumn && this.grid.parent) {
                this._navigateToNextParentRow(currentRowEl);
            }
            else if (isLastDataRow && hasSummaries && isLastColumn && this.grid.parent) {
                // navigating in child rows, next is child grid's summary row
                this.focusNextRow(summaryRows[0].nativeElement, 0, this.grid.parent, true);
            }
            else {
                _super.prototype.performTab.call(this, currentRowEl, selectedNode);
            }
        };
        IgxHierarchicalGridNavigationService.prototype._navigateToNextParentRow = function (currentRowEl) {
            // next is parent summary or next parent row
            var parent = this.grid.parent;
            var parentHasSummary = parent.summariesRowList.length > 0;
            var parentRowIndex = parseInt(this.getClosestElemByTag(currentRowEl, 'igx-child-grid-row').parentNode.getAttribute('data-rowindex'), 10);
            var isLastRowInParent = parent.dataView.length - 1 === parentRowIndex;
            // check if next is sibling
            var childRowContainer = this.getChildGridRowContainer(this.grid);
            var nextIsSiblingChild = !!childRowContainer.nextElementSibling;
            if (isLastRowInParent && parentHasSummary && !nextIsSiblingChild) {
                // next is parent summary
                var parentSummary = parent.summariesRowList.first.nativeElement;
                parent.navigation.focusNextRow(parentSummary, 0, parent, true);
            }
            else {
                // next is sibling or parent
                this.focusNext(0);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.focusNextChildDOMElem = function (currentRowEl, grid) {
            var gridElem = currentRowEl.nextElementSibling.querySelector('igx-hierarchical-grid');
            var childGridID = gridElem.getAttribute('id');
            var childGrid = this.getChildGrid(childGridID, grid);
            if (childGrid.allowFiltering && childGrid.filterMode === exports.FilterMode.quickFilter) {
                childGrid.navigation.moveFocusToFilterCell(true);
                return;
            }
            this.focusNextChild(currentRowEl.nextElementSibling, 0, grid);
        };
        IgxHierarchicalGridNavigationService.prototype.navigatePrevFilterCell = function (column, eventArgs) {
            if (column.visibleIndex === 0 && this.grid.parent) {
                eventArgs.preventDefault();
                var targetGrid = this.grid.parent;
                var prevSiblingChild = this.getChildGridRowContainer().previousElementSibling;
                if (prevSiblingChild) {
                    var gridElem = prevSiblingChild.querySelectorAll('igx-hierarchical-grid')[0];
                    targetGrid = this.getChildGrid(gridElem.getAttribute('id'), this.grid.parent);
                }
                this.focusPrev(targetGrid.unpinnedColumns[targetGrid.unpinnedColumns.length - 1].visibleIndex);
            }
            else {
                _super.prototype.navigatePrevFilterCell.call(this, column, eventArgs);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.navigateNextFilterCell = function (column, eventArgs) {
            var cols = this.grid.filteringService.unpinnedFilterableColumns;
            var nextFilterableIndex = cols.indexOf(column) + 1;
            if (nextFilterableIndex >= this.grid.filteringService.unpinnedFilterableColumns.length) {
                // next is not filter cell
                var dataRows = this.grid.rowList.toArray();
                var hasRows = dataRows.length !== 0;
                var summaryRows = this.grid.summariesRowList.toArray();
                var hasSummaries = summaryRows.length > 0 && summaryRows[0].summaryCells.length > 0;
                if (hasRows) {
                    this.focusNextRow(dataRows[0].nativeElement, 0, this.grid, false);
                }
                else if (hasSummaries) {
                    this.focusNextRow(summaryRows[0].nativeElement, 0, this.grid, true);
                }
                else {
                    this.focusNext(0);
                }
                eventArgs.preventDefault();
            }
            else {
                _super.prototype.navigateNextFilterCell.call(this, column, eventArgs);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.performShiftTabKey = function (currentRowEl, selectedNode) {
            var _this = this;
            if (this.grid.rowInEditMode) {
                _super.prototype.performShiftTabKey.call(this, currentRowEl, selectedNode);
                return;
            }
            var rowIndex = selectedNode.row;
            var visibleColumnIndex = selectedNode.column;
            var isSummary = selectedNode.isSummaryRow;
            if (visibleColumnIndex === 0 && rowIndex === 0 && this.grid.parent && !isSummary) {
                if (this.grid.allowFiltering && this.grid.filterMode === exports.FilterMode.quickFilter) {
                    this.moveFocusToFilterCell();
                }
                else {
                    var prevSiblingChild = this.getChildGridRowContainer().previousElementSibling;
                    if (prevSiblingChild) {
                        var gridElem = prevSiblingChild.querySelectorAll('igx-hierarchical-grid')[0];
                        this.performShiftTabIntoChild(gridElem, currentRowEl, rowIndex);
                    }
                    else {
                        var selNode = {
                            row: rowIndex,
                            column: this.grid.parent.unpinnedColumns[this.grid.parent.unpinnedColumns.length - 1].visibleIndex
                        };
                        this.navigateUp(currentRowEl, selNode);
                    }
                }
            }
            else if (visibleColumnIndex === 0 && currentRowEl.previousElementSibling &&
                currentRowEl.previousElementSibling.children[0].tagName.toLowerCase() === 'igx-child-grid-row') {
                var gridElem = this.getLastGridElem(currentRowEl.previousElementSibling);
                this.performShiftTabIntoChild(gridElem, currentRowEl, rowIndex);
            }
            else if (visibleColumnIndex === 0 && isSummary) {
                var lastRowIndex_1 = this.grid.dataView.length - 1;
                if (lastRowIndex_1 === -1) {
                    // no child data
                    if (this.grid.allowFiltering && this.grid.filterMode === exports.FilterMode.quickFilter) {
                        this.moveFocusToFilterCell();
                    }
                    else {
                        var selNode = {
                            row: rowIndex,
                            column: this.grid.parent.unpinnedColumns[this.grid.parent.unpinnedColumns.length - 1].visibleIndex
                        };
                        this.navigateUp(currentRowEl, selNode);
                    }
                }
                else if (!this.getIsChildAtIndex(lastRowIndex_1)) {
                    _super.prototype.goToLastCell.call(this);
                }
                else {
                    var scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(lastRowIndex_1, true);
                    var verticalScrollTop = this.grid.verticalScrollContainer.scrollPosition;
                    if (verticalScrollTop === scrTopPosition || isNaN(scrTopPosition)) {
                        var closestChild = this.getLastGridElem(this.grid.getRowByIndex(lastRowIndex_1).nativeElement.parentElement);
                        this.performShiftTabIntoChild(closestChild, currentRowEl, rowIndex);
                    }
                    else {
                        this.scrollGrid(this.grid, scrTopPosition - verticalScrollTop, function () {
                            var closestChild = _this.getLastGridElem(_this.grid.getRowByIndex(lastRowIndex_1).nativeElement.parentElement);
                            _this.performShiftTabIntoChild(closestChild, currentRowEl, rowIndex);
                        });
                    }
                }
            }
            else {
                _super.prototype.performShiftTabKey.call(this, currentRowEl, selectedNode);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.getFocusableGrid = function () {
            return (isIE() && this.grid.rootGrid) ? this.grid.rootGrid : this.grid;
        };
        IgxHierarchicalGridNavigationService.prototype.getLastGridElem = function (trContainer) {
            var children = trContainer.children;
            var closestChild = children[children.length - 1].children[0].children[0];
            return closestChild;
        };
        IgxHierarchicalGridNavigationService.prototype.performShiftTabIntoChild = function (gridElem, currentRowEl, rowIndex) {
            var childGridID = gridElem.getAttribute('id');
            var childGrid = this.getChildGrid(childGridID, this.grid) || this.getChildGrid(childGridID, this.grid.parent);
            var lastIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
            var summaryRows = childGrid.summariesRowList.toArray();
            if (summaryRows.length > 0 && summaryRows[0].summaryCells.length > 0) {
                // move focus to last summary row cell
                var summaryRow = summaryRows[0].nativeElement;
                this.focusPrevRow(summaryRow, lastIndex, childGrid, true, true);
            }
            else if (childGrid.rowList.length === 0 &&
                childGrid.allowFiltering && childGrid.filterMode === exports.FilterMode.quickFilter) {
                // move to filter cell
                childGrid.navigation.moveFocusToFilterCell();
            }
            else if (childGrid.rowList.length === 0) {
                // move to prev child or parent row
                var prevChild = this.getSibling(childGrid);
                if (prevChild) {
                    this.performShiftTabIntoChild(prevChild, currentRowEl, rowIndex);
                }
                else {
                    var selNode = {
                        row: rowIndex,
                        column: this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex
                    };
                    this.navigateUp(currentRowEl, selNode);
                }
            }
            else {
                // move to prev cell
                childGrid.navigation.goToLastCell();
            }
        };
        IgxHierarchicalGridNavigationService.prototype.getSibling = function (childGrid) {
            var prevChildRow = childGrid.childRow.nativeElement.previousElementSibling;
            if (prevChildRow) {
                return prevChildRow.children[0].children[0];
            }
            return null;
        };
        IgxHierarchicalGridNavigationService.prototype.focusNextChild = function (elem, visibleColumnIndex, grid) {
            var _this = this;
            var gridElem = elem.querySelector('igx-hierarchical-grid');
            var childGridID = gridElem.getAttribute('id');
            var childGrid = this.getChildGrid(childGridID, grid);
            if (childGrid.rowList.length === 0) {
                this.focusNext(visibleColumnIndex, childGrid);
                return;
            }
            // Update column index since the next child can have in general less columns than visibleColumnIndex value.
            var lastCellIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
            visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);
            if (childGrid.verticalScrollContainer.state.startIndex !== 0) {
                // scroll to top
                this.scrollGrid(childGrid, 'top', function () { return _this.focusNextRow(elem, visibleColumnIndex, childGrid); });
            }
            else {
                this.focusNextRow(elem, visibleColumnIndex, childGrid);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.focusPrevChild = function (elem, visibleColumnIndex, grid) {
            var _this = this;
            var grids = [];
            var gridElems = Array.from(elem.querySelectorAll('igx-hierarchical-grid'));
            var childLevel = grid.childLayoutList.first.level;
            gridElems.forEach(function (hg) {
                var parentRow = _this.getClosestElemByTag(hg, 'igx-child-grid-row');
                if (parentRow && parseInt(parentRow.getAttribute('data-level'), 10) === childLevel) {
                    grids.push(hg);
                }
            });
            var gridElem = grids[grids.length - 1];
            var childGridID = gridElem.getAttribute('id');
            var childGrid = this.getChildGrid(childGridID, grid);
            if (childGrid.rowList.length === 0) {
                this.focusPrev(visibleColumnIndex, childGrid);
                return;
            }
            // Update column index since the previous child can have in general less columns than visibleColumnIndex value.
            var lastCellIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
            visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);
            var isScrolledToBottom = this._isScrolledToBottom(childGrid);
            var lastIndex = childGrid.dataView.length - 1;
            if (!isScrolledToBottom) {
                // scroll to end
                this.scrollGrid(childGrid, 'bottom', function () { return _this.focusPrevChild(elem, visibleColumnIndex, grid); });
            }
            else {
                var lastRowInChild = childGrid.getRowByIndex(lastIndex);
                var isChildGrid = lastRowInChild.nativeElement.nodeName.toLowerCase() === 'igx-child-grid-row';
                if (isChildGrid) {
                    this.focusPrevChild(lastRowInChild.nativeElement.parentNode, visibleColumnIndex, childGrid);
                }
                else {
                    this.focusPrevRow(lastRowInChild.nativeElement, visibleColumnIndex, childGrid, true);
                }
            }
        };
        IgxHierarchicalGridNavigationService.prototype.focusPrev = function (visibleColumnIndex, grid) {
            var _this = this;
            var currGrid = grid || this.grid;
            var parentContainer = this.getChildContainer(currGrid);
            var childRowContainer = this.getChildGridRowContainer(currGrid);
            var prevIsSiblingChild = !!childRowContainer.previousElementSibling;
            var prev = childRowContainer.previousElementSibling || parentContainer.previousElementSibling;
            if (prev) {
                if (prevIsSiblingChild) {
                    this.focusPrevChild(prev, visibleColumnIndex, currGrid.parent);
                }
                else {
                    this.focusPrevRow(prev, visibleColumnIndex, currGrid.parent);
                }
            }
            else {
                this.scrollGrid(currGrid.parent, 'prev', function () {
                    parentContainer = _this.getChildContainer(grid);
                    childRowContainer = _this.getChildGridRowContainer(grid);
                    prev = childRowContainer.previousElementSibling || parentContainer.previousElementSibling;
                    if (prevIsSiblingChild) {
                        _this.focusPrevChild(prev, visibleColumnIndex, currGrid.parent);
                    }
                    else {
                        _this.focusPrevRow(prev, visibleColumnIndex, currGrid.parent);
                    }
                });
            }
        };
        IgxHierarchicalGridNavigationService.prototype.getNextParentInfo = function (grid) {
            // find next parent that is not at bottom
            var currGrid = grid.parent;
            var nextElem = this.getChildContainer(grid).nextElementSibling;
            while (!nextElem && currGrid.parent !== null) {
                nextElem = this.getChildContainer(currGrid).nextElementSibling;
                currGrid = currGrid.parent;
            }
            return { grid: currGrid, nextElement: nextElem };
        };
        IgxHierarchicalGridNavigationService.prototype.getNextScrollable = function (grid) {
            var currGrid = grid.parent;
            if (!currGrid) {
                return { grid: grid, prev: null };
            }
            var nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
            var prev = grid;
            while (nonScrollable && currGrid.parent !== null) {
                prev = currGrid;
                currGrid = currGrid.parent;
                nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
            }
            return { grid: currGrid, prev: prev };
        };
        IgxHierarchicalGridNavigationService.prototype.focusNext = function (visibleColumnIndex, grid) {
            var _this = this;
            var currGrid = grid || this.grid;
            var parentInfo = this.getNextParentInfo(currGrid);
            var nextParentGrid = parentInfo.grid;
            var nextParentElem = parentInfo.nextElement;
            var childRowContainer = this.getChildGridRowContainer(currGrid);
            var nextIsSiblingChild = !!childRowContainer.nextElementSibling;
            var next = childRowContainer.nextElementSibling || nextParentElem;
            var verticalScroll = nextParentGrid.verticalScrollContainer.getScroll();
            var parentState = nextParentGrid.verticalScrollContainer.state;
            var atLastChunk = parentState.startIndex + parentState.chunkSize ===
                nextParentGrid.dataView.length;
            if (next) {
                if (nextIsSiblingChild) {
                    this.focusNextChild(next, visibleColumnIndex, nextParentGrid);
                }
                else {
                    this.focusNextRow(next, visibleColumnIndex, grid || nextParentGrid);
                }
            }
            else if (verticalScroll.scrollTop !==
                verticalScroll.scrollHeight - nextParentGrid.verticalScrollContainer.igxForContainerSize && !atLastChunk) {
                this.scrollGrid(nextParentGrid, 'next', function () {
                    nextParentElem = parentInfo.nextElement;
                    childRowContainer = _this.getChildGridRowContainer();
                    next = childRowContainer.nextElementSibling || nextParentElem;
                    if (next && nextIsSiblingChild) {
                        _this.focusNextChild(next, visibleColumnIndex, nextParentGrid);
                    }
                    else if (next) {
                        _this.focusNextRow(next, visibleColumnIndex, grid || nextParentGrid);
                    }
                });
            }
        };
        IgxHierarchicalGridNavigationService.prototype.getNextScrollableDown = function (grid) {
            var currGrid = grid.parent;
            if (!currGrid) {
                return { grid: grid, prev: null };
            }
            var scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            var scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            var nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
            var prev = grid;
            while (nonScrollable && currGrid.parent !== null) {
                prev = currGrid;
                currGrid = currGrid.parent;
                scrollTop = currGrid.verticalScrollContainer.scrollPosition;
                scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
                nonScrollable = scrollHeight === 0 ||
                    Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
            }
            return { grid: currGrid, prev: prev };
        };
        IgxHierarchicalGridNavigationService.prototype._getMinBottom = function (grid) {
            var currGrid = grid;
            var bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
            while (currGrid.parent) {
                currGrid = currGrid.parent;
                bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom);
            }
            return bottom;
        };
        IgxHierarchicalGridNavigationService.prototype._getMaxTop = function (grid) {
            var currGrid = grid;
            var top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
            while (currGrid.parent) {
                currGrid = currGrid.parent;
                top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top);
            }
            return top;
        };
        IgxHierarchicalGridNavigationService.prototype.focusNextRow = function (elem, visibleColumnIndex, grid, isSummary) {
            var _this = this;
            var lastCellIndex = grid.unpinnedColumns[grid.unpinnedColumns.length - 1].visibleIndex;
            visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);
            var cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
            if (grid.navigation.isColumnFullyVisible(visibleColumnIndex) || grid.rowList.length === 0) {
                var cell_1 = elem.querySelector(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                var closestScrollableGrid = this.getNextScrollableDown(grid).grid;
                // const diff = cell.getBoundingClientRect().bottom - grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;
                var gridBottom = this._getMinBottom(grid);
                var diff = cell_1.getBoundingClientRect().bottom - gridBottom;
                var inView = diff <= 0;
                var scrollTop = closestScrollableGrid.verticalScrollContainer.scrollPosition;
                var scrollHeight = closestScrollableGrid.verticalScrollContainer.getScroll().scrollHeight;
                var canScroll = !(scrollHeight === 0 ||
                    Math.round(scrollTop + closestScrollableGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight);
                if (!inView && canScroll) {
                    this.scrollGrid(closestScrollableGrid, diff, function () { return cell_1.focus({ preventScroll: true }); });
                }
                else {
                    cell_1.focus({ preventScroll: true });
                }
            }
            else {
                this.horizontalScrollGridToIndex(grid, visibleColumnIndex, function () {
                    _this.focusNextRow(elem, visibleColumnIndex, grid, isSummary);
                });
            }
        };
        IgxHierarchicalGridNavigationService.prototype.getColumnUnpinnedIndex = function (visibleColumnIndex, grid) {
            var currGrid = grid || this.grid;
            var column = currGrid.unpinnedColumns.find(function (col) { return !col.columnGroup && col.visibleIndex === visibleColumnIndex; });
            return currGrid.pinnedColumns.length ? currGrid.unpinnedColumns.filter(function (c) { return !c.columnGroup; }).indexOf(column) :
                visibleColumnIndex;
        };
        IgxHierarchicalGridNavigationService.prototype.focusPrevRow = function (elem, visibleColumnIndex, grid, inChild, isSummary) {
            var _this = this;
            var lastCellIndex = grid.unpinnedColumns[grid.unpinnedColumns.length - 1].visibleIndex;
            visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);
            if (grid.navigation.isColumnFullyVisible(visibleColumnIndex)) {
                var cellSelector_2 = this.getCellSelector(visibleColumnIndex, isSummary);
                var cells = elem.querySelectorAll(cellSelector_2 + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                var cell_2 = cells[cells.length - 1];
                var rIndex_1 = parseInt(elem.getAttribute('data-rowindex'), 10);
                var scrGrid = grid.verticalScrollContainer.scrollPosition !== 0 ? grid :
                    this.getNextScrollable(grid).grid;
                var topGrid = scrGrid.tbody.nativeElement.getBoundingClientRect().top >
                    grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top ? scrGrid : grid.rootGrid;
                var gridTop = this._getMaxTop(grid);
                var scrTop = scrGrid.verticalScrollContainer.scrollPosition;
                var diff = cell_2.getBoundingClientRect().bottom -
                    cell_2.offsetHeight - gridTop;
                if (scrTop !== 0 && diff < 0 && !inChild) {
                    this.scrollGrid(scrGrid, diff, function () {
                        var el = !isSummary ? grid.navigation.getRowByIndex(rIndex_1) : elem;
                        cell_2 = el.querySelectorAll(cellSelector_2 + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]")[0];
                        cell_2.focus({ preventScroll: true });
                    });
                }
                else if (diff < 0 && inChild) {
                    this.scrollGrid(topGrid, diff, function () {
                        cell_2.focus({ preventScroll: true });
                    });
                }
                else {
                    cell_2.focus({ preventScroll: true });
                }
            }
            else {
                this.horizontalScrollGridToIndex(grid, visibleColumnIndex, function () {
                    _this.focusPrevRow(elem, visibleColumnIndex, grid, inChild, isSummary);
                });
            }
        };
        IgxHierarchicalGridNavigationService.prototype.horizontalScrollGridToIndex = function (grid, visibleColumnIndex, callBackFunc) {
            var unpinnedIndex = this.getColumnUnpinnedIndex(visibleColumnIndex, grid);
            grid.parentVirtDir.onChunkLoad
                .pipe(operators.first())
                .subscribe(callBackFunc);
            if (grid.dataRowList.length > 0) {
                grid.dataRowList.first.virtDirRow.scrollTo(unpinnedIndex);
            }
            else {
                grid.headerContainer.scrollTo(unpinnedIndex);
            }
        };
        IgxHierarchicalGridNavigationService.prototype.scrollGrid = function (grid, target, callBackFunc) {
            this.getFocusableGrid().nativeElement.focus({ preventScroll: true });
            requestAnimationFrame(function () {
                if (typeof target === 'number') {
                    grid.verticalScrollContainer.addScrollTop(target);
                }
                else {
                    switch (target) {
                        case 'top':
                            grid.verticalScrollContainer.scrollTo(0);
                            break;
                        case 'bottom':
                            grid.verticalScrollContainer.scrollTo(grid.dataView.length - 1);
                            break;
                        case 'next':
                            grid.verticalScrollContainer.scrollNext();
                            break;
                        case 'prev':
                            grid.verticalScrollContainer.scrollPrev();
                            break;
                    }
                }
                grid.verticalScrollContainer.onChunkLoad
                    .pipe(operators.first())
                    .subscribe(callBackFunc);
            });
        };
        IgxHierarchicalGridNavigationService.prototype._navigateUpInChild = function (rowElement, currentRowIndex, visibleColumnIndex) {
            var _this = this;
            var prevElem = rowElement.previousElementSibling;
            var scrollable = this.getNextScrollable(this.grid);
            var grid = scrollable.grid;
            var scrTop = grid.verticalScrollContainer.scrollPosition;
            var containerTop = scrollable.prev.nativeElement.parentNode.parentNode.parentNode.parentNode;
            var top = parseInt(containerTop.style.top, 10);
            if (scrTop !== 0 && top < 0) {
                this.scrollGrid(grid, -prevElem.offsetHeight, function () { return _super.prototype.navigateUp.call(_this, rowElement, { row: currentRowIndex, column: visibleColumnIndex }); });
            }
            else {
                _super.prototype.navigateUp.call(this, rowElement, { row: currentRowIndex, column: visibleColumnIndex });
            }
        };
        IgxHierarchicalGridNavigationService.prototype._navigateDownInChild = function (rowElement, currentRowIndex, visibleColumnIndex) {
            var _this = this;
            var nextElem = rowElement.nextElementSibling;
            var childContainer = this.grid.nativeElement.parentNode.parentNode;
            var diff = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.nativeElement.getBoundingClientRect().bottom;
            var endIsVisible = diff < 0;
            var scrollable = this.getNextScrollableDown(this.grid);
            var grid = scrollable.grid;
            if (!endIsVisible) {
                this.scrollGrid(grid, nextElem.offsetHeight, function () { return _super.prototype.navigateDown.call(_this, rowElement, { row: currentRowIndex, column: visibleColumnIndex }); });
            }
            else {
                _super.prototype.navigateDown.call(this, rowElement, { row: currentRowIndex, column: visibleColumnIndex });
            }
        };
        IgxHierarchicalGridNavigationService.prototype.getNextRowByIndex = function (nextIndex) {
            return this.grid.dataRowList.find(function (element) { return element.index === nextIndex; }).element.nativeElement;
        };
        IgxHierarchicalGridNavigationService = __decorate([
            core.Injectable()
        ], IgxHierarchicalGridNavigationService);
        return IgxHierarchicalGridNavigationService;
    }(IgxGridNavigationService));

    var IgxHierarchicalTransactionServiceFactory = {
        provide: IgxGridTransaction,
        useFactory: hierarchicalTransactionServiceFactory
    };
    function hierarchicalTransactionServiceFactory() {
        return new IgxTransactionService();
    }
    var IgxHierarchicalGridBaseDirective = /** @class */ (function (_super) {
        __extends(IgxHierarchicalGridBaseDirective, _super);
        function IgxHierarchicalGridBaseDirective(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
            var _this = _super.call(this, selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) || this;
            _this.selectionService = selectionService;
            _this.colResizingService = colResizingService;
            _this.transactionFactory = transactionFactory;
            _this.document = document;
            _this.overlayService = overlayService;
            _this.summaryService = summaryService;
            _this._displayDensityOptions = _displayDensityOptions;
            _this.showExpandAll = false;
            _this.hgridAPI = gridAPI;
            return _this;
        }
        Object.defineProperty(IgxHierarchicalGridBaseDirective.prototype, "maxLevelHeaderDepth", {
            /**
             * @hidden
             */
            get: function () {
                if (this._maxLevelHeaderDepth === null) {
                    this._maxLevelHeaderDepth = this.columnList.reduce(function (acc, col) { return Math.max(acc, col.level); }, 0);
                }
                return this._maxLevelHeaderDepth;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridBaseDirective.prototype, "outlet", {
            /**
            * @hidden
            */
            get: function () {
                return this.rootGrid ? this.rootGrid.outletDirective : this.outletDirective;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxHierarchicalGridBaseDirective.prototype.createColumnsList = function (cols) {
            var _this = this;
            var columns = [];
            var topLevelCols = this.onlyTopLevel(cols);
            topLevelCols.forEach(function (col) {
                var ref = _this._createColumn(col);
                ref.changeDetectorRef.detectChanges();
                columns.push(ref.instance);
            });
            var result = flatten$1(columns);
            this.columnList.reset(result);
            this.columnList.notifyOnChanges();
            this.initPinning();
        };
        IgxHierarchicalGridBaseDirective.prototype._createColumn = function (col) {
            var ref;
            if (col instanceof IgxColumnGroupComponent) {
                ref = this._createColGroupComponent(col);
            }
            else {
                ref = this._createColComponent(col);
            }
            return ref;
        };
        IgxHierarchicalGridBaseDirective.prototype._createColGroupComponent = function (col) {
            var _this = this;
            var factoryGroup = this.resolver.resolveComponentFactory(IgxColumnGroupComponent);
            var ref = this.viewRef.createComponent(factoryGroup, null, this.viewRef.injector);
            ref.changeDetectorRef.detectChanges();
            factoryGroup.inputs.forEach(function (input) {
                var propName = input.propName;
                ref.instance[propName] = col[propName];
            });
            if (col.children.length > 0) {
                var newChildren_1 = [];
                col.children.forEach(function (child) {
                    var newCol = _this._createColumn(child).instance;
                    newCol.parent = ref.instance;
                    newChildren_1.push(newCol);
                });
                ref.instance.children.reset(newChildren_1);
                ref.instance.children.notifyOnChanges();
            }
            return ref;
        };
        IgxHierarchicalGridBaseDirective.prototype._createColComponent = function (col) {
            var factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);
            var ref = this.viewRef.createComponent(factoryColumn, null, this.viewRef.injector);
            factoryColumn.inputs.forEach(function (input) {
                var propName = input.propName;
                if (!(col[propName] instanceof IgxSummaryOperand)) {
                    ref.instance[propName] = col[propName];
                }
                else {
                    ref.instance[propName] = col[propName].constructor;
                }
            });
            return ref;
        };
        IgxHierarchicalGridBaseDirective.prototype.getGridsForIsland = function (rowIslandID) {
            return this.hgridAPI.getChildGridsForRowIsland(rowIslandID);
        };
        IgxHierarchicalGridBaseDirective.prototype.getChildGrid = function (path) {
            if (!path) {
                return;
            }
            return this.hgridAPI.getChildGrid(path);
        };
        IgxHierarchicalGridBaseDirective.ctorParameters = function () { return [
            { type: IgxGridSelectionService },
            { type: IgxGridCRUDService },
            { type: IgxColumnResizingService },
            { type: GridBaseAPIService },
            { type: undefined, decorators: [{ type: core.Inject, args: [IgxGridTransaction,] }] },
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.ChangeDetectorRef },
            { type: core.ComponentFactoryResolver },
            { type: core.IterableDiffers },
            { type: core.ViewContainerRef },
            { type: IgxHierarchicalGridNavigationService },
            { type: IgxFilteringService },
            { type: IgxOverlayService, decorators: [{ type: core.Inject, args: [IgxOverlayService,] }] },
            { type: IgxGridSummaryService },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] }
        ]; };
        __decorate([
            core.Input()
        ], IgxHierarchicalGridBaseDirective.prototype, "expandChildren", void 0);
        __decorate([
            core.Input()
        ], IgxHierarchicalGridBaseDirective.prototype, "hasChildrenKey", void 0);
        __decorate([
            core.Input()
        ], IgxHierarchicalGridBaseDirective.prototype, "showExpandAll", void 0);
        __decorate([
            core.ViewChild('dragIndicatorIconBase', { read: core.TemplateRef, static: true })
        ], IgxHierarchicalGridBaseDirective.prototype, "dragIndicatorIconBase", void 0);
        IgxHierarchicalGridBaseDirective = __decorate([
            core.Directive({
                selector: '[igxHierarchicalGridBase]'
            }),
            __param(4, core.Inject(IgxGridTransaction)),
            __param(7, core.Inject(common.DOCUMENT)),
            __param(14, core.Inject(IgxOverlayService)),
            __param(16, core.Optional()), __param(16, core.Inject(DisplayDensityToken))
        ], IgxHierarchicalGridBaseDirective);
        return IgxHierarchicalGridBaseDirective;
    }(IgxGridBaseDirective));
    function flatten$1(arr) {
        var result = [];
        arr.forEach(function (el) {
            result.push(el);
            if (el.children) {
                result = result.concat(flatten$1(el.children.toArray()));
            }
        });
        return result;
    }

    var IgxHierarchicalGridAPIService = /** @class */ (function (_super) {
        __extends(IgxHierarchicalGridAPIService, _super);
        function IgxHierarchicalGridAPIService() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.childRowIslands = new Map();
            _this.childGrids = new Map();
            return _this;
        }
        IgxHierarchicalGridAPIService.prototype.registerChildRowIsland = function (rowIsland) {
            this.childRowIslands.set(rowIsland.key, rowIsland);
            this.destroyMap.set(rowIsland.key, new rxjs.Subject());
        };
        IgxHierarchicalGridAPIService.prototype.unsetChildRowIsland = function (rowIsland) {
            this.childGrids.delete(rowIsland.key);
            this.childRowIslands.delete(rowIsland.key);
            this.destroyMap.delete(rowIsland.key);
        };
        IgxHierarchicalGridAPIService.prototype.getChildRowIsland = function (key) {
            return this.childRowIslands.get(key);
        };
        IgxHierarchicalGridAPIService.prototype.getChildGrid = function (path) {
            var currPath = path;
            var grid;
            var pathElem = currPath.shift();
            var childrenForLayout = this.childGrids.get(pathElem.rowIslandKey);
            if (childrenForLayout) {
                var childGrid = childrenForLayout.get(pathElem.rowID);
                if (currPath.length === 0) {
                    grid = childGrid;
                }
                else {
                    grid = childGrid.hgridAPI.getChildGrid(currPath);
                }
            }
            return grid;
        };
        IgxHierarchicalGridAPIService.prototype.getChildGrids = function (inDepth) {
            var allChildren = [];
            this.childGrids.forEach(function (layoutMap) {
                layoutMap.forEach(function (grid) {
                    allChildren.push(grid);
                    if (inDepth) {
                        var children = grid.hgridAPI.getChildGrids(inDepth);
                        children.forEach(function (item) {
                            allChildren.push(item);
                        });
                    }
                });
            });
            return allChildren;
        };
        IgxHierarchicalGridAPIService.prototype.getParentRowId = function (childGrid) {
            var rowID;
            this.childGrids.forEach(function (layoutMap) {
                layoutMap.forEach(function (grid, key) {
                    if (grid === childGrid) {
                        rowID = key;
                        return;
                    }
                });
            });
            return rowID;
        };
        IgxHierarchicalGridAPIService.prototype.registerChildGrid = function (parentRowID, rowIslandKey, grid) {
            var childrenForLayout = this.childGrids.get(rowIslandKey);
            if (!childrenForLayout) {
                this.childGrids.set(rowIslandKey, new Map());
                childrenForLayout = this.childGrids.get(rowIslandKey);
            }
            childrenForLayout.set(parentRowID, grid);
        };
        IgxHierarchicalGridAPIService.prototype.getChildGridsForRowIsland = function (rowIslandKey) {
            var childrenForLayout = this.childGrids.get(rowIslandKey);
            var children = [];
            if (childrenForLayout) {
                childrenForLayout.forEach(function (child) {
                    children.push(child);
                });
            }
            return children;
        };
        IgxHierarchicalGridAPIService.prototype.getChildGridByID = function (rowIslandKey, rowID) {
            var childrenForLayout = this.childGrids.get(rowIslandKey);
            return childrenForLayout.get(rowID);
        };
        IgxHierarchicalGridAPIService.prototype.get_row_expansion_state = function (record) {
            var inState;
            if (record.childGridsData !== undefined) {
                var ri = record.rowID;
                var rec = this.grid.primaryKey ? this.get_rec_by_id(ri) : ri;
                inState = !!_super.prototype.get_row_expansion_state.call(this, rec);
            }
            else {
                inState = !!_super.prototype.get_row_expansion_state.call(this, record);
            }
            return inState && this.grid.childLayoutList.length !== 0;
        };
        IgxHierarchicalGridAPIService.prototype.allow_expansion_state_change = function (rowID, expanded) {
            var rec = this.get_rec_by_id(rowID);
            return !!rec && this.grid.expansionStates.get(rowID) !== expanded;
        };
        IgxHierarchicalGridAPIService.prototype.get_rec_by_id = function (rowID) {
            var data = this.get_all_data(false);
            var index = this.get_row_index_in_data(rowID);
            return data[index];
        };
        IgxHierarchicalGridAPIService = __decorate([
            core.Injectable()
        ], IgxHierarchicalGridAPIService);
        return IgxHierarchicalGridAPIService;
    }(GridBaseAPIService));

    var IgxRowIslandComponent = /** @class */ (function (_super) {
        __extends(IgxRowIslandComponent, _super);
        function IgxRowIslandComponent(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, rowIslandAPI) {
            var _this = _super.call(this, selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) || this;
            _this.selectionService = selectionService;
            _this.colResizingService = colResizingService;
            _this.transactionFactory = transactionFactory;
            _this.document = document;
            _this.overlayService = overlayService;
            _this.summaryService = summaryService;
            _this._displayDensityOptions = _displayDensityOptions;
            _this.rowIslandAPI = rowIslandAPI;
            /**
             * @hidden
             */
            _this.children = new core.QueryList();
            /**
             * @hidden
             */
            _this.childColumns = new core.QueryList();
            /**
             * @hidden
             */
            _this.onLayoutChange = new core.EventEmitter();
            /**
             * Event emmited when a grid is being created based on this row island.
             * ```html
             * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
             *      <igx-row-island [key]="'childData'" (onGridCreated)="gridCreated($event)" #rowIsland>
             *          <!-- ... -->
             *      </igx-row-island>
             * </igx-hierarchical-grid>
             * ```
             * @memberof IgxRowIslandComponent
             */
            _this.onGridCreated = new core.EventEmitter();
            /**
             * @hidden
             */
            _this.initialChanges = [];
            /**
             * @hidden
             */
            _this.rootGrid = null;
            _this.layout_id = "igx-row-island-";
            _this.isInit = false;
            _this.hgridAPI = gridAPI;
            return _this;
        }
        IgxRowIslandComponent_1 = IgxRowIslandComponent;
        Object.defineProperty(IgxRowIslandComponent.prototype, "expandChildren", {
            /**
             * Gets if all immediate children of the grids for this `IgxRowIslandComponent` have been set to be expanded/collapsed.
             * ```typescript
             * const expanded = this.rowIsland.expandChildren;
             * ```
             * @memberof IgxRowIslandComponent
             */
            get: function () {
                return this._defaultExpandState;
            },
            /**
             * Sets if all immediate children of the grids for this `IgxRowIslandComponent` should be expanded/collapsed.
             * ```html
             * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
             *      <igx-row-island [key]="'childData'" [expandChildren]="true" #rowIsland>
             *          <!-- ... -->
             *      </igx-row-island>
             * </igx-hierarchical-grid>
             * ```
             * @memberof IgxRowIslandComponent
             */
            set: function (value) {
                this._defaultExpandState = value;
                this.rowIslandAPI.getChildGrids().forEach(function (grid) {
                    if (document.body.contains(grid.nativeElement)) {
                        // Detect changes right away if the grid is visible
                        grid.expandChildren = value;
                        grid.markForCheck();
                    }
                    else {
                        // Else defer the detection on changes when the grid gets into view for performance.
                        grid.updateOnRender = true;
                    }
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowIslandComponent.prototype, "id", {
            /**
             * @hidden
             */
            get: function () {
                var pId = this.parentId ? this.parentId.substring(this.parentId.indexOf(this.layout_id) + this.layout_id.length) + '-' : '';
                return this.layout_id + pId + this.key;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowIslandComponent.prototype, "parentId", {
            /**
             * @hidden
             */
            get: function () {
                return this.parentIsland ? this.parentIsland.id : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRowIslandComponent.prototype, "level", {
            /**
             * @hidden
             */
            get: function () {
                var ptr = this.parentIsland;
                var lvl = 0;
                while (ptr) {
                    lvl++;
                    ptr = ptr.parentIsland;
                }
                return lvl + 1;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngOnInit = function () {
            this.rootGrid = this.hgridAPI.grid;
            this.rowIslandAPI.rowIsland = this;
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngDoCheck = function () {
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.updateChildren();
            this.children.notifyOnChanges();
            this.children.changes.pipe(operators.takeUntil(this.destroy$))
                .subscribe(function (change) {
                _this.updateChildren();
                // update existing grids since their child ri have been changed.
                _this.getGridsForIsland(_this.key).forEach(function (grid) {
                    grid.onRowIslandChange(_this.children);
                });
            });
            var nestedColumns = this.children.map(function (layout) { return layout.columnList.toArray(); });
            var colsArray = [].concat.apply([], nestedColumns);
            var topCols = this.columnList.filter(function (item) {
                return colsArray.indexOf(item) === -1;
            });
            this.childColumns.reset(topCols);
            this.columnList.changes.pipe(operators.takeUntil(this.destroy$)).subscribe(function () { _this.updateColumnList(); });
        };
        IgxRowIslandComponent.prototype.updateChildren = function () {
            var _this = this;
            if (this.children.first === this) {
                this.children.reset(this.children.toArray().slice(1));
            }
            this.children.forEach(function (child) {
                child.parentIsland = _this;
            });
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngAfterViewInit = function () {
            this.rowIslandAPI.register(this);
            if (this.parentIsland) {
                this.parentIsland.rowIslandAPI.registerChildRowIsland(this);
            }
            else {
                this.rootGrid.hgridAPI.registerChildRowIsland(this);
            }
            this._init = false;
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngOnChanges = function (changes) {
            this.onLayoutChange.emit(changes);
            if (!this.isInit) {
                this.initialChanges.push(changes);
            }
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            // Override the base destroy because we don't have rendered anything to use removeEventListener on
            this.destroy$.next(true);
            this.destroy$.complete();
            this._destroyed = true;
            this.rowIslandAPI.unset(this.id);
            if (this.parentIsland) {
                this.getGridsForIsland(this.key).forEach(function (grid) {
                    _this.cleanGridState(grid);
                    grid.hgridAPI.unsetChildRowIsland(_this);
                });
                this.parentIsland.rowIslandAPI.unsetChildRowIsland(this);
            }
            else {
                this.rootGrid.hgridAPI.unsetChildRowIsland(this);
                this.cleanGridState(this.rootGrid);
            }
        };
        IgxRowIslandComponent.prototype.cleanGridState = function (grid) {
            grid.childGridTemplates.forEach(function (tmpl) {
                tmpl.owner.cleanView(tmpl.context.templateID);
            });
            grid.childGridTemplates.clear();
            grid.onRowIslandChange();
        };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.reflow = function () { };
        /**
         * @hidden
         */
        IgxRowIslandComponent.prototype.calculateGridHeight = function () { };
        IgxRowIslandComponent.prototype.updateColumnList = function () {
            var _this = this;
            var nestedColumns = this.children.map(function (layout) { return layout.columnList.toArray(); });
            var colsArray = [].concat.apply([], nestedColumns);
            var topCols = this.columnList.filter(function (item) {
                if (colsArray.indexOf(item) === -1) {
                    /* Reset the default width of the columns that come into this row island,
                    because the root catches them first during the detectChanges() and sets their defaultWidth. */
                    item.defaultWidth = undefined;
                    return true;
                }
                return false;
            });
            this.childColumns.reset(topCols);
            if (this.parentIsland) {
                this.parentIsland.columnList.notifyOnChanges();
            }
            else {
                this.rootGrid.columnList.notifyOnChanges();
            }
            this.rowIslandAPI.getChildGrids().forEach(function (grid) {
                grid.createColumnsList(_this.childColumns.toArray());
                if (!document.body.contains(grid.nativeElement)) {
                    grid.updateOnRender = true;
                }
            });
        };
        var IgxRowIslandComponent_1;
        IgxRowIslandComponent.ctorParameters = function () { return [
            { type: IgxGridSelectionService },
            { type: IgxGridCRUDService },
            { type: IgxColumnResizingService },
            { type: GridBaseAPIService },
            { type: undefined, decorators: [{ type: core.Inject, args: [IgxGridTransaction,] }] },
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
            { type: core.ChangeDetectorRef },
            { type: core.ComponentFactoryResolver },
            { type: core.IterableDiffers },
            { type: core.ViewContainerRef },
            { type: IgxHierarchicalGridNavigationService },
            { type: IgxFilteringService },
            { type: IgxOverlayService, decorators: [{ type: core.Inject, args: [IgxOverlayService,] }] },
            { type: IgxGridSummaryService },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DisplayDensityToken,] }] },
            { type: IgxRowIslandAPIService }
        ]; };
        __decorate([
            core.Input()
        ], IgxRowIslandComponent.prototype, "key", void 0);
        __decorate([
            core.Input()
        ], IgxRowIslandComponent.prototype, "expandChildren", null);
        __decorate([
            core.ContentChildren(IgxRowIslandComponent_1, { read: IgxRowIslandComponent_1, descendants: false })
        ], IgxRowIslandComponent.prototype, "children", void 0);
        __decorate([
            core.ContentChildren(IgxColumnComponent, { read: IgxColumnComponent, descendants: false })
        ], IgxRowIslandComponent.prototype, "childColumns", void 0);
        __decorate([
            core.Output()
        ], IgxRowIslandComponent.prototype, "onLayoutChange", void 0);
        __decorate([
            core.Output()
        ], IgxRowIslandComponent.prototype, "onGridCreated", void 0);
        IgxRowIslandComponent = IgxRowIslandComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                selector: 'igx-row-island',
                template: "",
                providers: [IgxRowIslandAPIService]
            }),
            __param(4, core.Inject(IgxGridTransaction)),
            __param(7, core.Inject(common.DOCUMENT)),
            __param(14, core.Inject(IgxOverlayService)),
            __param(16, core.Optional()), __param(16, core.Inject(DisplayDensityToken))
        ], IgxRowIslandComponent);
        return IgxRowIslandComponent;
    }(IgxHierarchicalGridBaseDirective));

    var IgxChildGridRowComponent = /** @class */ (function () {
        function IgxChildGridRowComponent(gridAPI, element, resolver, cdr) {
            this.gridAPI = gridAPI;
            this.element = element;
            this.cdr = cdr;
            /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
            this.expanded = false;
            /**
             *  The data passed to the row component.
             *
             * ```typescript
             * // get the row data for the first selected row
             * let selectedRowData = this.grid.selectedRows[0].rowData;
             * ```
             */
            this.rowData = [];
            /**
             * @hidden
             */
            this.tabindex = 0;
            /**
             * @hidden
             */
            this.role = 'row';
            this.resolver = resolver;
        }
        Object.defineProperty(IgxChildGridRowComponent.prototype, "parentHasScroll", {
            /**
             * @hidden
             */
            get: function () {
                return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxChildGridRowComponent.prototype, "parentGrid", {
            /**
             * Get a reference to the grid that contains the selected row.
             *
             * ```typescript
             * handleRowSelection(event) {
             *  // the grid on which the onRowSelectionChange event was triggered
             *  const grid = event.row.grid;
             * }
             * ```
             *
             * ```html
             *  <igx-grid
             *    [data]="data"
             *    (onRowSelectionChange)="handleRowSelection($event)">
             *  </igx-grid>
             * ```
             */
            // TODO: Refactor
            get: function () {
                return this.gridAPI.grid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxChildGridRowComponent.prototype, "level", {
            get: function () {
                return this.layout.level;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxChildGridRowComponent.prototype, "nativeElement", {
            /**
             * The native DOM element representing the row. Could be null in certain environments.
             *
             * ```typescript
             * // get the nativeElement of the second selected row
             * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
             * ```
             */
            get: function () {
                return this.element.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxChildGridRowComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.layout.onLayoutChange.subscribe(function (ch) {
                _this._handleLayoutChanges(ch);
            });
            var changes = this.layout.initialChanges;
            changes.forEach(function (change) {
                _this._handleLayoutChanges(change);
            });
            this.hGrid.parent = this.parentGrid;
            this.hGrid.parentIsland = this.layout;
            this.hGrid.childRow = this;
            // handler logic that re-emits hgrid events on the row island
            this.setupEventEmitters();
            this.layout.onGridCreated.emit({
                owner: this.layout,
                parentID: this.rowData.rowID,
                grid: this.hGrid
            });
        };
        /**
         * @hidden
         */
        IgxChildGridRowComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.hGrid.childLayoutList = this.layout.children;
            if (this.layout.childColumns.length > 0 && !this.hGrid.autoGenerate) {
                this.hGrid.createColumnsList(this.layout.childColumns.toArray());
            }
            var layouts = this.hGrid.childLayoutList.toArray();
            layouts.forEach(function (l) { return _this.hGrid.hgridAPI.registerChildRowIsland(l); });
            this.parentGrid.hgridAPI.registerChildGrid(this.rowData.rowID, this.layout.key, this.hGrid);
            this.layout.rowIslandAPI.registerChildGrid(this.rowData.rowID, this.hGrid);
            this.hGrid.cdr.detectChanges();
        };
        IgxChildGridRowComponent.prototype.setupEventEmitters = function () {
            var _this = this;
            var destructor = operators.takeUntil(this.hGrid.destroy$);
            var factory = this.resolver.resolveComponentFactory(IgxGridComponent);
            // exclude outputs related to two-way binding functionality
            var inputNames = factory.inputs.map(function (input) { return input.propName; });
            var outputs = factory.outputs.filter(function (o) {
                var matchingInputPropName = o.propName.slice(0, o.propName.indexOf('Change'));
                return inputNames.indexOf(matchingInputPropName) === -1;
            });
            outputs.forEach(function (output) {
                if (_this.hGrid[output.propName]) {
                    _this.hGrid[output.propName].pipe(destructor).subscribe(function (args) {
                        if (!args) {
                            args = {};
                        }
                        args.owner = _this.hGrid;
                        _this.layout[output.propName].emit(args);
                    });
                }
            });
        };
        IgxChildGridRowComponent.prototype._handleLayoutChanges = function (changes) {
            for (var change in changes) {
                if (changes.hasOwnProperty(change)) {
                    this.hGrid[change] = changes[change].currentValue;
                }
            }
        };
        IgxChildGridRowComponent.ctorParameters = function () { return [
            { type: GridBaseAPIService },
            { type: core.ElementRef },
            { type: core.ComponentFactoryResolver },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxChildGridRowComponent.prototype, "layout", void 0);
        __decorate([
            core.Input()
        ], IgxChildGridRowComponent.prototype, "parentGridID", void 0);
        __decorate([
            core.Input()
        ], IgxChildGridRowComponent.prototype, "rowData", void 0);
        __decorate([
            core.Input()
        ], IgxChildGridRowComponent.prototype, "index", void 0);
        __decorate([
            core.ViewChild('hgrid', { static: true })
        ], IgxChildGridRowComponent.prototype, "hGrid", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxChildGridRowComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxChildGridRowComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.data-level')
        ], IgxChildGridRowComponent.prototype, "level", null);
        IgxChildGridRowComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-child-grid-row',
                template: "<div class=\"igx-grid__hierarchical-indent\" [ngClass]=\"{'igx-grid__hierarchical-indent--scroll': parentHasScroll}\">\n    <igx-hierarchical-grid #hgrid [data]='rowData.childGridsData[layout.key]'></igx-hierarchical-grid>\n</div>\n"
            })
        ], IgxChildGridRowComponent);
        return IgxChildGridRowComponent;
    }());

    var NEXT_ID$o = 0;
    var IgxHierarchicalGridComponent = /** @class */ (function (_super) {
        __extends(IgxHierarchicalGridComponent, _super);
        function IgxHierarchicalGridComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *@hidden
             *@deprecated
             */
            _this.hierarchicalStateChange = new core.EventEmitter();
            /**
             * @hidden
             */
            _this.childLayoutKeys = [];
            /**
             * @hidden
             */
            _this.highlightedRowID = null;
            /**
             * @hidden
             */
            _this.updateOnRender = false;
            /**
             * @hidden
             */
            _this.parent = null;
            _this._filteredData = null;
            _this.h_id = "igx-hierarchical-grid-" + NEXT_ID$o++;
            _this.childGridTemplates = new Map();
            _this.scrollTop = 0;
            _this.scrollLeft = 0;
            return _this;
        }
        IgxHierarchicalGridComponent_1 = IgxHierarchicalGridComponent;
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "id", {
            /**
             * Sets the value of the `id` attribute. If not provided it will be automatically generated.
             * ```html
             * <igx-hierarchical-grid [id]="'igx-hgrid-1'" [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
             * ```
             * @memberof IgxHierarchicalGridComponent
             */
            get: function () {
                return this.h_id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "data", {
            /**
             * Returns an array of data set to the `IgxHierarchicalGridComponent`.
             * ```typescript
             * let filteredData = this.grid.filteredData;
             * ```
             * @memberof IgxHierarchicalGridComponent
             */
            get: function () {
                return this._data;
            },
            /**
             * An @Input property that lets you fill the `IgxHierarchicalGridComponent` with an array of data.
             * ```html
             * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
             * ```
             * @memberof IgxHierarchicalGridComponent
             */
            set: function (value) {
                this._data = value || [];
                this.summaryService.clearSummaryCache();
                if (this.shouldGenerate) {
                    this.setupColumns();
                    this.reflow();
                }
                this.cdr.markForCheck();
                if (this.parent && (this.height === null || this.height.indexOf('%') !== -1)) {
                    // If the height will change based on how much data there is, recalculate sizes in igxForOf.
                    this.notifyChanges(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "hierarchicalState", {
            /**
             *@hidden
             *@deprecated
             * Sets the state of the `IgxHierarchicalGridComponent` containing which rows are expanded.
            */
            get: function () {
                var res = Array.from(this.expansionStates.entries()).filter(function (_a) {
                    var v = _a[1];
                    return v === true;
                }).map(function (_a) {
                    var _b = __read(_a, 1), k = _b[0];
                    return k;
                });
                return res;
            },
            set: function (val) {
                var _this = this;
                if (this.hasChildrenKey) {
                    val = val.filter(function (item) {
                        var rec = _this.primaryKey ? _this.data.find(function (x) { return x[_this.primaryKey] === item.rowID; }) : item.rowID;
                        return rec[_this.hasChildrenKey];
                    });
                }
                var expansionStates = new Map();
                val.forEach(function (item) {
                    var rec = _this.primaryKey ? _this.data.find(function (x) { return x[_this.primaryKey] === item.rowID; }) : item.rowID;
                    expansionStates.set(rec, true);
                });
                this.expansionStates = expansionStates;
                if (this.parent) {
                    this.notifyChanges(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "filteredData", {
            /**
             * Returns an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
             * ```typescript
             * let filteredData = this.grid.filteredData;
             * ```
             * @memberof IgxHierarchicalGridComponent
             */
            get: function () {
                return this._filteredData;
            },
            /**
             * Sets an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
             * ```typescript
             * this.grid.filteredData = [{
             *       ID: 1,
             *       Name: "A"
             * }];
             * ```
             * @memberof IgxHierarchicalGridComponent
             */
            set: function (value) {
                this._filteredData = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "expandChildren", {
            /**
             * Gets if all immediate children of the `IgxHierarchicalGridComponent` previously have been set to be expanded/collapsed.
             * If previously set and some rows have been manually expanded/collapsed it will still return the last set value.
             * ```typescript
             * const expanded = this.grid.expandChildren;
             * ```
             * @memberof IgxHierarchicalGridComponent
             */
            get: function () {
                return this._defaultExpandState;
            },
            /**
             * Sets if all immediate children of the `IgxHierarchicalGridComponent` should be expanded/collapsed.
             * Defult value is false.
             * ```html
             * <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" [expandChildren]="true"></igx-hierarchical-grid>
             * ```
             * @memberof IgxHierarchicalGridComponent
             */
            set: function (value) {
                this._defaultExpandState = value;
                this.expansionStates = new Map();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "foreignKey", {
            /**
             * Gets the unique identifier of the parent row. It may be a `string` or `number` if `primaryKey` of the
             * parent grid is set or an object reference of the parent record otherwise.
             * ```typescript
             * const foreignKey = this.grid.foreignKey;
             * ```
             * @memberof IgxHierarchicalGridComponent
             */
            get: function () {
                if (!this.parent) {
                    return null;
                }
                return this.parent.hgridAPI.getParentRowId(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "hasExpandableChildren", {
            /**
             * @hidden
             */
            get: function () {
                return !!this.childLayoutKeys.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (this._transactions instanceof IgxTransactionService) {
                // transaction service cannot be injected in a derived class in a factory manner
                this._transactions = new IgxTransactionService();
            }
            this.expansionStatesChange.pipe(operators.takeUntil(this.destroy$)).subscribe(function (value) {
                var res = Array.from(value.entries()).filter(function (_a) {
                    var v = _a[1];
                    return v === true;
                }).map(function (_a) {
                    var _b = __read(_a, 1), k = _b[0];
                    return k;
                });
                _this.hierarchicalStateChange.emit(res);
            });
            _super.prototype.ngOnInit.call(this);
        };
        IgxHierarchicalGridComponent.prototype.ngDoCheck = function () {
            if (this._cdrRequestRepaint && !this._init) {
                this.updateSizes();
            }
            _super.prototype.ngDoCheck.call(this);
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            _super.prototype.ngAfterViewInit.call(this);
            this.verticalScrollContainer.getScroll().addEventListener('scroll', this.hg_verticalScrollHandler.bind(this));
            this.headerContainer.getScroll().addEventListener('scroll', this.hg_horizontalScrollHandler.bind(this));
            this.verticalScrollContainer.onBeforeViewDestroyed.pipe(operators.takeUntil(this.destroy$)).subscribe(function (view) {
                var rowData = view.context.$implicit;
                if (_this.isChildGridRecord(rowData)) {
                    var cachedData = _this.childGridTemplates.get(rowData.rowID);
                    if (cachedData) {
                        var tmlpOutlet = cachedData.owner;
                        tmlpOutlet._viewContainerRef.detach(0);
                    }
                }
            });
            if (this.parent) {
                this._displayDensity = this.rootGrid._displayDensity;
                this.rootGrid.onDensityChanged.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                    _this._displayDensity = _this.rootGrid._displayDensity;
                    _this.notifyChanges(true);
                    _this.cdr.markForCheck();
                });
                this.childLayoutKeys = this.parentIsland.children.map(function (item) { return item.key; });
            }
            this.toolbarCustomContentTemplates = this.parentIsland ?
                this.parentIsland.toolbarCustomContentTemplates :
                this.toolbarCustomContentTemplates;
            this.headSelectorsTemplates = this.parentIsland ?
                this.parentIsland.headSelectorsTemplates :
                this.headSelectorsTemplates;
            this.rowSelectorsTemplates = this.parentIsland ?
                this.parentIsland.rowSelectorsTemplates :
                this.rowSelectorsTemplates;
            this.dragIndicatorIconTemplate = this.parentIsland ?
                this.parentIsland.dragIndicatorIconTemplate :
                this.dragIndicatorIconTemplate;
            this.rowExpandedIndicatorTemplate = this.rootGrid.rowExpandedIndicatorTemplate;
            this.rowCollapsedIndicatorTemplate = this.rootGrid.rowCollapsedIndicatorTemplate;
            this.headerCollapseIndicatorTemplate = this.rootGrid.headerCollapseIndicatorTemplate;
            this.headerExpandIndicatorTemplate = this.rootGrid.headerExpandIndicatorTemplate;
            this.hasChildrenKey = this.parentIsland ?
                this.parentIsland.hasChildrenKey || this.rootGrid.hasChildrenKey :
                this.rootGrid.hasChildrenKey;
            this.showExpandAll = this.parentIsland ?
                this.parentIsland.showExpandAll : this.rootGrid.showExpandAll;
        };
        IgxHierarchicalGridComponent.prototype.updateSizes = function () {
            if (document.body.contains(this.nativeElement) && this.isPercentWidth) {
                this.reflow();
                this.hgridAPI.getChildGrids(false).forEach(function (grid) {
                    grid.updateSizes();
                });
            }
        };
        IgxHierarchicalGridComponent.prototype._shouldAutoSize = function (renderedHeight) {
            if (this.isPercentHeight && this.parent) {
                return true;
            }
            return _super.prototype._shouldAutoSize.call(this, renderedHeight);
        };
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "outletDirective", {
            get: function () {
                return this.rootGrid._outletDirective;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.updateColumnList(false);
            this.childLayoutKeys = this.parent ?
                this.parentIsland.children.map(function (item) { return item.key; }) :
                this.childLayoutKeys = this.childLayoutList.map(function (item) { return item.key; });
            this.childLayoutList.notifyOnChanges();
            this.childLayoutList.changes.pipe(operators.takeUntil(this.destroy$)).subscribe(function () {
                return _this.onRowIslandChange();
            });
            _super.prototype.ngAfterContentInit.call(this);
        };
        /** @hidden */
        IgxHierarchicalGridComponent.prototype.featureColumnsWidth = function () {
            return _super.prototype.featureColumnsWidth.call(this, this.headerHierarchyExpander);
        };
        /**
        * @hidden
        */
        IgxHierarchicalGridComponent.prototype.onRowIslandChange = function () {
            if (this.parent) {
                this.childLayoutKeys = this.parentIsland.children.filter(function (item) { return !item._destroyed; }).map(function (item) { return item.key; });
            }
            else {
                this.childLayoutKeys = this.childLayoutList.filter(function (item) { return !item._destroyed; }).map(function (item) { return item.key; });
            }
            if (!this.cdr.destroyed) {
                this.cdr.detectChanges();
            }
        };
        IgxHierarchicalGridComponent.prototype.onColumnsChanged = function (change) {
            var _this = this;
            this.updateColumnList();
            var cols = change.filter(function (c) { return c.gridAPI.grid === _this; });
            if (cols.length > 0 || this.autoGenerate) {
                this.columnList.reset(cols);
                _super.prototype.onColumnsChanged.call(this, this.columnList);
            }
        };
        IgxHierarchicalGridComponent.prototype.updateColumnList = function (recalcColSizes) {
            if (recalcColSizes === void 0) { recalcColSizes = true; }
            var childLayouts = this.parent ? this.childLayoutList : this.allLayoutList;
            var nestedColumns = childLayouts.map(function (layout) {
                return layout.columnList.toArray();
            });
            var colsArray = [].concat.apply([], nestedColumns);
            var colLength = this.columnList.length;
            if (colsArray.length > 0) {
                var topCols = this.columnList.filter(function (item) {
                    return colsArray.indexOf(item) === -1;
                });
                this.columnList.reset(topCols);
                if (recalcColSizes && this.columnList.length !== colLength) {
                    this.calculateGridSizes(false);
                }
            }
        };
        IgxHierarchicalGridComponent.prototype.ngOnDestroy = function () {
            if (!this.parent) {
                this.hgridAPI.getChildGrids(true).forEach(function (grid) {
                    if (!grid.childRow.cdr.destroyed) {
                        grid.childRow.cdr.destroy();
                    }
                });
            }
            if (this.parent && this.selectionService.activeElement) {
                // in case selection is in destroyed child grid, selection should be cleared.
                this._clearSeletionHighlights();
            }
            _super.prototype.ngOnDestroy.call(this);
        };
        IgxHierarchicalGridComponent.prototype._clearSeletionHighlights = function () {
            __spread([this.rootGrid], this.rootGrid.getChildGrids(true)).forEach(function (grid) {
                grid.selectionService.clear();
                grid.selectionService.activeElement = null;
                grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
                grid.highlightedRowID = null;
                grid.cdr.markForCheck();
            });
        };
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "template", {
            /**
            * @hidden
            */
            get: function () {
                if (this.filteredData && this.filteredData.length === 0) {
                    return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
                }
                if (this.isLoading && (!this.data || this.dataLength === 0)) {
                    return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
                }
                if (this.dataLength === 0) {
                    return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.isRowHighlighted = function (rowData) {
            return this.highlightedRowID === rowData.rowID;
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.isHierarchicalRecord = function (record) {
            return this.childLayoutList.length !== 0 && record[this.childLayoutList.first.key];
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.isChildGridRecord = function (record) {
            // Can be null when there is defined layout but no child data was found
            return record.childGridsData !== undefined;
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.trackChanges = function (index, rec) {
            if (rec.childGridsData !== undefined) {
                // if is child rec
                return rec.rowID;
            }
            return rec;
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.getContext = function (rowData) {
            if (this.isChildGridRecord(rowData)) {
                var cachedData = this.childGridTemplates.get(rowData.rowID);
                if (cachedData) {
                    var view = cachedData.view;
                    var tmlpOutlet = cachedData.owner;
                    return {
                        $implicit: rowData,
                        moveView: view,
                        owner: tmlpOutlet,
                        index: this.dataView.indexOf(rowData)
                    };
                }
                else {
                    var rowID = this.primaryKey ? rowData.rowID : this.data.indexOf(rowData.rowID);
                    // child rows contain unique grids, hence should have unique templates
                    return {
                        $implicit: rowData,
                        templateID: 'childRow-' + rowID,
                        index: this.dataView.indexOf(rowData)
                    };
                }
            }
            else {
                return {
                    $implicit: rowData,
                    templateID: 'dataRow',
                    index: this.dataView.indexOf(rowData)
                };
            }
        };
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "rootGrid", {
            /**
             * @hidden
            */
            get: function () {
                var currGrid = this;
                while (currGrid.parent) {
                    currGrid = currGrid.parent;
                }
                return currGrid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalGridComponent.prototype, "iconTemplate", {
            /**
             * @hidden
            */
            get: function () {
                var expanded = this.hasExpandedRecords() && this.hasExpandableChildren;
                if (!expanded && this.showExpandAll) {
                    return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
                }
                else {
                    return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxHierarchicalGridComponent.prototype.getDragGhostCustomTemplate = function () {
            if (this.parentIsland) {
                return this.parentIsland.getDragGhostCustomTemplate();
            }
            return _super.prototype.getDragGhostCustomTemplate.call(this);
        };
        /**
         * @hidden
        */
        IgxHierarchicalGridComponent.prototype.initColumns = function (collection, cb) {
            if (cb === void 0) { cb = null; }
            if (this.hasColumnLayouts) {
                // invalid configuration - hierarchical grid should not allow column layouts
                // remove column layouts
                var nonColumnLayoutColumns = this.columnList.filter(function (col) { return !col.columnLayout && !col.columnLayoutChild; });
                this.columnList.reset(nonColumnLayoutColumns);
            }
            _super.prototype.initColumns.call(this, collection, cb);
        };
        /**
         * @hidden
         * Gets the visible content height that includes header + tbody + footer.
         * For hierarchical child grid it may be scrolled and not fully visible.
         */
        IgxHierarchicalGridComponent.prototype.getVisibleContentHeight = function () {
            var height = _super.prototype.getVisibleContentHeight.call(this);
            if (this.parent) {
                var rootHeight = this.rootGrid.getVisibleContentHeight();
                var topDiff = this.nativeElement.getBoundingClientRect().top - this.rootGrid.nativeElement.getBoundingClientRect().top;
                height = rootHeight - topDiff > height ? height : rootHeight - topDiff;
            }
            return height;
        };
        /**
         * @hidden
        */
        IgxHierarchicalGridComponent.prototype.toggleAll = function () {
            var expanded = this.hasExpandedRecords() && this.hasExpandableChildren;
            if (!expanded && this.showExpandAll) {
                this.expandAll();
            }
            else {
                this.collapseAll();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxHierarchicalGridComponent.prototype.hasExpandedRecords = function () {
            if (this.expandChildren) {
                return true;
            }
            var hasExpandedEntry = false;
            this.expansionStates.forEach(function (value, key) {
                if (value) {
                    hasExpandedEntry = value;
                }
            });
            return hasExpandedEntry;
        };
        IgxHierarchicalGridComponent.prototype.getDefaultExpandState = function (record) {
            return this.expandChildren;
        };
        /**
        * @hidden
        */
        IgxHierarchicalGridComponent.prototype.isExpanded = function (record) {
            return this.gridAPI.get_row_expansion_state(record);
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.viewCreatedHandler = function (args) {
            if (this.isChildGridRecord(args.context.$implicit)) {
                var key = args.context.$implicit.rowID;
                this.childGridTemplates.set(key, args);
            }
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.viewMovedHandler = function (args) {
            var _this = this;
            if (this.isChildGridRecord(args.context.$implicit)) {
                // view was moved, update owner in cache
                var key = args.context.$implicit.rowID;
                var cachedData = this.childGridTemplates.get(key);
                cachedData.owner = args.owner;
                this.childLayoutList.forEach(function (layout) {
                    var relatedGrid = _this.hgridAPI.getChildGridByID(layout.key, args.context.$implicit.rowID);
                    if (relatedGrid && relatedGrid.updateOnRender) {
                        // Detect changes if `expandChildren` has changed when the grid wasn't visible. This is for performance reasons.
                        relatedGrid.notifyChanges(true);
                        relatedGrid.updateOnRender = false;
                    }
                });
                var childGrids = this.getChildGrids(true);
                childGrids.forEach(function (grid) {
                    if (grid.isPercentWidth) {
                        grid.notifyChanges(true);
                    }
                    grid.updateScrollPosition();
                });
            }
        };
        /**
         * @hidden
         */
        IgxHierarchicalGridComponent.prototype.updateScrollPosition = function () {
            var vScr = this.verticalScrollContainer.getScroll();
            var hScr = this.headerContainer.getScroll();
            if (vScr) {
                vScr.scrollTop = this.scrollTop;
            }
            if (hScr) {
                hScr.scrollLeft = this.scrollLeft;
            }
        };
        IgxHierarchicalGridComponent.prototype.getChildGrids = function (inDeph) {
            return this.hgridAPI.getChildGrids(inDeph);
        };
        IgxHierarchicalGridComponent.prototype.generateDataFields = function (data) {
            var _this = this;
            return _super.prototype.generateDataFields.call(this, data).filter(function (field) {
                var layoutsList = _this.parentIsland ? _this.parentIsland.children : _this.childLayoutList;
                var keys = layoutsList.map(function (item) { return item.key; });
                return keys.indexOf(field) === -1;
            });
        };
        IgxHierarchicalGridComponent.prototype.hg_verticalScrollHandler = function (event) {
            this.scrollTop = event.target.scrollTop;
        };
        IgxHierarchicalGridComponent.prototype.onContainerScroll = function () {
            this.hideOverlays();
        };
        IgxHierarchicalGridComponent.prototype.hg_horizontalScrollHandler = function (event) {
            this.scrollLeft = event.target.scrollLeft;
        };
        var IgxHierarchicalGridComponent_1;
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxHierarchicalGridComponent.prototype, "id", null);
        __decorate([
            core.Input()
        ], IgxHierarchicalGridComponent.prototype, "data", null);
        __decorate([
            core.Input(),
            DeprecateProperty("'hierarchicalState' property is deprecated. Use 'expansionStates' instead.")
        ], IgxHierarchicalGridComponent.prototype, "hierarchicalState", null);
        __decorate([
            core.Output(),
            DeprecateProperty("'hierarchicalStateChange' @Output property is deprecated. Use 'expansionStates' instead.")
        ], IgxHierarchicalGridComponent.prototype, "hierarchicalStateChange", void 0);
        __decorate([
            core.Input()
        ], IgxHierarchicalGridComponent.prototype, "expandChildren", null);
        __decorate([
            core.ContentChildren(IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false })
        ], IgxHierarchicalGridComponent.prototype, "childLayoutList", void 0);
        __decorate([
            core.ContentChildren(IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: true })
        ], IgxHierarchicalGridComponent.prototype, "allLayoutList", void 0);
        __decorate([
            core.ViewChild('hierarchical_record_template', { read: core.TemplateRef, static: true })
        ], IgxHierarchicalGridComponent.prototype, "hierarchicalRecordTemplate", void 0);
        __decorate([
            core.ViewChild('child_record_template', { read: core.TemplateRef, static: true })
        ], IgxHierarchicalGridComponent.prototype, "childTemplate", void 0);
        __decorate([
            core.ViewChild('headerHierarchyExpander', { read: core.ElementRef, static: true })
        ], IgxHierarchicalGridComponent.prototype, "headerHierarchyExpander", void 0);
        __decorate([
            core.ViewChildren(IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective })
        ], IgxHierarchicalGridComponent.prototype, "templateOutlets", void 0);
        __decorate([
            core.ViewChildren(IgxChildGridRowComponent, { read: IgxChildGridRowComponent })
        ], IgxHierarchicalGridComponent.prototype, "hierarchicalRows", void 0);
        IgxHierarchicalGridComponent = IgxHierarchicalGridComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid',
                template: "<igx-grid-toolbar role=\"rowgroup\" [style.max-width.px]='outerWidth' [style.flex-basis.px]=\"outerWidth\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <div #headerHierarchyExpander (click)=\"toggleAll()\" [hidden]='!hasExpandableChildren || !hasVisibleColumns' [ngClass]=\"{\n                'igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header': hasExpandableChildren,\n                'igx-grid__hierarchical-expander--push': filteringService.isFilterRowVisible,\n                'igx-grid__hierarchical-expander--no-border': isRowSelectable || rowDraggable\n            }\">\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n            </div>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                        'igx-grid__drag-indicator--header': !isRowSelectable\n                    }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                        'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                    }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter,\n                                        selectAll: selectAllRows.bind(this),\n                                        deselectAll: deselectAllRows.bind(this) }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" role=\"rowgroup\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridHierarchicalPaging:page:perPage:id:pipeTrigger\n        | gridHierarchical:expansionStates:id:primaryKey:childLayoutKeys:pipeTrigger\" let-rowIndex=\"index\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #hierarchical_record_template>\n                <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n                </igx-hierarchical-grid-row>\n            </ng-template>\n            <ng-template #child_record_template let-rowIndex=\"index\" let-rowData>\n                <div style=\"overflow:auto;width: 100%;\" [attr.data-rowindex]='rowIndex' (scroll)='onContainerScroll()'\n                    [ngClass]=\"{\n                    'igx-grid__tr-container': true,\n                    'igx-grid__tr--highlighted':isRowHighlighted(rowData)\n                }\">\n                    <igx-child-grid-row *ngFor=\"let layout of childLayoutList\" [parentGridID]=\"id\" [index]=\"rowIndex\"\n                        [rowData]=\"rowData\" [layout]='layout' #row>\n                    </igx-child-grid-row>\n                </div>\n            </ng-template>\n            <ng-template\n            [igxTemplateOutlet]='(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template))'\n            [igxTemplateOutletContext]='getContext(rowData)' (onViewCreated)='viewCreatedHandler($event)'\n            (onViewMoved)='viewMovedHandler($event)' (onCachedViewLoaded)='cachedViewLoaded($event)'\n            (onBeforeViewDetach)='viewDetachHandler($event)'></ng-template>\n            <!-- <ng-container *igxTemplateOutlet=\"(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template)); context: getContext(rowData)\"></ng-container> -->\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n            id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" fontSet=\"material\">unfold_more</igx-icon>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" [isActive]='hasExpandedRecords() && hasExpandableChildren' fontSet=\"material\">unfold_less</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n",
                providers: [
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxHierarchicalGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: core.forwardRef(function () { return IgxHierarchicalGridComponent_1; }) },
                    IgxGridSummaryService,
                    IgxFilteringService,
                    IgxHierarchicalGridNavigationService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService,
                    IgxRowIslandAPIService
                ]
            })
        ], IgxHierarchicalGridComponent);
        return IgxHierarchicalGridComponent;
    }(IgxHierarchicalGridBaseDirective));

    var IgxHierarchicalGridCellComponent = /** @class */ (function (_super) {
        __extends(IgxHierarchicalGridCellComponent, _super);
        function IgxHierarchicalGridCellComponent(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil) {
            var _this = _super.call(this, selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil) || this;
            _this.selectionService = selectionService;
            _this.crudService = crudService;
            _this.gridAPI = gridAPI;
            _this.cdr = cdr;
            _this.helement = helement;
            _this.zone = zone;
            _this.platformUtil = platformUtil;
            return _this;
        }
        IgxHierarchicalGridCellComponent.prototype.ngOnInit = function () {
            _super.prototype.ngOnInit.call(this);
            this._rootGrid = this._getRootGrid();
        };
        IgxHierarchicalGridCellComponent.prototype._getRootGrid = function () {
            var currGrid = this.grid;
            while (currGrid.parent) {
                currGrid = currGrid.parent;
            }
            return currGrid;
        };
        // TODO: Extend the new selection service to avoid complete traversal
        IgxHierarchicalGridCellComponent.prototype._clearAllHighlights = function () {
            __spread([this._rootGrid], this._rootGrid.getChildGrids(true)).forEach(function (grid) {
                grid.selectionService.clear();
                grid.selectionService.activeElement = null;
                grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
                grid.highlightedRowID = null;
                grid.cdr.markForCheck();
            });
        };
        /**
         * @hidden
         * @internal
         */
        IgxHierarchicalGridCellComponent.prototype.onFocus = function (event) {
            if (this.focused) {
                return;
            }
            this._clearAllHighlights();
            var currentElement = this.grid.nativeElement;
            var parentGrid = this.grid;
            var childGrid;
            // add highligh to the current grid
            if (this._rootGrid.id !== currentElement.id) {
                currentElement.classList.add('igx-grid__tr--highlighted');
            }
            // add highligh to the current grid
            while (this._rootGrid.id !== parentGrid.id) {
                childGrid = parentGrid;
                parentGrid = parentGrid.parent;
                var parentRowID = parentGrid.hgridAPI.getParentRowId(childGrid);
                parentGrid.highlightedRowID = parentRowID;
            }
            _super.prototype.onFocus.call(this, event);
        };
        // TODO: Refactor
        /**
         * @hidden
         * @internal
         */
        IgxHierarchicalGridCellComponent.prototype.dispatchEvent = function (event) {
            var key = event.key.toLowerCase();
            if (event.altKey && !this.row.added) {
                var collapse = this.row.expanded && (key === 'left' || key === 'arrowleft' || key === 'up' || key === 'arrowup');
                var expand = !this.row.expanded && (key === 'right' || key === 'arrowright' || key === 'down' || key === 'arrowdown');
                if (collapse) {
                    this.gridAPI.set_row_expansion_state(this.row.rowID, false, event);
                }
                else if (expand) {
                    this.gridAPI.set_row_expansion_state(this.row.rowID, true, event);
                }
                return;
            }
            _super.prototype.dispatchEvent.call(this, event);
        };
        IgxHierarchicalGridCellComponent.ctorParameters = function () { return [
            { type: IgxGridSelectionService },
            { type: IgxGridCRUDService },
            { type: GridBaseAPIService },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: HammerGesturesManager },
            { type: PlatformUtil }
        ]; };
        __decorate([
            core.HostListener('focus', ['$event'])
        ], IgxHierarchicalGridCellComponent.prototype, "onFocus", null);
        IgxHierarchicalGridCellComponent = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid-cell',
                template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\"\n            [igxFocus]=\"focused\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n            [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n",
                providers: [HammerGesturesManager]
            })
        ], IgxHierarchicalGridCellComponent);
        return IgxHierarchicalGridCellComponent;
    }(IgxGridCellComponent));

    var IgxHierarchicalRowComponent = /** @class */ (function (_super) {
        __extends(IgxHierarchicalRowComponent, _super);
        function IgxHierarchicalRowComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @hidden
             */
            _this.tabindex = 0;
            /**
             * @hidden
             * @internal
             */
            _this.select = function () {
                _this.grid.selectRows([_this.rowID]);
            };
            /**
             * @hidden
             * @internal
             */
            _this.deselect = function () {
                _this.grid.deselectRows([_this.rowID]);
            };
            return _this;
        }
        IgxHierarchicalRowComponent_1 = IgxHierarchicalRowComponent;
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "viewIndex", {
            get: function () {
                return this.index + this.grid.page * this.grid.perPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "expanded", {
            /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
            get: function () {
                return this.gridAPI.get_row_expansion_state(this.rowData);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "hasChildren", {
            get: function () {
                return !!this.grid.childLayoutKeys.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "highlighted", {
            /**
             * @hidden
             */
            get: function () {
                return this.grid && this.grid.highlightedRowID === this.rowID;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * @hidden
        */
        IgxHierarchicalRowComponent.prototype.expanderClick = function (event) {
            event.stopPropagation();
            this.toggle();
        };
        /**
         * Toggles the hierarchical row.
         * ```typescript
         * this.grid1.rowList.first.toggle()
         * ```
         */
        IgxHierarchicalRowComponent.prototype.toggle = function () {
            if (this.added) {
                return;
            }
            var grid = this.gridAPI.grid;
            this.endEdit(grid.rootGrid);
            this.gridAPI.set_row_expansion_state(this.rowID, !this.expanded);
            grid.cdr.detectChanges();
        };
        Object.defineProperty(IgxHierarchicalRowComponent.prototype, "iconTemplate", {
            /**
            * @hidden
            */
            get: function () {
                var expandable = true;
                if (this.grid.hasChildrenKey) {
                    expandable = this.rowData[this.grid.hasChildrenKey];
                }
                if (!expandable) {
                    return this.defaultEmptyTemplate;
                }
                if (this.expanded) {
                    return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
                }
                else {
                    return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxHierarchicalRowComponent.prototype.endEdit = function (grid) {
            if (grid.crudService.inEditMode) {
                grid.endEdit();
            }
            grid.hgridAPI.getChildGrids(true).forEach(function (g) {
                if (g.crudService.inEditMode) {
                    g.endEdit();
                }
            });
        };
        var IgxHierarchicalRowComponent_1;
        __decorate([
            core.ViewChildren(core.forwardRef(function () { return IgxHierarchicalGridCellComponent; }), { read: IgxHierarchicalGridCellComponent })
        ], IgxHierarchicalRowComponent.prototype, "cells", void 0);
        __decorate([
            core.ViewChild('expander', { read: core.ElementRef })
        ], IgxHierarchicalRowComponent.prototype, "expander", void 0);
        __decorate([
            core.ViewChild('defaultExpandedTemplate', { read: core.TemplateRef, static: true })
        ], IgxHierarchicalRowComponent.prototype, "defaultExpandedTemplate", void 0);
        __decorate([
            core.ViewChild('defaultEmptyTemplate', { read: core.TemplateRef, static: true })
        ], IgxHierarchicalRowComponent.prototype, "defaultEmptyTemplate", void 0);
        __decorate([
            core.ViewChild('defaultCollapsedTemplate', { read: core.TemplateRef, static: true })
        ], IgxHierarchicalRowComponent.prototype, "defaultCollapsedTemplate", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxHierarchicalRowComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('class.igx-grid__tr--expanded')
        ], IgxHierarchicalRowComponent.prototype, "expanded", null);
        __decorate([
            core.HostBinding('class.igx-grid__tr--highlighted')
        ], IgxHierarchicalRowComponent.prototype, "highlighted", null);
        IgxHierarchicalRowComponent = IgxHierarchicalRowComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid-row',
                template: "<div (click)=\"expanderClick($event)\" class=\"igx-grid__hierarchical-expander\" [tabIndex]=\"tabindex\" *ngIf=\"hasChildren\" #expander>\n        <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n        </ng-container>\n</div>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon [isActive]='!added' fontSet=\"material\">expand_more</igx-icon>\n    </ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon [isActive]='!added' fontSet=\"material\">chevron_right</igx-icon>\n </ng-template>\n\n <ng-template #defaultEmptyTemplate>\n    <igx-icon fontSet=\"material\"></igx-icon>\n</ng-template>\n\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n            <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: {\n                            index: viewIndex,\n                            rowID: rowID,\n                            selected: selected,\n                            select: select,\n                            deselect: deselect }}\">\n        </ng-template>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"pinnedColumns.length > 0\">\n    <igx-hierarchical-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.isLastPinned\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\">\n    </igx-hierarchical-grid-cell>\n</ng-container>\n\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"' [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-hierarchical-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\">\n    </igx-hierarchical-grid-cell>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            disableRipple=\"true\"\n            [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n",
                providers: [{ provide: IgxRowDirective, useExisting: core.forwardRef(function () { return IgxHierarchicalRowComponent_1; }) }]
            })
        ], IgxHierarchicalRowComponent);
        return IgxHierarchicalRowComponent;
    }(IgxRowDirective));

    /**
     *@hidden
     */
    var IgxGridHierarchicalPipe = /** @class */ (function () {
        function IgxGridHierarchicalPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridHierarchicalPipe.prototype.transform = function (collection, state, id, primaryKey, childKeys, pipeTrigger) {
            if (state === void 0) { state = new Map(); }
            if (childKeys.length === 0) {
                return collection;
            }
            var grid = this.gridAPI.grid;
            var result = this.addHierarchy(grid, cloneArray(collection), state, primaryKey, childKeys);
            return result;
        };
        IgxGridHierarchicalPipe.prototype.addHierarchy = function (grid, data, state, primaryKey, childKeys) {
            var result = [];
            data.forEach(function (v) {
                result.push(v);
                var childGridsData = {};
                childKeys.forEach(function (childKey) {
                    var childData = v[childKey] ? v[childKey] : null;
                    childGridsData[childKey] = childData;
                });
                if (grid.gridAPI.get_row_expansion_state(v)) {
                    result.push({ rowID: primaryKey ? v[primaryKey] : v, childGridsData: childGridsData });
                }
            });
            return result;
        };
        IgxGridHierarchicalPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxGridHierarchicalPipe = __decorate([
            core.Pipe({
                name: 'gridHierarchical',
                pure: true
            })
        ], IgxGridHierarchicalPipe);
        return IgxGridHierarchicalPipe;
    }());
    /**
     *@hidden
     */
    var IgxGridHierarchicalPagingPipe = /** @class */ (function () {
        function IgxGridHierarchicalPagingPipe(gridAPI) {
            this.gridAPI = gridAPI;
        }
        IgxGridHierarchicalPagingPipe.prototype.transform = function (collection, page, perPage, id, pipeTrigger) {
            if (page === void 0) { page = 0; }
            if (perPage === void 0) { perPage = 15; }
            if (!this.gridAPI.grid.paging) {
                return collection;
            }
            var state = {
                index: page,
                recordsPerPage: perPage
            };
            var result = DataUtil.page(cloneArray(collection), state);
            this.gridAPI.grid.pagingState = state;
            return result;
        };
        IgxGridHierarchicalPagingPipe.ctorParameters = function () { return [
            { type: GridBaseAPIService }
        ]; };
        IgxGridHierarchicalPagingPipe = __decorate([
            core.Pipe({
                name: 'gridHierarchicalPaging',
                pure: true
            })
        ], IgxGridHierarchicalPagingPipe);
        return IgxGridHierarchicalPagingPipe;
    }());

    /**
     * @hidden
     */
    var IgxHierarchicalGridModule = /** @class */ (function () {
        function IgxHierarchicalGridModule() {
        }
        IgxHierarchicalGridModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxHierarchicalGridBaseDirective,
                    IgxHierarchicalGridComponent,
                    IgxHierarchicalRowComponent,
                    IgxRowIslandComponent,
                    IgxChildGridRowComponent,
                    IgxHierarchicalGridCellComponent,
                    IgxGridHierarchicalPipe,
                    IgxGridHierarchicalPagingPipe
                ],
                exports: [
                    IgxGridModule,
                    IgxHierarchicalGridComponent,
                    IgxHierarchicalRowComponent,
                    IgxHierarchicalGridCellComponent,
                    IgxRowIslandComponent,
                    IgxChildGridRowComponent
                ],
                imports: [
                    IgxGridModule,
                ],
                entryComponents: [
                    IgxGridComponent
                ]
            })
        ], IgxHierarchicalGridModule);
        return IgxHierarchicalGridModule;
    }());

    /**
     * IgxActionIcon is a container for the action nav icon of the IgxNavbar.
     */
    var IgxActionIconDirective = /** @class */ (function () {
        function IgxActionIconDirective() {
        }
        IgxActionIconDirective = __decorate([
            core.Directive({
                // tslint:disable-next-line:directive-selector
                selector: 'igx-action-icon'
            })
        ], IgxActionIconDirective);
        return IgxActionIconDirective;
    }());
    var NEXT_ID$p = 0;
    /**
     * **Ignite UI for Angular Navbar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navbar.html)
     *
     * The Ignite UI Navbar is most commonly used to provide an app header with a hamburger menu and navigation
     * state such as a "Go Back" button. It also supports other actions represented by icons.
     *
     * Example:
     * ```html
     * <igx-navbar title="Sample App" actionButtonIcon="menu">
     *   <igx-icon>search</igx-icon>
     *   <igx-icon>favorite</igx-icon>
     *   <igx-icon>more_vert</igx-icon>
     * </igx-navbar>
     * ```
     */
    var IgxNavbarComponent = /** @class */ (function () {
        function IgxNavbarComponent() {
            this.isVisible = true;
            /**
             *An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
             *```html
             *<igx-navbar [id]="'igx-navbar-12'" title="Sample App" actionButtonIcon="menu">
             *```
             */
            this.id = "igx-navbar-" + NEXT_ID$p++;
            /**
             *The event that will be thrown when the action is executed,
             *provides reference to the `IgxNavbar` component as argument
             *```typescript
             *public actionExc(event){
             *    alert("Action Execute!");
             *}
             * //..
             *```
             *```html
             *<igx-navbar (onAction)="actionExc($event)" title="Sample App" actionButtonIcon="menu">
             *```
             */
            this.onAction = new core.EventEmitter();
            /**
             *An @Input property that sets the titleId of the `IgxNavbarComponent`. If not set it will be automatically generated.
             *```html
             *<igx-navbar [titleId]="'igx-navbar-7'" title="Sample App" actionButtonIcon="menu">
             *```
             */
            this.titleId = "igx-navbar-" + IgxNavbarComponent_1.NEXT_ID++;
        }
        IgxNavbarComponent_1 = IgxNavbarComponent;
        Object.defineProperty(IgxNavbarComponent.prototype, "isActionButtonVisible", {
            /**
             *Returns whether the `IgxNavbarComponent` action button is visible, true/false.
             *```typescript
             *@ViewChild("MyChild")
             *public navBar: IgxNavbarComponent;
             *ngAfterViewInit(){
             *    let actionButtonVisibile = this.navBar.isActionButtonVisible;
             *}
             *```
             */
            get: function () {
                if (this.actionIconTemplate || !this.actionButtonIcon) {
                    return false;
                }
                return this.isVisible;
            },
            /**
             *Sets whether the action button of the `IgxNavbarComponent` is visible.
             *```html
             *<igx-navbar [title]="currentView" [isActionButtonVisible]="'false'"></igx-navbar>
             *```
             */
            set: function (value) {
                this.isVisible = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxNavbarComponent.prototype._triggerAction = function () {
            this.onAction.emit(this);
        };
        var IgxNavbarComponent_1;
        IgxNavbarComponent.NEXT_ID = 1;
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxNavbarComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxNavbarComponent.prototype, "isActionButtonVisible", null);
        __decorate([
            core.Input()
        ], IgxNavbarComponent.prototype, "actionButtonIcon", void 0);
        __decorate([
            core.Input()
        ], IgxNavbarComponent.prototype, "title", void 0);
        __decorate([
            core.Output()
        ], IgxNavbarComponent.prototype, "onAction", void 0);
        __decorate([
            core.Input()
        ], IgxNavbarComponent.prototype, "titleId", void 0);
        __decorate([
            core.ContentChild(IgxActionIconDirective, { read: IgxActionIconDirective })
        ], IgxNavbarComponent.prototype, "actionIconTemplate", void 0);
        IgxNavbarComponent = IgxNavbarComponent_1 = __decorate([
            core.Component({
                selector: 'igx-navbar',
                template: "<nav class=\"igx-navbar\" role=\"navigation\" [attr.aria-labelledby]=\"titleId\">\n    <div class=\"igx-navbar__left\">\n        <igx-icon (click)=\"_triggerAction()\" fontSet=\"material\" *ngIf=\"isActionButtonVisible\">{{actionButtonIcon}}</igx-icon>\n        <ng-content select=\"igx-action-icon\"></ng-content>\n        <h1 class=\"igx-navbar__title\" [attr.id]=\"titleId\">{{ title }}</h1>\n    </div>\n    <div class=\"igx-navbar__right\">\n        <ng-content></ng-content>\n    </div>\n</nav>\n",
                styles: ["\n        :host {\n            display: block;\n        }\n    "]
            })
        ], IgxNavbarComponent);
        return IgxNavbarComponent;
    }());
    /**
     * @hidden
     */
    var IgxNavbarModule = /** @class */ (function () {
        function IgxNavbarModule() {
        }
        IgxNavbarModule = __decorate([
            core.NgModule({
                declarations: [IgxNavbarComponent, IgxActionIconDirective],
                exports: [IgxNavbarComponent, IgxActionIconDirective],
                imports: [IgxButtonModule, IgxIconModule, common.CommonModule]
            })
        ], IgxNavbarModule);
        return IgxNavbarModule;
    }());

    var IgxNavDrawerItemDirective = /** @class */ (function () {
        function IgxNavDrawerItemDirective() {
            /**
             * @hidden
             */
            this.active = false;
            /**
             * @hidden
             */
            this.isHeader = false;
            /**
             * @hidden
             */
            this.activeClass = 'igx-nav-drawer__item--active';
        }
        Object.defineProperty(IgxNavDrawerItemDirective.prototype, "defaultCSS", {
            /**
             * @hidden
             */
            get: function () {
                return !this.active && !this.isHeader;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavDrawerItemDirective.prototype, "currentCSS", {
            /**
             * @hidden
             */
            get: function () {
                return this.active && !this.isHeader;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavDrawerItemDirective.prototype, "headerCSS", {
            /**
             * @hidden
             */
            get: function () {
                return this.isHeader;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            core.Input('active')
        ], IgxNavDrawerItemDirective.prototype, "active", void 0);
        __decorate([
            core.Input('isHeader')
        ], IgxNavDrawerItemDirective.prototype, "isHeader", void 0);
        __decorate([
            core.HostBinding('class.igx-nav-drawer__item')
        ], IgxNavDrawerItemDirective.prototype, "defaultCSS", null);
        __decorate([
            core.HostBinding('class.igx-nav-drawer__item--active')
        ], IgxNavDrawerItemDirective.prototype, "currentCSS", null);
        __decorate([
            core.HostBinding('class.igx-nav-drawer__item--header')
        ], IgxNavDrawerItemDirective.prototype, "headerCSS", null);
        IgxNavDrawerItemDirective = __decorate([
            core.Directive({
                selector: '[igxDrawerItem]',
                exportAs: 'igxDrawerItem'
            })
        ], IgxNavDrawerItemDirective);
        return IgxNavDrawerItemDirective;
    }());
    var IgxNavDrawerTemplateDirective = /** @class */ (function () {
        function IgxNavDrawerTemplateDirective(template) {
            this.template = template;
        }
        IgxNavDrawerTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxNavDrawerTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxDrawer]'
            })
        ], IgxNavDrawerTemplateDirective);
        return IgxNavDrawerTemplateDirective;
    }());
    var IgxNavDrawerMiniTemplateDirective = /** @class */ (function () {
        function IgxNavDrawerMiniTemplateDirective(template) {
            this.template = template;
        }
        IgxNavDrawerMiniTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxNavDrawerMiniTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxDrawerMini]'
            })
        ], IgxNavDrawerMiniTemplateDirective);
        return IgxNavDrawerMiniTemplateDirective;
    }());

    var NEXT_ID$q = 0;
    /**
     * **Ignite UI for Angular Navigation Drawer** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer.html)
     *
     * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
     *
     * Example:
     * ```html
     * <igx-nav-drawer id="navigation" [isOpen]="true">
     *   <ng-template igxDrawer>
     *     <nav>
     *       <span igxDrawerItem [isHeader]="true">Email</span>
     *       <span igxDrawerItem igxRipple>Inbox</span>
     *       <span igxDrawerItem igxRipple>Deleted</span>
     *       <span igxDrawerItem igxRipple>Sent</span>
     *     </nav>
     *   </ng-template>
     * </igx-nav-drawer>
     * ```
     */
    var IgxNavigationDrawerComponent = /** @class */ (function () {
        function IgxNavigationDrawerComponent(elementRef, _state, renderer, _touchManager, platformUtil) {
            var _this = this;
            this.elementRef = elementRef;
            this._state = _state;
            this.renderer = renderer;
            this._touchManager = _touchManager;
            this.platformUtil = platformUtil;
            this._isOpen = false;
            /** @hidden @internal */
            this.cssClass = true;
            /**
             * ID of the component
             *
             * ```typescript
             * // get
             * let myNavDrawerId = this.navdrawer.id;
             * ```
             *
             * ```html
             * <!--set-->
             *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
             * ```
             */
            this.id = "igx-nav-drawer-" + NEXT_ID$q++;
            /**
             * Position of the Navigation Drawer. Can be "left"(default) or "right".
             *
             * ```typescript
             * // get
             * let myNavDrawerPosition = this.navdrawer.position;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
             * ```
             */
            this.position = 'left';
            /**
             * Enables the use of touch gestures to manipulate the drawer:
             * - swipe/pan from edge to open, swipe-toggle and pan-drag.
             *
             * ```typescript
             * // get
             * let gesturesEnabled = this.navdrawer.enableGestures;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
             * ```
             */
            this.enableGestures = true;
            /**
             *@hidden
             */
            this.isOpenChange = new core.EventEmitter();
            /**
             * When pinned the drawer is relatively positioned instead of sitting above content.
             * May require additional layout styling.
             *
             * ```typescript
             * // get
             * let navDrawerIsPinned = this.navdrawer.pin;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
             * ```
             */
            this.pin = false;
            /**
             * Minimum device width required for automatic pin to be toggled.
             * Default is 1024, can be set to a falsy value to disable this behavior.
             *
             * ```typescript
             * // get
             * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
             * ```
             */
            this.pinThreshold = 1024;
            /**
             * Width of the drawer in its open state. Defaults to "280px".
             *
             * ```typescript
             * // get
             * let navDrawerWidth = this.navdrawer.width;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
             * ```
             */
            this.width = '280px';
            /**
             * Width of the drawer in its mini state. Defaults to 68px.
             *
             * ```typescript
             * // get
             * let navDrawerMiniWidth = this.navdrawer.miniWidth;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
             * ```
             */
            this.miniWidth = '68px';
            /**
             * Pinned state change output for two-way binding.
             *
             * ```html
             * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
             * ```
             */
            this.pinChange = new core.EventEmitter(true);
            /**
             * Event fired as the Navigation Drawer is about to open.
             *
             * ```html
             *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
             * ```
             */
            this.opening = new core.EventEmitter();
            /**
             * Event fired when the Navigation Drawer has opened.
             *
             * ```html
             * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
             * ```
             */
            this.opened = new core.EventEmitter();
            /**
             * Event fired as the Navigation Drawer is about to close.
             *
             * ```html
             * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
             * ```
             */
            this.closing = new core.EventEmitter();
            /**
             * Event fired when the Navigation Drawer has closed.
             *
             * ```html
             * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
             * ```
             */
            this.closed = new core.EventEmitter();
            this._gesturesAttached = false;
            this._widthCache = { width: null, miniWidth: null, windowWidth: null };
            this.css = {
                drawer: 'igx-nav-drawer__aside',
                mini: 'igx-nav-drawer__aside--mini',
                overlay: 'igx-nav-drawer__overlay',
                styleDummy: 'igx-nav-drawer__style-dummy'
            };
            /** Pan animation properties */
            this._panning = false;
            this._maxEdgeZone = 50;
            this.checkPinThreshold = function (evt) {
                if (!_this.platformUtil.isBrowser) {
                    return;
                }
                var windowWidth;
                if (_this.pinThreshold) {
                    windowWidth = _this.getWindowWidth();
                    if (evt && _this._widthCache.windowWidth === windowWidth) {
                        return;
                    }
                    _this._widthCache.windowWidth = windowWidth;
                    if (!_this.pin && windowWidth >= _this.pinThreshold) {
                        _this.pin = true;
                        _this.pinChange.emit(true);
                    }
                    else if (_this.pin && windowWidth < _this.pinThreshold) {
                        _this.pin = false;
                        _this.pinChange.emit(false);
                    }
                }
            };
            this.swipe = function (evt) {
                // TODO: Could also force input type: http://stackoverflow.com/a/27108052
                if (!_this.enableGestures || evt.pointerType !== 'touch') {
                    return;
                }
                // HammerJS swipe is horizontal-only by default, don't check deltaY
                var deltaX;
                var startPosition;
                if (_this.position === 'right') {
                    // when on the right use inverse of deltaX
                    deltaX = -evt.deltaX;
                    startPosition = _this.getWindowWidth() - (evt.center.x + evt.distance);
                }
                else {
                    deltaX = evt.deltaX;
                    startPosition = evt.center.x - evt.distance;
                }
                // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
                if ((_this.isOpen && deltaX < 0) ||
                    // positive deltaX from the edge:
                    (deltaX > 0 && startPosition < _this.maxEdgeZone)) {
                    _this.toggle();
                }
            };
            this.panstart = function (evt) {
                if (!_this.enableGestures || _this.pin || evt.pointerType !== 'touch') {
                    return;
                }
                var startPosition = _this.position === 'right' ? _this.getWindowWidth() - (evt.center.x + evt.distance)
                    : evt.center.x - evt.distance;
                // cache width during animation, flag to allow further handling
                if (_this.isOpen || (startPosition < _this.maxEdgeZone)) {
                    _this._panning = true;
                    _this._panStartWidth = _this.getExpectedWidth(!_this.isOpen);
                    _this._panLimit = _this.getExpectedWidth(_this.isOpen);
                    _this.renderer.addClass(_this.overlay, 'panning');
                    _this.renderer.addClass(_this.drawer, 'panning');
                }
            };
            this.pan = function (evt) {
                // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
                // get actual delta (not total session one) from event?
                // pan WILL also fire after a full swipe, only resize on flag
                if (!_this._panning) {
                    return;
                }
                var right = _this.position === 'right';
                // when on the right use inverse of deltaX
                var deltaX = right ? -evt.deltaX : evt.deltaX;
                var visibleWidth;
                var newX;
                var percent;
                visibleWidth = _this._panStartWidth + deltaX;
                if (_this.isOpen && deltaX < 0) {
                    // when visibleWidth hits limit - stop animating
                    if (visibleWidth <= _this._panLimit) {
                        return;
                    }
                    if (_this.hasAnimateWidth) {
                        percent = (visibleWidth - _this._panLimit) / (_this._panStartWidth - _this._panLimit);
                        newX = visibleWidth;
                    }
                    else {
                        percent = visibleWidth / _this._panStartWidth;
                        newX = evt.deltaX;
                    }
                    _this.setXSize(newX, percent.toPrecision(2));
                }
                else if (!_this.isOpen && deltaX > 0) {
                    // when visibleWidth hits limit - stop animating
                    if (visibleWidth >= _this._panLimit) {
                        return;
                    }
                    if (_this.hasAnimateWidth) {
                        percent = (visibleWidth - _this._panStartWidth) / (_this._panLimit - _this._panStartWidth);
                        newX = visibleWidth;
                    }
                    else {
                        percent = visibleWidth / _this._panLimit;
                        newX = (_this._panLimit - visibleWidth) * (right ? 1 : -1);
                    }
                    _this.setXSize(newX, percent.toPrecision(2));
                }
            };
            this.panEnd = function (evt) {
                if (_this._panning) {
                    var deltaX = _this.position === 'right' ? -evt.deltaX : evt.deltaX;
                    var visibleWidth = _this._panStartWidth + deltaX;
                    _this.resetPan();
                    // check if pan brought the drawer to 50%
                    if (_this.isOpen && visibleWidth <= _this._panStartWidth / 2) {
                        _this.close();
                    }
                    else if (!_this.isOpen && visibleWidth >= _this._panLimit / 2) {
                        _this.open();
                    }
                    _this._panStartWidth = null;
                }
            };
            this.toggleOpenedEvent = function (evt) {
                _this.elementRef.nativeElement.removeEventListener('transitionend', _this.toggleOpenedEvent, false);
                _this.opened.emit();
            };
            this.toggleClosedEvent = function (evt) {
                _this.elementRef.nativeElement.removeEventListener('transitionend', _this.toggleClosedEvent, false);
                _this.closed.emit();
            };
        }
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "isOpen", {
            /**
             * State of the drawer.
             *
             * ```typescript
             * // get
             * let navDrawerIsOpen = this.navdrawer.isOpen;
             * ```
             *
             * ```html
             * <!--set-->
             * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
             * ```
             *
             * Two-way data binding.
             * ```html
             * <!--set-->
             * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
             * ```
             */
            get: function () {
                return this._isOpen;
            },
            set: function (value) {
                this._isOpen = value;
                this.isOpenChange.emit(this._isOpen);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "element", {
            /**
             * Returns nativeElement of the component.
             *
             * @hidden
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "template", {
            /**
             * @hidden
             */
            get: function () {
                if (this.miniTemplate && !this.isOpen) {
                    return this.miniTemplate.template;
                }
                else if (this.contentTemplate) {
                    return this.contentTemplate.template;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "miniTemplate", {
            /**
             * @hidden
             */
            get: function () {
                return this._miniTemplate;
            },
            /**
             * @hidden
             */
            set: function (v) {
                if (!this.isOpen) {
                    this.setDrawerWidth(v ? this.miniWidth : '');
                }
                this._miniTemplate = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "flexWidth", {
            /**
             * @hidden
             */
            get: function () {
                if (!this.pin) {
                    return '0px';
                }
                if (this.isOpen) {
                    return this.width;
                }
                if (this.miniTemplate && this.miniWidth) {
                    return this.miniWidth;
                }
                return '0px';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "isPinnedRight", {
            /** @hidden */
            get: function () {
                return this.pin && this.position === 'right' ? '1' : '0';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "drawer", {
            /**
              * @hidden
              */
            get: function () {
                return this._drawer.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "overlay", {
            /**
             * @hidden
             */
            get: function () {
                return this._overlay.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "styleDummy", {
            /**
             * @hidden
             */
            get: function () {
                return this._styleDummy.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "hasAnimateWidth", {
            /**
             * Property to decide whether to change width or translate the drawer from pan gesture.
             *
             * @hidden
             */
            get: function () {
                return this.pin || !!this.miniTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "maxEdgeZone", {
            /**
             * Used for touch gestures (swipe and pan).
             * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
             *
             * @hidden
             */
            get: function () {
                return this._maxEdgeZone;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "expectedWidth", {
            /**
             * Gets the Drawer width for specific state.
             * Will attempt to evaluate requested state and cache.
             *
             *
             * @hidden
             */
            get: function () {
                return this.getExpectedWidth(false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "expectedMiniWidth", {
            /**
             * Get the Drawer mini width for specific state.
             * Will attempt to evaluate requested state and cache.
             *
             * @hidden
             */
            get: function () {
                return this.getExpectedWidth(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "touchManager", {
            /**
             * @hidden
             */
            get: function () {
                return this._touchManager;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxNavigationDrawerComponent.prototype, "state", {
            /**
             * Exposes optional navigation service
             *
             * @hidden
             */
            get: function () {
                return this._state;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxNavigationDrawerComponent.prototype.ngOnInit = function () {
            // DOM and @Input()-s initialized
            if (this._state) {
                this._state.add(this.id, this);
            }
            if (this.isOpen) {
                this.setDrawerWidth(this.width);
            }
        };
        /**
         * @hidden
         */
        IgxNavigationDrawerComponent.prototype.ngAfterContentInit = function () {
            // wait for template and ng-content to be ready
            this.updateEdgeZone();
            this.checkPinThreshold();
            this.ensureEvents();
            // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
            // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
        };
        /**
         * @hidden
         */
        IgxNavigationDrawerComponent.prototype.ngOnDestroy = function () {
            this._touchManager.destroy();
            if (this._state) {
                this._state.remove(this.id);
            }
            if (this._resizeObserver) {
                this._resizeObserver.unsubscribe();
            }
        };
        /**
         * @hidden
         */
        IgxNavigationDrawerComponent.prototype.ngOnChanges = function (changes) {
            // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
            if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
                this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
                this.ensureEvents();
            }
            if (changes.pin && changes.pin.currentValue !== undefined) {
                this.pin = !!(this.pin && this.pin.toString() === 'true');
                if (this.pin) {
                    this._touchManager.destroy();
                    this._gesturesAttached = false;
                }
                else {
                    this.ensureEvents();
                }
            }
            if (changes.pinThreshold) {
                if (this.pinThreshold) {
                    this.ensureEvents();
                    this.checkPinThreshold();
                }
            }
            if (changes.width && this.isOpen) {
                this.setDrawerWidth(changes.width.currentValue);
            }
            if (changes.miniWidth) {
                if (!this.isOpen) {
                    this.setDrawerWidth(changes.miniWidth.currentValue);
                }
                this.updateEdgeZone();
            }
        };
        /**
         * Toggle the open state of the Navigation Drawer.
         *
         * ```typescript
         * this.navdrawer.toggle();
         * ```
         */
        IgxNavigationDrawerComponent.prototype.toggle = function () {
            if (this.isOpen) {
                this.close();
            }
            else {
                this.open();
            }
        };
        /**
         * Open the Navigation Drawer. Has no effect if already opened.
         *
         * ```typescript
         * this.navdrawer.open();
         * ```
         */
        IgxNavigationDrawerComponent.prototype.open = function () {
            if (this._panning) {
                this.resetPan();
            }
            if (this.isOpen) {
                return;
            }
            this.opening.emit();
            this.isOpen = true;
            // TODO: Switch to animate API when available
            // var animationCss = this.animate.css();
            //     animationCss
            //         .setStyles({'width':'50px'}, {'width':'400px'})
            //         .start(this.elementRef.nativeElement)
            //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
            this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
            this.setDrawerWidth(this.width);
        };
        /**
         * Close the Navigation Drawer. Has no effect if already closed.
         *
         * ```typescript
         * this.navdrawer.close();
         * ```
         */
        IgxNavigationDrawerComponent.prototype.close = function () {
            if (this._panning) {
                this.resetPan();
            }
            if (!this.isOpen) {
                return;
            }
            this.closing.emit();
            this.isOpen = false;
            this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
            this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
        };
        /**
         * @hidden
         */
        IgxNavigationDrawerComponent.prototype.set_maxEdgeZone = function (value) {
            this._maxEdgeZone = value;
        };
        /**
         * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
         *
         * @hidden
         * @param [mini] - Request mini width instead
         */
        IgxNavigationDrawerComponent.prototype.getExpectedWidth = function (mini) {
            if (mini) {
                if (!this.miniTemplate) {
                    return 0;
                }
                if (this.miniWidth) {
                    return parseFloat(this.miniWidth);
                }
                else {
                    // if (!this.isOpen) { // This WON'T work due to transition timings...
                    //     return this.elementRef.nativeElement.children[1].offsetWidth;
                    // } else {
                    if (this._widthCache.miniWidth === null) {
                        // force class for width calc. TODO?
                        // force class for width calc. TODO?
                        this.renderer.addClass(this.styleDummy, this.css.drawer);
                        this.renderer.addClass(this.styleDummy, this.css.mini);
                        this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                        this.renderer.removeClass(this.styleDummy, this.css.drawer);
                        this.renderer.removeClass(this.styleDummy, this.css.mini);
                    }
                    return this._widthCache.miniWidth;
                }
            }
            else {
                if (this.width) {
                    return parseFloat(this.width);
                }
                else {
                    if (this._widthCache.width === null) {
                        // force class for width calc. TODO?
                        // force class for width calc. TODO?
                        this.renderer.addClass(this.styleDummy, this.css.drawer);
                        this._widthCache.width = this.styleDummy.offsetWidth;
                        this.renderer.removeClass(this.styleDummy, this.css.drawer);
                    }
                    return this._widthCache.width;
                }
            }
        };
        IgxNavigationDrawerComponent.prototype.getWindowWidth = function () {
            return (window.innerWidth > 0) ? window.innerWidth : screen.width;
        };
        /**
         * Sets the drawer width.
         */
        IgxNavigationDrawerComponent.prototype.setDrawerWidth = function (width) {
            var _this = this;
            if (this.platformUtil.isBrowser) {
                requestAnimationFrame(function () {
                    if (_this.drawer) {
                        _this.renderer.setStyle(_this.drawer, 'width', width);
                    }
                });
            }
            else {
                this.renderer.setStyle(this.drawer, 'width', width);
            }
        };
        /**
         * Get current Drawer width.
         */
        IgxNavigationDrawerComponent.prototype.getDrawerWidth = function () {
            return this.drawer.offsetWidth;
        };
        IgxNavigationDrawerComponent.prototype.ensureEvents = function () {
            var _this = this;
            // set listeners for swipe/pan only if needed, but just once
            if (this.enableGestures && !this.pin && !this._gesturesAttached) {
                // Built-in manager handler(L20887) causes endless loop and max stack exception.
                // https://github.com/angular/angular/issues/6993
                // Use ours for now (until beta.10):
                // this.renderer.listen(document, "swipe", this.swipe);
                this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
                this._gesturesAttached = true;
                // this.renderer.listen(document, "panstart", this.panstart);
                // this.renderer.listen(document, "pan", this.pan);
                this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
                this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
                this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
            }
            if (!this._resizeObserver && this.platformUtil.isBrowser) {
                this._resizeObserver = rxjs.fromEvent(window, 'resize').pipe(operators.debounce(function () { return rxjs.interval(150); }))
                    .subscribe(function (value) {
                    _this.checkPinThreshold(value);
                });
            }
        };
        IgxNavigationDrawerComponent.prototype.updateEdgeZone = function () {
            var maxValue;
            if (this.miniTemplate) {
                maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
                this.set_maxEdgeZone(maxValue);
            }
        };
        IgxNavigationDrawerComponent.prototype.resetPan = function () {
            this._panning = false;
            /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
            /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
            this.renderer.removeClass(this.overlay, 'panning');
            this.renderer.removeClass(this.drawer, 'panning');
            this.setXSize(0, '');
        };
        /**
         * Sets the absolute position or width in case the drawer doesn't change position.
         * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
         * @param opacity optional value to apply to the overlay
         */
        IgxNavigationDrawerComponent.prototype.setXSize = function (x, opacity) {
            var _this = this;
            // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
            window.requestAnimationFrame(function () {
                if (_this.hasAnimateWidth) {
                    _this.renderer.setStyle(_this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
                }
                else {
                    _this.renderer.setStyle(_this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                    _this.renderer.setStyle(_this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                }
                if (opacity !== undefined) {
                    _this.renderer.setStyle(_this.overlay, 'opacity', opacity);
                }
            });
        };
        IgxNavigationDrawerComponent.ctorParameters = function () { return [
            { type: core.ElementRef, decorators: [{ type: core.Inject, args: [core.ElementRef,] }] },
            { type: IgxNavigationService, decorators: [{ type: core.Optional }] },
            { type: core.Renderer2 },
            { type: HammerGesturesManager },
            { type: PlatformUtil }
        ]; };
        __decorate([
            core.HostBinding('class.igx-nav-drawer')
        ], IgxNavigationDrawerComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxNavigationDrawerComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxNavigationDrawerComponent.prototype, "position", void 0);
        __decorate([
            core.Input()
        ], IgxNavigationDrawerComponent.prototype, "enableGestures", void 0);
        __decorate([
            core.Input()
        ], IgxNavigationDrawerComponent.prototype, "isOpen", null);
        __decorate([
            core.Output()
        ], IgxNavigationDrawerComponent.prototype, "isOpenChange", void 0);
        __decorate([
            core.Input()
        ], IgxNavigationDrawerComponent.prototype, "pin", void 0);
        __decorate([
            core.Input()
        ], IgxNavigationDrawerComponent.prototype, "pinThreshold", void 0);
        __decorate([
            core.Input()
        ], IgxNavigationDrawerComponent.prototype, "width", void 0);
        __decorate([
            core.Input()
        ], IgxNavigationDrawerComponent.prototype, "miniWidth", void 0);
        __decorate([
            core.Output()
        ], IgxNavigationDrawerComponent.prototype, "pinChange", void 0);
        __decorate([
            core.Output()
        ], IgxNavigationDrawerComponent.prototype, "opening", void 0);
        __decorate([
            core.Output()
        ], IgxNavigationDrawerComponent.prototype, "opened", void 0);
        __decorate([
            core.Output()
        ], IgxNavigationDrawerComponent.prototype, "closing", void 0);
        __decorate([
            core.Output()
        ], IgxNavigationDrawerComponent.prototype, "closed", void 0);
        __decorate([
            core.ContentChild(IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective })
        ], IgxNavigationDrawerComponent.prototype, "miniTemplate", null);
        __decorate([
            core.ContentChild(IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective })
        ], IgxNavigationDrawerComponent.prototype, "contentTemplate", void 0);
        __decorate([
            core.HostBinding('style.flexBasis')
        ], IgxNavigationDrawerComponent.prototype, "flexWidth", null);
        __decorate([
            core.HostBinding('style.order')
        ], IgxNavigationDrawerComponent.prototype, "isPinnedRight", null);
        __decorate([
            core.ViewChild('aside', { static: true })
        ], IgxNavigationDrawerComponent.prototype, "_drawer", void 0);
        __decorate([
            core.ViewChild('overlay', { static: true })
        ], IgxNavigationDrawerComponent.prototype, "_overlay", void 0);
        __decorate([
            core.ViewChild('dummy', { static: true })
        ], IgxNavigationDrawerComponent.prototype, "_styleDummy", void 0);
        IgxNavigationDrawerComponent = __decorate([
            core.Component({
                providers: [HammerGesturesManager],
                selector: 'igx-nav-drawer',
                template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside>\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                styles: ["\n        :host {\n            display: block;\n            height: 100%;\n        }\n    "]
            }),
            __param(0, core.Inject(core.ElementRef)),
            __param(1, core.Optional())
        ], IgxNavigationDrawerComponent);
        return IgxNavigationDrawerComponent;
    }());

    /**
     * @hidden
     */
    var IgxNavigationDrawerModule = /** @class */ (function () {
        function IgxNavigationDrawerModule() {
        }
        IgxNavigationDrawerModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxNavigationDrawerComponent,
                    IgxNavDrawerItemDirective,
                    IgxNavDrawerMiniTemplateDirective,
                    IgxNavDrawerTemplateDirective
                ],
                exports: [
                    IgxNavigationDrawerComponent,
                    IgxNavDrawerItemDirective,
                    IgxNavDrawerMiniTemplateDirective,
                    IgxNavDrawerTemplateDirective
                ],
                imports: [common.CommonModule]
            })
        ], IgxNavigationDrawerModule);
        return IgxNavigationDrawerModule;
    }());

    /**
     * Template directive that allows you to set a custom template representing the lower label value of the {@link IgxSliderComponent}
     *
     *```html
     * <igx-slider>
     *  <ng-template igxSliderThumbFrom let-value let-labels>{{value}}</ng-template>
     * </igx-slider>
     * ```
     *
     * @context {@link IgxSliderComponent.context}
     */
    var IgxThumbFromTemplateDirective = /** @class */ (function () {
        function IgxThumbFromTemplateDirective() {
        }
        IgxThumbFromTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxSliderThumbFrom]'
            })
        ], IgxThumbFromTemplateDirective);
        return IgxThumbFromTemplateDirective;
    }());
    /**
     * Template directive that allows you to set a custom template representing the upper label value of the {@link IgxSliderComponent}
     *
     * ```html
     * <igx-slider>
     *  <ng-template igxSliderThumbTo let-value let-labels>{{value}}</ng-template>
     * </igx-slider>
     * ```
     *
     * @context {@link IgxSliderComponent.context}
     */
    var IgxThumbToTemplateDirective = /** @class */ (function () {
        function IgxThumbToTemplateDirective() {
        }
        IgxThumbToTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxSliderThumbTo]'
            })
        ], IgxThumbToTemplateDirective);
        return IgxThumbToTemplateDirective;
    }());
    /**
     * Template directive that allows you to set a custom template, represeting primary/secondary tick labels of the {@link IgxSliderComponent}
     *
     * @context {@link IgxTicksComponent.context}
     */
    var IgxTickLabelTemplateDirective = /** @class */ (function () {
        function IgxTickLabelTemplateDirective() {
        }
        IgxTickLabelTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxSliderTickLabel]'
            })
        ], IgxTickLabelTemplateDirective);
        return IgxTickLabelTemplateDirective;
    }());

    (function (IgxSliderType) {
        /**
         * Slider with single thumb.
         */
        IgxSliderType[IgxSliderType["SLIDER"] = 0] = "SLIDER";
        /**
         *  Range slider with multiple thumbs, that can mark the range.
         */
        IgxSliderType[IgxSliderType["RANGE"] = 1] = "RANGE";
    })(exports.IgxSliderType || (exports.IgxSliderType = {}));

    (function (SliderHandle) {
        SliderHandle[SliderHandle["FROM"] = 0] = "FROM";
        SliderHandle[SliderHandle["TO"] = 1] = "TO";
    })(exports.SliderHandle || (exports.SliderHandle = {}));
    /**
     * Slider Tick labels Orientation
     */

    (function (TickLabelsOrientation) {
        TickLabelsOrientation[TickLabelsOrientation["Horizontal"] = 0] = "Horizontal";
        TickLabelsOrientation[TickLabelsOrientation["TopToBottom"] = 1] = "TopToBottom";
        TickLabelsOrientation[TickLabelsOrientation["BottomToTop"] = 2] = "BottomToTop";
    })(exports.TickLabelsOrientation || (exports.TickLabelsOrientation = {}));
    /**
     * Slider Ticks orientation
     */

    (function (TicksOrientation) {
        TicksOrientation[TicksOrientation["Top"] = 0] = "Top";
        TicksOrientation[TicksOrientation["Bottom"] = 1] = "Bottom";
        TicksOrientation[TicksOrientation["Mirror"] = 2] = "Mirror";
    })(exports.TicksOrientation || (exports.TicksOrientation = {}));

    /**
     * @hidden
     */
    var IgxSliderThumbComponent = /** @class */ (function () {
        function IgxSliderThumbComponent(_elementRef) {
            this._elementRef = _elementRef;
            this._isActive = false;
            this._isPressed = false;
            this._destroy$ = new rxjs.Subject();
            this.isActive = false;
            this.onThumbValueChange = new core.EventEmitter();
            this.onChange = new core.EventEmitter();
            this.onHoverChange = new core.EventEmitter();
            this.tabindex = 0;
            this.zIndex = 0;
        }
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbPositionX", {
            get: function () {
                var thumbBounderies = this.nativeElement.getBoundingClientRect();
                var thumbCenter = (thumbBounderies.right - thumbBounderies.left) / 2;
                return thumbBounderies.left + thumbCenter;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbFromClass", {
            get: function () {
                return this.type === exports.SliderHandle.FROM;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbToClass", {
            get: function () {
                return this.type === exports.SliderHandle.TO;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbFromActiveClass", {
            get: function () {
                return this.type === exports.SliderHandle.FROM && this._isActive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbToActiveClass", {
            get: function () {
                return this.type === exports.SliderHandle.TO && this._isActive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "thumbPressedClass", {
            get: function () {
                return this.isActive && this._isPressed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "nativeElement", {
            get: function () {
                return this._elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderThumbComponent.prototype, "destroy", {
            get: function () {
                return this._destroy$;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxSliderThumbComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.onPan
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function (mouseX) {
                return _this.updateThumbValue(mouseX);
            });
        };
        /**
         * @hidden
         */
        IgxSliderThumbComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next(true);
            this._destroy$.complete();
        };
        IgxSliderThumbComponent.prototype.onPinterEnter = function () {
            this.onHoverChange.emit(true);
        };
        IgxSliderThumbComponent.prototype.onPointerLeave = function () {
            this.onHoverChange.emit(false);
        };
        IgxSliderThumbComponent.prototype.onKeyDown = function (event) {
            if (this.disabled) {
                return;
            }
            var increment = 0;
            if (event.key.endsWith('Left')) {
                increment = this.step * -1;
            }
            else if (event.key.endsWith('Right')) {
                increment = this.step;
            }
            else {
                return;
            }
            this.onChange.emit();
            this.onThumbValueChange.emit(increment);
        };
        IgxSliderThumbComponent.prototype.onBlur = function () {
            this.isActive = false;
            this.zIndex = 0;
        };
        IgxSliderThumbComponent.prototype.onFocusListener = function () {
            this.isActive = true;
            this.zIndex = 1;
        };
        /**
         * Show thumb label and ripple.
         */
        IgxSliderThumbComponent.prototype.showThumbIndicators = function () {
            this.toggleThumbIndicators(true);
        };
        /**
         * Hide thumb label and ripple.
         */
        IgxSliderThumbComponent.prototype.hideThumbIndicators = function () {
            this.toggleThumbIndicators(false);
        };
        IgxSliderThumbComponent.prototype.updateThumbValue = function (mouseX) {
            var updateValue = this.calculateTrackUpdate(mouseX);
            if (this.isActive && updateValue !== 0) {
                this.onThumbValueChange.emit(updateValue);
            }
        };
        IgxSliderThumbComponent.prototype.calculateTrackUpdate = function (mouseX) {
            var scaleX = mouseX - this.thumbPositionX;
            var stepDistanceCenter = this.stepDistance / 2;
            // If the thumb scale range (slider update) is less thàn a half step,
            // the position stays the same.
            var scaleXPositive = Math.abs(scaleX);
            if (scaleXPositive < stepDistanceCenter) {
                return 0;
            }
            return this.stepToProceed(scaleX, this.stepDistance);
        };
        IgxSliderThumbComponent.prototype.stepToProceed = function (scaleX, stepDist) {
            return Math.round(scaleX / stepDist) * this.step;
        };
        IgxSliderThumbComponent.prototype.toggleThumbIndicators = function (visible) {
            this._isPressed = visible;
            if (this.continuous || this.deactiveState) {
                this._isActive = false;
            }
            else {
                this._isActive = visible;
            }
        };
        IgxSliderThumbComponent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "value", void 0);
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "continuous", void 0);
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "thumbLabelVisibilityDuration", void 0);
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "onPan", void 0);
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "stepDistance", void 0);
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "step", void 0);
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "templateRef", void 0);
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "context", void 0);
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "type", void 0);
        __decorate([
            core.Input()
        ], IgxSliderThumbComponent.prototype, "deactiveState", void 0);
        __decorate([
            core.Output()
        ], IgxSliderThumbComponent.prototype, "onThumbValueChange", void 0);
        __decorate([
            core.Output()
        ], IgxSliderThumbComponent.prototype, "onChange", void 0);
        __decorate([
            core.Output()
        ], IgxSliderThumbComponent.prototype, "onHoverChange", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxSliderThumbComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('attr.z-index')
        ], IgxSliderThumbComponent.prototype, "zIndex", void 0);
        __decorate([
            core.HostBinding('class.igx-slider__thumb-from')
        ], IgxSliderThumbComponent.prototype, "thumbFromClass", null);
        __decorate([
            core.HostBinding('class.igx-slider__thumb-to')
        ], IgxSliderThumbComponent.prototype, "thumbToClass", null);
        __decorate([
            core.HostBinding('class.igx-slider__thumb-from--active')
        ], IgxSliderThumbComponent.prototype, "thumbFromActiveClass", null);
        __decorate([
            core.HostBinding('class.igx-slider__thumb-to--active')
        ], IgxSliderThumbComponent.prototype, "thumbToActiveClass", null);
        __decorate([
            core.HostBinding('class.igx-slider__thumb--pressed')
        ], IgxSliderThumbComponent.prototype, "thumbPressedClass", null);
        __decorate([
            core.HostListener('pointerenter')
        ], IgxSliderThumbComponent.prototype, "onPinterEnter", null);
        __decorate([
            core.HostListener('pointerleave')
        ], IgxSliderThumbComponent.prototype, "onPointerLeave", null);
        __decorate([
            core.HostListener('keydown', ['$event'])
        ], IgxSliderThumbComponent.prototype, "onKeyDown", null);
        __decorate([
            core.HostListener('blur')
        ], IgxSliderThumbComponent.prototype, "onBlur", null);
        __decorate([
            core.HostListener('focus')
        ], IgxSliderThumbComponent.prototype, "onFocusListener", null);
        IgxSliderThumbComponent = __decorate([
            core.Component({
                selector: 'igx-thumb',
                template: "<div class=\"dot\"></div>\n"
            })
        ], IgxSliderThumbComponent);
        return IgxSliderThumbComponent;
    }());

    var IgxThumbLabelComponent = /** @class */ (function () {
        function IgxThumbLabelComponent(_elementRef) {
            this._elementRef = _elementRef;
        }
        Object.defineProperty(IgxThumbLabelComponent.prototype, "thumbFromClass", {
            get: function () {
                return this.type === exports.SliderHandle.FROM;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "thumbToClass", {
            get: function () {
                return this.type === exports.SliderHandle.TO;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "thumbFromActiveClass", {
            get: function () {
                return this.type === exports.SliderHandle.FROM && this.active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "thumbToActiveClass", {
            get: function () {
                return this.type === exports.SliderHandle.TO && this.active;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "nativeElement", {
            get: function () {
                return this._elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxThumbLabelComponent.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (val) {
                if (this.continuous || this.deactiveState) {
                    this._active = false;
                }
                else {
                    this._active = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        IgxThumbLabelComponent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxThumbLabelComponent.prototype, "value", void 0);
        __decorate([
            core.Input()
        ], IgxThumbLabelComponent.prototype, "templateRef", void 0);
        __decorate([
            core.Input()
        ], IgxThumbLabelComponent.prototype, "context", void 0);
        __decorate([
            core.Input()
        ], IgxThumbLabelComponent.prototype, "type", void 0);
        __decorate([
            core.Input()
        ], IgxThumbLabelComponent.prototype, "continuous", void 0);
        __decorate([
            core.Input()
        ], IgxThumbLabelComponent.prototype, "deactiveState", void 0);
        __decorate([
            core.HostBinding('class.igx-slider__label-from')
        ], IgxThumbLabelComponent.prototype, "thumbFromClass", null);
        __decorate([
            core.HostBinding('class.igx-slider__label-to')
        ], IgxThumbLabelComponent.prototype, "thumbToClass", null);
        __decorate([
            core.HostBinding('class.igx-slider__label-from--active')
        ], IgxThumbLabelComponent.prototype, "thumbFromActiveClass", null);
        __decorate([
            core.HostBinding('class.igx-slider__label-to--active')
        ], IgxThumbLabelComponent.prototype, "thumbToActiveClass", null);
        IgxThumbLabelComponent = __decorate([
            core.Component({
                selector: 'igx-thumb-label',
                template: "<div class=\"label\">\n    <ng-container *ngTemplateOutlet=\"templateRef ? templateRef : thumbFromDefaultTemplate; context: context\"></ng-container>\n</div>\n\n<ng-template #thumbFromDefaultTemplate>\n    {{ value }}\n</ng-template>\n"
            })
        ], IgxThumbLabelComponent);
        return IgxThumbLabelComponent;
    }());

    /**
     * @hidden
     */
    var IgxTicksComponent = /** @class */ (function () {
        function IgxTicksComponent() {
            /**
             * @hidden
             */
            this.ticksClass = true;
        }
        Object.defineProperty(IgxTicksComponent.prototype, "ticksTopClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.ticksOrientation === exports.TicksOrientation.Top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTicksComponent.prototype, "hasPrimaryClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.primaryTicks > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTicksComponent.prototype, "labelsTopToBottomClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.tickLabelsOrientation === exports.TickLabelsOrientation.TopToBottom;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTicksComponent.prototype, "labelsBottomToTopClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.tickLabelsOrientation === exports.TickLabelsOrientation.BottomToTop;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the template context corresponding to
         * {@link IgxTickLabelTemplateDirective}
         *
         * ```typescript
         * return {
         *  $implicit //returns the value per each tick label.
         *  isPrimery //returns if the tick is primary.
         *  labels // returns the {@link labels} collection.
         *  index // returns the index per each tick of the whole sequence.
         * }
         * ```
         *
         * @param idx the index per each tick label.
         */
        IgxTicksComponent.prototype.context = function (idx) {
            return {
                $implicit: this.tickLabel(idx),
                isPrimary: this.isPrimary(idx),
                labels: this.labels,
                index: idx
            };
        };
        Object.defineProperty(IgxTicksComponent.prototype, "ticksLength", {
            /**
             * @hidden
             */
            get: function () {
                return this.primaryTicks > 0 ?
                    ((this.primaryTicks - 1) * this.secondaryTicks) + this.primaryTicks :
                    this.secondaryTicks > 0 ? this.secondaryTicks : 0;
            },
            enumerable: true,
            configurable: true
        });
        IgxTicksComponent.prototype.hiddenTickLabels = function (idx) {
            return this.isPrimary(idx) ? this.primaryTickLabels : this.secondaryTickLabels;
        };
        /**
         * @hidden
         */
        IgxTicksComponent.prototype.isPrimary = function (idx) {
            return this.primaryTicks <= 0 ? false :
                idx % (this.secondaryTicks + 1) === 0;
        };
        /**
         * @hidden
         */
        IgxTicksComponent.prototype.tickLabel = function (idx) {
            if (this.labelsViewEnabled) {
                return this.labels[idx];
            }
            var labelStep = (Math.max(this.minValue, this.maxValue) - Math.min(this.minValue, this.maxValue)) / (this.ticksLength - 1);
            var labelVal = labelStep * idx;
            return (this.minValue + labelVal).toFixed(2);
        };
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "primaryTicks", void 0);
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "secondaryTicks", void 0);
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "primaryTickLabels", void 0);
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "secondaryTickLabels", void 0);
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "ticksOrientation", void 0);
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "tickLabelsOrientation", void 0);
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "maxValue", void 0);
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "minValue", void 0);
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "labelsViewEnabled", void 0);
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "labels", void 0);
        __decorate([
            core.Input()
        ], IgxTicksComponent.prototype, "tickLabelTemplateRef", void 0);
        __decorate([
            core.HostBinding('class.igx-slider__ticks')
        ], IgxTicksComponent.prototype, "ticksClass", void 0);
        __decorate([
            core.HostBinding('class.igx-slider__ticks--top')
        ], IgxTicksComponent.prototype, "ticksTopClass", null);
        __decorate([
            core.HostBinding('class.igx-slider__ticks--tall')
        ], IgxTicksComponent.prototype, "hasPrimaryClass", null);
        __decorate([
            core.HostBinding('class.igx-slider__tick-labels--top-bottom')
        ], IgxTicksComponent.prototype, "labelsTopToBottomClass", null);
        __decorate([
            core.HostBinding('class.igx-slider__tick-labels--bottom-top')
        ], IgxTicksComponent.prototype, "labelsBottomToTopClass", null);
        IgxTicksComponent = __decorate([
            core.Component({
                selector: 'igx-ticks',
                template: "<div class=\"igx-slider__ticks-group\" *ngFor=\"let n of [].constructor(ticksLength); let idx=index\" [ngClass]=\"{ 'igx-slider__ticks-group--tall': isPrimary(idx)}\">\n    <div class=\"igx-slider__ticks-tick\">\n        <span class=\"igx-slider__ticks-label\" [ngClass]=\"{ 'igx-slider__tick-label--hidden': !hiddenTickLabels(idx)}\">\n            <ng-container *ngTemplateOutlet=\"tickLabelTemplateRef ? tickLabelTemplateRef : tickLabelDefaultTemplate; context: context(idx)\"></ng-container>\n        </span>\n    </div>\n</div>\n\n<ng-template #tickLabelDefaultTemplate let-value>\n    {{ value }}\n</ng-template>\n"
            })
        ], IgxTicksComponent);
        return IgxTicksComponent;
    }());

    var IgxTickLabelsPipe = /** @class */ (function () {
        function IgxTickLabelsPipe() {
        }
        IgxTickLabelsPipe.prototype.transform = function (labels, secondaryTicks) {
            if (!labels) {
                return;
            }
            var result = [];
            labels.forEach(function (item) {
                result.push(item);
                for (var i = 0; i < secondaryTicks; i++) {
                    result.push('');
                }
            });
            return result;
        };
        IgxTickLabelsPipe = __decorate([
            core.Pipe({
                name: 'spreadTickLabels'
            })
        ], IgxTickLabelsPipe);
        return IgxTickLabelsPipe;
    }());

    var noop$7 = function () {
    };
    var ɵ0$8 = noop$7;
    var NEXT_ID$r = 0;
    /**
     * **Ignite UI for Angular Slider** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
     *
     * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
     * can be defined as continuous or stepped, and you can choose between single and range slider types.
     *
     * Example:
     * ```html
     * <igx-slider id="slider"
     *            [minValue]="0" [maxValue]="100"
     *            [continuous]=true [(ngModel)]="volume">
     * </igx-slider>
     * ```
     */
    var IgxSliderComponent = /** @class */ (function () {
        function IgxSliderComponent(renderer, _el, _cdr, _ngZone) {
            this.renderer = renderer;
            this._el = _el;
            this._cdr = _cdr;
            this._ngZone = _ngZone;
            // Limit handle travel zone
            this._pMin = 0;
            this._pMax = 1;
            // From/upperValue in percent values
            this._hasViewInit = false;
            this._minValue = 0;
            this._maxValue = 100;
            this._continuous = false;
            this._disabled = false;
            this._step = 1;
            this._value = 0;
            // ticks
            this._primaryTicks = 0;
            this._secondaryTicks = 0;
            this._labels = new Array();
            this._type = exports.IgxSliderType.SLIDER;
            this._destroyer$ = new rxjs.Subject();
            this._indicatorsDestroyer$ = new rxjs.Subject();
            this._onChangeCallback = noop$7;
            this._onTouchedCallback = noop$7;
            /**
             * @hidden
             */
            this.thumbs = new core.QueryList();
            /**
             * @hidden
             */
            this.labelRefs = new core.QueryList();
            /**
             * @hidden
             */
            this.stepDistance = this._step;
            /**
             * @hidden
             */
            this.onPan = new rxjs.Subject();
            /**
             * @hidden
             */
            this.role = 'slider';
            /**
             * @hidden
             */
            this.slierClass = true;
            /**
             * An @Input property that sets the value of the `id` attribute.
             * If not provided it will be automatically generated.
             * ```html
             * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
             * ```
             */
            this.id = "igx-slider-" + NEXT_ID$r++;
            /**
             *An @Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
             *```html
             *<igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
             *```
             */
            this.thumbLabelVisibilityDuration = 750;
            /**
             * Show/hide slider ticks
             * ```html
             * <igx-slier [showTicks]="true" [primaryTicks]="5"></igx-slier>
             * ```
             */
            this.showTicks = false;
            /**
             * show/hide primary tick labels
             * ```html
             * <igx-slider [primaryTicks]="5" [primaryTickLabels]="false"></igx-slider>
             * ```
             */
            this.primaryTickLabels = true;
            /**
             * show/hide secondary tick labels
             * ```html
             * <igx-slider [secondaryTicks]="5" [secondaryTickLabels]="false"></igx-slider>
             * ```
             */
            this.secondaryTickLabels = true;
            /**
             * Changes ticks orientation:
             * bottom - The default orienation, below the slider track.
             * top - Above the slider track
             * mirror - combines top and bottom orientation.
             * ```html
             * <igx-slider [primaryTicks]="5" [ticksOrientation]="ticksOrientation"></igx-slider>
             * ```
             */
            this.ticksOrientation = exports.TicksOrientation.Bottom;
            /**
             * Changes tick labels rotation:
             * horizontal - The default rotation
             * toptobottom - Rotates tick labels vertically to 90deg
             * bottomtotop - Rotate tick labels vertically to -90deg
             * ```html
             * <igx-slider [primaryTicks]="5" [secondaryTicks]="3" [tickLabelsOrientation]="tickLabelsOrientaiton"></igx-slider>
             * ```
             */
            this.tickLabelsOrientation = exports.TickLabelsOrientation.Horizontal;
            /**
             * This event is emitted every time the value is changed.
             * ```typescript
             * public change(event){
             *    alert("The value has been changed!");
             *}
             * ```
             * ```html
             * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
             * ```
             */
            this.onValueChange = new core.EventEmitter();
            /**
             * This event is emitted at the end of every slide interaction.
             * ```typescript
             * public change(event){
             *    alert("The value has been changed!");
             *}
             * ```
             * ```html
             * <igx-slider (onValueChanged)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
             * ```
             */
            this.onValueChanged = new core.EventEmitter();
        }
        IgxSliderComponent_1 = IgxSliderComponent;
        Object.defineProperty(IgxSliderComponent.prototype, "thumbFrom", {
            get: function () {
                return this.thumbs.find(function (thumb) { return thumb.type === exports.SliderHandle.FROM; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "thumbTo", {
            get: function () {
                return this.thumbs.find(function (thumb) { return thumb.type === exports.SliderHandle.TO; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "labelFrom", {
            get: function () {
                return this.labelRefs.find(function (label) { return label.type === exports.SliderHandle.FROM; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "labelTo", {
            get: function () {
                return this.labelRefs.find(function (label) { return label.type === exports.SliderHandle.TO; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "valuemin", {
            /**
             * @hidden
             */
            get: function () {
                return this.minValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "valuemax", {
            /**
             * @hidden
             */
            get: function () {
                return this.maxValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "readonly", {
            /**
             * @hidden
             */
            get: function () {
                return this.disabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "disabledClass", {
            /**
             * @hidden
             */
            get: function () {
                return this.disabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "type", {
            /**
             * An @Input property that gets the type of the `IgxSliderComponent`.
             * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
             * ```typescript
             * @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let type = this.slider.type;
             * }
             */
            get: function () {
                return this._type;
            },
            /**
             * An @Input property that sets the type of the `IgxSliderComponent`.
             * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
             * ```typescript
             * sliderType: IgxSliderType = IgxSliderType.RANGE;
             * ```
             * ```html
             * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
             * ```
             */
            set: function (type) {
                this._type = type;
                if (type === exports.IgxSliderType.SLIDER) {
                    this.lowerValue = 0;
                }
                if (this.labelsViewEnabled && this.upperValue > this.maxValue) {
                    this.upperValue = this.labels.length - 1;
                }
                if (this._hasViewInit) {
                    this.updateTrack();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "labels", {
            /**
             * Enables `labelView`, by accepting a collection of primitive values with more than one element.
             * Each element will be equally spread over the slider and it will serve as a thumb label.
             * Once the property is set, it will precendence over {@link maxValue}, {@link minValue}, {@link step}.
             * This means that the manipulation for those properties won't be allowed.
             */
            get: function () {
                return this._labels;
            },
            set: function (labels) {
                this._labels = labels;
                this._pMax = this.valueToFraction(this.upperBound, 0, 1);
                this._pMin = this.valueToFraction(this.lowerBound, 0, 1);
                this.stepDistance = this.calculateStepDistance();
                this.positionHandlersAndUpdateTrack();
                if (this._hasViewInit) {
                    this.setTickInterval();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "context", {
            /**
             * Returns the template context corresponding
             * to {@link IgxThumbFromTemplateDirective} and {@link IgxThumbToTemplateDirective} templates.
             *
             * ```typescript
             * return {
             *  $implicit // returns the value of the label,
             *  labels // returns the labels collection the user has passed.
             * }
             * ```
             */
            get: function () {
                return {
                    $implicit: this.value,
                    labels: this.labels
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "step", {
            /**
             * Returns the incremental/decremental dragging step of the {@link IgxSliderComponent}.
             * ```typescript
             * @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let step = this.slider.step;
             * }
             * ```
             */
            get: function () {
                return this.labelsViewEnabled ? 1 : this._step;
            },
            /**
             * An @Input property that sets the incremental/decremental step of the value when dragging the thumb.
             * The default step is 1, and step should not be less or equal than 0.
             * ```html
             * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
             * ```
             */
            set: function (step) {
                this._step = step;
                this.stepDistance = this.calculateStepDistance();
                if (this._hasViewInit) {
                    this.normalizeByStep(this.value);
                    this.setTickInterval();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "disabled", {
            /**
             * Returns if the {@link IgxSliderComponent} is disabled.
             * ```typescript
             * @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let isDisabled = this.slider.disabled;
             * }
             * ```
             */
            get: function () {
                return this._disabled;
            },
            /**
             *An @Input property that disables or enables UI interaction.
             *```html
             *<igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
             *```
             */
            set: function (disable) {
                this._disabled = disable;
                if (this._hasViewInit) {
                    this.changeThumbFocusableState(disable);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "continuous", {
            /**
             * Returns if the {@link IgxSliderComponent} is set as continuous.
             * ```typescript
             * @ViewChild("slider2")
             * public slider: IgxSliderComponent;
             * ngAfterViewInit(){
             *     let continuous = this.slider.continuous;
             * }
             * ```
             */
            get: function () {
                return this._continuous;
            },
            /**
             * An @Input property that marks the {@link IgxSliderComponent} as continuous.
             * By default is considered that the {@link IgxSliderComponent} is discrete.
             * Discrete {@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.
             * ```html
             * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
             * ```
             */
            set: function (continuous) {
                this._continuous = continuous;
                if (this._hasViewInit) {
                    this.setTickInterval();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "minValue", {
            /**
             *Returns the minimal value of the `IgxSliderComponent`.
             *```typescript
             *@ViewChild("slider2")
             *public slider: IgxSliderComponent;
             *ngAfterViewInit(){
             *    let sliderMin = this.slider.minValue;
             *}
             *```
             */
            get: function () {
                if (this.labelsViewEnabled) {
                    return 0;
                }
                return this._minValue;
            },
            /**
             * Sets the minimal value for the `IgxSliderComponent`.
             * The default minimal value is 0.
             * ```html
             * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
             * ```
             */
            set: function (value) {
                if (value >= this.maxValue) {
                    return;
                }
                else {
                    this._minValue = value;
                }
                if (value > this.upperBound) {
                    this.updateUpperBoundAndMaxTravelZone();
                    this.lowerBound = value;
                }
                // Refresh min travel zone limit.
                this._pMin = 0;
                // Recalculate step distance.
                this.stepDistance = this.calculateStepDistance();
                this.positionHandlersAndUpdateTrack();
                if (this._hasViewInit) {
                    this.setTickInterval();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "maxValue", {
            /**
         * Returns the maximum value for the {@link IgxSliderComponent}.
         * ```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderMax = this.slider.maxValue;
         *}
         * ```
         */
            get: function () {
                return this.labelsViewEnabled ?
                    this.labels.length - 1 :
                    this._maxValue;
            },
            /**
             * Sets the maximal value for the `IgxSliderComponent`.
             * The default maximum value is 100.
             * ```html
             * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
             * ```
             */
            set: function (value) {
                if (value <= this._minValue) {
                    return;
                }
                else {
                    this._maxValue = value;
                }
                if (value < this.lowerBound) {
                    this.updateLowerBoundAndMinTravelZone();
                    this.upperBound = value;
                }
                // refresh max travel zone limits.
                this._pMax = 1;
                // recalculate step distance.
                this.stepDistance = this.calculateStepDistance();
                this.positionHandlersAndUpdateTrack();
                if (this._hasViewInit) {
                    this.setTickInterval();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "lowerBound", {
            /**
             * Returns the lower boundary of the `IgxSliderComponent`.
             *```typescript
             *@ViewChild("slider")
             *public slider: IgxSliderComponent;
             *ngAfterViewInit(){
             *    let sliderLowBound = this.slider.lowerBound;
             *}
             *```
             */
            get: function () {
                if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {
                    return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);
                }
                return this.minValue;
            },
            /**
             * Sets the lower boundary of the `IgxSliderComponent`.
             * If not set is the same as min value.
             * ```html
             * <igx-slider [step]="5" [lowerBound]="20">
             * ```
             */
            set: function (value) {
                if (value >= this.upperBound || (this.labelsViewEnabled && value < 0)) {
                    return;
                }
                this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
                // Refresh min travel zone.
                this._pMin = this.valueToFraction(this._lowerBound, 0, 1);
                this.positionHandlersAndUpdateTrack();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "upperBound", {
            /**
             * Returns the upper boundary of the `IgxSliderComponent`.
             * ```typescript
             *@ViewChild("slider")
             *public slider: IgxSliderComponent;
             *ngAfterViewInit(){
             *    let sliderUpBound = this.slider.upperBound;
             *}
             * ```
             */
            get: function () {
                if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {
                    return this.valueInRange(this._upperBound, this.minValue, this.maxValue);
                }
                return this.maxValue;
            },
            /**
             * Sets the upper boundary of the `IgxSliderComponent`.
             * If not set is the same as max value.
             * ```html
             * <igx-slider [step]="5" [upperBound]="20">
             * ```
             */
            set: function (value) {
                if (value <= this.lowerBound || (this.labelsViewEnabled && value > this.labels.length - 1)) {
                    return;
                }
                this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
                // Refresh time travel zone.
                this._pMax = this.valueToFraction(this._upperBound, 0, 1);
                this.positionHandlersAndUpdateTrack();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "value", {
            /**
             * Returns the slider value. If the slider is of type {@link IgxSliderType.SLIDER} the returned value is number.
             * If the slider type is {@link IgxSliderType.RANGE}.
             * The returned value represents an object of {@link lowerValue} and {@link upperValue}.
             *```typescript
             *@ViewChild("slider2")
             *public slider: IgxSliderComponent;
             *public sliderValue(event){
             *    let sliderVal = this.slider.value;
             *}
             *```
             */
            get: function () {
                if (this.isRange) {
                    return {
                        lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),
                        upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)
                    };
                }
                else {
                    return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);
                }
            },
            /**
             * Sets the slider value.
             * If the slider is of type {@link IgxSliderType.SLIDER}.
             * The argument is number. By default the {@link value} gets the {@link lowerBound}.
             * If the slider type is {@link IgxSliderType.RANGE} the argument
             * represents an object of {@link lowerValue} and {@link upperValue} properties.
             * By default the object is associated with the {@link lowerBound} and {@link upperBound} property values.
             * ```typescript
             *rangeValue = {
             *   lower: 30,
             *   upper: 60
             *};
             * ```
             * ```html
             * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
             * ```
             */
            set: function (value) {
                if (this._hasViewInit) {
                    this.setValue(value);
                    this.positionHandlersAndUpdateTrack();
                }
                else {
                    this._value = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "primaryTicks", {
            /**
             * Returns the number of the presented primary ticks.
             * ```typescript
             * const primaryTicks = this.slider.primaryTicks;
             * ```
             */
            get: function () {
                if (this.labelsViewEnabled) {
                    return this._primaryTicks = this.labels.length;
                }
                return this._primaryTicks;
            },
            /**
             * Sets the number of primary ticks. If {@link @labels} is enabled, this property won't function.
             * Insted enable ticks by {@link showTicks} property.
             * ```typescript
             * this.slider.primaryTicks = 5;
             * ```
             */
            set: function (val) {
                if (val <= 1) {
                    return;
                }
                this._primaryTicks = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "secondaryTicks", {
            /**
             * Returns the number of the presented secondary ticks.
             * ```typescript
             * const secondaryTicks = this.slider.secondaryTicks;
             * ```
             */
            get: function () {
                return this._secondaryTicks;
            },
            /**
             * Sets the number of secondary ticks. The property functions even when {@link labels} is enabled,
             * but all secondary ticks won't present any tick labels.
             * ```typescript
             * this.slider.secondaryTicks = 5;
             * ```
             */
            set: function (val) {
                if (val < 1) {
                    return;
                }
                this._secondaryTicks = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "deactivateThumbLabel", {
            /**
             * @hidden
             */
            get: function () {
                return ((this.primaryTicks && this.primaryTickLabels) || (this.secondaryTicks && this.secondaryTickLabels)) &&
                    (this.ticksOrientation === exports.TicksOrientation.Top || this.ticksOrientation === exports.TicksOrientation.Mirror);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onPointerDown = function ($event) {
            this.findClosestThumb($event);
            if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
                return;
            }
            var activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbFrom;
            activeThumb.nativeElement.setPointerCapture($event.pointerId);
            this.showSliderIndicators();
            $event.preventDefault();
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onPointerUp = function ($event) {
            if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
                return;
            }
            var activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbTo;
            activeThumb.nativeElement.releasePointerCapture($event.pointerId);
            this.hideSliderIndicators();
            this.onValueChanged.emit(this.value);
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onFocus = function () {
            this.toggleSliderIndicators();
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onPanListener = function ($event) {
            this.update($event.srcEvent.clientX);
        };
        Object.defineProperty(IgxSliderComponent.prototype, "isRange", {
            /**
             *Returns whether the `IgxSliderComponent` type is RANGE.
             *```typescript
             *@ViewChild("slider")
             *public slider: IgxSliderComponent;
             *ngAfterViewInit(){
             *    let sliderRange = this.slider.isRange;
             *}
             * ```
             */
            get: function () {
                return this.type === exports.IgxSliderType.RANGE;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "lowerValue", {
            /**
             * Returns the lower value of the `IgxSliderComponent`.
             * ```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * public lowValue(event){
             *    let sliderLowValue = this.slider.lowerValue;
             *}
             *```
             */
            get: function () {
                if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {
                    return this._lowerValue;
                }
                return this.lowerBound;
            },
            /**
             *Sets the lower value of the `IgxSliderComponent`.
             *```typescript
             *@ViewChild("slider2")
             *public slider: IgxSliderComponent;
             *public lowValue(event){
             *    this.slider.lowerValue = 120;
             *}
             *```
             */
            set: function (value) {
                value = this.valueInRange(value, this.lowerBound, this.upperBound);
                this._lowerValue = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "upperValue", {
            /**
             *Returns the upper value of the `IgxSliderComponent`.
             *```typescript
             *@ViewChild("slider2")
             *public slider: IgxSliderComponent;
             *public upperValue(event){
             *    let upperValue = this.slider.upperValue;
             *}
             *```
             */
            get: function () {
                if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {
                    return this._upperValue;
                }
                return this.upperBound;
            },
            /**
             *Sets the upper value of the `IgxSliderComponent`.
             *```typescript
             *@ViewChild("slider2")
             *public slider: IgxSliderComponent;
             *public upperValue(event){
             *    this.slider.upperValue = 120;
             *}
             *```
             */
            set: function (value) {
                value = this.valueInRange(value, this.lowerBound, this.upperBound);
                this._upperValue = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "lowerLabel", {
            /**
             * Returns the value corresponding the lower label.
             *```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * let label = this.slider.lowerLabel;
             *```
             */
            get: function () {
                return this.labelsViewEnabled ?
                    this.labels[this.lowerValue] :
                    this.lowerValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "upperLabel", {
            /**
             * Returns the value corresponding the upper label.
             *```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * let label = this.slider.upperLabel;
             *```
             */
            get: function () {
                return this.labelsViewEnabled ?
                    this.labels[this.upperValue] :
                    this.upperValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "labelsViewEnabled", {
            /**
             * Returns if label view is enabled.
             * If the {@link labels} is set, the view is automatically activated.
             *```typescript
             * @ViewChild("slider")
             * public slider: IgxSliderComponent;
             * let labelView = this.slider.labelsViewEnabled;
             *```
             */
            get: function () {
                return !!(this.labels && this.labels.length > 1);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "showTopTicks", {
            /**
             * @hidden
             */
            get: function () {
                return this.ticksOrientation === exports.TicksOrientation.Top ||
                    this.ticksOrientation === exports.TicksOrientation.Mirror;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSliderComponent.prototype, "showBottomTicks", {
            /**
             * @hidden
             */
            get: function () {
                return this.ticksOrientation === exports.TicksOrientation.Bottom ||
                    this.ticksOrientation === exports.TicksOrientation.Mirror;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.ngOnInit = function () {
            this.sliderSetup();
            // Set track travel zone
            this._pMin = this.valueToFraction(this.lowerBound) || 0;
            this._pMax = this.valueToFraction(this.upperBound) || 1;
        };
        IgxSliderComponent.prototype.ngOnChanges = function (changes) {
            if (changes.minValue && changes.maxValue &&
                changes.minValue.currentValue < changes.maxValue.currentValue) {
                this._maxValue = changes.maxValue.currentValue;
                this._minValue = changes.minValue.currentValue;
            }
        };
        IgxSliderComponent.prototype.ngAfterContentInit = function () {
            this.setValue(this._value);
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this._hasViewInit = true;
            this.positionHandlersAndUpdateTrack();
            this.setTickInterval();
            this.changeThumbFocusableState(this.disabled);
            this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));
            this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));
            this.thumbs.changes.pipe(operators.takeUntil(this._destroyer$)).subscribe(function (change) {
                var thumbFrom = change.find(function (thumb) { return thumb.type === exports.SliderHandle.FROM; });
                _this.positionHandler(thumbFrom, null, _this.lowerValue);
                _this.subscribeTo(thumbFrom, _this.thumbChanged.bind(_this));
                _this.changeThumbFocusableState(_this.disabled);
            });
            this.labelRefs.changes.pipe(operators.takeUntil(this._destroyer$)).subscribe(function (change) {
                var labelFrom = _this.labelRefs.find(function (label) { return label.type === exports.SliderHandle.FROM; });
                _this.positionHandler(null, labelFrom, _this.lowerValue);
            });
            this._ngZone.runOutsideAngular(function () {
                resizeObservable(_this._el.nativeElement).pipe(operators.throttleTime(40), operators.takeUntil(_this._destroyer$)).subscribe(function () { return _this._ngZone.run(function () {
                    _this.stepDistance = _this.calculateStepDistance();
                }); });
            });
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.ngOnDestroy = function () {
            this._destroyer$.next(true);
            this._destroyer$.complete();
            this._indicatorsDestroyer$.next(true);
            this._indicatorsDestroyer$.complete();
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.writeValue = function (value) {
            if (!value) {
                return;
            }
            this.normalizeByStep(value);
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.registerOnChange = function (fn) {
            this._onChangeCallback = fn;
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.registerOnTouched = function (fn) {
            this._onTouchedCallback = fn;
        };
        /** @hidden */
        IgxSliderComponent.prototype.getEditElement = function () {
            return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
        };
        /**
         *
         * @hidden
         */
        IgxSliderComponent.prototype.update = function (mouseX) {
            if (this.disabled) {
                return;
            }
            // Update To/From Values
            this.onPan.next(mouseX);
            // Finally do positionHandlersAndUpdateTrack the DOM
            // based on data values
            this.positionHandlersAndUpdateTrack();
            this._onTouchedCallback();
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.thumbChanged = function (value, thumbType) {
            var oldValue = this.value;
            var newVal;
            if (this.isRange) {
                if (thumbType === exports.SliderHandle.FROM) {
                    newVal = {
                        lower: this.value.lower + value,
                        upper: this.value.upper
                    };
                }
                else {
                    newVal = {
                        lower: this.value.lower,
                        upper: this.value.upper + value
                    };
                }
                // Swap the thumbs if a collision appears.
                if (newVal.lower >= newVal.upper) {
                    this.value = this.swapThumb(newVal);
                }
                else {
                    this.value = newVal;
                }
            }
            else {
                this.value = this.value + value;
            }
            if (this.hasValueChanged(oldValue)) {
                this.emitValueChanged(oldValue);
            }
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onThumbChange = function () {
            this.toggleSliderIndicators();
        };
        /**
         * @hidden
         */
        IgxSliderComponent.prototype.onHoverChange = function (state) {
            return state ? this.showSliderIndicators() : this.hideSliderIndicators();
        };
        IgxSliderComponent.prototype.swapThumb = function (value) {
            if (this.thumbFrom.isActive) {
                value.upper = this.upperValue;
                value.lower = this.upperValue;
            }
            else {
                value.upper = this.lowerValue;
                value.lower = this.lowerValue;
            }
            this.toggleThumb();
            return value;
        };
        IgxSliderComponent.prototype.findClosestThumb = function (event) {
            if (this.isRange) {
                this.closestHandle(event);
            }
            else {
                this.thumbTo.nativeElement.focus();
            }
            this.update(event.clientX);
        };
        IgxSliderComponent.prototype.updateLowerBoundAndMinTravelZone = function () {
            this.lowerBound = this.minValue;
            this._pMin = 0;
        };
        IgxSliderComponent.prototype.updateUpperBoundAndMaxTravelZone = function () {
            this.upperBound = this.maxValue;
            this._pMax = 1;
        };
        IgxSliderComponent.prototype.sliderSetup = function () {
            /**
             * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.
             */
            if (!this.isRange && this._upperValue === undefined) {
                this._upperValue = this.lowerBound;
            }
        };
        IgxSliderComponent.prototype.calculateStepDistance = function () {
            return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;
        };
        IgxSliderComponent.prototype.toggleThumb = function () {
            return this.thumbFrom.isActive ?
                this.thumbTo.nativeElement.focus() :
                this.thumbFrom.nativeElement.focus();
        };
        IgxSliderComponent.prototype.valueInRange = function (value, min, max) {
            if (min === void 0) { min = 0; }
            if (max === void 0) { max = 100; }
            return Math.max(Math.min(value, max), min);
        };
        IgxSliderComponent.prototype.generateTickMarks = function (color, interval) {
            return interval !== null ? "repeating-linear-gradient(\n            " + 'to left' + ",\n            " + color + ",\n            " + color + " 1.5px,\n            transparent 1.5px,\n            transparent " + interval + "%\n        ), repeating-linear-gradient(\n            " + 'to right' + ",\n            " + color + ",\n            " + color + " 1.5px,\n            transparent 1.5px,\n            transparent " + interval + "%\n        )" : interval;
        };
        IgxSliderComponent.prototype.positionHandler = function (thumbHandle, labelHandle, position) {
            var positionLeft = this.valueToFraction(position) * 100 + "%";
            if (thumbHandle) {
                thumbHandle.nativeElement.style.left = positionLeft;
            }
            if (labelHandle) {
                labelHandle.nativeElement.style.left = positionLeft;
            }
        };
        IgxSliderComponent.prototype.positionHandlersAndUpdateTrack = function () {
            if (!this.isRange) {
                this.positionHandler(this.thumbTo, this.labelTo, this.value);
            }
            else {
                this.positionHandler(this.thumbTo, this.labelTo, this.value.upper);
                this.positionHandler(this.thumbFrom, this.labelFrom, this.value.lower);
            }
            if (this._hasViewInit) {
                this.updateTrack();
            }
        };
        IgxSliderComponent.prototype.closestHandle = function (event) {
            var fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
            var toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
            var xPointer = event.clientX - this._el.nativeElement.getBoundingClientRect().left;
            var match = this.closestTo(xPointer, [fromOffset, toOffset]);
            if (fromOffset === toOffset && toOffset < xPointer) {
                this.thumbTo.nativeElement.focus();
            }
            else if (fromOffset === toOffset && toOffset > xPointer) {
                this.thumbFrom.nativeElement.focus();
            }
            else if (match === fromOffset) {
                this.thumbFrom.nativeElement.focus();
            }
            else {
                this.thumbTo.nativeElement.focus();
            }
        };
        IgxSliderComponent.prototype.setTickInterval = function () {
            var interval;
            var trackProgress = 100;
            if (this.labelsViewEnabled) {
                // Calc ticks depending on the labels length;
                interval = ((trackProgress / (this.labels.length - 1) * 10)) / 10;
            }
            else {
                var trackRange = this.maxValue - this.minValue;
                interval = this.step > 1 ?
                    (trackProgress / ((trackRange / this.step)) * 10) / 10
                    : null;
            }
            var renderCallbackExecution = !this.continuous ? this.generateTickMarks('white', interval) : null;
            this.renderer.setStyle(this.ticks.nativeElement, 'background', renderCallbackExecution);
        };
        IgxSliderComponent.prototype.showSliderIndicators = function () {
            if (this.disabled) {
                return;
            }
            if (this._indicatorsTimer) {
                this._indicatorsDestroyer$.next(true);
                this._indicatorsTimer = null;
            }
            this.thumbTo.showThumbIndicators();
            this.labelTo.active = true;
            if (this.thumbFrom) {
                this.thumbFrom.showThumbIndicators();
            }
            if (this.labelFrom) {
                this.labelFrom.active = true;
            }
        };
        IgxSliderComponent.prototype.hideSliderIndicators = function () {
            var _this = this;
            if (this.disabled) {
                return;
            }
            this._indicatorsTimer = rxjs.timer(this.thumbLabelVisibilityDuration);
            this._indicatorsTimer.pipe(operators.takeUntil(this._indicatorsDestroyer$)).subscribe(function () {
                _this.thumbTo.hideThumbIndicators();
                _this.labelTo.active = false;
                if (_this.thumbFrom) {
                    _this.thumbFrom.hideThumbIndicators();
                }
                if (_this.labelFrom) {
                    _this.labelFrom.active = false;
                }
            });
        };
        IgxSliderComponent.prototype.toggleSliderIndicators = function () {
            this.showSliderIndicators();
            this.hideSliderIndicators();
        };
        IgxSliderComponent.prototype.changeThumbFocusableState = function (state) {
            var value = state ? -1 : 1;
            if (this.isRange) {
                this.thumbFrom.tabindex = value;
            }
            this.thumbTo.tabindex = value;
            this._cdr.detectChanges();
        };
        IgxSliderComponent.prototype.closestTo = function (goal, positions) {
            return positions.reduce(function (previous, current) {
                return (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
            });
        };
        IgxSliderComponent.prototype.valueToFraction = function (value, pMin, pMax) {
            if (pMin === void 0) { pMin = this._pMin; }
            if (pMax === void 0) { pMax = this._pMax; }
            return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);
        };
        /**
         * @hidden
         * Normalizе the value when two-way data bind is used and {@link this.step} is set.
         * @param value
         */
        IgxSliderComponent.prototype.normalizeByStep = function (value) {
            if (this.isRange) {
                this.value = {
                    lower: value.lower - (value.lower % this.step),
                    upper: value.upper - (value.upper % this.step)
                };
            }
            else {
                this.value = value - (value % this.step);
            }
        };
        IgxSliderComponent.prototype.updateTrack = function () {
            var fromPosition = this.valueToFraction(this.lowerValue);
            var toPosition = this.valueToFraction(this.upperValue);
            var positionGap = toPosition - fromPosition;
            var trackLeftIndention = fromPosition;
            if (this.isRange) {
                if (positionGap) {
                    trackLeftIndention = Math.round((1 / positionGap * fromPosition) * 100);
                }
                this.renderer.setStyle(this.trackRef.nativeElement, 'transform', "scaleX(" + positionGap + ") translateX(" + trackLeftIndention + "%)");
            }
            else {
                this.renderer.setStyle(this.trackRef.nativeElement, 'transform', "scaleX(" + toPosition + ")");
            }
        };
        IgxSliderComponent.prototype.validateInitialValue = function (value) {
            if (value.lower < this.lowerBound && value.upper < this.lowerBound) {
                value.upper = this.lowerBound;
                value.lower = this.lowerBound;
            }
            if (value.lower > this.upperBound && value.upper > this.upperBound) {
                value.upper = this.upperBound;
                value.lower = this.upperBound;
            }
            if (value.upper < value.lower) {
                value.upper = this.upperValue;
                value.lower = this.lowerValue;
            }
            return value;
        };
        IgxSliderComponent.prototype.subscribeTo = function (thumb, callback) {
            if (!thumb) {
                return;
            }
            thumb.onThumbValueChange
                .pipe(operators.takeUntil(this.unsubscriber(thumb)))
                .subscribe(function (value) { return callback(value, thumb.type); });
        };
        IgxSliderComponent.prototype.unsubscriber = function (thumb) {
            return rxjs.merge(this._destroyer$, thumb.destroy);
        };
        IgxSliderComponent.prototype.hasValueChanged = function (oldValue) {
            var isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
            var isRangeWithOneDifferentValue = this.isRange &&
                (oldValue.lower !== this.value.lower ||
                    oldValue.upper !== this.value.upper);
            return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
        };
        IgxSliderComponent.prototype.setValue = function (value) {
            if (!this.isRange) {
                this.upperValue = value - (value % this.step);
            }
            else {
                value = this.validateInitialValue(value);
                this.upperValue = value.upper;
                this.lowerValue = value.lower;
            }
            this._onChangeCallback(this.value);
        };
        IgxSliderComponent.prototype.emitValueChanged = function (oldValue) {
            this.onValueChange.emit({ oldValue: oldValue, value: this.value });
        };
        var IgxSliderComponent_1;
        IgxSliderComponent.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.ViewChild('ticks', { static: true })
        ], IgxSliderComponent.prototype, "ticks", void 0);
        __decorate([
            core.ViewChildren(IgxSliderThumbComponent)
        ], IgxSliderComponent.prototype, "thumbs", void 0);
        __decorate([
            core.ViewChildren(IgxThumbLabelComponent)
        ], IgxSliderComponent.prototype, "labelRefs", void 0);
        __decorate([
            core.ViewChild('track', { static: true })
        ], IgxSliderComponent.prototype, "trackRef", void 0);
        __decorate([
            core.ContentChild(IgxThumbFromTemplateDirective, { read: core.TemplateRef })
        ], IgxSliderComponent.prototype, "thumbFromTemplateRef", void 0);
        __decorate([
            core.ContentChild(IgxThumbToTemplateDirective, { read: core.TemplateRef })
        ], IgxSliderComponent.prototype, "thumbToTemplateRef", void 0);
        __decorate([
            core.ContentChild(IgxTickLabelTemplateDirective, { read: core.TemplateRef, static: false })
        ], IgxSliderComponent.prototype, "tickLabelTemplateRef", void 0);
        __decorate([
            core.HostBinding("attr.role")
        ], IgxSliderComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding("attr.aria-valuemin")
        ], IgxSliderComponent.prototype, "valuemin", null);
        __decorate([
            core.HostBinding("attr.aria-valuemax")
        ], IgxSliderComponent.prototype, "valuemax", null);
        __decorate([
            core.HostBinding("attr.aria-readonly")
        ], IgxSliderComponent.prototype, "readonly", null);
        __decorate([
            core.HostBinding('class.igx-slider')
        ], IgxSliderComponent.prototype, "slierClass", void 0);
        __decorate([
            core.HostBinding('class.igx-slider--disabled')
        ], IgxSliderComponent.prototype, "disabledClass", null);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxSliderComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "type", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "thumbLabelVisibilityDuration", void 0);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "labels", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "step", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "disabled", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "continuous", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "minValue", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "maxValue", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "lowerBound", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "upperBound", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "value", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "primaryTicks", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "secondaryTicks", null);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "showTicks", void 0);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "primaryTickLabels", void 0);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "secondaryTickLabels", void 0);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "ticksOrientation", void 0);
        __decorate([
            core.Input()
        ], IgxSliderComponent.prototype, "tickLabelsOrientation", void 0);
        __decorate([
            core.Output()
        ], IgxSliderComponent.prototype, "onValueChange", void 0);
        __decorate([
            core.Output()
        ], IgxSliderComponent.prototype, "onValueChanged", void 0);
        __decorate([
            core.HostListener('pointerdown', ['$event'])
        ], IgxSliderComponent.prototype, "onPointerDown", null);
        __decorate([
            core.HostListener('pointerup', ['$event'])
        ], IgxSliderComponent.prototype, "onPointerUp", null);
        __decorate([
            core.HostListener('focus')
        ], IgxSliderComponent.prototype, "onFocus", null);
        __decorate([
            core.HostListener('pan', ['$event'])
        ], IgxSliderComponent.prototype, "onPanListener", null);
        IgxSliderComponent = IgxSliderComponent_1 = __decorate([
            core.Component({
                providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent_1, multi: true }],
                selector: 'igx-slider',
                template: "<div class=\"igx-slider__track\">\n    <igx-ticks\n        *ngIf=\"showTicks && showTopTicks\"\n        [ticksOrientation]=\"0\"\n        [primaryTicks]=\"primaryTicks\"\n        [secondaryTicks]=\"secondaryTicks\"\n        [primaryTickLabels]=\"primaryTickLabels\"\n        [secondaryTickLabels]=\"secondaryTickLabels\"\n        [tickLabelsOrientation]=\"tickLabelsOrientation\"\n        [labelsViewEnabled]=\"labelsViewEnabled\"\n        [labels]=\"labels | spreadTickLabels:secondaryTicks\"\n        [tickLabelTemplateRef]=\"tickLabelTemplateRef\"\n        [minValue]=\"minValue\"\n        [maxValue]=\"maxValue\"></igx-ticks>\n\n    <div #track class=\"igx-slider__track-fill\"></div>\n    <div #ticks class=\"igx-slider__track-steps\"></div>\n\n    <igx-ticks\n        *ngIf=\"showTicks && showBottomTicks\"\n        [ticksOrientation]=\"1\"\n        [primaryTicks]=\"primaryTicks\"\n        [secondaryTicks]=\"secondaryTicks\"\n        [primaryTickLabels]=\"primaryTickLabels\"\n        [secondaryTickLabels]=\"secondaryTickLabels\"\n        [tickLabelsOrientation]=\"tickLabelsOrientation\"\n        [labelsViewEnabled]=\"labelsViewEnabled\"\n        [labels]=\"labels | spreadTickLabels:secondaryTicks\"\n        [tickLabelTemplateRef]=\"tickLabelTemplateRef\"\n        [minValue]=\"minValue\"\n        [maxValue]=\"maxValue\"></igx-ticks>\n</div>\n<div class=\"igx-slider__thumbs\">\n    <igx-thumb-label\n        *ngIf=\"isRange\"\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"\n        [deactiveState]=\"deactivateThumbLabel\"></igx-thumb-label>\n\n    <igx-thumb\n        *ngIf=\"isRange\"\n        #thumbFrom\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n\n    <igx-thumb-label\n        [value]=\"upperLabel\"\n        [type]=\"1\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"\n        [deactiveState]=\"deactivateThumbLabel\"></igx-thumb-label>\n\n    <igx-thumb\n        #thumbTo\n        [type]=\"1\"\n        [value]=\"upperLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n</div>\n"
            })
        ], IgxSliderComponent);
        return IgxSliderComponent;
    }());
    /**
     * @hidden
     */
    var IgxSliderModule = /** @class */ (function () {
        function IgxSliderModule() {
        }
        IgxSliderModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxTickLabelTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent,
                    IgxTicksComponent,
                    IgxTickLabelsPipe
                ],
                exports: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxTickLabelTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent,
                    IgxTicksComponent
                ],
                imports: [common.CommonModule, forms.FormsModule]
            })
        ], IgxSliderModule);
        return IgxSliderModule;
    }());

    var NEXT_ID$s = 0;
    /**
     * **Ignite UI for Angular Snackbar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/snackbar.html)
     *
     * The Ignite UI Snack Bar provides feedback about an operation with a single-line message, which can
     * include a link to an action such as Undo.
     *
     * Example:
     * ```html
     * <button (click)="snackbar.show()">Send message</button>
     * <div>
     *   <igx-snackbar #snackbar message="Message sent">
     *   </igx-snackbar>
     * </div>
     * ```
     */
    var IgxSnackbarComponent = /** @class */ (function () {
        function IgxSnackbarComponent(zone) {
            this.zone = zone;
            /**
             * Sets/gets the `id` of the snackbar.
             * If not set, the `id` of the first snackbar component  will be `"igx-snackbar-0"`;
             * ```html
             * <igx-snackbar id = "Snackbar1"></igx-snackbar>
             * ```
             * ```typescript
             * let snackbarId = this.snackbar.id;
             * ```
             * @memberof IgxSnackbarComponent
             */
            this.id = "igx-snackbar-" + NEXT_ID$s++;
            /**
             * Enables/Disables the visibility of the snackbar.
             * If not set, the `isVisible` attribute will have value `false`.
             * ```html
             * <igx-snackbar [isVisible] = "true"></igx-snackbar>
             * ```
             * ```typescript
             * let isVisible =  this.snackbar.isVisible;
             * ```
             */
            this.isVisible = false;
            /**
             * Sets/gets if the snackbar will be automatically hidden after the `displayTime` is over.
             * Default value is `true`.
             * ```html
             * <igx-snackbar [autoHide] = "false"></igx-snackbar>
             * ```
             * ```typescript
             * let autoHide =  this.snackbar.autoHide;
             * ```
             */
            this.autoHide = true;
            /**
             * Sets/gets the duration of time(in milliseconds) in which the snackbar will be visible after it is being shown.
             * Default value is 4000.
             * ```html
             * <igx-snackbar [displayTime] = "2000"></igx-snackbar>
             * ```
             * ```typescript
             * let displayTime = this.snackbar.displayTime;
             * ```
             */
            this.displayTime = 4000;
            /**
             * An event that will be emitted when the action is executed.
             * Provides reference to the `IgxSnackbarComponent` as an argument.
             * ```html
             * <igx-snackbar (onAction) = "onAction($event)"></igx-snackbar>
             * ```
             */
            this.onAction = new core.EventEmitter();
            /**
             * An event that will be emitted when the snackbar animation starts.
             * Provides reference to the `AnimationEvent` interface as an argument.
             * ```html
             * <igx-snackbar (animationStarted) = "animationStarted($event)"></igx-snackbar>
             * ```
             */
            this.animationStarted = new core.EventEmitter();
            /**
             * An event that will be emitted when the snackbar animation ends.
             * Provides reference to the `AnimationEvent` interface as an argument.
             * ```html
             * <igx-snackbar (animationDone) = "animationDone($event)"></igx-snackbar>
             * ```
             */
            this.animationDone = new core.EventEmitter();
        }
        /**
         * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
         * ```typescript
         * this.snackbar.show();
         * ```
         */
        IgxSnackbarComponent.prototype.show = function () {
            var _this = this;
            clearTimeout(this.timeoutId);
            setTimeout(this.timeoutId);
            this.isVisible = true;
            if (this.autoHide) {
                this.timeoutId = setTimeout(function () {
                    _this.hide();
                }, this.displayTime);
            }
        };
        /**
         * Hides the snackbar.
         * ```typescript
         * this.snackbar.hide();
         * ```
         */
        IgxSnackbarComponent.prototype.hide = function () {
            this.isVisible = false;
            clearTimeout(this.timeoutId);
        };
        /**
         *@hidden
         */
        IgxSnackbarComponent.prototype.triggerAction = function () {
            this.onAction.emit(this);
        };
        /**
         *@hidden
         * @memberof IgxSnackbarComponent
         */
        IgxSnackbarComponent.prototype.snackbarAnimationStarted = function (evt) {
            if (evt.fromState === 'void') {
                this.animationStarted.emit(evt);
            }
        };
        /**
         *@hidden
         * @memberof IgxSnackbarComponent
         */
        IgxSnackbarComponent.prototype.snackbarAnimationDone = function (evt) {
            if (evt.fromState === 'show') {
                this.animationDone.emit(evt);
            }
        };
        IgxSnackbarComponent.ctorParameters = function () { return [
            { type: core.NgZone }
        ]; };
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxSnackbarComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxSnackbarComponent.prototype, "message", void 0);
        __decorate([
            core.Input()
        ], IgxSnackbarComponent.prototype, "isVisible", void 0);
        __decorate([
            core.Input()
        ], IgxSnackbarComponent.prototype, "autoHide", void 0);
        __decorate([
            core.Input()
        ], IgxSnackbarComponent.prototype, "displayTime", void 0);
        __decorate([
            core.Input()
        ], IgxSnackbarComponent.prototype, "actionText", void 0);
        __decorate([
            core.Output()
        ], IgxSnackbarComponent.prototype, "onAction", void 0);
        __decorate([
            core.Output()
        ], IgxSnackbarComponent.prototype, "animationStarted", void 0);
        __decorate([
            core.Output()
        ], IgxSnackbarComponent.prototype, "animationDone", void 0);
        IgxSnackbarComponent = __decorate([
            core.Component({
                animations: [
                    animations.trigger('slideInOut', [
                        animations.transition('void => *', [
                            animations.useAnimation(slideInBottom, {
                                params: {
                                    duration: '.35s',
                                    easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
                                    fromPosition: 'translateY(100%)',
                                    toPosition: 'translateY(0)'
                                }
                            })
                        ]),
                        animations.transition('* => void', [
                            animations.useAnimation(slideOutBottom, {
                                params: {
                                    duration: '.2s',
                                    easing: 'cubic-bezier(0.4, 0.0, 1, 1)',
                                    fromPosition: 'translateY(0)',
                                    toOpacity: 1,
                                    toPosition: 'translateY(100%)'
                                }
                            })
                        ])
                    ]),
                    animations.trigger('fadeInOut', [
                        animations.transition('void => *', [
                            animations.useAnimation(fadeIn, {
                                params: {
                                    duration: '.35s',
                                    easing: 'ease-out'
                                }
                            })
                        ]),
                        animations.transition('* => void', [
                            animations.useAnimation(fadeOut, {
                                params: {
                                    duration: '.2s',
                                    easing: 'ease-out'
                                }
                            })
                        ])
                    ])
                ],
                selector: 'igx-snackbar',
                template: "<div class=\"igx-snackbar\" *ngIf=\"isVisible\" (@slideInOut.start)=\"snackbarAnimationStarted($event)\" (@slideInOut.done)=\"snackbarAnimationDone($event)\"\n    [@slideInOut]=\"isVisible\">\n    <div class=\"igx-snackbar__message\" [@fadeInOut]=\"isVisible\">\n        {{ message }}\n        <ng-content></ng-content>\n    </div>\n    <button class=\"igx-snackbar__button\" igxRipple=\"white\" *ngIf=\"actionText\" [@fadeInOut] (click)=\"triggerAction()\">\n        {{ actionText }}\n    </button>\n</div>\n",
                styles: ["\n        :host {\n            display: block;\n        }\n    "]
            })
        ], IgxSnackbarComponent);
        return IgxSnackbarComponent;
    }());
    /**
     * @hidden
     */
    var IgxSnackbarModule = /** @class */ (function () {
        function IgxSnackbarModule() {
        }
        IgxSnackbarModule = __decorate([
            core.NgModule({
                declarations: [IgxSnackbarComponent],
                exports: [IgxSnackbarComponent],
                imports: [common.CommonModule]
            })
        ], IgxSnackbarModule);
        return IgxSnackbarModule;
    }());


    (function (SwitchLabelPosition) {
        SwitchLabelPosition["BEFORE"] = "before";
        SwitchLabelPosition["AFTER"] = "after";
    })(exports.SwitchLabelPosition || (exports.SwitchLabelPosition = {}));
    var noop$8 = function () { };
    var ɵ0$9 = noop$8;
    var nextId$3 = 0;
    /**
     *
     * The Switch component is a binary choice selection component.
     *
     * @igxModule IgxSwitchModule
     *
     * @igxTheme igx-switch-theme, igx-tooltip-theme
     *
     * @igxKeywords switch, states, tooltip
     *
     * @igxGroup Data Entry & Display
     *
     * @remarks
     *
     * The Ignite UI Switch lets the user toggle between on/off or true/false states.
     *
     * @example
     * ```html
     * <igx-switch [checked]="true">
     *   Simple switch
     * </igx-switch>
     * ```
     */
    var IgxSwitchComponent = /** @class */ (function () {
        function IgxSwitchComponent() {
            /**
             * Sets/gets the `id` of the switch component.
             * If not set, the `id` of the first switch component will be `"igx-switch-0"`.
             *
             * @example
             * ```html
             * <igx-switch id="my-first-switch"></igx-switch>
             * ```
             */
            this.id = "igx-switch-" + nextId$3++;
            /**
             * Sets/gets the id of the `label` element of the switch component.
             * If not set, the label of the first switch component will have value `"igx-switch-0-label"`.
             *
             * @example
             * ```html
             * <igx-switch labelId="Label1"></igx-switch>
             * ```
             */
            this.labelId = this.id + "-label";
            /**
             * Sets/gets the value of the `tabindex` attribute.
             *
             * @example
             * ```html
             * <igx-switch [tabindex]="1"></igx-switch>
             * ```
             */
            this.tabindex = null;
            /**
             * Sets/gets the position of the `label` in the switch component.
             * If not set, `labelPosition` will have value `"after"`.
             *
             * @example
             * ```html
             * <igx-switch labelPosition="before"></igx-switch>
             * ```
             */
            this.labelPosition = 'after';
            /**
             * Enables/Disables the ripple effect
             * If not set, `disableRipple` will have value `false`.
             *
             * @example
             * ```html
             * <igx-switch [disableRipple]="true"></igx-switch>
             * ```
             */
            this.disableRipple = false;
            /**
             * Sets/gets whether switch is required.
             * If not set, `required` will have value `false`.
             *
             * @example
             * ```html
             * <igx-switch [required]="true"></igx-switch>
             * ```
             */
            this.required = false;
            /**
             * Sets/gets the `aria-labelledBy` attribute.
             * If not set, the  value of `aria-labelledBy` will be equal to the value of `labelId` attribute.
             *
             * @example
             * ```html
             * <igx-switch aria-labelledby = "Label1"></igx-switch>
             * ```
             */
            this.ariaLabelledBy = this.labelId;
            /**
             * Sets/gets the value of the `aria-label` attribute.
             *
             * @example
             * ```html
             * <igx-switch aria-label="Label1"></igx-switch>
             * ```
             */
            this.ariaLabel = null;
            /**
             * An event that is emitted after the switch state is changed.
             * Provides references to the `IgxSwitchComponent` and the `checked` property as event arguments.
             */
            this.change = new core.EventEmitter();
            /**
             * @hidden
             * @internal
             */
            this._onTouchedCallback = noop$8;
            /**
             * @hidden
             * @internal
             */
            this._onChangeCallback = noop$8;
            /**
             * Returns the class of the switch component.
             *
             * @example
             * ```typescript
             * let switchClass = this.switch.cssClass;
             * ```
             */
            this.cssClass = 'igx-switch';
            /**
             * Sets/gets whether the switch is on or off.
             * Default value is 'false'.
             *
             * @example
             * ```html
             *  <igx-switch [checked]="true"></igx-switch>
             * ```
             */
            this.checked = false;
            /**
             * Sets/gets the `disabled` attribute.
             * Default value is `false`.
             *
             * @example
             * ```html
             * <igx-switch [disabled]="true"><igx-switch>
             * ```
             */
            this.disabled = false;
            /**
             * Sets/gets whether the switch component is on focus.
             * Default value is `false`.
             *
             * @example
             * ```typescript
             * this.switch.focused = true;
             * ```
             */
            this.focused = false;
            /**
             * @hidden
             * @internal
             */
            this.inputId = this.id + "-input";
        }
        IgxSwitchComponent_1 = IgxSwitchComponent;
        /**
         * Toggles the checked state of the switch.
         *
         * @example
         * ```typescript
         * this.switch.toggle();
         * ```
         */
        IgxSwitchComponent.prototype.toggle = function () {
            if (this.disabled) {
                return;
            }
            this.checked = !this.checked;
            this.focused = false;
            this.change.emit({ checked: this.checked, switch: this });
            this._onChangeCallback(this.checked);
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype._onSwitchChange = function (event) {
            event.stopPropagation();
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype._onSwitchClick = function (event) {
            event.stopPropagation();
            this.toggle();
            if (isIE()) {
                this.nativeCheckbox.nativeElement.blur();
            }
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype._onLabelClick = function (event) {
            this.toggle();
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.onFocus = function (event) {
            this.focused = true;
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.onBlur = function (event) {
            this.focused = false;
            this._onTouchedCallback();
        };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.writeValue = function (value) {
            this._value = value;
            this.checked = !!this._value;
        };
        /**
         * @hidden
         * @internal
         * */
        IgxSwitchComponent.prototype.getEditElement = function () {
            return this.nativeCheckbox.nativeElement;
        };
        Object.defineProperty(IgxSwitchComponent.prototype, "labelClass", {
            /**
             * @hidden
             * @internal
             */
            get: function () {
                switch (this.labelPosition) {
                    case exports.SwitchLabelPosition.BEFORE:
                        return this.cssClass + "__label--before";
                    case exports.SwitchLabelPosition.AFTER:
                    default:
                        return this.cssClass + "__label";
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.registerOnChange = function (fn) { this._onChangeCallback = fn; };
        /**
         * @hidden
         * @internal
         */
        IgxSwitchComponent.prototype.registerOnTouched = function (fn) { this._onTouchedCallback = fn; };
        var IgxSwitchComponent_1;
        __decorate([
            core.ViewChild('checkbox', { static: true })
        ], IgxSwitchComponent.prototype, "nativeCheckbox", void 0);
        __decorate([
            core.ViewChild('label', { static: true })
        ], IgxSwitchComponent.prototype, "nativeLabel", void 0);
        __decorate([
            core.ViewChild('placeholderLabel', { static: true })
        ], IgxSwitchComponent.prototype, "placeholderLabel", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxSwitchComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxSwitchComponent.prototype, "labelId", void 0);
        __decorate([
            core.Input()
        ], IgxSwitchComponent.prototype, "value", void 0);
        __decorate([
            core.Input()
        ], IgxSwitchComponent.prototype, "name", void 0);
        __decorate([
            core.Input()
        ], IgxSwitchComponent.prototype, "tabindex", void 0);
        __decorate([
            core.Input()
        ], IgxSwitchComponent.prototype, "labelPosition", void 0);
        __decorate([
            core.Input()
        ], IgxSwitchComponent.prototype, "disableRipple", void 0);
        __decorate([
            core.Input()
        ], IgxSwitchComponent.prototype, "required", void 0);
        __decorate([
            core.Input('aria-labelledby')
        ], IgxSwitchComponent.prototype, "ariaLabelledBy", void 0);
        __decorate([
            core.Input('aria-label')
        ], IgxSwitchComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.Output()
        ], IgxSwitchComponent.prototype, "change", void 0);
        __decorate([
            core.HostBinding('class.igx-switch')
        ], IgxSwitchComponent.prototype, "cssClass", void 0);
        __decorate([
            core.HostBinding('class.igx-switch--checked'),
            core.Input()
        ], IgxSwitchComponent.prototype, "checked", void 0);
        __decorate([
            core.HostBinding('class.igx-switch--disabled'),
            core.Input()
        ], IgxSwitchComponent.prototype, "disabled", void 0);
        __decorate([
            core.HostBinding('class.igx-switch--focused')
        ], IgxSwitchComponent.prototype, "focused", void 0);
        IgxSwitchComponent = IgxSwitchComponent_1 = __decorate([
            core.Component({
                providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: IgxSwitchComponent_1, multi: true }],
                selector: 'igx-switch',
                template: "<input #checkbox class=\"igx-switch__input\" type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onSwitchChange($event)\"\n    (click)=\"_onSwitchClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<label #label class =\"igx-switch__composite\" [for]=\"inputId\"\n    igxRipple\n    igxRippleTarget=\".igx-switch__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\">\n    <div class=\"igx-switch__composite-thumb\">\n        <div class=\"igx-switch__ripple\"></div>\n    </div>\n</label>\n\n<span #placeholderLabel role=\"label\"\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
            })
        ], IgxSwitchComponent);
        return IgxSwitchComponent;
    }());
    var IGX_SWITCH_REQUIRED_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return IgxSwitchRequiredDirective; }),
        multi: true
    };
    /* tslint:disable directive-selector */
    var IgxSwitchRequiredDirective = /** @class */ (function (_super) {
        __extends(IgxSwitchRequiredDirective, _super);
        function IgxSwitchRequiredDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IgxSwitchRequiredDirective = __decorate([
            core.Directive({
                selector: "igx-switch[required][formControlName],\n    igx-switch[required][formControl],\n    igx-switch[required][ngModel]",
                providers: [IGX_SWITCH_REQUIRED_VALIDATOR]
            })
        ], IgxSwitchRequiredDirective);
        return IgxSwitchRequiredDirective;
    }(forms.CheckboxRequiredValidator));
    /**
     * @hidden
     */
    var IgxSwitchModule = /** @class */ (function () {
        function IgxSwitchModule() {
        }
        IgxSwitchModule = __decorate([
            core.NgModule({
                declarations: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                exports: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                imports: [IgxRippleModule]
            })
        ], IgxSwitchModule);
        return IgxSwitchModule;
    }());

    var NEXT_ID$t = 0;
    var IgxTabTemplateDirective = /** @class */ (function () {
        function IgxTabTemplateDirective(template) {
            this.template = template;
        }
        IgxTabTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxTabTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxTab]'
            })
        ], IgxTabTemplateDirective);
        return IgxTabTemplateDirective;
    }());
    /**
     * **Ignite UI for Angular Tab Bar** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tabbar.html)
     *
     * The Ignite UI Tab Bar enables the user to navigate among a number of content panels displayed in a single view.
     *
     * Example:
     * ```html
     * <igx-bottom-nav>
     *   <igx-tab-panel label="Tab 1">Tab 1 Content</igx-tab-panel>
     *   <igx-tab-panel label="Tab 2">Tab 2 Content</igx-tab-panel>
     *   <igx-tab-panel label="Tab 3">Tab 3 Content</igx-tab-panel>
     * </igx-bottom-nav>
     * ```
     */
    var IgxBottomNavComponent = /** @class */ (function () {
        function IgxBottomNavComponent(_element) {
            this._element = _element;
            /**
             * Sets/gets the `id` of the tab bar.
             * If not set, the `id` of the first tab bar component will be `"igx-bottom-nav-0"`.
             * ```html
             * <igx-bottom-nav id = "my-first-tab-bar"></igx-bottom-nav>
             * ```
             * ```typescript
             * let tabBarId =  this.tabBar.id;
             * ```
             * @memberof IgxBottomNavComponent
             */
            this.id = "igx-bottom-nav-" + NEXT_ID$t++;
            /**
             * Emits an event when a new tab is selected.
             * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
             * ```html
             * <igx-bottom-nav (onTableSelected) = "onTabSelected($event)"><igx-bottom-nav>
             * ```
             * @memberof IgxBottomNavComponent
             */
            this.onTabSelected = new core.EventEmitter();
            /**
             * Emits an event when a tab is deselected.
             * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
             * ```html
             * <igx-bottom-nav (onTabDeselected) = "onTabDeselected($event)"><igx-bottom-nav>
             * ```
             * @memberof IgxBottomNavComponent
             */
            this.onTabDeselected = new core.EventEmitter();
            /**
             * Gets the `index` of selected tab/panel in the respective collection.
             * ```typescript
             * let index =  this.tabBar.selectedIndex;
             * ```
             * @memberof IgxBottomNavComponent
             */
            this.selectedIndex = -1;
            /**
             *@hidden
             */
            this._itemStyle = 'igx-bottom-nav';
        }
        Object.defineProperty(IgxBottomNavComponent.prototype, "tabs", {
            /**
             * Gets the `IgxTabComponent` elements for this bottom navigation component.
             * First try to get them as content children if not available get them as view children.
             * ```typescript
             * let tabs: QueryList<IgxTabComponent> =  this.tabBar.tabs;
             * ```
             * @memberof IgxBottomNavComponent
             */
            get: function () {
                return this.hasContentTabs ? this.contentTabs : this.viewTabs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxBottomNavComponent.prototype, "itemStyle", {
            /**
             * Gets the `itemStyle` of the tab bar.
             * ```typescript
             * let itemStyle =  this.tabBar.itemStyle;
             * ```
             * @memberof IgxBottomNavComponent
             */
            get: function () {
                return this._itemStyle;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxBottomNavComponent.prototype, "hasContentTabs", {
            /**
             *@hidden
             */
            get: function () {
                return (this.contentTabs && this.contentTabs.length > 0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxBottomNavComponent.prototype, "selectedTab", {
            /**
             * Gets the selected tab in the tab bar.
             * ```typescript
             * let tab =  this.tabBar.selectedTab;
             * ```
             * @memberof IgxBottomNavComponent
             */
            get: function () {
                if (this.tabs && this.selectedIndex !== undefined) {
                    return this.tabs.toArray()[this.selectedIndex];
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxBottomNavComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            // initial selection
            setTimeout(function () {
                if (_this.selectedIndex === -1) {
                    var selectablePanels = _this.panels.filter(function (p) { return !p.disabled; });
                    var panel = selectablePanels[0];
                    if (panel) {
                        panel.select();
                    }
                }
            }, 0);
        };
        /**
         *@hidden
         */
        IgxBottomNavComponent.prototype._selectedPanelHandler = function (args) {
            var _this = this;
            if (this.hasContentTabs) {
                this.selectedIndex = args.tab.index;
                this.contentTabs.forEach(function (t) {
                    if (t !== args.tab) {
                        _this._deselectTab(t);
                    }
                });
            }
            else {
                if (args.panel) {
                    this.selectedIndex = args.panel.index;
                    this.panels.forEach(function (p) {
                        if (p.index !== _this.selectedIndex) {
                            _this._deselectPanel(p);
                        }
                    });
                }
            }
        };
        /**
         *@hidden
         */
        IgxBottomNavComponent.prototype._deselectPanel = function (panel) {
            // Cannot deselect the selected tab - this will mean that there will be not selected tab left
            if (panel.disabled || this.selectedTab.index === panel.index) {
                return;
            }
            panel.isSelected = false;
            this.onTabDeselected.emit({ tab: this.tabs[panel.index], panel: panel });
        };
        IgxBottomNavComponent.prototype._deselectTab = function (aTab) {
            aTab.isSelected = false;
            this.onTabDeselected.emit({ tab: aTab, panel: null });
        };
        IgxBottomNavComponent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.ViewChildren(core.forwardRef(function () { return IgxTabComponent; }))
        ], IgxBottomNavComponent.prototype, "viewTabs", void 0);
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return IgxTabComponent; }))
        ], IgxBottomNavComponent.prototype, "contentTabs", void 0);
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return IgxTabPanelComponent; }))
        ], IgxBottomNavComponent.prototype, "panels", void 0);
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxBottomNavComponent.prototype, "id", void 0);
        __decorate([
            core.Output()
        ], IgxBottomNavComponent.prototype, "onTabSelected", void 0);
        __decorate([
            core.Output()
        ], IgxBottomNavComponent.prototype, "onTabDeselected", void 0);
        __decorate([
            core.HostListener('onTabSelected', ['$event'])
        ], IgxBottomNavComponent.prototype, "_selectedPanelHandler", null);
        IgxBottomNavComponent = __decorate([
            core.Component({
                selector: 'igx-bottom-nav',
                template: "<div *ngIf=\"!hasContentTabs\">\n    <ng-content></ng-content>\n</div>\n<div #tablist class=\"{{itemStyle}}__menu {{itemStyle}}__menu--bottom\" role=\"tablist\" aria-orientation=\"horizontal\">\n    <ng-container *ngIf=\"!hasContentTabs\">    \n        <igx-tab *ngFor=\"let panel of panels\" [relatedPanel]=\"panel\">\n        </igx-tab>\n    </ng-container>\n    <ng-content select=\"igx-tab\"></ng-content>\n</div>",
                styles: ["\n        :host {\n            display: block;\n        }\n    "]
            })
        ], IgxBottomNavComponent);
        return IgxBottomNavComponent;
    }());
    // ================================= IgxTabPanelComponent ======================================
    var IgxTabPanelComponent = /** @class */ (function () {
        function IgxTabPanelComponent(_tabBar, _element) {
            this._tabBar = _tabBar;
            this._element = _element;
            /**
             *@hidden
             */
            this._itemStyle = 'igx-tab-panel';
            /**
             *@hidden
             */
            this._isSelected = false;
            /**
             * Gets the role of the tab panel.
             * ```typescript
             * let tabPanelRole = this.tabPanel.role;
             * ```
             * @memberof IgxTabPanelComponent
             */
            this.role = 'tabpanel';
        }
        Object.defineProperty(IgxTabPanelComponent.prototype, "styleClass", {
            /**
             * Gets whether a tab panel will have `igx-bottom-nav__panel` class.
             * ```typescript
             * let styleClass = this.tabPanel.styleClass;
             * ```
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                return (!this.isSelected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "isSelected", {
            /**
             * Sets/gets whether a tab panel is selected.
             * ```typescript
             * this.tabPanel.isSelected = true;
             * ```
             * ```typescript
             * let isSelected =  this.tabPanel.isSelected;
             * ```
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                return this._isSelected;
            },
            set: function (newValue) {
                if (this._isSelected !== newValue) {
                    if (newValue) {
                        this.select();
                    }
                    else {
                        this._isSelected = newValue;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "itemStyle", {
            /**
             * Gets the `itemStyle` of the tab panel.
             * ```typescript
             * let itemStyle = this.tabPanel.itemStyle;
             * ```
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                return this._itemStyle;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "relatedTab", {
            /**
             * Gets the tab associated with the panel.
             * ```typescript
             * let tab = this.tabPanel.relatedTab;
             * ```
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                if (this._tabBar.tabs) {
                    return this._tabBar.tabs.toArray()[this.index];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "changesCount", {
            /**
             * Gets the changes and updates accordingly applied to the tab/panel.
             *
             * @memberof IgxTabComponent
             */
            get: function () {
                return this.relatedTab ? this.relatedTab.changesCount : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "index", {
            /**
             * Gets the index of a panel in the panels collection.
             * ```typescript
             * let panelIndex =  this.tabPanel.index
             * ```
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                if (this._tabBar.panels) {
                    return this._tabBar.panels.toArray().indexOf(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabPanelComponent.prototype, "customTabTemplate", {
            /**
             * Gets the tab template.
             * ```typescript
             * let tabTemplate = this.tabPanel.customTabTemplate
             * ```
             * @memberof IgxTabPanelComponent
             */
            get: function () {
                return this._tabTemplate;
            },
            /**
             * Sets the tab template.
             * ```typescript
             * this.tabPanel.customTabTemplate(tabTemplate);
             * ```
             * @memberof IgxTabPanelComponent
             */
            set: function (template) {
                this._tabTemplate = template;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *@hidden
         */
        IgxTabPanelComponent.prototype.ngAfterContentInit = function () {
            if (this.tabTemplate) {
                this._tabTemplate = this.tabTemplate.template;
            }
        };
        /**
         *@hidden
         */
        IgxTabPanelComponent.prototype.ngAfterViewChecked = function () {
            this._element.nativeElement.setAttribute('aria-labelledby', "igx-tab-" + this.index);
            this._element.nativeElement.setAttribute('id', "igx-bottom-nav__panel-" + this.index);
        };
        /**
         * Selects the current tab and the tab panel.
         * ```typescript
         * this.tabPanel.select();
         * ```
         * @memberof IgxTabPanelComponent
         */
        IgxTabPanelComponent.prototype.select = function () {
            if (this.disabled || this._tabBar.selectedIndex === this.index) {
                return;
            }
            this._isSelected = true;
            this._tabBar.onTabSelected.emit({ tab: this._tabBar.tabs.toArray()[this.index], panel: this });
        };
        IgxTabPanelComponent.ctorParameters = function () { return [
            { type: IgxBottomNavComponent },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxTabPanelComponent.prototype, "label", void 0);
        __decorate([
            core.Input()
        ], IgxTabPanelComponent.prototype, "icon", void 0);
        __decorate([
            core.Input()
        ], IgxTabPanelComponent.prototype, "disabled", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxTabPanelComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('class.igx-bottom-nav__panel')
        ], IgxTabPanelComponent.prototype, "styleClass", null);
        __decorate([
            core.HostBinding('class.igx-bottom-nav__panel--selected')
        ], IgxTabPanelComponent.prototype, "isSelected", null);
        __decorate([
            core.ContentChild(IgxTabTemplateDirective, { read: IgxTabTemplateDirective })
        ], IgxTabPanelComponent.prototype, "tabTemplate", void 0);
        IgxTabPanelComponent = __decorate([
            core.Component({
                selector: 'igx-tab-panel',
                template: "<ng-content></ng-content>\n"
            })
        ], IgxTabPanelComponent);
        return IgxTabPanelComponent;
    }());
    // ======================================= IgxTabComponent ==========================================
    var IgxTabComponent = /** @class */ (function () {
        function IgxTabComponent(_tabBar, _element) {
            this._tabBar = _tabBar;
            this._element = _element;
            /**
             * Gets the `role` attribute.
             * ```typescript
             * let tabRole = this.tab.role;
             * ```
             * @memberof IgxTabComponent
             */
            this.role = 'tab';
            /**
             * @hidden @internal
             */
            this.id = 'igx-tab-' + this.index;
            /**
             * @hidden @internal
             */
            this.ariaLabel = this.label;
            /**
             * @hidden @internal
             */
            this.ariaDisabled = this.disabled;
            /**
             * @hidden @internal
             */
            this.ariaSelected = this.isSelected;
            /**
             * @hidden @internal
             */
            this.ariaControls = 'igx-tab-panel-' + this.index;
            /**
             *@hidden
             */
            this._changesCount = 0; // changes and updates accordingly applied to the tab.
            this._disabled = false;
            this._selected = false;
        }
        Object.defineProperty(IgxTabComponent.prototype, "label", {
            /**
             * Sets/gets the `label` of the tab panel.
             * ```html
             * <igx-tab [label] = "'Tab label'"><igx-tab>
             * ```
             * ```typescript
             * let tabLabel = this.tab.label;
             * ```
             * @memberof IgxTabComponent
             */
            get: function () {
                return this.relatedPanel ? this.relatedPanel.label : this._label;
            },
            set: function (newValue) {
                if (this.relatedPanel) {
                    this.relatedPanel.label = newValue;
                }
                this._label = newValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "icon", {
            /**
             * Sets/gets  the `icon` of the tab panel.
             * ```html
             * <igx-tab [icon] = "tab_icon"><igx-tab>
             * ```
             * ```typescript
             * let tabIcon =  this.tab.icon;
             * ```
             * @memberof IgxTabComponent
             */
            get: function () {
                return this.relatedPanel ? this.relatedPanel.icon : this._icon;
            },
            set: function (newValue) {
                if (this.relatedPanel) {
                    this.relatedPanel.icon = newValue;
                }
                this._icon = newValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "changesCount", {
            /**
             * Gets the changes and updates accordingly applied to the tab.
             *
             * @memberof IgxTabComponent
             */
            get: function () {
                return this._changesCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "disabled", {
            /**
             * Gets whether the tab is disabled.
             * ```typescript
             * let isDisabled = this.tab.disabled;
             * ```
             * @memberof IgxTabComponent
             */
            get: function () {
                return this.relatedPanel ? this.relatedPanel.disabled : this._disabled;
            },
            set: function (newValue) {
                if (this.relatedPanel) {
                    this.relatedPanel.disabled = newValue;
                }
                else {
                    this._disabled = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "isSelected", {
            get: function () {
                return this.relatedPanel ? this.relatedPanel.isSelected : this._selected;
            },
            /**
             * Gets whether the tab is selected.
             * ```typescript
             * let isSelected  = this.tab.isSelected;
             * ```
             * @memberof IgxTabComponent
             */
            set: function (newValue) {
                if (this.relatedPanel) {
                    this.relatedPanel.isSelected = newValue;
                }
                else if (this._selected !== newValue) {
                    this._selected = newValue;
                    if (this._selected) {
                        this._tabBar.onTabSelected.emit({ tab: this, panel: null });
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "cssClassSelected", {
            get: function () {
                return this.isSelected;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "cssClassDisabled", {
            get: function () {
                return this.disabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "cssClass", {
            get: function () {
                return (!this.disabled && !this.isSelected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "index", {
            /**
             * Gets the `index` of the tab.
             * ```typescript
             * let tabIndex = this.tab.index;
             * ```
             * @memberof IgxTabComponent
             */
            get: function () {
                if (this._tabBar.tabs) {
                    return this._tabBar.tabs.toArray().indexOf(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "template", {
            /**
             * Returns the `template` for this IgxTabComponent.
             * ```typescript
             * let tabItemTemplate = this.tabItem.template;
             * ```
             * @memberof IgxTabComponent
             */
            get: function () {
                if (this.relatedPanel && this.relatedPanel.customTabTemplate) {
                    return this.relatedPanel.customTabTemplate;
                }
                if (this.customTabTemplateDir) {
                    return this.customTabTemplateDir.template;
                }
                return this.defaultTabTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabComponent.prototype, "context", {
            /**
             * Returns the `context` object for the template of this `IgxTabComponent`.
             * ```typescript
             * let tabItemContext = this.tabItem.context;
             * ```
             */
            get: function () {
                return this.relatedPanel ? this.relatedPanel : this;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Selects the current tab and the associated panel.
         * ```typescript
         * this.tab.select();
         * ```
         * @memberof IgxTabComponent
         */
        IgxTabComponent.prototype.select = function () {
            if (this.relatedPanel) {
                this.relatedPanel.select();
            }
            else {
                this._selected = true;
                this._tabBar.onTabSelected.emit({ tab: this, panel: null });
            }
        };
        /**
         * @hidden
         */
        IgxTabComponent.prototype.onClick = function () {
            this.select();
        };
        IgxTabComponent.prototype.elementRef = function () {
            return this._element;
        };
        IgxTabComponent.ctorParameters = function () { return [
            { type: IgxBottomNavComponent },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.HostBinding('attr.role')
        ], IgxTabComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.id')
        ], IgxTabComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('attr.aria-label')
        ], IgxTabComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.HostBinding('attr.aria-disabled')
        ], IgxTabComponent.prototype, "ariaDisabled", void 0);
        __decorate([
            core.HostBinding('attr.aria-selected')
        ], IgxTabComponent.prototype, "ariaSelected", void 0);
        __decorate([
            core.HostBinding('attr.aria-controls')
        ], IgxTabComponent.prototype, "ariaControls", void 0);
        __decorate([
            core.Input()
        ], IgxTabComponent.prototype, "relatedPanel", void 0);
        __decorate([
            core.Input()
        ], IgxTabComponent.prototype, "label", null);
        __decorate([
            core.Input()
        ], IgxTabComponent.prototype, "icon", null);
        __decorate([
            core.Input()
        ], IgxTabComponent.prototype, "disabled", null);
        __decorate([
            core.Input()
        ], IgxTabComponent.prototype, "isSelected", null);
        __decorate([
            core.HostBinding('class.igx-bottom-nav__menu-item--selected')
        ], IgxTabComponent.prototype, "cssClassSelected", null);
        __decorate([
            core.HostBinding('class.igx-bottom-nav__menu-item--disabled')
        ], IgxTabComponent.prototype, "cssClassDisabled", null);
        __decorate([
            core.HostBinding('class.igx-bottom-nav__menu-item')
        ], IgxTabComponent.prototype, "cssClass", null);
        __decorate([
            core.ViewChild('defaultTabTemplate', { read: core.TemplateRef, static: true })
        ], IgxTabComponent.prototype, "defaultTabTemplate", void 0);
        __decorate([
            core.ContentChild(IgxTabTemplateDirective, { read: IgxTabTemplateDirective })
        ], IgxTabComponent.prototype, "customTabTemplateDir", void 0);
        __decorate([
            core.HostListener('click')
        ], IgxTabComponent.prototype, "onClick", null);
        IgxTabComponent = __decorate([
            core.Component({
                selector: 'igx-tab',
                template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"tab-icon\">\n        <igx-icon fontSet=\"material\">{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"context.changesCount\" [hidden]=\"context.changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"tab-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>"
            })
        ], IgxTabComponent);
        return IgxTabComponent;
    }());
    /**
     * @hidden
     */
    var IgxBottomNavModule = /** @class */ (function () {
        function IgxBottomNavModule() {
        }
        IgxBottomNavModule = __decorate([
            core.NgModule({
                declarations: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                exports: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                imports: [common.CommonModule, IgxBadgeModule, IgxIconModule]
            })
        ], IgxBottomNavModule);
        return IgxBottomNavModule;
    }());

    /** @hidden */
    var IgxTabsBase = /** @class */ (function () {
        function IgxTabsBase() {
        }
        IgxTabsBase.prototype.scrollElement = function (element, scrollRight) { };
        IgxTabsBase.prototype.performSelectionChange = function (newTab) { };
        IgxTabsBase.prototype.transformContentAnimation = function (tab, duration) { };
        IgxTabsBase.prototype.transformIndicatorAnimation = function (element, duration) { };
        return IgxTabsBase;
    }());
    /** @hidden */
    var IgxTabItemBase = /** @class */ (function () {
        function IgxTabItemBase() {
        }
        Object.defineProperty(IgxTabItemBase.prototype, "index", {
            get: function () { return 0; },
            enumerable: true,
            configurable: true
        });
        IgxTabItemBase.prototype.select = function () { };
        IgxTabItemBase.prototype.setSelectedInternal = function (newValue) { };
        return IgxTabItemBase;
    }());
    /** @hidden */
    var IgxTabsGroupBase = /** @class */ (function () {
        function IgxTabsGroupBase() {
        }
        IgxTabsGroupBase.prototype.select = function () { };
        IgxTabsGroupBase.prototype.setSelectedInternal = function (newValue) { };
        return IgxTabsGroupBase;
    }());

    var ButtonStyle;
    (function (ButtonStyle) {
        ButtonStyle["VISIBLE"] = "visible";
        ButtonStyle["HIDDEN"] = "hidden";
        ButtonStyle["NOT_DISPLAYED"] = "not_displayed";
    })(ButtonStyle || (ButtonStyle = {}));
    var IgxRightButtonStyleDirective = /** @class */ (function () {
        function IgxRightButtonStyleDirective(tabs) {
            this.tabs = tabs;
        }
        Object.defineProperty(IgxRightButtonStyleDirective.prototype, "visibleCSS", {
            get: function () {
                return (this.getRightButtonStyle() === ButtonStyle.VISIBLE) ? true : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRightButtonStyleDirective.prototype, "hiddenCSS", {
            get: function () {
                return (this.getRightButtonStyle() === ButtonStyle.HIDDEN) ? true : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxRightButtonStyleDirective.prototype, "notDisplayedCSS", {
            get: function () {
                return (this.getRightButtonStyle() === ButtonStyle.NOT_DISPLAYED) ? true : false;
            },
            enumerable: true,
            configurable: true
        });
        IgxRightButtonStyleDirective.prototype.getRightButtonStyle = function () {
            var viewPortWidth = this.tabs.viewPort.nativeElement.offsetWidth;
            // We use this hacky way to get the width of the itemsContainer,
            // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
            var itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
            var itemsContainerWidth = 0;
            if (itemsContainerChildrenCount > 1) {
                var lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
                itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
            }
            var headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
            var offset = this.tabs.offset;
            var total = offset + viewPortWidth;
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
                return ButtonStyle.NOT_DISPLAYED;
            }
            if (itemsContainerWidth > total) {
                return ButtonStyle.VISIBLE;
            }
            else {
                return ButtonStyle.HIDDEN;
            }
        };
        IgxRightButtonStyleDirective.ctorParameters = function () { return [
            { type: IgxTabsBase }
        ]; };
        __decorate([
            core.HostBinding('class.igx-tabs__header-button')
        ], IgxRightButtonStyleDirective.prototype, "visibleCSS", null);
        __decorate([
            core.HostBinding('class.igx-tabs__header-button--hidden')
        ], IgxRightButtonStyleDirective.prototype, "hiddenCSS", null);
        __decorate([
            core.HostBinding('class.igx-tabs__header-button--none')
        ], IgxRightButtonStyleDirective.prototype, "notDisplayedCSS", null);
        IgxRightButtonStyleDirective = __decorate([
            core.Directive({
                selector: '[igxRightButtonStyle]'
            })
        ], IgxRightButtonStyleDirective);
        return IgxRightButtonStyleDirective;
    }());
    var IgxLeftButtonStyleDirective = /** @class */ (function () {
        function IgxLeftButtonStyleDirective(tabs) {
            this.tabs = tabs;
        }
        Object.defineProperty(IgxLeftButtonStyleDirective.prototype, "visibleCSS", {
            get: function () {
                return (this.getLeftButtonStyle() === ButtonStyle.VISIBLE) ? true : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLeftButtonStyleDirective.prototype, "hiddenCSS", {
            get: function () {
                return (this.getLeftButtonStyle() === ButtonStyle.HIDDEN) ? true : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxLeftButtonStyleDirective.prototype, "notDisplayedCSS", {
            get: function () {
                return (this.getLeftButtonStyle() === ButtonStyle.NOT_DISPLAYED) ? true : false;
            },
            enumerable: true,
            configurable: true
        });
        IgxLeftButtonStyleDirective.prototype.getLeftButtonStyle = function () {
            // We use this hacky way to get the width of the itemsContainer,
            // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
            var itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
            var itemsContainerWidth = 0;
            if (itemsContainerChildrenCount > 1) {
                var lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
                itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
            }
            var headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
            var offset = this.tabs.offset;
            if (offset === 0) {
                // Fix for IE 11, a difference is accumulated from the widths calculations.
                if (itemsContainerWidth - headerContainerWidth <= 1) {
                    return ButtonStyle.NOT_DISPLAYED;
                }
                return ButtonStyle.HIDDEN;
            }
            else {
                return ButtonStyle.VISIBLE;
            }
        };
        IgxLeftButtonStyleDirective.ctorParameters = function () { return [
            { type: IgxTabsBase }
        ]; };
        __decorate([
            core.HostBinding('class.igx-tabs__header-button')
        ], IgxLeftButtonStyleDirective.prototype, "visibleCSS", null);
        __decorate([
            core.HostBinding('class.igx-tabs__header-button--hidden')
        ], IgxLeftButtonStyleDirective.prototype, "hiddenCSS", null);
        __decorate([
            core.HostBinding('class.igx-tabs__header-button--none')
        ], IgxLeftButtonStyleDirective.prototype, "notDisplayedCSS", null);
        IgxLeftButtonStyleDirective = __decorate([
            core.Directive({
                selector: '[igxLeftButtonStyle]'
            })
        ], IgxLeftButtonStyleDirective);
        return IgxLeftButtonStyleDirective;
    }());
    var IgxTabItemTemplateDirective = /** @class */ (function () {
        function IgxTabItemTemplateDirective(template) {
            this.template = template;
        }
        IgxTabItemTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxTabItemTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxTab]'
            })
        ], IgxTabItemTemplateDirective);
        return IgxTabItemTemplateDirective;
    }());

    var IgxTabItemComponent = /** @class */ (function (_super) {
        __extends(IgxTabItemComponent, _super);
        function IgxTabItemComponent(_tabs, _element, _ngZone) {
            var _this = _super.call(this) || this;
            _this._tabs = _tabs;
            _this._element = _element;
            _this._ngZone = _ngZone;
            _this._changesCount = 0; // changes and updates accordingly applied to the tab.
            _this._isSelected = false;
            _this._disabled = false;
            /**
             * @hidden @internal
             */
            _this.role = 'tab';
            /**
             * @hidden @internal
             */
            _this.id = 'igx-tab-item-' + _this.index;
            /**
             * @hidden @internal
             */
            _this.ariaLabel = _this.label;
            /**
             * @hidden @internal
             */
            _this.ariaDisabled = _this.disabled;
            /**
             * @hidden @internal
             */
            _this.ariaSelected = _this.isSelected;
            /**
             * @hidden @internal
             */
            _this.ariaControls = 'igx-tab-item-group-' + _this.index;
            _this._nativeTabItem = _element;
            return _this;
        }
        Object.defineProperty(IgxTabItemComponent.prototype, "icon", {
            /**
            * An @Input property that sets the value of the `icon`.
            * The value should be valid icon name from {@link https://material.io/tools/icons/?style=baseline}.
            *```html
            *<igx-tab-item label="Tab 1" icon="home">
            *```
            */
            get: function () {
                return this.relatedGroup ? this.relatedGroup.icon : this._icon;
            },
            set: function (newValue) {
                if (this.relatedGroup) {
                    this.relatedGroup.icon = newValue;
                }
                this._icon = newValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "label", {
            /**
            * An @Input property that sets the value of the `label`.
            *```html
            *<igx-tabs-item label="Tab 2" icon="folder">
            *```
            */
            get: function () {
                return this.relatedGroup ? this.relatedGroup.label : this._label;
            },
            set: function (newValue) {
                if (this.relatedGroup) {
                    this.relatedGroup.label = newValue;
                }
                this._label = newValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "provideCssClassSelected", {
            get: function () {
                return this.isSelected;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "provideCssClassDisabled", {
            get: function () {
                return this.disabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "provideCssClass", {
            get: function () {
                return (!this.disabled && !this.isSelected);
            },
            enumerable: true,
            configurable: true
        });
        IgxTabItemComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this._ngZone.runOutsideAngular(function () {
                _this._resizeObserver = new ResizeObserver(function () {
                    _this._tabs.transformIndicatorAnimation(_this._nativeTabItem.nativeElement, 0);
                });
            });
        };
        IgxTabItemComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            this._ngZone.runOutsideAngular(function () {
                _this._resizeObserver.disconnect();
            });
        };
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.onClick = function (event) {
            this.select();
        };
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.onKeydownArrowRight = function (event) {
            this.onKeyDown(false);
        };
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.onKeydownArrowLeft = function (event) {
            this.onKeyDown(true);
        };
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.onKeydownHome = function (event) {
            event.preventDefault();
            this.onKeyDown(false, 0);
        };
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.onKeydownEnd = function (event) {
            event.preventDefault();
            this.onKeyDown(false, this._tabs.tabs.toArray().length - 1);
        };
        Object.defineProperty(IgxTabItemComponent.prototype, "changesCount", {
            /**
             * @hidden
             */
            get: function () {
                return this._changesCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "nativeTabItem", {
            /**
             * @hidden
             */
            get: function () {
                return this._nativeTabItem;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "disabled", {
            /**
            * 	Gets whether the tab is disabled.
            * ```
            * const disabledItem = this.myTabComponent.tabs.first.disabled;
            * ```
            */
            get: function () {
                return this.relatedGroup ? this.relatedGroup.disabled : this._disabled;
            },
            set: function (newValue) {
                if (this.relatedGroup) {
                    this.relatedGroup.disabled = newValue;
                }
                else {
                    this._disabled = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "isSelected", {
            /**
             * Gets whether the tab is selected.
             * ```typescript
             * const selectedItem = this.myTabComponent.tabs.first.isSelected;
             * ```
             */
            get: function () {
                return this.relatedGroup ? this.relatedGroup.isSelected : this._isSelected;
            },
            set: function (newValue) {
                if (!this.disabled && this.isSelected !== newValue) {
                    this._tabs.performSelectionChange(newValue ? this : null);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.select = function () {
            if (!this.disabled && !this.isSelected) {
                this._tabs.performSelectionChange(this);
            }
        };
        Object.defineProperty(IgxTabItemComponent.prototype, "index", {
            /**
             * @hidden
             */
            get: function () {
                if (this._tabs.tabs) {
                    return this._tabs.tabs.toArray().indexOf(this);
                }
                return -1;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabItemComponent.prototype.setSelectedInternal = function (newValue) {
            var _this = this;
            this._isSelected = newValue;
            this._ngZone.runOutsideAngular(function () {
                if (_this._resizeObserver) {
                    if (_this._isSelected) {
                        _this._resizeObserver.observe(_this._element.nativeElement);
                    }
                    else {
                        _this._resizeObserver.disconnect();
                    }
                }
            });
            this.tabindex = newValue ? 0 : -1;
        };
        IgxTabItemComponent.prototype.onKeyDown = function (isLeftArrow, index) {
            if (index === void 0) { index = null; }
            var tabsArray = this._tabs.tabs.toArray();
            if (index === null) {
                index = (isLeftArrow)
                    ? (this._tabs.selectedIndex === 0) ? tabsArray.length - 1 : this._tabs.selectedIndex - 1
                    : (this._tabs.selectedIndex === tabsArray.length - 1) ? 0 : this._tabs.selectedIndex + 1;
            }
            var tab = tabsArray[index];
            tab.select();
        };
        Object.defineProperty(IgxTabItemComponent.prototype, "template", {
            /**
             * @hidden
             */
            get: function () {
                if (this.relatedGroup && this.relatedGroup.customTabTemplate) {
                    return this.relatedGroup.customTabTemplate;
                }
                if (this.customTabTemplateDir) {
                    return this.customTabTemplateDir.template;
                }
                return this.defaultTabTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabItemComponent.prototype, "context", {
            /**
             * @hidden
             */
            get: function () {
                return this.relatedGroup ? this.relatedGroup : this;
            },
            enumerable: true,
            configurable: true
        });
        IgxTabItemComponent.ctorParameters = function () { return [
            { type: IgxTabsBase },
            { type: core.ElementRef },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.Input()
        ], IgxTabItemComponent.prototype, "relatedGroup", void 0);
        __decorate([
            core.Input()
        ], IgxTabItemComponent.prototype, "icon", null);
        __decorate([
            core.Input()
        ], IgxTabItemComponent.prototype, "label", null);
        __decorate([
            core.ViewChild('defaultTabTemplate', { read: core.TemplateRef, static: true })
        ], IgxTabItemComponent.prototype, "defaultTabTemplate", void 0);
        __decorate([
            core.ContentChild(IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective })
        ], IgxTabItemComponent.prototype, "customTabTemplateDir", void 0);
        __decorate([
            core.HostBinding('class.igx-tabs__header-menu-item--selected')
        ], IgxTabItemComponent.prototype, "provideCssClassSelected", null);
        __decorate([
            core.HostBinding('class.igx-tabs__header-menu-item--disabled')
        ], IgxTabItemComponent.prototype, "provideCssClassDisabled", null);
        __decorate([
            core.HostBinding('class.igx-tabs__header-menu-item')
        ], IgxTabItemComponent.prototype, "provideCssClass", null);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxTabItemComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxTabItemComponent.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('attr.id')
        ], IgxTabItemComponent.prototype, "id", void 0);
        __decorate([
            core.HostBinding('attr.aria-label')
        ], IgxTabItemComponent.prototype, "ariaLabel", void 0);
        __decorate([
            core.HostBinding('attr.aria-disabled')
        ], IgxTabItemComponent.prototype, "ariaDisabled", void 0);
        __decorate([
            core.HostBinding('attr.aria-selected')
        ], IgxTabItemComponent.prototype, "ariaSelected", void 0);
        __decorate([
            core.HostBinding('attr.aria-controls')
        ], IgxTabItemComponent.prototype, "ariaControls", void 0);
        __decorate([
            core.HostListener('click', ['$event'])
        ], IgxTabItemComponent.prototype, "onClick", null);
        __decorate([
            core.HostListener('keydown.arrowright', ['$event'])
        ], IgxTabItemComponent.prototype, "onKeydownArrowRight", null);
        __decorate([
            core.HostListener('keydown.arrowleft', ['$event'])
        ], IgxTabItemComponent.prototype, "onKeydownArrowLeft", null);
        __decorate([
            core.HostListener('keydown.home', ['$event'])
        ], IgxTabItemComponent.prototype, "onKeydownHome", null);
        __decorate([
            core.HostListener('keydown.end', ['$event'])
        ], IgxTabItemComponent.prototype, "onKeydownEnd", null);
        __decorate([
            core.Input()
        ], IgxTabItemComponent.prototype, "disabled", null);
        __decorate([
            core.Input()
        ], IgxTabItemComponent.prototype, "isSelected", null);
        IgxTabItemComponent = __decorate([
            core.Component({
                selector: 'igx-tab-item',
                template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"igx-tabs__header-menu-item-icon\">\n        <igx-icon fontSet=\"material\">{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"changesCount\" [hidden]=\"changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"igx-tabs__item-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>"
            })
        ], IgxTabItemComponent);
        return IgxTabItemComponent;
    }(IgxTabItemBase));

    var IgxTabsGroupComponent = /** @class */ (function (_super) {
        __extends(IgxTabsGroupComponent, _super);
        function IgxTabsGroupComponent(_tabs, _element) {
            var _this = _super.call(this) || this;
            _this._tabs = _tabs;
            _this._element = _element;
            /**
            * An @Input property that allows you to enable/disable the `IgxTabGroupComponent`.
            *```html
            *<igx-tabs-group label="Tab 2  Lorem ipsum dolor sit" icon="home" [disabled]="true">
            *```
            */
            _this.disabled = false;
            _this._isSelected = false;
            /**
             * @hidden
             */
            _this.role = 'tabpanel';
            /**
             * @hidden
             */
            _this.styleClass = true;
            return _this;
        }
        Object.defineProperty(IgxTabsGroupComponent.prototype, "isSelected", {
            /**
             * Sets/gets whether a tab group is selected.
             * ```typescript
             * this.tabGroup.isSelected = true;
             * ```
             * ```typescript
             * let isSelected = this.tabGroup.isSelected;
             * ```
             * @memberof IgxTabsGroupComponent
             */
            get: function () {
                return this._isSelected;
            },
            set: function (newValue) {
                if (!this.disabled && this.isSelected !== newValue) {
                    this._tabs.performSelectionChange(newValue ? this.relatedTab : null);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabsGroupComponent.prototype, "relatedTab", {
            /**
             * An accessor that returns the `IgxTabItemComponent` component.
             * ```typescript
             * @ViewChild("MyTabsGroup")
             * public tab: IgxTabsGroupComponent;
             * ngAfterViewInIt(){
             *    let tabComponent = this.tab.relatedTab;
             * }
             * ```
             */
            get: function () {
                if (this._tabs.tabs) {
                    return this._tabs.tabs.toArray()[this.index];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabsGroupComponent.prototype, "index", {
            /**
             * An accessor that returns the value of the index of the `IgxTabsGroupComponent`.
             * ```typescript
             * @ViewChild("MyTabsGroup")
             * public tab: IgxTabsGroupComponent;
             * ngAfterViewInIt(){
             *    let tabIndex = this.tab.index;
             * }
             * ```
             */
            get: function () {
                if (this._tabs.groups) {
                    return this._tabs.groups.toArray().indexOf(this);
                }
                return -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabsGroupComponent.prototype, "customTabTemplate", {
            /**
             * @hidden
             */
            get: function () {
                return this._tabTemplate;
            },
            /**
             *@hidden
             */
            set: function (template) {
                this._tabTemplate = template;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabsGroupComponent.prototype.ngAfterContentInit = function () {
            if (this.tabTemplate) {
                this._tabTemplate = this.tabTemplate.template;
            }
        };
        /**
         * @hidden
         */
        IgxTabsGroupComponent.prototype.ngAfterViewChecked = function () {
            this._element.nativeElement.setAttribute('aria-labelledby', "igx-tab-item-" + this.index);
            this._element.nativeElement.setAttribute('id', "igx-tabs__group-" + this.index);
        };
        /**
         * A method that sets the focus on a tab.
         * @memberof {@link IgxTabsGroupComponent}
         *```typescript
         *@ViewChild("MyChild")
         *public tab : IgxTabsGroupComponent;
         *ngAfterViewInit(){
         *    this.tab.select();
         *}
         *```
         */
        IgxTabsGroupComponent.prototype.select = function () {
            if (!this.disabled && !this.isSelected) {
                this._tabs.performSelectionChange(this.relatedTab);
            }
        };
        /**
         * @hidden
         */
        IgxTabsGroupComponent.prototype.setSelectedInternal = function (newValue) {
            this._isSelected = newValue;
        };
        IgxTabsGroupComponent.ctorParameters = function () { return [
            { type: IgxTabsBase },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input()
        ], IgxTabsGroupComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input()
        ], IgxTabsGroupComponent.prototype, "icon", void 0);
        __decorate([
            core.Input()
        ], IgxTabsGroupComponent.prototype, "label", void 0);
        __decorate([
            core.ContentChild(IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective })
        ], IgxTabsGroupComponent.prototype, "tabTemplate", void 0);
        __decorate([
            core.HostBinding('attr.role')
        ], IgxTabsGroupComponent.prototype, "role", void 0);
        __decorate([
            core.HostBinding('class.igx-tabs__group')
        ], IgxTabsGroupComponent.prototype, "styleClass", void 0);
        IgxTabsGroupComponent = __decorate([
            core.Component({
                selector: 'igx-tabs-group',
                template: "<ng-content *ngIf=\"isSelected\"></ng-content>\n"
            })
        ], IgxTabsGroupComponent);
        return IgxTabsGroupComponent;
    }(IgxTabsGroupBase));


    (function (IgxTabsType) {
        IgxTabsType["FIXED"] = "fixed";
        IgxTabsType["CONTENTFIT"] = "contentfit";
    })(exports.IgxTabsType || (exports.IgxTabsType = {}));
    var IgxTabsComponent = /** @class */ (function () {
        function IgxTabsComponent(_element, _ngZone, platformUtil) {
            this._element = _element;
            this._ngZone = _ngZone;
            this.platformUtil = platformUtil;
            /**
             *@hidden
             */
            this.selectedIndexChange = new core.EventEmitter();
            /**
             * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
             * By default the header sizing mode is `contentfit`.
             * ```html
             * <igx-tabs type="fixed">
             *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
             * </igx-tabs>
             * ```
             */
            this.type = 'contentfit';
            /**
            * @hidden
            */
            this.class = '';
            /**
             * Emitted when a tab item is deselected.
             * ```html
             * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
             *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
             *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
             * </igx-tabs>
             * ```
             * ```typescript
             * itemDeselected(e){
             *      const tabGroup = e.group;
             *      const tabItem = e.tab;
             * }
             * ```
             */
            this.onTabItemDeselected = new core.EventEmitter();
            /**
            * Emitted when a tab item is selected.
            * ```html
            * <igx-tabs (onTabItemSelected)="itemSelected($event)">
            *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
            *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
            * </igx-tabs>
            * ```
            * ```typescript
            * itemSelected(e){
            *      const tabGroup = e.group;
            *      const tabItem = e.tab;
            * }
            * ```
            */
            this.onTabItemSelected = new core.EventEmitter();
            /**
             * @hidden
             */
            this.offset = 0;
            this._selectedIndex = -1;
        }
        IgxTabsComponent_1 = IgxTabsComponent;
        Object.defineProperty(IgxTabsComponent.prototype, "selectedIndex", {
            /**
            * An @Input property that sets the value of the `selectedIndex`.
            * Default value is 0.
            * ```html
            * <igx-tabs selectedIndex="1">
            * ```
            *
            * Two-way data binding.
            * ```html
            * <igx-tabs [(selectedIndex)]="model.selectedIndex">
            * ```
            */
            get: function () {
                return this._selectedIndex;
            },
            set: function (index) {
                var newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;
                if (this._selectedIndex !== newIndex) {
                    if (this.tabs && this.tabs.length > 0) {
                        var newTab = this.tabs.toArray()[newIndex];
                        if (newTab) {
                            this.performSelectionChange(newTab);
                        }
                    }
                    else {
                        this._selectedIndex = newIndex;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabsComponent.prototype, "tabs", {
            /**
             * Provides an observable collection of all `IgxTabItemComponent`s.
             * First try to get them as content children if not available get them as view children.
             * ```typescript
             * const tabItems = this.myTabComponent.tabs;
             * ```
             */
            get: function () {
                if (this.hasContentTabs) {
                    return this.contentTabs;
                }
                return this.viewTabs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabsComponent.prototype, "hasContentTabs", {
            /**
             *@hidden
             */
            get: function () {
                return (this.contentTabs && this.contentTabs.length > 0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTabsComponent.prototype, "cssClass", {
            /**
             * @hidden
             */
            get: function () {
                var defaultStyle = "igx-tabs";
                var fixedStyle = "igx-tabs--fixed";
                var iconStyle = "igx-tabs--icons";
                var iconLabelFoundInGroups = this.groups.find(function (group) { return group.icon != null && group.label != null; });
                var iconLabelFoundInTabs = this.contentTabs.find(function (tab) { return tab.icon != null && tab.label != null; });
                var css;
                switch (exports.IgxTabsType[this.type.toUpperCase()]) {
                    case exports.IgxTabsType.FIXED: {
                        css = fixedStyle;
                        break;
                    }
                    default: {
                        css = defaultStyle;
                        break;
                    }
                }
                // Layout fix for items with icons
                if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
                    css = css + " " + iconStyle;
                }
                return css + " " + this.class;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.scrollLeft = function (event) {
            this.scroll(false);
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.scrollRight = function (event) {
            this.scroll(true);
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.scrollElement = function (element, scrollRight) {
            var viewPortWidth = this.viewPort.nativeElement.offsetWidth;
            this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
            this.itemsContainer.nativeElement.style.transform = "translate(" + -this.offset + "px)";
        };
        Object.defineProperty(IgxTabsComponent.prototype, "selectedTabItem", {
            /**
             * Gets the selected `IgxTabItemComponent`.
             * ```
             * const selectedItem = this.myTabComponent.selectedTabItem;
             * ```
             */
            get: function () {
                if (this.tabs && this.selectedIndex !== undefined) {
                    return this.tabs.toArray()[this.selectedIndex];
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this._selectedIndex === -1) {
                this.tabs.forEach(function (t) {
                    if (t.isSelected) {
                        _this._selectedIndex = t.index;
                    }
                });
            }
            if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
                this._selectedIndex = 0;
            }
            if (this.platformUtil.isBrowser) {
                requestAnimationFrame(function () {
                    var newTab = _this.tabs.toArray()[_this._selectedIndex];
                    if (newTab) {
                        _this.performSelection(newTab);
                    }
                    else {
                        _this.hideIndicator();
                    }
                });
                this._ngZone.runOutsideAngular(function () {
                    _this._resizeObserver = new ResizeObserver(function () {
                        if (!_this.hasContentTabs && _this._selectedIndex >= 0 && _this._selectedIndex < _this.tabs.length) {
                            var newTab = _this.tabs.toArray()[_this._selectedIndex];
                            _this.transformContentAnimation(newTab, 0);
                        }
                    });
                    _this._resizeObserver.observe(_this.tabsContainer.nativeElement);
                });
            }
            this._groupChanges$ = this.groups.changes.subscribe(function () {
                _this.resetSelectionOnCollectionChanged();
            });
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            if (this._groupChanges$) {
                this._groupChanges$.unsubscribe();
            }
            if (this._resizeObserver) {
                this._ngZone.runOutsideAngular(function () {
                    _this._resizeObserver.disconnect();
                });
            }
        };
        IgxTabsComponent.prototype.resetSelectionOnCollectionChanged = function () {
            var _this = this;
            requestAnimationFrame(function () {
                var currentTab = _this.tabs.toArray()[_this.selectedIndex];
                if (currentTab) {
                    _this.performSelectionChange(currentTab);
                }
                else if (_this.selectedIndex >= _this.tabs.length) {
                    _this.performSelectionChange(_this.tabs.last);
                }
                else {
                    _this.hideIndicator();
                }
            });
        };
        IgxTabsComponent.prototype.scroll = function (scrollRight) {
            var e_1, _a;
            var tabsArray = this.tabs.toArray();
            try {
                for (var tabsArray_1 = __values(tabsArray), tabsArray_1_1 = tabsArray_1.next(); !tabsArray_1_1.done; tabsArray_1_1 = tabsArray_1.next()) {
                    var tab = tabsArray_1_1.value;
                    var element = tab.nativeTabItem.nativeElement;
                    if (scrollRight) {
                        if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                            this.scrollElement(element, scrollRight);
                            break;
                        }
                    }
                    else {
                        if (element.offsetWidth + element.offsetLeft >= this.offset) {
                            this.scrollElement(element, scrollRight);
                            break;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (tabsArray_1_1 && !tabsArray_1_1.done && (_a = tabsArray_1.return)) _a.call(tabsArray_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.performSelectionChange = function (newTab) {
            var oldTab = this.selectedTabItem;
            if (oldTab) {
                this.performDeselection(oldTab);
            }
            if (newTab) {
                this.performSelection(newTab);
            }
            else {
                // if there is no new selected tab hide the selection indicator
                this.hideIndicator();
            }
            this.selectedIndexChange.emit(this._selectedIndex);
        };
        IgxTabsComponent.prototype.performDeselection = function (oldTab) {
            oldTab.setSelectedInternal(false);
            var oldTabRelatedGroup = this.groups.toArray()[oldTab.index];
            if (oldTabRelatedGroup) {
                oldTabRelatedGroup.setSelectedInternal(false);
            }
            this._selectedIndex = -1;
            this.onTabItemDeselected.emit({ tab: oldTab, group: oldTabRelatedGroup });
        };
        IgxTabsComponent.prototype.performSelection = function (newTab) {
            var _this = this;
            newTab.setSelectedInternal(true);
            this._selectedIndex = newTab.index;
            var newTabRelatedGroup = null;
            if (!this.hasContentTabs && this.groups) {
                newTabRelatedGroup = this.groups.toArray()[newTab.index];
                if (newTabRelatedGroup) {
                    newTabRelatedGroup.setSelectedInternal(true);
                }
            }
            this.onTabItemSelected.emit({ tab: newTab, group: newTabRelatedGroup });
            requestAnimationFrame(function () {
                // bring the new selected tab into view if it is not
                _this.bringNewTabIntoView(newTab);
                // animate the new selection indicator
                _this.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement);
                // animate the new tab's group content
                if (!_this.hasContentTabs) {
                    _this.transformContentAnimation(newTab, 0.2);
                }
            });
        };
        IgxTabsComponent.prototype.bringNewTabIntoView = function (newTab) {
            var tabNativeElement = newTab.nativeTabItem.nativeElement;
            // Scroll left if there is need
            if (tabNativeElement.offsetLeft < this.offset) {
                this.scrollElement(tabNativeElement, false);
            }
            // Scroll right if there is need
            var viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
            var delta = (tabNativeElement.offsetLeft + tabNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
            // Fix for IE 11, a difference is accumulated from the widths calculations
            if (delta > 1) {
                this.scrollElement(tabNativeElement, true);
            }
        };
        /**
         * @hidden
         */
        // animation for the new panel/group (not needed for tab only mode)
        IgxTabsComponent.prototype.transformContentAnimation = function (tab, duration) {
            var contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
            this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? duration + "s" : 'initial';
            this.contentsContainer.nativeElement.style.transform = "translate(" + -contentOffset + "px)";
        };
        /**
         * @hidden
         */
        IgxTabsComponent.prototype.transformIndicatorAnimation = function (element, duration) {
            if (duration === void 0) { duration = 0.3; }
            if (this.selectedIndicator) {
                this.selectedIndicator.nativeElement.style.visibility = 'visible';
                this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? duration + "s" : 'initial';
                this.selectedIndicator.nativeElement.style.width = element.offsetWidth + "px";
                this.selectedIndicator.nativeElement.style.transform = "translate(" + element.offsetLeft + "px)";
            }
        };
        IgxTabsComponent.prototype.hideIndicator = function () {
            if (this.selectedIndicator) {
                this.selectedIndicator.nativeElement.style.visibility = 'hidden';
            }
        };
        var IgxTabsComponent_1;
        IgxTabsComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: PlatformUtil }
        ]; };
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return IgxTabsGroupComponent; }))
        ], IgxTabsComponent.prototype, "groups", void 0);
        __decorate([
            core.ContentChildren(core.forwardRef(function () { return IgxTabItemComponent; }))
        ], IgxTabsComponent.prototype, "contentTabs", void 0);
        __decorate([
            core.Input()
        ], IgxTabsComponent.prototype, "selectedIndex", null);
        __decorate([
            core.Output()
        ], IgxTabsComponent.prototype, "selectedIndexChange", void 0);
        __decorate([
            core.Input('type')
        ], IgxTabsComponent.prototype, "type", void 0);
        __decorate([
            core.Input()
        ], IgxTabsComponent.prototype, "class", void 0);
        __decorate([
            core.Output()
        ], IgxTabsComponent.prototype, "onTabItemDeselected", void 0);
        __decorate([
            core.Output()
        ], IgxTabsComponent.prototype, "onTabItemSelected", void 0);
        __decorate([
            core.ViewChild('contentsContainer', { static: true })
        ], IgxTabsComponent.prototype, "contentsContainer", void 0);
        __decorate([
            core.ViewChild('headerContainer', { static: true })
        ], IgxTabsComponent.prototype, "headerContainer", void 0);
        __decorate([
            core.ViewChild('itemsContainer', { static: true })
        ], IgxTabsComponent.prototype, "itemsContainer", void 0);
        __decorate([
            core.ViewChild('selectedIndicator')
        ], IgxTabsComponent.prototype, "selectedIndicator", void 0);
        __decorate([
            core.ViewChild('tabsContainer', { static: true })
        ], IgxTabsComponent.prototype, "tabsContainer", void 0);
        __decorate([
            core.ViewChild('viewPort', { static: true })
        ], IgxTabsComponent.prototype, "viewPort", void 0);
        __decorate([
            core.ViewChildren(core.forwardRef(function () { return IgxTabItemComponent; }))
        ], IgxTabsComponent.prototype, "viewTabs", void 0);
        __decorate([
            core.HostBinding('attr.class')
        ], IgxTabsComponent.prototype, "cssClass", null);
        IgxTabsComponent = IgxTabsComponent_1 = __decorate([
            core.Component({
                selector: 'igx-tabs',
                template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft($event)\" igxLeftButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple *ngFor=\"let group of groups\" [relatedGroup]=\"group\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight($event)\" igxRightButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>",
                providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent_1 }]
            })
        ], IgxTabsComponent);
        return IgxTabsComponent;
    }());
    /**
     * @hidden
     */
    var IgxTabsModule = /** @class */ (function () {
        function IgxTabsModule() {
        }
        IgxTabsModule = __decorate([
            core.NgModule({
                declarations: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                exports: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                imports: [common.CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
            })
        ], IgxTabsModule);
        return IgxTabsModule;
    }());

    /** @hidden */
    var IGX_TIME_PICKER_COMPONENT = 'IgxTimePickerComponentToken';

    /** @hidden */
    var IgxItemListDirective = /** @class */ (function () {
        function IgxItemListDirective(timePicker, elementRef) {
            this.timePicker = timePicker;
            this.elementRef = elementRef;
            this.tabindex = 0;
        }
        Object.defineProperty(IgxItemListDirective.prototype, "defaultCSS", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxItemListDirective.prototype, "hourCSS", {
            get: function () {
                return this.type === 'hourList';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxItemListDirective.prototype, "minuteCSS", {
            get: function () {
                return this.type === 'minuteList';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxItemListDirective.prototype, "secondsCSS", {
            get: function () {
                return this.type === 'secondsList';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxItemListDirective.prototype, "ampmCSS", {
            get: function () {
                return this.type === 'ampmList';
            },
            enumerable: true,
            configurable: true
        });
        IgxItemListDirective.prototype.onFocus = function () {
            this.isActive = true;
        };
        IgxItemListDirective.prototype.onBlur = function () {
            this.isActive = false;
        };
        IgxItemListDirective.prototype.nextItem = function () {
            switch (this.type) {
                case 'hourList': {
                    this.timePicker.nextHour();
                    break;
                }
                case 'minuteList': {
                    this.timePicker.nextMinute();
                    break;
                }
                case 'secondsList': {
                    this.timePicker.nextSeconds();
                    break;
                }
                case 'ampmList': {
                    this.timePicker.nextAmPm();
                    break;
                }
            }
        };
        IgxItemListDirective.prototype.prevItem = function () {
            switch (this.type) {
                case 'hourList': {
                    this.timePicker.prevHour();
                    break;
                }
                case 'minuteList': {
                    this.timePicker.prevMinute();
                    break;
                }
                case 'secondsList': {
                    this.timePicker.prevSeconds();
                    break;
                }
                case 'ampmList': {
                    this.timePicker.prevAmPm();
                    break;
                }
            }
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownArrowDown = function (event) {
            event.preventDefault();
            this.nextItem();
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownArrowUp = function (event) {
            event.preventDefault();
            this.prevItem();
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownArrowRight = function (event) {
            event.preventDefault();
            var listName = event.target.className;
            if (listName.indexOf('hourList') !== -1 && this.timePicker.minuteList) {
                this.timePicker.minuteList.nativeElement.focus();
            }
            else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.secondsList) {
                this.timePicker.secondsList.nativeElement.focus();
            }
            else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1 ||
                listName.indexOf('secondsList') !== -1) && this.timePicker.ampmList) {
                this.timePicker.ampmList.nativeElement.focus();
            }
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownArrowLeft = function (event) {
            event.preventDefault();
            var listName = event.target.className;
            if (listName.indexOf('ampmList') !== -1 && this.timePicker.secondsList) {
                this.timePicker.secondsList.nativeElement.focus();
            }
            else if (listName.indexOf('secondsList') !== -1 && this.timePicker.secondsList
                && listName.indexOf('minutesList') && this.timePicker.minuteList) {
                this.timePicker.minuteList.nativeElement.focus();
            }
            else if (listName.indexOf('ampmList') !== -1 && this.timePicker.minuteList) {
                this.timePicker.minuteList.nativeElement.focus();
            }
            else if ((listName.indexOf('ampmList') !== -1 || listName.indexOf('secondsList') !== -1 ||
                listName.indexOf('minuteList') !== -1) && this.timePicker.hourList) {
                this.timePicker.hourList.nativeElement.focus();
            }
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownEnter = function (event) {
            event.preventDefault();
            if (this.timePicker.mode === exports.InteractionMode.DropDown) {
                this.timePicker.close();
                return;
            }
            this.timePicker.okButtonClick();
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onKeydownEscape = function (event) {
            event.preventDefault();
            this.timePicker.cancelButtonClick();
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onHover = function () {
            this.elementRef.nativeElement.focus();
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onScroll = function (event) {
            event.preventDefault();
            event.stopPropagation();
            if (event.deltaY > 0) {
                this.nextItem();
            }
            else if (event.deltaY < 0) {
                this.prevItem();
            }
        };
        /**
         * @hidden
         */
        IgxItemListDirective.prototype.onPanMove = function (event) {
            if (event.deltaY < 0) {
                this.nextItem();
            }
            else if (event.deltaY > 0) {
                this.prevItem();
            }
        };
        IgxItemListDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input('igxItemList')
        ], IgxItemListDirective.prototype, "type", void 0);
        __decorate([
            core.HostBinding('attr.tabindex')
        ], IgxItemListDirective.prototype, "tabindex", void 0);
        __decorate([
            core.HostBinding('class.igx-time-picker__column')
        ], IgxItemListDirective.prototype, "defaultCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__hourList')
        ], IgxItemListDirective.prototype, "hourCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__minuteList')
        ], IgxItemListDirective.prototype, "minuteCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__secondsList')
        ], IgxItemListDirective.prototype, "secondsCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__ampmList')
        ], IgxItemListDirective.prototype, "ampmCSS", null);
        __decorate([
            core.HostListener('focus')
        ], IgxItemListDirective.prototype, "onFocus", null);
        __decorate([
            core.HostListener('blur')
        ], IgxItemListDirective.prototype, "onBlur", null);
        __decorate([
            core.HostListener('keydown.arrowdown', ['$event'])
        ], IgxItemListDirective.prototype, "onKeydownArrowDown", null);
        __decorate([
            core.HostListener('keydown.arrowup', ['$event'])
        ], IgxItemListDirective.prototype, "onKeydownArrowUp", null);
        __decorate([
            core.HostListener('keydown.arrowright', ['$event'])
        ], IgxItemListDirective.prototype, "onKeydownArrowRight", null);
        __decorate([
            core.HostListener('keydown.arrowleft', ['$event'])
        ], IgxItemListDirective.prototype, "onKeydownArrowLeft", null);
        __decorate([
            core.HostListener('keydown.enter', ['$event'])
        ], IgxItemListDirective.prototype, "onKeydownEnter", null);
        __decorate([
            core.HostListener('keydown.escape', ['$event'])
        ], IgxItemListDirective.prototype, "onKeydownEscape", null);
        __decorate([
            core.HostListener('mouseover')
        ], IgxItemListDirective.prototype, "onHover", null);
        __decorate([
            core.HostListener('wheel', ['$event'])
        ], IgxItemListDirective.prototype, "onScroll", null);
        __decorate([
            core.HostListener('panmove', ['$event'])
        ], IgxItemListDirective.prototype, "onPanMove", null);
        IgxItemListDirective = __decorate([
            core.Directive({
                selector: '[igxItemList]'
            }),
            __param(0, core.Inject(IGX_TIME_PICKER_COMPONENT))
        ], IgxItemListDirective);
        return IgxItemListDirective;
    }());
    /**
     * @hidden
     */
    var IgxHourItemDirective = /** @class */ (function () {
        function IgxHourItemDirective(timePicker, itemList) {
            this.timePicker = timePicker;
            this.itemList = itemList;
        }
        Object.defineProperty(IgxHourItemDirective.prototype, "defaultCSS", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHourItemDirective.prototype, "selectedCSS", {
            get: function () {
                return this.isSelectedHour;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHourItemDirective.prototype, "activeCSS", {
            get: function () {
                return this.isSelectedHour && this.itemList.isActive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxHourItemDirective.prototype, "isSelectedHour", {
            get: function () {
                return this.timePicker.selectedHour === this.value;
            },
            enumerable: true,
            configurable: true
        });
        IgxHourItemDirective.prototype.onClick = function (item) {
            if (item !== '') {
                this.timePicker.scrollHourIntoView(item);
            }
        };
        IgxHourItemDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
            { type: IgxItemListDirective }
        ]; };
        __decorate([
            core.Input('igxHourItem')
        ], IgxHourItemDirective.prototype, "value", void 0);
        __decorate([
            core.HostBinding('class.igx-time-picker__item')
        ], IgxHourItemDirective.prototype, "defaultCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__item--selected')
        ], IgxHourItemDirective.prototype, "selectedCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__item--active')
        ], IgxHourItemDirective.prototype, "activeCSS", null);
        __decorate([
            core.HostListener('click', ['value'])
        ], IgxHourItemDirective.prototype, "onClick", null);
        IgxHourItemDirective = __decorate([
            core.Directive({
                selector: '[igxHourItem]'
            }),
            __param(0, core.Inject(IGX_TIME_PICKER_COMPONENT))
        ], IgxHourItemDirective);
        return IgxHourItemDirective;
    }());
    /**
     * @hidden
     */
    var IgxMinuteItemDirective = /** @class */ (function () {
        function IgxMinuteItemDirective(timePicker, itemList) {
            this.timePicker = timePicker;
            this.itemList = itemList;
        }
        Object.defineProperty(IgxMinuteItemDirective.prototype, "defaultCSS", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMinuteItemDirective.prototype, "selectedCSS", {
            get: function () {
                return this.isSelectedMinute;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMinuteItemDirective.prototype, "activeCSS", {
            get: function () {
                return this.isSelectedMinute && this.itemList.isActive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxMinuteItemDirective.prototype, "isSelectedMinute", {
            get: function () {
                return this.timePicker.selectedMinute === this.value;
            },
            enumerable: true,
            configurable: true
        });
        IgxMinuteItemDirective.prototype.onClick = function (item) {
            if (item !== '') {
                this.timePicker.scrollMinuteIntoView(item);
            }
        };
        IgxMinuteItemDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
            { type: IgxItemListDirective }
        ]; };
        __decorate([
            core.Input('igxMinuteItem')
        ], IgxMinuteItemDirective.prototype, "value", void 0);
        __decorate([
            core.HostBinding('class.igx-time-picker__item')
        ], IgxMinuteItemDirective.prototype, "defaultCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__item--selected')
        ], IgxMinuteItemDirective.prototype, "selectedCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__item--active')
        ], IgxMinuteItemDirective.prototype, "activeCSS", null);
        __decorate([
            core.HostListener('click', ['value'])
        ], IgxMinuteItemDirective.prototype, "onClick", null);
        IgxMinuteItemDirective = __decorate([
            core.Directive({
                selector: '[igxMinuteItem]'
            }),
            __param(0, core.Inject(IGX_TIME_PICKER_COMPONENT))
        ], IgxMinuteItemDirective);
        return IgxMinuteItemDirective;
    }());
    /**
     * @hidden
     */
    var IgxSecondsItemDirective = /** @class */ (function () {
        function IgxSecondsItemDirective(timePicker, itemList) {
            this.timePicker = timePicker;
            this.itemList = itemList;
        }
        Object.defineProperty(IgxSecondsItemDirective.prototype, "defaultCSS", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSecondsItemDirective.prototype, "selectedCSS", {
            get: function () {
                return this.isSelectedSeconds;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSecondsItemDirective.prototype, "activeCSS", {
            get: function () {
                return this.isSelectedSeconds && this.itemList.isActive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxSecondsItemDirective.prototype, "isSelectedSeconds", {
            get: function () {
                return this.timePicker.selectedSeconds === this.value;
            },
            enumerable: true,
            configurable: true
        });
        IgxSecondsItemDirective.prototype.onClick = function (item) {
            if (item !== '') {
                this.timePicker.scrollSecondsIntoView(item);
            }
        };
        IgxSecondsItemDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
            { type: IgxItemListDirective }
        ]; };
        __decorate([
            core.Input('igxSecondsItem')
        ], IgxSecondsItemDirective.prototype, "value", void 0);
        __decorate([
            core.HostBinding('class.igx-time-picker__item')
        ], IgxSecondsItemDirective.prototype, "defaultCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__item--selected')
        ], IgxSecondsItemDirective.prototype, "selectedCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__item--active')
        ], IgxSecondsItemDirective.prototype, "activeCSS", null);
        __decorate([
            core.HostListener('click', ['value'])
        ], IgxSecondsItemDirective.prototype, "onClick", null);
        IgxSecondsItemDirective = __decorate([
            core.Directive({
                selector: '[igxSecondsItem]'
            }),
            __param(0, core.Inject(IGX_TIME_PICKER_COMPONENT))
        ], IgxSecondsItemDirective);
        return IgxSecondsItemDirective;
    }());
    /**
     * @hidden
     */
    var IgxAmPmItemDirective = /** @class */ (function () {
        function IgxAmPmItemDirective(timePicker, itemList) {
            this.timePicker = timePicker;
            this.itemList = itemList;
        }
        Object.defineProperty(IgxAmPmItemDirective.prototype, "defaultCSS", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAmPmItemDirective.prototype, "selectedCSS", {
            get: function () {
                return this.isSelectedAmPm;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAmPmItemDirective.prototype, "activeCSS", {
            get: function () {
                return this.isSelectedAmPm && this.itemList.isActive;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxAmPmItemDirective.prototype, "isSelectedAmPm", {
            get: function () {
                return this.timePicker.selectedAmPm === this.value;
            },
            enumerable: true,
            configurable: true
        });
        IgxAmPmItemDirective.prototype.onClick = function (item) {
            if (item !== '') {
                this.timePicker.scrollAmPmIntoView(item);
            }
        };
        IgxAmPmItemDirective.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
            { type: IgxItemListDirective }
        ]; };
        __decorate([
            core.Input('igxAmPmItem')
        ], IgxAmPmItemDirective.prototype, "value", void 0);
        __decorate([
            core.HostBinding('class.igx-time-picker__item')
        ], IgxAmPmItemDirective.prototype, "defaultCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__item--selected')
        ], IgxAmPmItemDirective.prototype, "selectedCSS", null);
        __decorate([
            core.HostBinding('class.igx-time-picker__item--active')
        ], IgxAmPmItemDirective.prototype, "activeCSS", null);
        __decorate([
            core.HostListener('click', ['value'])
        ], IgxAmPmItemDirective.prototype, "onClick", null);
        IgxAmPmItemDirective = __decorate([
            core.Directive({
                selector: '[igxAmPmItem]'
            }),
            __param(0, core.Inject(IGX_TIME_PICKER_COMPONENT))
        ], IgxAmPmItemDirective);
        return IgxAmPmItemDirective;
    }());
    /**
     * This directive should be used to mark which ng-template will be used from IgxTimePicker when re-templating its input group.
     */
    var IgxTimePickerTemplateDirective = /** @class */ (function () {
        function IgxTimePickerTemplateDirective(template) {
            this.template = template;
        }
        IgxTimePickerTemplateDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxTimePickerTemplateDirective = __decorate([
            core.Directive({
                selector: '[igxTimePickerTemplate]'
            })
        ], IgxTimePickerTemplateDirective);
        return IgxTimePickerTemplateDirective;
    }());
    /**
     * This directive can be used to add custom action buttons to the dropdownb/dialog.
     */
    var IgxTimePickerActionsDirective = /** @class */ (function () {
        function IgxTimePickerActionsDirective(template) {
            this.template = template;
        }
        IgxTimePickerActionsDirective.ctorParameters = function () { return [
            { type: core.TemplateRef }
        ]; };
        IgxTimePickerActionsDirective = __decorate([
            core.Directive({
                selector: '[igxTimePickerActions]'
            })
        ], IgxTimePickerActionsDirective);
        return IgxTimePickerActionsDirective;
    }());

    /**
     * Formats `IgxTimePickerComponent` display value according to the `format` property,
     * when the input element loses focus.
     **/
    var TimeDisplayFormatPipe = /** @class */ (function () {
        function TimeDisplayFormatPipe(timePicker) {
            this.timePicker = timePicker;
        }
        TimeDisplayFormatPipe.prototype.transform = function (value) {
            var hour, minutes, seconds, amPM;
            var maskAmPM = this.timePicker.parseMask();
            var mask = this.timePicker.parseMask(false);
            if (!value || value === mask || value === maskAmPM) {
                return '';
            }
            var sections = value.split(/[\s:]+/);
            if (this.timePicker.showHoursList) {
                hour = sections[0];
            }
            if (this.timePicker.showMinutesList) {
                minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
            }
            if (this.timePicker.showSecondsList) {
                seconds = sections[sections.length - (this.timePicker.showAmPmList ? 2 : 1)];
            }
            if (this.timePicker.showAmPmList) {
                amPM = sections[sections.length - 1];
            }
            var format = this.timePicker.format;
            var prompt = this.timePicker.promptChar;
            var regExp = new RegExp(this.timePicker.promptChar, 'g');
            if (format.indexOf('hh') !== -1 || format.indexOf('HH') !== -1 && hour.indexOf(prompt) !== -1) {
                hour = hour === prompt + prompt ? '00' : hour.replace(regExp, '0');
            }
            if (format.indexOf('mm') !== -1 && minutes.indexOf(prompt) !== -1) {
                minutes = minutes === prompt + prompt ? '00' : minutes.replace(regExp, '0');
            }
            if (format.indexOf('ss') !== -1 && seconds.indexOf(prompt) !== -1) {
                seconds = seconds === prompt + prompt ? '00' : seconds.replace(regExp, '0');
            }
            if (format.indexOf('hh') === -1 && format.indexOf('HH') === -1 && hour !== undefined) {
                hour = hour.indexOf(prompt) !== -1 ? hour.replace(regExp, '') : hour;
                var hourVal = parseInt(hour, 10);
                hour = !hourVal ? '0' : hourVal < 10 && hourVal !== 0 ? hour.replace('0', '') : hour;
            }
            if (format.indexOf('mm') === -1 && minutes !== undefined) {
                minutes = minutes.indexOf(prompt) !== -1 ? minutes.replace(regExp, '') : minutes;
                var minutesVal = parseInt(minutes, 10);
                minutes = !minutesVal ? '0' : minutesVal < 10 && minutesVal !== 0 ? minutes.replace('0', '') : minutes;
            }
            if (format.indexOf('ss') === -1 && seconds !== undefined) {
                seconds = seconds.indexOf(prompt) !== -1 ? seconds.replace(regExp, '') : seconds;
                var secondsVal = parseInt(seconds, 10);
                seconds = !secondsVal ? '0' : secondsVal < 10 && secondsVal !== 0 ? seconds.replace('0', '') : seconds;
            }
            if (format.indexOf('tt') !== -1 && (amPM !== 'AM' || amPM !== 'PM')) {
                amPM = amPM.indexOf('p') !== -1 || amPM.indexOf('P') !== -1 ? 'PM' : 'AM';
            }
            var result = hour + ":" + minutes + ":" + seconds;
            if (!hour) {
                // remove the hours
                result = result.slice(result.indexOf(':') + 1);
            }
            if (!minutes) {
                if (hour) {
                    // get the hours and seconds and concat them
                    result = result.slice(0, result.indexOf(':')) +
                        result.slice(result.lastIndexOf(':'), result.length);
                }
                else {
                    // remove the minutes
                    result = result.slice(result.indexOf(':') + 1);
                }
            }
            if (!seconds) {
                // remove the seconds
                result = result.slice(0, result.lastIndexOf(':'));
            }
            return amPM ? result + " " + amPM : result;
        };
        TimeDisplayFormatPipe.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
        ]; };
        TimeDisplayFormatPipe = __decorate([
            core.Pipe({ name: 'displayFormat' }),
            __param(0, core.Inject(IGX_TIME_PICKER_COMPONENT))
        ], TimeDisplayFormatPipe);
        return TimeDisplayFormatPipe;
    }());
    /**
     * Formats `IgxTimePickerComponent` display value according to the `format` property,
     * when the input element gets focus.
     **/
    var TimeInputFormatPipe = /** @class */ (function () {
        function TimeInputFormatPipe(timePicker) {
            this.timePicker = timePicker;
        }
        TimeInputFormatPipe.prototype.transform = function (value) {
            var prompt = this.timePicker.promptChar;
            var regExp = new RegExp(prompt, 'g');
            var mask, hour, minutes, seconds, amPM;
            if (this.timePicker.cleared) {
                this.timePicker.cleared = false;
                mask = this.timePicker.parseMask(false);
            }
            else {
                mask = this.timePicker.parseMask();
            }
            if (!value || value === mask) {
                return mask;
            }
            var sections = value.split(/[\s:]+/);
            if (this.timePicker.showHoursList) {
                hour = sections[0];
                hour = hour.replace(regExp, '');
                var leadZeroHour = (parseInt(hour, 10) < 10 && !hour.startsWith('0')) || hour === '0';
                hour = leadZeroHour ? '0' + hour : hour;
            }
            if (this.timePicker.showMinutesList) {
                minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
                minutes = minutes.replace(regExp, '');
                var leadZeroMinutes = (parseInt(minutes, 10) < 10 && !minutes.startsWith('0')) || minutes === '0';
                minutes = leadZeroMinutes ? '0' + minutes : minutes;
            }
            if (this.timePicker.showSecondsList) {
                seconds = sections[sections.length - (this.timePicker.showAmPmList ? 2 : 1)];
                seconds = seconds.replace(regExp, '');
                var leadZeroSeconds = (parseInt(seconds, 10) < 10 && !seconds.startsWith('0')) || seconds === '0';
                seconds = leadZeroSeconds ? '0' + seconds : seconds;
            }
            if (this.timePicker.showAmPmList) {
                amPM = sections[sections.length - 1];
            }
            var result = hour + ":" + minutes + ":" + seconds;
            if (!hour) {
                // remove the hours
                result = result.slice(result.indexOf(':') + 1);
            }
            if (!minutes) {
                if (hour) {
                    // get the hours and seconds and concat them
                    result = result.slice(0, result.indexOf(':')) +
                        result.slice(result.lastIndexOf(':'), result.length);
                }
                else {
                    // remove the minutes
                    result = result.slice(result.indexOf(':') + 1);
                }
            }
            if (!seconds) {
                // remove the seconds
                result = result.slice(0, result.lastIndexOf(':'));
            }
            return amPM ? result + " " + amPM : result;
        };
        TimeInputFormatPipe.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
        ]; };
        TimeInputFormatPipe = __decorate([
            core.Pipe({ name: 'inputFormat' }),
            __param(0, core.Inject(IGX_TIME_PICKER_COMPONENT))
        ], TimeInputFormatPipe);
        return TimeInputFormatPipe;
    }());

    var NEXT_ID$u = 0;
    var ITEMS_COUNT = 7;
    var TimePickerHammerConfig = /** @class */ (function (_super) {
        __extends(TimePickerHammerConfig, _super);
        function TimePickerHammerConfig() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.overrides = {
                pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
            };
            return _this;
        }
        TimePickerHammerConfig = __decorate([
            core.Injectable()
        ], TimePickerHammerConfig);
        return TimePickerHammerConfig;
    }(platformBrowser.HammerGestureConfig));
    var noop$9 = function () { };
    var ɵ0$a = noop$9;
    var IgxTimePickerComponent = /** @class */ (function () {
        function IgxTimePickerComponent(_injector, _cdr) {
            this._injector = _injector;
            this._cdr = _cdr;
            /**
             * An @Input property that sets the value of the `id` attribute.
             * ```html
             * <igx-time-picker [id]="'igx-time-picker-5'" format="h:mm tt" ></igx-time-picker>
             * ```
             */
            this.id = "igx-time-picker-" + NEXT_ID$u++;
            /**
             * An @Input property that allows you to disable the `igx-time-picker` component. By default `disabled` is set to false.
             * ```html
             * <igx-time-picker [disabled]="'true'" [vertical]="true" format="h:mm tt" ></igx-time-picker>
             * ```
             */
            this.disabled = false;
            /**
             * An @Input property that determines the spin behavior. By default `isSpinLoop` is set to true.
             * The seconds, minutes and hour spinning will wrap around by default.
             *```html
             *<igx-time-picker [isSpinLoop]="false" id="time-picker"></igx-time-picker>
             *```
             */
            this.isSpinLoop = true;
            /**
             * An @Input property that Gets/Sets the orientation of the `igxTimePicker`. By default `vertical` is set to false.
             * ```html
             *<igx-time-picker [vertical]="true" id="time-picker"></igx-time-picker>
             * ```
             */
            this.vertical = false;
            /**
             * Sets the character used to prompt the user for input.
             * Default value is "'-'".
             * ```html
             * <igx-time-picker [promptChar] = "'_'">
             * ```
             * @memberof IgxTimePickerComponent
             */
            this.promptChar = '-';
            /**
             * An @Input property that allows you to switch the interaction mode between
             * a dialog picker or dropdown with editable masked input.
             * Deafult is dialog picker.
             *```html
             *public mode = InteractionMode.DROPDOWN;
             *  //..
             *<igx-time-picker [mode]="mode"></igx-time-picker>
             *```
             * @memberof IgxTimePickerComponent
             */
            this.mode = exports.InteractionMode.Dialog;
            /**
             * Emitted when selection is made. The event contains the selected value. Returns {`oldValue`: `Date`, `newValue`: `Date`}.
             *```typescript
             * @ViewChild("toast")
             *private toast: IgxToastComponent;
             *public onValueChanged(timepicker){
             *    this.toast.show()
             *}
             * //...
             * ```
             * ```html
             *<igx-time-picker (onValueChanged)="onValueChanged($event)"></igx-time-picker>
             *<igx-toast #toast message="The value has been changed!"></igx-toast>
             *```
             */
            this.onValueChanged = new core.EventEmitter();
            /**
             * Emitted when an invalid value is being set. Returns {`timePicker`: `any`, `currentValue`: `Date`, `setThroughUI`: `boolean`}
             * ```typescript
             *public min: string = "09:00";
             *public max: string = "18:00";
             *@ViewChild("toast")
             *private toast: IgxToastComponent;
             *public onValidationFailed(timepicker){
             *    this.toast.show();
             *}
             * //...
             * ```
             * ```html
             *<igx-time-picker [minValue]="min" [maxValue]="max" (onValidationFailed)="onValidationFailed($event)"></igx-time-picker>
             *<igx-toast #toast message="Value must be between 09:00 and 18:00!"></igx-toast>
             * ```
             */
            this.onValidationFailed = new core.EventEmitter();
            /**
             * Emitted when a timePicker is opened.
             */
            this.onOpened = new core.EventEmitter();
            /**
             * Emitted when a timePicker is closed.
             */
            this.onClosed = new core.EventEmitter();
            /**
             * Emitted when a timePicker is being closed.
             */
            this.onClosing = new core.EventEmitter();
            /**
             * @hidden
             */
            this._hourItems = [];
            /**
             * @hidden
             */
            this._minuteItems = [];
            /**
             * @hidden
             */
            this._secondsItems = [];
            /**
             * @hidden
             */
            this._ampmItems = [];
            /**
             * @hidden
            */
            this.cleared = false;
            /**
             * @hidden
            */
            this.isNotEmpty = false;
            /**
             * @hidden
            */
            this.displayFormat = new TimeDisplayFormatPipe(this);
            /**
             * @hidden
            */
            this.inputFormat = new TimeInputFormatPipe(this);
            this._resourceStrings = CurrentResourceStrings.TimePickerResStrings;
            this._okButtonLabel = null;
            this._cancelButtonLabel = null;
            this._itemsDelta = { hours: 1, minutes: 1, seconds: 1 };
            this._isHourListLoop = this.isSpinLoop;
            this._isMinuteListLoop = this.isSpinLoop;
            this._isSecondsListLoop = this.isSpinLoop;
            this._hourView = [];
            this._minuteView = [];
            this._secondsView = [];
            this._ampmView = [];
            this._destroy$ = new rxjs.Subject();
            this._onOpen = new core.EventEmitter();
            this._onClose = new core.EventEmitter();
            this._hoursPos = new Set();
            this._minutesPos = new Set();
            this._secondsPos = new Set();
            this._amPmPos = new Set();
            this._ngControl = null;
            //#region ControlValueAccessor
            this._onChangeCallback = noop$9;
            this._onTouchedCallback = noop$9;
        }
        IgxTimePickerComponent_1 = IgxTimePickerComponent;
        Object.defineProperty(IgxTimePickerComponent.prototype, "value", {
            /**
             * An accessor that returns the value of `igx-time-picker` component.
             * ```html
             *@ViewChild("MyPick")
             *public pick: IgxTimePickerComponent;
             *ngAfterViewInit(){
             *    let pickSelect = this.pick.value;
             * }
             * ```
             */
            get: function () {
                return this._value;
            },
            /**
             * An accessor that allows you to set a time using the `value` input.
             * ```html
             *public date: Date = new Date(Date.now());
             *  //...
             *<igx-time-picker [value]="date" format="h:mm tt"></igx-time-picker>
             * ```
             */
            set: function (value) {
                if (this._isValueValid(value)) {
                    var oldVal = this._value;
                    this._value = value;
                    this._onChangeCallback(value);
                    var dispVal = this._formatTime(this.value, this.format);
                    if (this.mode === exports.InteractionMode.DropDown && this._displayValue !== dispVal) {
                        this.displayValue = dispVal;
                    }
                    var args = {
                        oldValue: oldVal,
                        newValue: value
                    };
                    this.onValueChanged.emit(args);
                }
                else {
                    var args = {
                        timePicker: this,
                        currentValue: value,
                        setThroughUI: false
                    };
                    this.onValidationFailed.emit(args);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "resourceStrings", {
            /**
             * An accessor that returns the resource strings.
            */
            get: function () {
                return this._resourceStrings;
            },
            /**
             * An accessor that sets the resource strings.
             * By default it uses EN resources.
            */
            set: function (value) {
                this._resourceStrings = Object.assign({}, this._resourceStrings, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "okButtonLabel", {
            /**
             * An accessor that returns the label of ok button.
            */
            get: function () {
                if (this._okButtonLabel === null) {
                    return this.resourceStrings.igx_time_picker_ok;
                }
                return this._okButtonLabel;
            },
            /**
             * An @Input property that renders OK button with custom text. By default `okButtonLabel` is set to OK.
             * ```html
             * <igx-time-picker okButtonLabel='SET' [value]="date" format="h:mm tt"></igx-time-picker>
             * ```
             */
            set: function (value) {
                this._okButtonLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "cancelButtonLabel", {
            /**
            * An accessor that returns the label of cancel button.
            */
            get: function () {
                if (this._cancelButtonLabel === null) {
                    return this.resourceStrings.igx_time_picker_cancel;
                }
                return this._cancelButtonLabel;
            },
            /**
             * An @Input property that renders cancel button with custom text.
             * By default `cancelButtonLabel` is set to Cancel.
             * ```html
             * <igx-time-picker cancelButtonLabel='Exit' [value]="date" format="h:mm tt"></igx-time-picker>
             * ```
             */
            set: function (value) {
                this._cancelButtonLabel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "itemsDelta", {
            get: function () {
                return this._itemsDelta;
            },
            /**
             * An @Input property that gets/sets the delta by which hour and minute items would be changed <br>
             * when the user presses the Up/Down keys.
             * By default `itemsDelta` is set to `{hours: 1, minutes: 1, seconds: 1}`
             * ```html
             *<igx-time-picker [itemsDelta]="{hours:3, minutes:5, seconds:10}" id="time-picker"></igx-time-picker>
             *```
             */
            set: function (value) {
                this._itemsDelta = __assign({ hours: 1, minutes: 1, seconds: 1 }, value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "format", {
            /**
             * An @Input property that Gets/Sets format of time while `igxTimePicker` does not have focus. <br>
             * By default `format` is set to hh:mm tt. <br>
             * List of time-flags: <br>
             * `h` : hours field in 12-hours format without leading zero <br>
             * `hh` : hours field in 12-hours format with leading zero <br>
             * `H` : hours field in 24-hours format without leading zero <br>
             * `HH` : hours field in 24-hours format with leading zero <br>
             * `m` : minutes field without leading zero <br>
             * `mm` : minutes field with leading zero <br>
             * `s` : seconds field without leading zero <br>
             * `ss` : seconds field with leading zero <br>
             * `tt` : 2 character string which represents AM/PM field <br>
             * ```html
             *<igx-time-picker format="HH:m" id="time-picker"></igx-time-picker>
             * ```
             */
            get: function () {
                return this._format || 'hh:mm tt';
            },
            set: function (formatValue) {
                this._format = formatValue;
                this.mask = this._format.indexOf('tt') !== -1 ? '00:00:00 LL' : '00:00:00';
                if (!this.showHoursList || !this.showMinutesList) {
                    this.trimMask();
                }
                if (!this.showSecondsList) {
                    this.trimMask();
                }
                if (this.displayValue) {
                    this.displayValue = this._formatTime(this.value, this._format);
                }
                this.determineCursorPos();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "overlaySettings", {
            get: function () {
                return this._overlaySettings ? this._overlaySettings :
                    (this.mode === exports.InteractionMode.Dialog ? this._dialogOverlaySettings : this._dropDownOverlaySettings);
            },
            /**
            * An @Input property that allows you to modify overlay positioning, interaction and scroll behavior.
            * ```typescript
            * const settings: OverlaySettings = {
            *      closeOnOutsideClick: true,
            *      modal: false
            *  }
            * ```
            * ---
            * ```html
            * <igx-time-picker [overlaySettings]="settings"></igx-time-picker>
            * ```
             * @memberof IgxTimePickerComponent
             */
            set: function (value) {
                this._overlaySettings = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "onOpen", {
            /**
             * @deprecated Use 'onOpened' instead.
             * Emitted when a timePicker is being opened.
             * ```html
             *@ViewChild("toast")
             *private toast: IgxToastComponent;
             *public onOpen(timepicker){
             *    this.toast.show();
             *}
             * //...
             * ```
             * ```html
             *<igx-time-picker [minValue]="min" [maxValue]="max" (onOpen)="onOpen($event)"></igx-time-picker>
             *<igx-toast #toast message="The time picker has been opened!"></igx-toast>
             * ```
             */
            get: function () {
                return this._onOpen;
            },
            set: function (val) {
                this._onOpen = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "onClose", {
            /**
             * @deprecated Use 'onClosed' instead.
             * Emitted when a timePicker is being closed.
             */
            get: function () {
                return this._onClose;
            },
            set: function (val) {
                this._onClose = val;
            },
            enumerable: true,
            configurable: true
        });
        /** @hidden @internal */
        IgxTimePickerComponent.prototype.writeValue = function (value) {
            // use this flag to make sure that min/maxValue are checked (in _convertMinMaxValue() method)
            // against the real value when initializing the component and value is bound via ngModel
            this._dateFromModel = value;
            this._value = value;
            if (this.mode === exports.InteractionMode.DropDown) {
                this.displayValue = this._formatTime(this.value, this.format);
            }
        };
        /** @hidden @internal */
        IgxTimePickerComponent.prototype.registerOnChange = function (fn) { this._onChangeCallback = fn; };
        /** @hidden @internal */
        IgxTimePickerComponent.prototype.registerOnTouched = function (fn) { this._onTouchedCallback = fn; };
        /** @hidden @internal */
        IgxTimePickerComponent.prototype.setDisabledState = function (isDisabled) { this.disabled = isDisabled; };
        //#endregion
        IgxTimePickerComponent.prototype.trimMask = function () {
            this.mask = this.mask.slice(this.mask.indexOf(':') + 1, this.mask.length);
        };
        Object.defineProperty(IgxTimePickerComponent.prototype, "mask", {
            /**
             * @hidden
            */
            get: function () {
                return this._mask || '00:00 LL';
            },
            set: function (val) {
                this._mask = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "displayValue", {
            /**
             * @hidden
             */
            get: function () {
                if (this._displayValue === undefined) {
                    return this._formatTime(this.value, this.format);
                }
                return this._displayValue;
            },
            set: function (value) {
                this._displayValue = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "displayTime", {
            /**
             * Returns the current time formatted as string using the `format` option.
             * If there is no set time the return is an empty string.
             *```typescript
             *@ViewChild("MyChild")
             *private picker: IgxTimePickerComponent;
             *ngAfterViewInit(){
             *    let time = this.picker.displayTime;
             *}
             *```
             */
            get: function () {
                if (this.value) {
                    return this._formatTime(this.value, this.format);
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "hourView", {
            /**
             * @hidden
             */
            get: function () {
                return this._hourView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "minuteView", {
            /**
             * @hidden
             */
            get: function () {
                return this._minuteView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "secondsView", {
            /**
             * @hidden
             */
            get: function () {
                return this._secondsView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "ampmView", {
            /**
             * @hidden
             */
            get: function () {
                return this._ampmView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "showClearButton", {
            /**
             * @hidden
             */
            get: function () {
                return (this.displayValue && this.displayValue !== this.parseMask(false)) || this.isNotEmpty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "showHoursList", {
            /**
             * @hidden
             */
            get: function () {
                return this.format.indexOf('h') !== -1 || this.format.indexOf('H') !== -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "showMinutesList", {
            /**
             * @hidden
             */
            get: function () {
                return this.format.indexOf('m') !== -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "showSecondsList", {
            /**
             * @hidden
             */
            get: function () {
                return this.format.indexOf('s') !== -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "showAmPmList", {
            /**
             * @hidden
             */
            get: function () {
                return this.format.indexOf('t') !== -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "validSecondsEntries", {
            /**
             * @hidden
             */
            get: function () {
                var secondsEntries = [];
                for (var i = 0; i < 60; i++) {
                    secondsEntries.push(i);
                }
                return secondsEntries;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "validMinuteEntries", {
            /**
             * @hidden
             */
            get: function () {
                var minuteEntries = [];
                for (var i = 0; i < 60; i++) {
                    minuteEntries.push(i);
                }
                return minuteEntries;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "validHourEntries", {
            /**
             * @hidden
             */
            get: function () {
                var hourEntries = [];
                var index = this.format.indexOf('h') !== -1 ? 13 : 24;
                for (var i = 0; i < index; i++) {
                    hourEntries.push(i);
                }
                return hourEntries;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "template", {
            /**
             * Gets the input group template.
             * ```typescript
             * let template = this.template();
             * ```
             * @memberof IgxTimePickerComponent
             */
            get: function () {
                if (this.timePickerTemplateDirective) {
                    return this.timePickerTemplateDirective.template;
                }
                return this.mode === exports.InteractionMode.Dialog ? this.defaultTimePickerTemplate : this.dropdownInputTemplate;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "context", {
            /**
             * Gets the context passed to the input group template.
             * @memberof IgxTimePickerComponent
             */
            get: function () {
                var _this = this;
                return {
                    value: this.value,
                    displayTime: this.displayTime,
                    displayValue: this.displayValue,
                    openDialog: function (target) { return _this.openDialog(target); }
                };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxTimePickerComponent.prototype, "required", {
            get: function () {
                if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
                    // Run the validation with empty object to check if required is enabled.
                    var error = this._ngControl.control.validator({});
                    return error && error.required;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.ngOnInit = function () {
            this._generateHours();
            this._generateMinutes();
            this._generateSeconds();
            if (this.format.indexOf('tt') !== -1) {
                this._generateAmPm();
            }
            this._dropDownOverlaySettings = {
                modal: false,
                closeOnOutsideClick: true,
                scrollStrategy: new AbsoluteScrollStrategy(),
                positionStrategy: new AutoPositionStrategy()
            };
            this._dialogOverlaySettings = {};
            this._ngControl = this._injector.get(forms.NgControl, null);
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (this.mode === exports.InteractionMode.DropDown && this._inputElementRef) {
                rxjs.fromEvent(this._inputElementRef.nativeElement, 'keydown').pipe(operators.throttle(function () { return rxjs.interval(0, rxjs.animationFrameScheduler); }), operators.takeUntil(this._destroy$)).subscribe(function (event) {
                    if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
                        event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
                        _this.spinOnEdit(event);
                    }
                });
            }
            if (this.toggleRef && this._inputGroup) {
                this.toggleRef.element.style.width = this._inputGroup.element.nativeElement.getBoundingClientRect().width + 'px';
            }
            if (this.toggleRef) {
                this.toggleRef.onClosed.pipe(operators.takeUntil(this._destroy$)).subscribe(function () {
                    if (_this.mode === exports.InteractionMode.DropDown) {
                        _this._onDropDownClosed();
                    }
                    _this.onClosed.emit(_this);
                    // TODO: remove this line after deprecating 'onClose'
                    _this._onClose.emit(_this);
                });
                this.toggleRef.onOpened.pipe(operators.takeUntil(this._destroy$)).subscribe(function () {
                    _this.onOpened.emit(_this);
                    // TODO: remove this line after deprecating 'onOpen'
                    _this._onOpen.emit(_this);
                });
                this.toggleRef.onClosing.pipe(operators.takeUntil(this._destroy$)).subscribe(function (event) {
                    _this.onClosing.emit(event);
                    // If canceled in a user onClosing handler
                    if (event.cancel) {
                        return;
                    }
                    // Do not focus the input if clicking outside in dropdown mode
                    var input = _this.getEditElement();
                    if (input && !(event.event && _this.mode === exports.InteractionMode.DropDown)) {
                        input.focus();
                    }
                    else {
                        _this._updateValidityOnBlur();
                    }
                });
                this.determineCursorPos();
                if (this._ngControl) {
                    this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
                }
            }
        };
        IgxTimePickerComponent.prototype.ngAfterViewChecked = function () {
            // if one sets mode at run time this forces initialization of new igxInputGroup
            // As a result a new igxInputDirective is initialized too. In ngAfterViewInit of
            // the new directive isRequired of the igxInputGroup is set again. However
            // ngAfterViewInit of the time picker is not called again and we may finish with wrong
            // isRequired in igxInputGroup. This is why we should set it her, only when needed
            if (this._inputGroup && this._inputGroup.isRequired !== this.required) {
                this._inputGroup.isRequired = this.required;
                this._cdr.detectChanges();
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next(true);
            this._destroy$.complete();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.onKeydownSpace = function (event) {
            this.openDialog(this.getInputGroupElement());
            event.preventDefault();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.onAltArrowDown = function () {
            this.openDialog(this.getInputGroupElement());
        };
        IgxTimePickerComponent.prototype.determineCursorPos = function () {
            var e_1, _a;
            this.clearCursorPos();
            try {
                for (var _b = __values(this.format), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var char = _c.value;
                    switch (char) {
                        case 'H':
                        case 'h':
                            this._hoursPos.size === 0 ? this._hoursPos.add(this.format.indexOf(char)) :
                                this._hoursPos.add(this.format.lastIndexOf(char));
                            this._hoursPos.add(this.format.lastIndexOf(char) + 1);
                            break;
                        case 'M':
                        case 'm':
                            this._minutesPos.size === 0 ? this._minutesPos.add(this.format.indexOf(char)) :
                                this._minutesPos.add(this.format.lastIndexOf(char));
                            this._minutesPos.add(this.format.lastIndexOf(char) + 1);
                            break;
                        case 'S':
                        case 's':
                            this._secondsPos.size === 0 ? this._secondsPos.add(this.format.indexOf(char)) :
                                this._secondsPos.add(this.format.lastIndexOf(char));
                            this._secondsPos.add(this.format.lastIndexOf(char) + 1);
                            break;
                        case 'T':
                        case 't':
                            this._amPmPos.size === 0 ? this._amPmPos.add(this.format.indexOf(char)) :
                                this._amPmPos.add(this.format.lastIndexOf(char));
                            this._amPmPos.add(this.format.lastIndexOf(char) + 1);
                            break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        IgxTimePickerComponent.prototype.clearCursorPos = function () {
            var _this = this;
            this._hoursPos.forEach(function (v) { return _this._hoursPos.delete(v); });
            this._minutesPos.forEach(function (v) { return _this._minutesPos.delete(v); });
            this._secondsPos.forEach(function (v) { return _this._secondsPos.delete(v); });
            this._amPmPos.forEach(function (v) { return _this._amPmPos.delete(v); });
        };
        IgxTimePickerComponent.prototype._scrollItemIntoView = function (item, items, selectedItem, isListLoop, viewType) {
            var itemIntoView;
            if (items) {
                var index = (item === 'AM' || item === 'PM') ? items.indexOf(item) : items.indexOf(parseInt(item, 10));
                var view = void 0;
                if (index !== -1) {
                    if (isListLoop) {
                        if (index > 0) {
                            selectedItem = this._itemToString(items[index - 1], viewType);
                            itemIntoView = this._nextItem(items, selectedItem, isListLoop, viewType);
                        }
                        else {
                            selectedItem = this._itemToString(items[1], viewType);
                            itemIntoView = this._prevItem(items, selectedItem, isListLoop, viewType);
                        }
                    }
                    else {
                        view = items.slice(index - 3, index + 4);
                        selectedItem = this._itemToString(items[index], viewType);
                        itemIntoView = { selectedItem: selectedItem, view: view };
                    }
                    itemIntoView.view = this._viewToString(itemIntoView.view, viewType);
                }
            }
            return itemIntoView;
        };
        IgxTimePickerComponent.prototype._viewToString = function (view, viewType) {
            for (var i = 0; i < view.length; i++) {
                if (typeof (view[i]) !== 'string') {
                    view[i] = this._itemToString(view[i], viewType);
                }
            }
            return view;
        };
        IgxTimePickerComponent.prototype._itemToString = function (item, viewType) {
            if (item === null) {
                item = '';
            }
            else if (viewType && typeof (item) !== 'string') {
                var leadZeroHour = (item < 10 && (this.format.indexOf('hh') !== -1 || this.format.indexOf('HH') !== -1));
                var leadZeroMinute = (item < 10 && this.format.indexOf('mm') !== -1);
                var leadZeroSeconds = (item < 10 && this.format.indexOf('ss') !== -1);
                var leadZero = {
                    hour: leadZeroHour,
                    minute: leadZeroMinute,
                    seconds: leadZeroSeconds
                }[viewType];
                item = (leadZero) ? '0' + item : "" + item;
            }
            return item;
        };
        IgxTimePickerComponent.prototype._prevItem = function (items, selectedItem, isListLoop, viewType) {
            var selectedIndex = items.indexOf(parseInt(selectedItem, 10));
            var itemsCount = items.length;
            var view;
            if (selectedIndex === -1) {
                view = items.slice(0, 7);
                selectedItem = items[3];
            }
            else if (isListLoop) {
                if (selectedIndex - 4 < 0) {
                    view = items.slice(itemsCount - (4 - selectedIndex), itemsCount);
                    view = view.concat(items.slice(0, selectedIndex + 3));
                }
                else if (selectedIndex + 4 > itemsCount) {
                    view = items.slice(selectedIndex - 4, itemsCount);
                    view = view.concat(items.slice(0, selectedIndex + 3 - itemsCount));
                }
                else {
                    view = items.slice(selectedIndex - 4, selectedIndex + 3);
                }
                selectedItem = (selectedIndex === 0) ? items[itemsCount - 1] : items[selectedIndex - 1];
            }
            else if (selectedIndex > 3) {
                view = items.slice(selectedIndex - 4, selectedIndex + 3);
                selectedItem = items[selectedIndex - 1];
            }
            else if (selectedIndex === 3) {
                view = items.slice(0, 7);
            }
            view = this._viewToString(view, viewType);
            selectedItem = this._itemToString(selectedItem, viewType);
            return {
                selectedItem: selectedItem,
                view: view
            };
        };
        IgxTimePickerComponent.prototype._nextItem = function (items, selectedItem, isListLoop, viewType) {
            var selectedIndex = items.indexOf(parseInt(selectedItem, 10));
            var itemsCount = items.length;
            var view;
            if (selectedIndex === -1) {
                view = items.slice(0, 7);
                selectedItem = items[3];
            }
            else if (isListLoop) {
                if (selectedIndex < 2) {
                    view = items.slice(itemsCount - (2 - selectedIndex), itemsCount);
                    view = view.concat(items.slice(0, selectedIndex + 5));
                }
                else if (selectedIndex + 4 >= itemsCount) {
                    view = items.slice(selectedIndex - 2, itemsCount);
                    view = view.concat(items.slice(0, selectedIndex + 5 - itemsCount));
                }
                else {
                    view = items.slice(selectedIndex - 2, selectedIndex + 5);
                }
                selectedItem = (selectedIndex === itemsCount - 1) ? items[0] : items[selectedIndex + 1];
            }
            else if (selectedIndex + 1 < itemsCount - 3) {
                view = items.slice(selectedIndex - 2, selectedIndex + 5);
                selectedItem = items[selectedIndex + 1];
            }
            else if (selectedIndex === itemsCount - 4) {
                view = items.slice(selectedIndex - 3, itemsCount);
            }
            view = this._viewToString(view, viewType);
            selectedItem = this._itemToString(selectedItem, viewType);
            return {
                selectedItem: selectedItem,
                view: view
            };
        };
        IgxTimePickerComponent.prototype._formatTime = function (value, format) {
            if (!value) {
                return '';
            }
            else {
                var hour = value.getHours();
                var formattedSeconds = void 0, formattedMinute = void 0, formattedHour = void 0;
                var minute = value.getMinutes();
                var seconds = value.getSeconds();
                var amPM = (hour > 11) ? 'PM' : 'AM';
                if (format.indexOf('h') !== -1) {
                    if (hour > 12) {
                        hour -= 12;
                        formattedHour = hour < 10 && format.indexOf('hh') !== -1 ? '0' + hour : "" + hour;
                    }
                    else if (hour === 0) {
                        formattedHour = '12';
                    }
                    else if (hour < 10 && format.indexOf('hh') !== -1) {
                        formattedHour = '0' + hour;
                    }
                    else {
                        formattedHour = "" + hour;
                    }
                }
                else {
                    if (hour < 10 && format.indexOf('HH') !== -1) {
                        formattedHour = '0' + hour;
                    }
                    else {
                        formattedHour = "" + hour;
                    }
                }
                formattedMinute = minute < 10 && format.indexOf('mm') !== -1 ? '0' + minute : "" + minute;
                formattedSeconds = seconds < 10 && format.indexOf('ss') !== -1 ? '0' + seconds : "" + seconds;
                return format.replace('hh', formattedHour).replace('h', formattedHour)
                    .replace('HH', formattedHour).replace('H', formattedHour)
                    .replace('mm', formattedMinute).replace('m', formattedMinute)
                    .replace('ss', formattedSeconds).replace('s', formattedSeconds)
                    .replace('tt', amPM);
            }
        };
        IgxTimePickerComponent.prototype._updateHourView = function (start, end) {
            this._hourView = this._viewToString(this._hourItems.slice(start, end), 'hour');
        };
        IgxTimePickerComponent.prototype._updateMinuteView = function (start, end) {
            this._minuteView = this._viewToString(this._minuteItems.slice(start, end), 'minute');
        };
        IgxTimePickerComponent.prototype._updateSecondsView = function (start, end) {
            this._secondsView = this._viewToString(this._secondsItems.slice(start, end), 'seconds');
        };
        IgxTimePickerComponent.prototype._updateAmPmView = function (start, end) {
            this._ampmView = this._ampmItems.slice(start, end);
        };
        IgxTimePickerComponent.prototype._addEmptyItems = function (items) {
            for (var i = 0; i < 3; i++) {
                items.push(null);
            }
        };
        IgxTimePickerComponent.prototype._generateHours = function () {
            var hourItemsCount = 24;
            if (this.format.indexOf('h') !== -1) {
                hourItemsCount = 13;
            }
            hourItemsCount /= this.itemsDelta.hours;
            var i = this.format.indexOf('H') !== -1 ? 0 : 1;
            if (hourItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._hourItems);
                this._isHourListLoop = false;
            }
            if (hourItemsCount > 1) {
                for (i; i < hourItemsCount; i++) {
                    this._hourItems.push(i * this.itemsDelta.hours);
                }
            }
            else {
                this._hourItems.push(0);
            }
            if (hourItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._hourItems);
            }
        };
        IgxTimePickerComponent.prototype._generateMinutes = function () {
            var minuteItemsCount = 60 / this.itemsDelta.minutes;
            if (minuteItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._minuteItems);
                this._isMinuteListLoop = false;
            }
            for (var i = 0; i < minuteItemsCount; i++) {
                this._minuteItems.push(i * this.itemsDelta.minutes);
            }
            if (minuteItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._minuteItems);
            }
        };
        IgxTimePickerComponent.prototype._generateSeconds = function () {
            var secondsItemsCount = 60 / this.itemsDelta.seconds;
            if (secondsItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._secondsItems);
                this._isSecondsListLoop = false;
            }
            for (var i = 0; i < secondsItemsCount; i++) {
                this._secondsItems.push(i * this.itemsDelta.seconds);
            }
            if (secondsItemsCount < 7 || !this.isSpinLoop) {
                this._addEmptyItems(this._secondsItems);
            }
        };
        IgxTimePickerComponent.prototype._generateAmPm = function () {
            this._addEmptyItems(this._ampmItems);
            this._ampmItems.push('AM');
            this._ampmItems.push('PM');
            this._addEmptyItems(this._ampmItems);
        };
        IgxTimePickerComponent.prototype._getSelectedTime = function () {
            var date = this.value ? new Date(this.value) : new Date();
            if (this.selectedHour) {
                date.setHours(parseInt(this.selectedHour, 10));
            }
            if (this.selectedMinute) {
                date.setMinutes(parseInt(this.selectedMinute, 10));
            }
            if (this.selectedSeconds) {
                date.setSeconds(parseInt(this.selectedSeconds, 10));
            }
            if (((this.showHoursList && this.selectedHour !== '12') || (!this.showHoursList && this.selectedHour <= '11')) &&
                this.selectedAmPm === 'PM') {
                date.setHours(date.getHours() + 12);
            }
            if (!this.showHoursList && this.selectedAmPm === 'AM' && this.selectedHour > '11') {
                date.setHours(date.getHours() - 12);
            }
            if (this.selectedAmPm === 'AM' && this.selectedHour === '12') {
                date.setHours(0);
            }
            return date;
        };
        IgxTimePickerComponent.prototype._convertMinMaxValue = function (value) {
            var date = this.value ? new Date(this.value) : this._dateFromModel ? new Date(this._dateFromModel) : new Date();
            var sections = value.split(/[\s:]+/);
            var hour, minutes, seconds, amPM;
            date.setSeconds(0);
            if (this.showHoursList) {
                hour = sections[0];
                date.setHours(parseInt(hour, 10));
            }
            if (this.showMinutesList) {
                minutes = this.showHoursList ? sections[1] : sections[0];
                date.setMinutes(parseInt(minutes, 10));
            }
            if (this.showSecondsList) {
                seconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
                date.setSeconds(parseInt(seconds, 10));
            }
            if (this.showAmPmList) {
                amPM = sections[sections.length - 1];
                if (((this.showHoursList && date.getHours().toString() !== '12') ||
                    (!this.showHoursList && date.getHours().toString() <= '11')) && amPM === 'PM') {
                    date.setHours(date.getHours() + 12);
                }
                if (!this.showHoursList && amPM === 'AM' && date.getHours().toString() > '11') {
                    date.setHours(date.getHours() - 12);
                }
                if (this.showHoursList && date.getHours() === 12 && amPM === 'AM') {
                    date.setHours(0);
                }
            }
            return date;
        };
        IgxTimePickerComponent.prototype._isValueValid = function (value) {
            if (this.maxValue && value > this._convertMinMaxValue(this.maxValue)) {
                return false;
            }
            else if (this.minValue && value < this._convertMinMaxValue(this.minValue)) {
                return false;
            }
            return true;
        };
        IgxTimePickerComponent.prototype._isEntryValid = function (val) {
            var validH = true;
            var validM = true;
            var validS = true;
            var sections = val.split(/[\s:]+/);
            var re = new RegExp(this.promptChar, 'g');
            if (this.showHoursList) {
                validH = this.validHourEntries.indexOf(parseInt(sections[0].replace(re, ''), 10)) !== -1;
            }
            if (this.showMinutesList) {
                var minutes = this.showHoursList ? sections[1] : sections[0];
                validM = this.validMinuteEntries.indexOf(parseInt(minutes.replace(re, ''), 10)) !== -1;
            }
            if (this.showSecondsList) {
                var seconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
                validS = this.validSecondsEntries.indexOf(parseInt(seconds.replace(re, ''), 10)) !== -1;
            }
            return validH && validM && validS;
        };
        IgxTimePickerComponent.prototype._getCursorPosition = function () {
            return this._inputElementRef.nativeElement.selectionStart;
        };
        IgxTimePickerComponent.prototype._setCursorPosition = function (start, end) {
            if (end === void 0) { end = start; }
            this._inputElementRef.nativeElement.setSelectionRange(start, end);
        };
        IgxTimePickerComponent.prototype._updateEditableInput = function () {
            if (this.mode === exports.InteractionMode.DropDown) {
                this.displayValue = this._formatTime(this._getSelectedTime(), this.format);
            }
        };
        IgxTimePickerComponent.prototype._spinHours = function (currentVal, minVal, maxVal, hDelta, sign) {
            var oldVal = new Date(currentVal);
            currentVal.setMinutes(sign * hDelta);
            if (currentVal.getDate() !== oldVal.getDate() && this.isSpinLoop) {
                currentVal.setDate(oldVal.getDate());
            }
            var minutes = currentVal.getMinutes();
            if (currentVal.getTime() > maxVal.getTime()) {
                if (this.isSpinLoop) {
                    minutes = minutes < minVal.getMinutes() ? 60 + minutes : minutes;
                    minVal.setMinutes(sign * minutes);
                    return minVal;
                }
                else {
                    return oldVal;
                }
            }
            else if (currentVal.getTime() < minVal.getTime()) {
                if (this.isSpinLoop) {
                    minutes = minutes <= maxVal.getMinutes() ? minutes : minutes - 60;
                    maxVal.setMinutes(minutes);
                    return maxVal;
                }
                else {
                    return oldVal;
                }
            }
            else {
                return currentVal;
            }
        };
        IgxTimePickerComponent.prototype._spinMinutes = function (currentVal, mDelta, sign) {
            var minutes = currentVal.getMinutes() + (sign * mDelta);
            if (minutes < 0 || minutes >= 60) {
                minutes = this.isSpinLoop ? minutes - (sign * 60) : currentVal.getMinutes();
            }
            currentVal.setMinutes(minutes);
            return currentVal;
        };
        IgxTimePickerComponent.prototype._spinSeconds = function (currentVal, sDelta, sign) {
            var seconds = currentVal.getSeconds() + (sign * sDelta);
            if (seconds < 0 || seconds >= 60) {
                seconds = this.isSpinLoop ? seconds - (sign * 60) : currentVal.getSeconds();
            }
            currentVal.setSeconds(seconds);
            return currentVal;
        };
        IgxTimePickerComponent.prototype._initializeContainer = function () {
            var _this = this;
            if (this.value) {
                var formttedTime = this._formatTime(this.value, this.format);
                var sections = formttedTime.split(/[\s:]+/);
                if (this.showHoursList) {
                    this.selectedHour = sections[0];
                }
                if (this.showMinutesList) {
                    this.selectedMinute = this.showHoursList ? sections[1] : sections[0];
                }
                if (this.showSecondsList) {
                    this.selectedSeconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
                }
                if (this.showAmPmList && this._ampmItems !== null) {
                    this.selectedAmPm = sections[sections.length - 1];
                }
            }
            if (this.selectedHour === undefined) {
                this.selectedHour = !this.showHoursList && this.value ? this.value.getHours().toString() :
                    this.showHoursList ? "" + this._hourItems[3] : '0';
            }
            if (this.selectedMinute === undefined) {
                this.selectedMinute = !this.showMinutesList && this.value ? this.value.getMinutes().toString() : '0';
            }
            if (this.selectedSeconds === undefined) {
                this.selectedSeconds = !this.showSecondsList && this.value ? this.value.getSeconds().toString() : '0';
            }
            if (this.selectedAmPm === undefined && this._ampmItems !== null) {
                this.selectedAmPm = this._ampmItems[3];
            }
            this._prevSelectedHour = this.selectedHour;
            this._prevSelectedMinute = this.selectedMinute;
            this._prevSelectedSeconds = this.selectedSeconds;
            this._prevSelectedAmPm = this.selectedAmPm;
            this._onTouchedCallback();
            this._updateHourView(0, ITEMS_COUNT);
            this._updateMinuteView(0, ITEMS_COUNT);
            this._updateSecondsView(0, ITEMS_COUNT);
            this._updateAmPmView(0, ITEMS_COUNT);
            if (this.selectedHour) {
                this.scrollHourIntoView(this.selectedHour);
            }
            if (this.selectedMinute) {
                this.scrollMinuteIntoView(this.selectedMinute);
            }
            if (this.selectedSeconds) {
                this.scrollSecondsIntoView(this.selectedSeconds);
            }
            if (this.selectedAmPm) {
                this.scrollAmPmIntoView(this.selectedAmPm);
            }
            requestAnimationFrame(function () {
                if (_this.hourList) {
                    _this.hourList.nativeElement.focus();
                }
                else if (_this.minuteList) {
                    _this.minuteList.nativeElement.focus();
                }
                else if (_this.secondsList) {
                    _this.secondsList.nativeElement.focus();
                }
            });
        };
        IgxTimePickerComponent.prototype._onDropDownClosed = function () {
            var oldValue = this.value;
            var newVal = this._convertMinMaxValue(this.displayValue);
            if (this.displayValue === this.parseMask(false)) {
                return;
            }
            if (this._isValueValid(newVal)) {
                if (!this.value || oldValue.getTime() !== newVal.getTime()) {
                    this.value = newVal;
                }
            }
            else {
                this.displayValue = this.inputFormat.transform(this._formatTime(oldValue, this.format));
                var args = {
                    timePicker: this,
                    currentValue: newVal,
                    setThroughUI: true
                };
                this.onValidationFailed.emit(args);
            }
        };
        IgxTimePickerComponent.prototype.onStatusChanged = function () {
            if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
                (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
                var input = this._inputDirective || this._inputDirectiveUserTemplate;
                if (this._inputGroup.isFocused) {
                    input.valid = this._ngControl.valid ? exports.IgxInputState.VALID : exports.IgxInputState.INVALID;
                }
                else {
                    input.valid = this._ngControl.valid ? exports.IgxInputState.INITIAL : exports.IgxInputState.INVALID;
                }
            }
            if (this._inputGroup && this._inputGroup.isRequired !== this.required) {
                this._inputGroup.isRequired = this.required;
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.getEditElement = function () {
            return this._inputElementRef ? this._inputElementRef.nativeElement : null;
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.getInputGroupElement = function () {
            return this._inputGroup ? this._inputGroup.element.nativeElement : null;
        };
        /**
         * opens the dialog.
         * @param target HTMLElement - the target element to use for positioning the drop down container according to
         * ```html
         * <igx-time-picker [value]="date" mode="dropdown" #retemplated>
         *   <ng-template igxTimePickerTemplate let-openDialog="openDialog"
         *                let-displayTime="displayTime">
         *     <igx-input-group>
         *       <input #dropDownTarget igxInput [value]="displayTime" />
         *       <igx-suffix (click)="openDialog(dropDownTarget)">
         *         <igx-icon>alarm</igx-icon>
         *       </igx-suffix>
         *     </igx-input-group>
         *   </ng-template>
         * </igx-time-picker>
         * ```
         */
        IgxTimePickerComponent.prototype.openDialog = function (target) {
            if (!this.toggleRef.collapsed) {
                return this._onDropDownClosed();
            }
            var settings = this.overlaySettings;
            if (target && settings && settings.positionStrategy) {
                settings.positionStrategy.settings.target = target;
            }
            if (this.outlet) {
                settings.outlet = this.outlet;
            }
            this.toggleRef.open(settings);
            this._initializeContainer();
        };
        /**
         * Scrolls a hour item into view.
         * ```typescript
         *scrhintoView(picker) {
         *picker.scrollHourIntoView('2');
         *}
         * ```
         *```html
         *<igx-time-picker #picker format="h:mm tt" (onOpen)="scrhintoView(picker)"></igx-time-picker>
         *```
         *@param item to be scrolled in view.
         */
        IgxTimePickerComponent.prototype.scrollHourIntoView = function (item) {
            if (this.showHoursList) {
                var hourIntoView = this._scrollItemIntoView(item, this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
                if (hourIntoView) {
                    this._hourView = hourIntoView.view;
                    this.selectedHour = hourIntoView.selectedItem;
                    this._updateEditableInput();
                }
            }
        };
        /**
         * Scrolls a minute item into view.
         * ```typescript
         *scrMintoView(picker) {
         *picker.scrollMinuteIntoView('3');
         *}
         * ```
         *```html
         *<igx-time-picker #picker format="h:mm tt" (onOpen)="scrMintoView(picker)"></igx-time-picker>
         *```
         * @param item to be scrolled in view.
         */
        IgxTimePickerComponent.prototype.scrollMinuteIntoView = function (item) {
            if (this.showMinutesList) {
                var minuteIntoView = this._scrollItemIntoView(item, this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
                if (minuteIntoView) {
                    this._minuteView = minuteIntoView.view;
                    this.selectedMinute = minuteIntoView.selectedItem;
                    this._updateEditableInput();
                }
            }
        };
        /**
         * Scrolls a seconds item into view.
         * ```typescript
         *scrMintoView(picker) {
         *picker.scrollSecondsIntoView('4');
         *}
         * ```
         *```html
         *<igx-time-picker #picker format="h:mm tt" (onOpen)="scrMintoView(picker)"></igx-time-picker>
         *```
         * @param item to be scrolled in view.
         */
        IgxTimePickerComponent.prototype.scrollSecondsIntoView = function (item) {
            if (this.showSecondsList) {
                var secondsIntoView = this._scrollItemIntoView(item, this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
                if (secondsIntoView) {
                    this._secondsView = secondsIntoView.view;
                    this.selectedSeconds = secondsIntoView.selectedItem;
                    this._updateEditableInput();
                }
            }
        };
        /**
         * Scrolls an ampm item into view.
         * ```typescript
         *scrAmPmIntoView(picker) {
         *picker.scrollAmPmIntoView('PM');
         *}
         * ```
         *```html
         *<igx-time-picker #picker format="h:mm tt" (onOpen)="scrAmPmIntoView(picker)"></igx-time-picker>
         *```
         * @param item to be scrolled in view.
         */
        IgxTimePickerComponent.prototype.scrollAmPmIntoView = function (item) {
            if (this.showAmPmList) {
                var ampmIntoView = this._scrollItemIntoView(item, this._ampmItems, this.selectedAmPm, false, null);
                if (ampmIntoView) {
                    this._ampmView = ampmIntoView.view;
                    this.selectedAmPm = ampmIntoView.selectedItem;
                    this._updateEditableInput();
                }
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.nextHour = function () {
            var nextHour = this._nextItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
            this._hourView = nextHour.view;
            this.selectedHour = nextHour.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.prevHour = function () {
            var prevHour = this._prevItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
            this._hourView = prevHour.view;
            this.selectedHour = prevHour.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.nextMinute = function () {
            var nextMinute = this._nextItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
            this._minuteView = nextMinute.view;
            this.selectedMinute = nextMinute.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.prevMinute = function () {
            var prevMinute = this._prevItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
            this._minuteView = prevMinute.view;
            this.selectedMinute = prevMinute.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.nextSeconds = function () {
            var nextSeconds = this._nextItem(this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
            this._secondsView = nextSeconds.view;
            this.selectedSeconds = nextSeconds.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.prevSeconds = function () {
            var prevSeconds = this._prevItem(this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
            this._secondsView = prevSeconds.view;
            this.selectedSeconds = prevSeconds.selectedItem;
            this._updateEditableInput();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.nextAmPm = function () {
            var selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
            if (selectedIndex + 1 < this._ampmItems.length - 3) {
                this._updateAmPmView(selectedIndex - 2, selectedIndex + 5);
                this.selectedAmPm = this._ampmItems[selectedIndex + 1];
                this._updateEditableInput();
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.prevAmPm = function () {
            var selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
            if (selectedIndex > 3) {
                this._updateAmPmView(selectedIndex - 4, selectedIndex + 3);
                this.selectedAmPm = this._ampmItems[selectedIndex - 1];
                this._updateEditableInput();
            }
        };
        /**
         * If current value is valid selects it, closes the dialog and returns true, otherwise returns false.
         * ```html
         * <igx-dialog class="igx-time-picker__dialog-popup" [rightButtonLabel]="okButtonLabel" (onRightButtonSelect)="okButtonClick()">
         * //..
         * </igx-dialog>
         * ```
         */
        IgxTimePickerComponent.prototype.okButtonClick = function () {
            var time = this._getSelectedTime();
            if (this._isValueValid(time)) {
                this.close();
                this.value = time;
                return true;
            }
            else {
                var args = {
                    timePicker: this,
                    currentValue: time,
                    setThroughUI: true
                };
                this.onValidationFailed.emit(args);
                return false;
            }
        };
        /**
         * Closes the dialog without selecting the current value.
         * ```html
         * <igx-dialog class="igx-time-picker__dialog-popup" [leftButtonLabel]="cancelButtonLabel" (onLeftButtonSelect)="cancelButtonClick()">
         * //...
         * </igx-dialog>
         * ```
         */
        IgxTimePickerComponent.prototype.cancelButtonClick = function () {
            if (this.mode === exports.InteractionMode.DropDown) {
                this.displayValue = this.value ? this._formatTime(this.value, this.format) : this.parseMask(false);
            }
            this.close();
            this.selectedHour = this._prevSelectedHour;
            this.selectedMinute = this._prevSelectedMinute;
            this.selectedSeconds = this._prevSelectedSeconds;
            this.selectedAmPm = this._prevSelectedAmPm;
        };
        /**
         * Returns an array of the hours currently in view.
         *```html
         *@ViewChild("MyChild")
         *private picker: IgxTimePickerComponent;
         *ngAfterViewInit(){
         *    let hInView = this.picker.hoursInView;
         *}
         *```
         */
        IgxTimePickerComponent.prototype.hoursInView = function () {
            return this._hourView.filter(function (hour) { return hour !== ''; });
        };
        /**
         * Returns an array of the minutes currently in view.
         *```html
         *@ViewChild("MyChild")
         *private picker: IgxTimePickerComponent;
         *ngAfterViewInit(){
         *    let minInView = this.picker.minutesInView;
         *}
         *```
         */
        IgxTimePickerComponent.prototype.minutesInView = function () {
            return this._minuteView.filter(function (minute) { return minute !== ''; });
        };
        /**
         * Returns an array of the seconds currently in view.
         *```html
         *@ViewChild("MyChild")
         *private picker: IgxTimePickerComponent;
         *ngAfterViewInit(){
         *    let minInView = this.picker.secondsInView;
         *}
         *```
         */
        IgxTimePickerComponent.prototype.secondsInView = function () {
            return this._secondsView.filter(function (seconds) { return seconds !== ''; });
        };
        /**
         * Returns an array of the AM/PM currently in view.
         *```html
         *@ViewChild("MyChild")
         *private picker: IgxTimePickerComponent;
         *ngAfterViewInit(){
         *    let ApInView = this.picker.ampmInView;
         *}
         *```
         */
        IgxTimePickerComponent.prototype.ampmInView = function () {
            return this._ampmView.filter(function (ampm) { return ampm !== ''; });
        };
        /**
         * Closes the dropdown/dialog.
         * ```html
         *<igx-time-picker #timePicker></igx-time-picker>
         * ```
         * ```typescript
         * @ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;
         * picker.close();
         * ```
         */
        IgxTimePickerComponent.prototype.close = function () {
            this.toggleRef.close();
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.parseMask = function (preserveAmPm) {
            if (preserveAmPm === void 0) { preserveAmPm = true; }
            var maskWithAmPm = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace('LL', 'AM');
            var pureMask = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace(new RegExp('L', 'g'), this.promptChar);
            return preserveAmPm ? maskWithAmPm : pureMask;
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.clear = function () {
            if (this.toggleRef.collapsed) {
                this.cleared = true;
                this.isNotEmpty = false;
                var oldVal = new Date(this.value);
                this.displayValue = '';
                this.value.setHours(0, 0);
                if (oldVal.getTime() !== this.value.getTime()) {
                    var args = {
                        oldValue: oldVal,
                        newValue: this.value
                    };
                    this.onValueChanged.emit(args);
                }
            }
            else {
                this.close();
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.onInput = function (event) {
            var val = event.target.value;
            var oldVal = new Date(this.value);
            this.isNotEmpty = val !== this.parseMask(false);
            // handle cases where all empty positions (promts) are filled and we want to update
            // timepicker own value property if it is a valid Date
            if (val.indexOf(this.promptChar) === -1) {
                if (this._isEntryValid(val)) {
                    var newVal = this._convertMinMaxValue(val);
                    if (oldVal.getTime() !== newVal.getTime()) {
                        this.value = newVal;
                    }
                }
                else {
                    var args = {
                        timePicker: this,
                        currentValue: val,
                        setThroughUI: false
                    };
                    this.onValidationFailed.emit(args);
                }
                // handle cases where the user deletes the display value (when pressing backspace or delete)
            }
            else if (!this.value || !val || val === this.parseMask(false)) {
                this.isNotEmpty = false;
                this.value.setHours(0, 0);
                this.displayValue = val;
                if (oldVal.getTime() !== this.value.getTime()) {
                    var args = {
                        oldValue: oldVal,
                        newValue: this.value
                    };
                    this.onValueChanged.emit(args);
                }
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.onFocus = function (event) {
            this.isNotEmpty = event.target.value !== this.parseMask(false);
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.onBlur = function (event) {
            if (this.mode === exports.InteractionMode.DropDown) {
                var value = event.target.value;
                this.isNotEmpty = value !== '';
                this.displayValue = value;
                if (value && value !== this.parseMask()) {
                    if (this._isEntryValid(value)) {
                        var newVal = this._convertMinMaxValue(value);
                        if (!this.value || this.value.getTime() !== newVal.getTime()) {
                            this.value = newVal;
                        }
                    }
                    else {
                        var args = {
                            timePicker: this,
                            currentValue: value,
                            setThroughUI: false
                        };
                        this.onValidationFailed.emit(args);
                    }
                }
            }
            if (this.toggleRef.collapsed) {
                this._updateValidityOnBlur();
            }
        };
        IgxTimePickerComponent.prototype.mouseDown = function (event) {
            // if the click is not on the input but in input group
            // e.g. on prefix or suffix, prevent default and this way prevent blur
            if (event.target !== this.getEditElement()) {
                event.preventDefault();
            }
        };
        /**
         * @hidden
         */
        IgxTimePickerComponent.prototype.spinOnEdit = function (event) {
            var _this = this;
            event.preventDefault();
            var sign;
            var displayVal;
            var currentVal = new Date(this.value);
            var min = this.minValue ? this._convertMinMaxValue(this.minValue) : this._convertMinMaxValue('00:00');
            var max = this.maxValue ? this._convertMinMaxValue(this.maxValue) : this._convertMinMaxValue('24:00');
            var cursor = this._getCursorPosition();
            if (event.key) {
                var key = event.key;
                sign = key === "ArrowDown" /* DOWN_ARROW */ || key === "Down" /* DOWN_ARROW_IE */ ? -1 : 1;
            }
            if (event.deltaY) {
                sign = event.deltaY < 0 ? 1 : -1;
            }
            if (!this.displayValue) {
                this.value = min;
                displayVal = this._formatTime(this.value, this.format);
            }
            else {
                var hDelta = this.itemsDelta.hours * 60 + (sign * this.value.getMinutes());
                var mDelta = this.itemsDelta.minutes;
                var sDelta = this.itemsDelta.seconds;
                if (this.cursorOnHours(cursor, this.showHoursList)) {
                    this.value = this._spinHours(currentVal, min, max, hDelta, sign);
                }
                if (this.cursorOnMinutes(cursor, this.showHoursList, this.showMinutesList)) {
                    this.value = this._spinMinutes(currentVal, mDelta, sign);
                }
                if (this.cursorOnSeconds(cursor, this.showHoursList, this.showMinutesList, this.showSecondsList)) {
                    this.value = this._spinSeconds(currentVal, sDelta, sign);
                }
                if (this.cursorOnAmPm(cursor, this.showHoursList, this.showMinutesList, this.showSecondsList, this.showAmPmList)) {
                    var sections = this.displayValue.split(/[\s:]+/);
                    sign = sections[sections.length - 1] === 'AM' ? 1 : -1;
                    currentVal.setHours(currentVal.getHours() + (sign * 12));
                    this.value = currentVal;
                }
                displayVal = this._formatTime(this.value, this.format);
            }
            // minor hack for preventing cursor jumping in IE
            this._displayValue = this.inputFormat.transform(displayVal);
            this._inputElementRef.nativeElement.value = this._displayValue;
            this._setCursorPosition(cursor);
            requestAnimationFrame(function () {
                _this._setCursorPosition(cursor);
            });
        };
        IgxTimePickerComponent.prototype.cursorOnHours = function (cursor, showHours) {
            return showHours && this._hoursPos.has(cursor);
        };
        IgxTimePickerComponent.prototype.cursorOnMinutes = function (cursor, showHours, showMinutes) {
            return showMinutes &&
                (showHours && this._minutesPos.has(cursor)) ||
                (!showHours && this._minutesPos.has(cursor));
        };
        IgxTimePickerComponent.prototype.cursorOnSeconds = function (cursor, showHours, showMinutes, showSeconds) {
            return showSeconds &&
                (showHours && showMinutes && this._secondsPos.has(cursor)) ||
                ((!showHours || !showMinutes) && this._secondsPos.has(cursor)) ||
                (!showHours && !showMinutes && this._secondsPos.has(cursor));
        };
        IgxTimePickerComponent.prototype.cursorOnAmPm = function (cursor, showHours, showMinutes, showSeconds, showAmPm) {
            return showAmPm &&
                (showHours && showMinutes && showSeconds && this._amPmPos.has(cursor)) ||
                ((!showHours || !showMinutes || !showSeconds) && this._amPmPos.has(cursor)) ||
                (!showHours && (!showMinutes || !showSeconds) && this._amPmPos.has(cursor));
        };
        IgxTimePickerComponent.prototype._updateValidityOnBlur = function () {
            this._onTouchedCallback();
            var input = this._inputDirective || this._inputDirectiveUserTemplate;
            if (this._ngControl && !this._ngControl.valid) {
                input.valid = exports.IgxInputState.INVALID;
            }
            else {
                input.valid = exports.IgxInputState.INITIAL;
            }
        };
        var IgxTimePickerComponent_1;
        IgxTimePickerComponent.ctorParameters = function () { return [
            { type: core.Injector },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxTimePickerComponent.prototype, "id", void 0);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "value", null);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "disabled", void 0);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "resourceStrings", null);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "okButtonLabel", null);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "cancelButtonLabel", null);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "itemsDelta", null);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "minValue", void 0);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "maxValue", void 0);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "isSpinLoop", void 0);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "vertical", void 0);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "format", null);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "promptChar", void 0);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "mode", void 0);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "outlet", void 0);
        __decorate([
            core.Input()
        ], IgxTimePickerComponent.prototype, "overlaySettings", null);
        __decorate([
            core.Output()
        ], IgxTimePickerComponent.prototype, "onValueChanged", void 0);
        __decorate([
            core.Output()
        ], IgxTimePickerComponent.prototype, "onValidationFailed", void 0);
        __decorate([
            DeprecateProperty("'onOpen' @Output property is deprecated. Use 'onOpened' instead."),
            core.Output()
        ], IgxTimePickerComponent.prototype, "onOpen", null);
        __decorate([
            core.Output()
        ], IgxTimePickerComponent.prototype, "onOpened", void 0);
        __decorate([
            DeprecateProperty("'onClose' @Output property is deprecated. Use 'onClosed' instead."),
            core.Output()
        ], IgxTimePickerComponent.prototype, "onClose", null);
        __decorate([
            core.Output()
        ], IgxTimePickerComponent.prototype, "onClosed", void 0);
        __decorate([
            core.Output()
        ], IgxTimePickerComponent.prototype, "onClosing", void 0);
        __decorate([
            core.ViewChild('hourList')
        ], IgxTimePickerComponent.prototype, "hourList", void 0);
        __decorate([
            core.ViewChild('minuteList')
        ], IgxTimePickerComponent.prototype, "minuteList", void 0);
        __decorate([
            core.ViewChild('secondsList')
        ], IgxTimePickerComponent.prototype, "secondsList", void 0);
        __decorate([
            core.ViewChild('ampmList')
        ], IgxTimePickerComponent.prototype, "ampmList", void 0);
        __decorate([
            core.ViewChild('defaultTimePickerTemplate', { read: core.TemplateRef, static: true })
        ], IgxTimePickerComponent.prototype, "defaultTimePickerTemplate", void 0);
        __decorate([
            core.ViewChild('dropdownInputTemplate', { read: core.TemplateRef, static: true })
        ], IgxTimePickerComponent.prototype, "dropdownInputTemplate", void 0);
        __decorate([
            core.ContentChild(IgxTimePickerTemplateDirective, { read: IgxTimePickerTemplateDirective })
        ], IgxTimePickerComponent.prototype, "timePickerTemplateDirective", void 0);
        __decorate([
            core.ContentChild(IgxTimePickerActionsDirective, { read: IgxTimePickerActionsDirective })
        ], IgxTimePickerComponent.prototype, "timePickerActionsDirective", void 0);
        __decorate([
            core.ViewChild(IgxToggleDirective, { static: true })
        ], IgxTimePickerComponent.prototype, "toggleRef", void 0);
        __decorate([
            core.ViewChild(IgxInputDirective, { read: core.ElementRef })
        ], IgxTimePickerComponent.prototype, "_inputElementRef", void 0);
        __decorate([
            core.ViewChild(IgxInputDirective, { read: IgxInputDirective })
        ], IgxTimePickerComponent.prototype, "_inputDirective", void 0);
        __decorate([
            core.ContentChild(IgxInputDirective, { read: IgxInputDirective })
        ], IgxTimePickerComponent.prototype, "_inputDirectiveUserTemplate", void 0);
        __decorate([
            core.ViewChild(IgxInputGroupComponent, { read: IgxInputGroupComponent })
        ], IgxTimePickerComponent.prototype, "_inputGroup", void 0);
        __decorate([
            core.HostListener('keydown.spacebar', ['$event']),
            core.HostListener('keydown.space', ['$event'])
        ], IgxTimePickerComponent.prototype, "onKeydownSpace", null);
        __decorate([
            core.HostListener('keydown.Alt.ArrowDown')
        ], IgxTimePickerComponent.prototype, "onAltArrowDown", null);
        IgxTimePickerComponent = IgxTimePickerComponent_1 = __decorate([
            core.Component({
                providers: [
                    {
                        provide: forms.NG_VALUE_ACCESSOR,
                        useExisting: IgxTimePickerComponent_1,
                        multi: true
                    },
                    {
                        provide: platformBrowser.HAMMER_GESTURE_CONFIG,
                        useClass: TimePickerHammerConfig
                    },
                    {
                        provide: IGX_TIME_PICKER_COMPONENT,
                        useExisting: IgxTimePickerComponent_1
                    }
                ],
                selector: 'igx-time-picker',
                template: "<ng-template #dropdownInputTemplate>\n    <igx-input-group #group (mousedown)=\"mouseDown($event)\">\n        <label igxLabel>Time</label>\n        <igx-prefix (click)=\"openDialog(group.element.nativeElement)\">\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <input \n            type=\"text\"\n            [igxMask]=\"mask\"\n            igxInput\n            [includeLiterals]=\"false\"\n            [placeholder]=\"format\"\n            [displayValuePipe]=\"displayFormat\"\n            [focusedValuePipe]=\"inputFormat\"\n            [promptChar]=\"promptChar\"\n            [value]=\"displayValue\"\n            (input)=\"onInput($event)\"\n            (blur)=\"onBlur($event)\"\n            (focus)=\"onFocus($event)\"\n            (wheel)=\"spinOnEdit($event)\"\n            [disabled]=\"disabled\" />\n        <igx-suffix *ngIf=\"showClearButton\" igxRipple (click)=\"clear()\">\n            <igx-icon fontSet=\"material\">clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n<ng-template #defaultTimePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\" (mousedown)=\"mouseDown($event)\">\n        <igx-prefix>\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <label igxLabel>Time</label>\n        <input\n            igxInput\n            [value]=\"displayTime || ''\"\n            [disabled]=\"disabled\"\n            tabindex=\"0\" readonly\n            (blur)=\"onBlur($event)\" />\n    </igx-input-group>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n\n<ng-template #defaultTimePickerActions>\n    <div *ngIf=\"cancelButtonLabel || okButtonLabel\" class=\"igx-time-picker__buttons\">\n        <button *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" (click)=\"cancelButtonClick()\">\n            {{cancelButtonLabel}}\n        </button>\n        <button *ngIf=\"okButtonLabel\" igxButton=\"flat\" (click)=\"okButtonClick()\">\n            {{okButtonLabel}}\n        </button>\n    </div>\n</ng-template>\n<div igxToggle class=\"igx-time-picker\"\n    [ngClass]=\"{'igx-time-picker--dropdown': mode === 'dropdown', 'igx-time-picker--vertical': vertical && mode === 'dialog'}\">\n    <div *ngIf=\"mode === 'dialog'\" class=\"igx-time-picker__header\">\n        <h5 class=\"igx-time-picker__header-ampm\">{{ selectedAmPm }}</h5>\n        <h2 class=\"igx-time-picker__header-hour\">\n            <span>{{ selectedHour }}</span>:<span>{{ selectedMinute }}</span>:<span>{{ selectedSeconds }}</span>\n        </h2>\n    </div>\n    <div class=\"igx-time-picker__main\">\n        <div class=\"igx-time-picker__body\">\n            <div *ngIf=\"showHoursList\" #hourList [igxItemList]=\"'hourList'\">\n                <span [igxHourItem]=\"hour\" *ngFor=\"let hour of hourView\">{{ hour }}</span>\n            </div>\n            <div *ngIf=\"showMinutesList\" #minuteList [igxItemList]=\"'minuteList'\">\n                <span [igxMinuteItem]=\"minute\" *ngFor=\"let minute of minuteView\">{{ minute }}</span>\n            </div>\n            <div *ngIf=\"showSecondsList\" #secondsList [igxItemList]=\"'secondsList'\">\n                <span [igxSecondsItem]=\"seconds\" *ngFor=\"let seconds of secondsView\">{{ seconds }}</span>\n            </div>\n            <div *ngIf=\"showAmPmList\" #ampmList [igxItemList]=\"'ampmList'\">\n                <span [igxAmPmItem]=\"ampm\" *ngFor=\"let ampm of ampmView\">{{ ampm }}</span>\n            </div>\n        </div>\n        <ng-container\n            *ngTemplateOutlet=\"timePickerActionsDirective ? timePickerActionsDirective.template : defaultTimePickerActions\">\n        </ng-container>\n    </div>\n</div>\n",
                styles: [":host {\n            display: block;\n        }"]
            })
        ], IgxTimePickerComponent);
        return IgxTimePickerComponent;
    }());
    /**
     * @hidden
     */
    var IgxTimePickerModule = /** @class */ (function () {
        function IgxTimePickerModule() {
        }
        IgxTimePickerModule = __decorate([
            core.NgModule({
                declarations: [
                    IgxTimePickerComponent,
                    IgxHourItemDirective,
                    IgxMinuteItemDirective,
                    IgxSecondsItemDirective,
                    IgxItemListDirective,
                    IgxAmPmItemDirective,
                    IgxTimePickerTemplateDirective,
                    IgxTimePickerActionsDirective,
                    TimeDisplayFormatPipe,
                    TimeInputFormatPipe
                ],
                exports: [
                    IgxTimePickerComponent,
                    IgxTimePickerTemplateDirective,
                    IgxTimePickerActionsDirective,
                    TimeDisplayFormatPipe,
                    TimeInputFormatPipe
                ],
                imports: [
                    common.CommonModule,
                    IgxInputGroupModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxMaskModule,
                    IgxToggleModule
                ],
                providers: []
            })
        ], IgxTimePickerModule);
        return IgxTimePickerModule;
    }());

    var NEXT_ID$v = 0;
    /**
     * **Ignite UI for Angular Toast** -
     * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/toast.html)
     *
     * The Ignite UI Toast provides information and warning messages that are non-interactive and cannot
     * be dismissed by the user. Toasts can be displayed at the bottom, middle, or top of the page.
     *
     * Example:
     * ```html
     * <button (click)="toast.show()">Show notification</button>
     * <igx-toast #toast
     *           message="Notification displayed"
     *           displayTime="1000">
     * </igx-toast>
     * ```
     */
    var IgxToastComponent = /** @class */ (function () {
        function IgxToastComponent(elementRef, navService) {
            this.elementRef = elementRef;
            this.navService = navService;
            this._isVisible = false;
            /**
             * Returns a list of available CSS classes.
             * ```typescript
             * let toastClasses =  this.toast.CSS_CLASSES;
             * ```
             * @memberof IgxToastComponent
             */
            this.CSS_CLASSES = {
                IGX_TOAST_BOTTOM: 'igx-toast--bottom',
                IGX_TOAST_MIDDLE: 'igx-toast--middle',
                IGX_TOAST_TOP: 'igx-toast--top'
            };
            /**
             * Sets/gets the `id` of the toast.
             * If not set, the `id` will have value `"igx-toast-0"`.
             * ```html
             * <igx-toast id = "my-first-toast"></igx-toast>
             * ```
             * ```typescript
             * let toastId = this.toast.id;
             * ```
             */
            this.id = "igx-toast-" + NEXT_ID$v++;
            /**
             * Emits an event prior the toast is shown.
             * Provides reference to the `IgxToastComponent` as event argument.
             * ```html
             * <igx-toast (onShowing) = "onShowing($event)"></igx-toast>
             * ```
             * @memberof IgxToastComponent
             */
            this.onShowing = new core.EventEmitter();
            /**
             * Emits an event when the toast is shown.
             * Provides reference to the `IgxToastComponent` as event argument.
             * ```html
             * <igx-toast (onShown) = "onShown($event)"></igx-toast>
             * ```
             * @memberof IgxToastComponent
             */
            this.onShown = new core.EventEmitter();
            /**
             * Emits an event prior the toast is hidden.
             * Provides reference to the `IgxToastComponent` as event argument.
             * ```html
             * <igx-toast (onHiding) = "onHiding($event)"></igx-toast>
             * ```
             * @memberof IgxToastComponent
             */
            this.onHiding = new core.EventEmitter();
            /**
             *  Emits an event when the toast is hidden.
             *  Provides reference to the `IgxToastComponent` as event argument.
             * ```html
             * <igx-toast (onHidden) = "onHidden($event)"></igx-toast>
             * ```
             * @memberof IgxToastComponent
             */
            this.onHidden = new core.EventEmitter();
            /**
             * Sets/gets the `role` attribute.
             * If not set, `role` will have value `"alert"`.
             * ```html
             * <igx-toast [role] = "'notify'"></igx-toast>
             * ```
             * ```typescript
             * let toastRole = this.toast.role;
             * ```
             * @memberof IgxToastComponent
             */
            this.role = 'alert';
            /**
             * Sets/gets whether the toast will be hidden after the `displayTime` is over.
             * Default value is `true`.
             * ```html
             * <igx-toast [autoHide] = "false"></igx-toast>
             * ```
             * ```typescript
             * let autoHide = this.toast.autoHide;
             * ```
             * @memberof IgxToastComponent
             */
            this.autoHide = true;
            /**
             * Sets/gets the duration of time span(in milliseconds) which the toast will be visible
             * after it is being shown.
             * Default value is `4000`.
             * ```html
             * <igx-toast [displayTime] = "2500"></igx-toast>
             * ```
             * ```typescript
             * let displayTime = this.toast.displayTime;
             * ```
             * @memberof IgxToastComponent
             */
            this.displayTime = 4000;
            /**
             *@hidden
             */
            this.isVisibleChange = new core.EventEmitter();
            /**
             * Sets/gets the position of the toast.
             * If not set, the `position` attribute will have value `IgxToastPosition.Bottom`.
             * ```html
             * <igx-toast [position] = "top"></igx-toast>
             * ```
             * ```typescript
             * let toastPosition = this.toast.position;
             * ```
             * @memberof IgxToastComponent
             */
            this.position = exports.IgxToastPosition.Bottom;
        }
        Object.defineProperty(IgxToastComponent.prototype, "isVisible", {
            /**
             * Enables/Disables the visibility of the toast.
             * If not set, the `isVisible` attribute will have value `false`.
             * ```html
             * <igx-toast [isVisible] = "true"></igx-toast>
             * ```
             * ```typescript
             * let isVisible = this.toast.isVisible;
             * ```
             *
             * Two-way data binding.
             * ```html
             * <igx-toast [(isVisible)] = "model.isVisible"></igx-toast>
             * ```
             * @memberof IgxToastComponent
             */
            get: function () {
                return this._isVisible;
            },
            set: function (value) {
                this._isVisible = value;
                this.isVisibleChange.emit(this._isVisible);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgxToastComponent.prototype, "element", {
            /**
             * Gets the nativeElement of the toast.
             * ```typescript
             * let nativeElement = this.toast.element;
             * ```
             * @memberof IgxToastComponent
             */
            get: function () {
                return this.elementRef.nativeElement;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Shows the toast.
         * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
         * ```typescript
         * this.toast.show();
         * ```
         * @memberof IgxToastComponent
         */
        IgxToastComponent.prototype.show = function () {
            var _this = this;
            clearInterval(this.timeoutId);
            this.onShowing.emit(this);
            this.isVisible = true;
            if (this.autoHide) {
                this.timeoutId = setTimeout(function () {
                    _this.hide();
                }, this.displayTime);
            }
            this.onShown.emit(this);
        };
        /**
         * Hides the toast.
         * ```typescript
         * this.toast.hide();
         * ```
         * @memberof IgxToastComponent
         */
        IgxToastComponent.prototype.hide = function () {
            this.onHiding.emit(this);
            this.isVisible = false;
            this.onHidden.emit(this);
            clearInterval(this.timeoutId);
        };
        /**
         * Wraps @show() method due @IToggleView interface implementation.
         * @hidden
         */
        IgxToastComponent.prototype.open = function () {
            this.show();
        };
        /**
         * Wraps @hide() method due @IToggleView interface implementation.
         * @hidden
         */
        IgxToastComponent.prototype.close = function () {
            this.hide();
        };
        /**
         * Toggles the visible state of the toast.
         * ```typescript
         * this.toast.toggle();
         * ```
         * @memberof IgxToastComponent
         */
        IgxToastComponent.prototype.toggle = function () {
            this.isVisible ? this.close() : this.open();
        };
        /**
         * Sets/gets the class name of the toast based on the `position` value.
         * ```typescript
         * let className =  this.toast.mapPositionToClassName();
         * ```
         * @memberof IgxToastComponent
         */
        IgxToastComponent.prototype.mapPositionToClassName = function () {
            if (this.position === exports.IgxToastPosition.Top) {
                return this.CSS_CLASSES.IGX_TOAST_TOP;
            }
            if (this.position === exports.IgxToastPosition.Middle) {
                return this.CSS_CLASSES.IGX_TOAST_MIDDLE;
            }
            if (this.position === exports.IgxToastPosition.Bottom) {
                return this.CSS_CLASSES.IGX_TOAST_BOTTOM;
            }
        };
        /**
         *@hidden
         */
        IgxToastComponent.prototype.ngOnInit = function () {
            if (this.navService && this.id) {
                this.navService.add(this.id, this);
            }
        };
        /**
         *@hidden
         */
        IgxToastComponent.prototype.ngOnDestroy = function () {
            if (this.navService && this.id) {
                this.navService.remove(this.id);
            }
        };
        IgxToastComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: IgxNavigationService, decorators: [{ type: core.Optional }] }
        ]; };
        __decorate([
            core.HostBinding('attr.id'),
            core.Input()
        ], IgxToastComponent.prototype, "id", void 0);
        __decorate([
            core.Output()
        ], IgxToastComponent.prototype, "onShowing", void 0);
        __decorate([
            core.Output()
        ], IgxToastComponent.prototype, "onShown", void 0);
        __decorate([
            core.Output()
        ], IgxToastComponent.prototype, "onHiding", void 0);
        __decorate([
            core.Output()
        ], IgxToastComponent.prototype, "onHidden", void 0);
        __decorate([
            core.Input()
        ], IgxToastComponent.prototype, "role", void 0);
        __decorate([
            core.Input()
        ], IgxToastComponent.prototype, "autoHide", void 0);
        __decorate([
            core.Input()
        ], IgxToastComponent.prototype, "displayTime", void 0);
        __decorate([
            core.Input()
        ], IgxToastComponent.prototype, "isVisible", null);
        __decorate([
            core.Output()
        ], IgxToastComponent.prototype, "isVisibleChange", void 0);
        __decorate([
            core.Input()
        ], IgxToastComponent.prototype, "message", void 0);
        __decorate([
            core.Input()
        ], IgxToastComponent.prototype, "position", void 0);
        IgxToastComponent = __decorate([
            core.Component({
                animations: [
                    animations.trigger('animate', [
                        animations.state('show', animations.style({
                            opacity: 1
                        })),
                        animations.transition('* => show', animations.animate('.20s ease')),
                        animations.transition('show => *', animations.animate('.40s ease-out'))
                    ])
                ],
                selector: 'igx-toast',
                template: "<div [ngClass]=\"mapPositionToClassName()\" *ngIf=\"this.isVisible\" [@animate]=\"'show'\">\n    {{ message }}\n</div>\n",
                styles: ["\n        :host {\n            display: block;\n        }\n    "]
            }),
            __param(1, core.Optional())
        ], IgxToastComponent);
        return IgxToastComponent;
    }());
    /**
     * Enumeration for toast position
     * Can be:
     * Bottom
     * Middle
     * Top
     */

    (function (IgxToastPosition) {
        IgxToastPosition[IgxToastPosition["Bottom"] = 0] = "Bottom";
        IgxToastPosition[IgxToastPosition["Middle"] = 1] = "Middle";
        IgxToastPosition[IgxToastPosition["Top"] = 2] = "Top";
    })(exports.IgxToastPosition || (exports.IgxToastPosition = {}));
    /**
     * @hidden
     */
    var IgxToastModule = /** @class */ (function () {
        function IgxToastModule() {
        }
        IgxToastModule = __decorate([
            core.NgModule({
                declarations: [IgxToastComponent],
                exports: [IgxToastComponent],
                imports: [common.CommonModule]
            })
        ], IgxToastModule);
        return IgxToastModule;
    }());

    exports.AbsoluteScrollStrategy = AbsoluteScrollStrategy;
    exports.AutoPositionStrategy = AutoPositionStrategy;
    exports.BaseFilteringStrategy = BaseFilteringStrategy;
    exports.BaseProgress = BaseProgress;
    exports.BlockScrollStrategy = BlockScrollStrategy;
    exports.Calendar = Calendar;
    exports.CalendarHammerConfig = CalendarHammerConfig;
    exports.CarouselHammerConfig = CarouselHammerConfig;
    exports.CloseScrollStrategy = CloseScrollStrategy;
    exports.ConnectedPositioningStrategy = ConnectedPositioningStrategy;
    exports.ContainerPositionStrategy = ContainerPositionStrategy;
    exports.DataUtil = DataUtil;
    exports.DefaultSortingStrategy = DefaultSortingStrategy;
    exports.DisplayDensityBase = DisplayDensityBase;
    exports.DisplayDensityToken = DisplayDensityToken;
    exports.ElasticPositionStrategy = ElasticPositionStrategy;
    exports.FilteringExpressionsTree = FilteringExpressionsTree;
    exports.FilteringStrategy = FilteringStrategy;
    exports.GlobalPositionStrategy = GlobalPositionStrategy;
    exports.GridBaseAPIService = GridBaseAPIService;
    exports.GroupedRecords = GroupedRecords;
    exports.IGX_CHECKBOX_REQUIRED_VALIDATOR = IGX_CHECKBOX_REQUIRED_VALIDATOR;
    exports.IGX_SWITCH_REQUIRED_VALIDATOR = IGX_SWITCH_REQUIRED_VALIDATOR;
    exports.IgxActionIconDirective = IgxActionIconDirective;
    exports.IgxAppendDropStrategy = IgxAppendDropStrategy;
    exports.IgxAutocompleteDirective = IgxAutocompleteDirective;
    exports.IgxAutocompleteModule = IgxAutocompleteModule;
    exports.IgxAvatarComponent = IgxAvatarComponent;
    exports.IgxAvatarModule = IgxAvatarModule;
    exports.IgxBadgeComponent = IgxBadgeComponent;
    exports.IgxBadgeModule = IgxBadgeModule;
    exports.IgxBannerComponent = IgxBannerComponent;
    exports.IgxBannerModule = IgxBannerModule;
    exports.IgxBaseExporter = IgxBaseExporter;
    exports.IgxBaseTransactionService = IgxBaseTransactionService;
    exports.IgxBooleanFilteringOperand = IgxBooleanFilteringOperand;
    exports.IgxBottomNavComponent = IgxBottomNavComponent;
    exports.IgxBottomNavModule = IgxBottomNavModule;
    exports.IgxButtonDirective = IgxButtonDirective;
    exports.IgxButtonGroupComponent = IgxButtonGroupComponent;
    exports.IgxButtonGroupModule = IgxButtonGroupModule;
    exports.IgxButtonModule = IgxButtonModule;
    exports.IgxCalendarComponent = IgxCalendarComponent;
    exports.IgxCalendarHeaderTemplateDirective = IgxCalendarHeaderTemplateDirective;
    exports.IgxCalendarModule = IgxCalendarModule;
    exports.IgxCalendarMonthDirective = IgxCalendarMonthDirective;
    exports.IgxCalendarScrollMonthDirective = IgxCalendarScrollMonthDirective;
    exports.IgxCalendarSubheaderTemplateDirective = IgxCalendarSubheaderTemplateDirective;
    exports.IgxCalendarYearDirective = IgxCalendarYearDirective;
    exports.IgxCardActionsComponent = IgxCardActionsComponent;
    exports.IgxCardComponent = IgxCardComponent;
    exports.IgxCardContentDirective = IgxCardContentDirective;
    exports.IgxCardFooterDirective = IgxCardFooterDirective;
    exports.IgxCardHeaderComponent = IgxCardHeaderComponent;
    exports.IgxCardHeaderSubtitleDirective = IgxCardHeaderSubtitleDirective;
    exports.IgxCardHeaderTitleDirective = IgxCardHeaderTitleDirective;
    exports.IgxCardMediaDirective = IgxCardMediaDirective;
    exports.IgxCardModule = IgxCardModule;
    exports.IgxCardThumbnailDirective = IgxCardThumbnailDirective;
    exports.IgxCarouselComponent = IgxCarouselComponent;
    exports.IgxCarouselModule = IgxCarouselModule;
    exports.IgxCellEditorTemplateDirective = IgxCellEditorTemplateDirective;
    exports.IgxCellFooterTemplateDirective = IgxCellFooterTemplateDirective;
    exports.IgxCellHeaderTemplateDirective = IgxCellHeaderTemplateDirective;
    exports.IgxCellTemplateDirective = IgxCellTemplateDirective;
    exports.IgxCheckboxComponent = IgxCheckboxComponent;
    exports.IgxCheckboxModule = IgxCheckboxModule;
    exports.IgxCheckboxRequiredDirective = IgxCheckboxRequiredDirective;
    exports.IgxChipComponent = IgxChipComponent;
    exports.IgxChipsAreaComponent = IgxChipsAreaComponent;
    exports.IgxChipsModule = IgxChipsModule;
    exports.IgxCircularProgressBarComponent = IgxCircularProgressBarComponent;
    exports.IgxCollapsibleIndicatorTemplateDirective = IgxCollapsibleIndicatorTemplateDirective;
    exports.IgxColumnComponent = IgxColumnComponent;
    exports.IgxColumnGroupComponent = IgxColumnGroupComponent;
    exports.IgxColumnHidingComponent = IgxColumnHidingComponent;
    exports.IgxColumnHidingModule = IgxColumnHidingModule;
    exports.IgxColumnLayoutComponent = IgxColumnLayoutComponent;
    exports.IgxColumnPinningComponent = IgxColumnPinningComponent;
    exports.IgxComboComponent = IgxComboComponent;
    exports.IgxComboModule = IgxComboModule;
    exports.IgxCsvExporterOptions = IgxCsvExporterOptions;
    exports.IgxCsvExporterService = IgxCsvExporterService;
    exports.IgxDataLoadingTemplateDirective = IgxDataLoadingTemplateDirective;
    exports.IgxDataRecordSorting = IgxDataRecordSorting;
    exports.IgxDateFilteringOperand = IgxDateFilteringOperand;
    exports.IgxDatePickerComponent = IgxDatePickerComponent;
    exports.IgxDatePickerModule = IgxDatePickerModule;
    exports.IgxDateSummaryOperand = IgxDateSummaryOperand;
    exports.IgxDaysViewComponent = IgxDaysViewComponent;
    exports.IgxDefaultDropStrategy = IgxDefaultDropStrategy;
    exports.IgxDialogComponent = IgxDialogComponent;
    exports.IgxDialogModule = IgxDialogModule;
    exports.IgxDisplayDensityModule = IgxDisplayDensityModule;
    exports.IgxDividerDirective = IgxDividerDirective;
    exports.IgxDividerModule = IgxDividerModule;
    exports.IgxDragDirective = IgxDragDirective;
    exports.IgxDragDropModule = IgxDragDropModule;
    exports.IgxDragLocation = IgxDragLocation;
    exports.IgxDropDirective = IgxDropDirective;
    exports.IgxDropDownBaseDirective = IgxDropDownBaseDirective;
    exports.IgxDropDownComponent = IgxDropDownComponent;
    exports.IgxDropDownGroupComponent = IgxDropDownGroupComponent;
    exports.IgxDropDownItemBaseDirective = IgxDropDownItemBaseDirective;
    exports.IgxDropDownItemComponent = IgxDropDownItemComponent;
    exports.IgxDropDownItemNavigationDirective = IgxDropDownItemNavigationDirective;
    exports.IgxDropDownModule = IgxDropDownModule;
    exports.IgxEmptyListTemplateDirective = IgxEmptyListTemplateDirective;
    exports.IgxExcelExporterOptions = IgxExcelExporterOptions;
    exports.IgxExcelExporterService = IgxExcelExporterService;
    exports.IgxExpansionPanelBodyComponent = IgxExpansionPanelBodyComponent;
    exports.IgxExpansionPanelComponent = IgxExpansionPanelComponent;
    exports.IgxExpansionPanelHeaderComponent = IgxExpansionPanelHeaderComponent;
    exports.IgxExpansionPanelModule = IgxExpansionPanelModule;
    exports.IgxExporterOptionsBase = IgxExporterOptionsBase;
    exports.IgxFilterCellTemplateDirective = IgxFilterCellTemplateDirective;
    exports.IgxFilterDirective = IgxFilterDirective;
    exports.IgxFilterModule = IgxFilterModule;
    exports.IgxFilterOptions = IgxFilterOptions;
    exports.IgxFilterPipe = IgxFilterPipe;
    exports.IgxFilteringOperand = IgxFilteringOperand;
    exports.IgxFlexDirective = IgxFlexDirective;
    exports.IgxFocusDirective = IgxFocusDirective;
    exports.IgxFocusModule = IgxFocusModule;
    exports.IgxForOfContext = IgxForOfContext;
    exports.IgxForOfDirective = IgxForOfDirective;
    exports.IgxForOfModule = IgxForOfModule;
    exports.IgxGridAPIService = IgxGridAPIService;
    exports.IgxGridBaseDirective = IgxGridBaseDirective;
    exports.IgxGridBodyDirective = IgxGridBodyDirective;
    exports.IgxGridCellComponent = IgxGridCellComponent;
    exports.IgxGridCommonModule = IgxGridCommonModule;
    exports.IgxGridComponent = IgxGridComponent;
    exports.IgxGridDetailTemplateDirective = IgxGridDetailTemplateDirective;
    exports.IgxGridForOfDirective = IgxGridForOfDirective;
    exports.IgxGridGroupByRowComponent = IgxGridGroupByRowComponent;
    exports.IgxGridModule = IgxGridModule;
    exports.IgxGridRowComponent = IgxGridRowComponent;
    exports.IgxGridStateDirective = IgxGridStateDirective;
    exports.IgxGridStateModule = IgxGridStateModule;
    exports.IgxGridTransaction = IgxGridTransaction;
    exports.IgxGroupAreaDropDirective = IgxGroupAreaDropDirective;
    exports.IgxGroupByRowTemplateDirective = IgxGroupByRowTemplateDirective;
    exports.IgxGrouping = IgxGrouping;
    exports.IgxHeaderCollapseIndicatorDirective = IgxHeaderCollapseIndicatorDirective;
    exports.IgxHeaderExpandIndicatorDirective = IgxHeaderExpandIndicatorDirective;
    exports.IgxHierarchicalGridAPIService = IgxHierarchicalGridAPIService;
    exports.IgxHierarchicalGridBaseDirective = IgxHierarchicalGridBaseDirective;
    exports.IgxHierarchicalGridCellComponent = IgxHierarchicalGridCellComponent;
    exports.IgxHierarchicalGridComponent = IgxHierarchicalGridComponent;
    exports.IgxHierarchicalGridModule = IgxHierarchicalGridModule;
    exports.IgxHierarchicalRowComponent = IgxHierarchicalRowComponent;
    exports.IgxHierarchicalTransactionService = IgxHierarchicalTransactionService;
    exports.IgxHierarchicalTransactionServiceFactory = IgxHierarchicalTransactionServiceFactory;
    exports.IgxHintDirective = IgxHintDirective;
    exports.IgxIconComponent = IgxIconComponent;
    exports.IgxIconModule = IgxIconModule;
    exports.IgxIconService = IgxIconService;
    exports.IgxInputDirective = IgxInputDirective;
    exports.IgxInputGroupComponent = IgxInputGroupComponent;
    exports.IgxInputGroupModule = IgxInputGroupModule;
    exports.IgxInsertDropStrategy = IgxInsertDropStrategy;
    exports.IgxLabelDirective = IgxLabelDirective;
    exports.IgxLayoutDirective = IgxLayoutDirective;
    exports.IgxLayoutModule = IgxLayoutModule;
    exports.IgxLeftButtonStyleDirective = IgxLeftButtonStyleDirective;
    exports.IgxLinearProgressBarComponent = IgxLinearProgressBarComponent;
    exports.IgxListActionDirective = IgxListActionDirective;
    exports.IgxListBaseDirective = IgxListBaseDirective;
    exports.IgxListComponent = IgxListComponent;
    exports.IgxListItemComponent = IgxListItemComponent;
    exports.IgxListItemLeftPanningTemplateDirective = IgxListItemLeftPanningTemplateDirective;
    exports.IgxListItemRightPanningTemplateDirective = IgxListItemRightPanningTemplateDirective;
    exports.IgxListLineDirective = IgxListLineDirective;
    exports.IgxListLineSubTitleDirective = IgxListLineSubTitleDirective;
    exports.IgxListLineTitleDirective = IgxListLineTitleDirective;
    exports.IgxListModule = IgxListModule;
    exports.IgxListThumbnailDirective = IgxListThumbnailDirective;
    exports.IgxMaskDirective = IgxMaskDirective;
    exports.IgxMaskModule = IgxMaskModule;
    exports.IgxMonthPickerBaseDirective = IgxMonthPickerBaseDirective;
    exports.IgxMonthPickerComponent = IgxMonthPickerComponent;
    exports.IgxMonthsViewComponent = IgxMonthsViewComponent;
    exports.IgxNavDrawerItemDirective = IgxNavDrawerItemDirective;
    exports.IgxNavDrawerMiniTemplateDirective = IgxNavDrawerMiniTemplateDirective;
    exports.IgxNavDrawerTemplateDirective = IgxNavDrawerTemplateDirective;
    exports.IgxNavbarComponent = IgxNavbarComponent;
    exports.IgxNavbarModule = IgxNavbarModule;
    exports.IgxNavigationCloseDirective = IgxNavigationCloseDirective;
    exports.IgxNavigationDrawerComponent = IgxNavigationDrawerComponent;
    exports.IgxNavigationDrawerModule = IgxNavigationDrawerModule;
    exports.IgxNavigationModule = IgxNavigationModule;
    exports.IgxNavigationService = IgxNavigationService;
    exports.IgxNavigationToggleDirective = IgxNavigationToggleDirective;
    exports.IgxNumberFilteringOperand = IgxNumberFilteringOperand;
    exports.IgxNumberSummaryOperand = IgxNumberSummaryOperand;
    exports.IgxOverlayOutletDirective = IgxOverlayOutletDirective;
    exports.IgxOverlayService = IgxOverlayService;
    exports.IgxPaginatorComponent = IgxPaginatorComponent;
    exports.IgxPaginatorModule = IgxPaginatorModule;
    exports.IgxPrefixDirective = IgxPrefixDirective;
    exports.IgxPrefixModule = IgxPrefixModule;
    exports.IgxPrependDropStrategy = IgxPrependDropStrategy;
    exports.IgxProgressBarModule = IgxProgressBarModule;
    exports.IgxRadioComponent = IgxRadioComponent;
    exports.IgxRadioGroupDirective = IgxRadioGroupDirective;
    exports.IgxRadioModule = IgxRadioModule;
    exports.IgxRightButtonStyleDirective = IgxRightButtonStyleDirective;
    exports.IgxRippleDirective = IgxRippleDirective;
    exports.IgxRippleModule = IgxRippleModule;
    exports.IgxRowCollapsedIndicatorDirective = IgxRowCollapsedIndicatorDirective;
    exports.IgxRowDirective = IgxRowDirective;
    exports.IgxRowExpandedIndicatorDirective = IgxRowExpandedIndicatorDirective;
    exports.IgxRowIslandAPIService = IgxRowIslandAPIService;
    exports.IgxRowIslandComponent = IgxRowIslandComponent;
    exports.IgxSelectComponent = IgxSelectComponent;
    exports.IgxSelectFooterDirective = IgxSelectFooterDirective;
    exports.IgxSelectGroupComponent = IgxSelectGroupComponent;
    exports.IgxSelectHeaderDirective = IgxSelectHeaderDirective;
    exports.IgxSelectItemComponent = IgxSelectItemComponent;
    exports.IgxSelectModule = IgxSelectModule;
    exports.IgxSelectToggleIconDirective = IgxSelectToggleIconDirective;
    exports.IgxSliderComponent = IgxSliderComponent;
    exports.IgxSliderModule = IgxSliderModule;
    exports.IgxSnackbarComponent = IgxSnackbarComponent;
    exports.IgxSnackbarModule = IgxSnackbarModule;
    exports.IgxSorting = IgxSorting;
    exports.IgxStringFilteringOperand = IgxStringFilteringOperand;
    exports.IgxSuffixDirective = IgxSuffixDirective;
    exports.IgxSuffixModule = IgxSuffixModule;
    exports.IgxSummaryOperand = IgxSummaryOperand;
    exports.IgxSwitchComponent = IgxSwitchComponent;
    exports.IgxSwitchModule = IgxSwitchModule;
    exports.IgxSwitchRequiredDirective = IgxSwitchRequiredDirective;
    exports.IgxTabComponent = IgxTabComponent;
    exports.IgxTabItemComponent = IgxTabItemComponent;
    exports.IgxTabItemTemplateDirective = IgxTabItemTemplateDirective;
    exports.IgxTabPanelComponent = IgxTabPanelComponent;
    exports.IgxTabTemplateDirective = IgxTabTemplateDirective;
    exports.IgxTabsComponent = IgxTabsComponent;
    exports.IgxTabsGroupComponent = IgxTabsGroupComponent;
    exports.IgxTabsModule = IgxTabsModule;
    exports.IgxTextHighlightDirective = IgxTextHighlightDirective;
    exports.IgxTextHighlightModule = IgxTextHighlightModule;
    exports.IgxTextSelectionDirective = IgxTextSelectionDirective;
    exports.IgxTextSelectionModule = IgxTextSelectionModule;
    exports.IgxThumbFromTemplateDirective = IgxThumbFromTemplateDirective;
    exports.IgxThumbToTemplateDirective = IgxThumbToTemplateDirective;
    exports.IgxTickLabelTemplateDirective = IgxTickLabelTemplateDirective;
    exports.IgxTimePickerComponent = IgxTimePickerComponent;
    exports.IgxTimePickerModule = IgxTimePickerModule;
    exports.IgxToastComponent = IgxToastComponent;
    exports.IgxToastModule = IgxToastModule;
    exports.IgxToggleActionDirective = IgxToggleActionDirective;
    exports.IgxToggleDirective = IgxToggleDirective;
    exports.IgxToggleModule = IgxToggleModule;
    exports.IgxTooltipDirective = IgxTooltipDirective;
    exports.IgxTooltipModule = IgxTooltipModule;
    exports.IgxTooltipTargetDirective = IgxTooltipTargetDirective;
    exports.IgxTransactionService = IgxTransactionService;
    exports.IgxTreeGridAPIService = IgxTreeGridAPIService;
    exports.IgxTreeGridCellComponent = IgxTreeGridCellComponent;
    exports.IgxTreeGridComponent = IgxTreeGridComponent;
    exports.IgxTreeGridModule = IgxTreeGridModule;
    exports.IgxTreeGridRowComponent = IgxTreeGridRowComponent;
    exports.IgxYearsViewComponent = IgxYearsViewComponent;
    exports.NoOpScrollStrategy = NoOpScrollStrategy;
    exports.NoopFilteringStrategy = NoopFilteringStrategy;
    exports.NoopSortingStrategy = NoopSortingStrategy;
    exports.Point = Point;
    exports.RowEditPositionStrategy = RowEditPositionStrategy;
    exports.ScrollStrategy = ScrollStrategy;
    exports.TimePickerHammerConfig = TimePickerHammerConfig;
    exports.blink = blink;
    exports.changei18n = changei18n;
    exports.convertInPercentage = convertInPercentage;
    exports.fadeIn = fadeIn;
    exports.fadeOut = fadeOut;
    exports.filteringStateDefaults = filteringStateDefaults;
    exports.flipBottom = flipBottom;
    exports.flipHorBck = flipHorBck;
    exports.flipHorFwd = flipHorFwd;
    exports.flipLeft = flipLeft;
    exports.flipRight = flipRight;
    exports.flipTop = flipTop;
    exports.flipVerBck = flipVerBck;
    exports.flipVerFwd = flipVerFwd;
    exports.getCurrentResourceStrings = getCurrentResourceStrings;
    exports.getTypeNameForDebugging = getTypeNameForDebugging;
    exports.getValueInProperRange = getValueInProperRange;
    exports.growVerIn = growVerIn;
    exports.growVerOut = growVerOut;
    exports.heartbeat = heartbeat;
    exports.hierarchicalTransactionServiceFactory = hierarchicalTransactionServiceFactory;
    exports.isDateInRanges = isDateInRanges;
    exports.isLeap = isLeap;
    exports.monthRange = monthRange;
    exports.pulsateBck = pulsateBck;
    exports.pulsateFwd = pulsateFwd;
    exports.range = range;
    exports.rotateInBl = rotateInBl;
    exports.rotateInBottom = rotateInBottom;
    exports.rotateInBr = rotateInBr;
    exports.rotateInCenter = rotateInCenter;
    exports.rotateInDiagonal1 = rotateInDiagonal1;
    exports.rotateInDiagonal2 = rotateInDiagonal2;
    exports.rotateInHor = rotateInHor;
    exports.rotateInLeft = rotateInLeft;
    exports.rotateInRight = rotateInRight;
    exports.rotateInTl = rotateInTl;
    exports.rotateInTop = rotateInTop;
    exports.rotateInTr = rotateInTr;
    exports.rotateInVer = rotateInVer;
    exports.rotateOutBl = rotateOutBl;
    exports.rotateOutBottom = rotateOutBottom;
    exports.rotateOutBr = rotateOutBr;
    exports.rotateOutCenter = rotateOutCenter;
    exports.rotateOutDiagonal1 = rotateOutDiagonal1;
    exports.rotateOutDiagonal2 = rotateOutDiagonal2;
    exports.rotateOutHor = rotateOutHor;
    exports.rotateOutLeft = rotateOutLeft;
    exports.rotateOutRight = rotateOutRight;
    exports.rotateOutTl = rotateOutTl;
    exports.rotateOutTop = rotateOutTop;
    exports.rotateOutTr = rotateOutTr;
    exports.rotateOutVer = rotateOutVer;
    exports.scaleInBl = scaleInBl;
    exports.scaleInBottom = scaleInBottom;
    exports.scaleInBr = scaleInBr;
    exports.scaleInCenter = scaleInCenter;
    exports.scaleInHorCenter = scaleInHorCenter;
    exports.scaleInHorLeft = scaleInHorLeft;
    exports.scaleInHorRight = scaleInHorRight;
    exports.scaleInLeft = scaleInLeft;
    exports.scaleInRight = scaleInRight;
    exports.scaleInTl = scaleInTl;
    exports.scaleInTop = scaleInTop;
    exports.scaleInTr = scaleInTr;
    exports.scaleInVerBottom = scaleInVerBottom;
    exports.scaleInVerCenter = scaleInVerCenter;
    exports.scaleInVerTop = scaleInVerTop;
    exports.scaleOutBl = scaleOutBl;
    exports.scaleOutBottom = scaleOutBottom;
    exports.scaleOutBr = scaleOutBr;
    exports.scaleOutCenter = scaleOutCenter;
    exports.scaleOutHorCenter = scaleOutHorCenter;
    exports.scaleOutHorLeft = scaleOutHorLeft;
    exports.scaleOutHorRight = scaleOutHorRight;
    exports.scaleOutLeft = scaleOutLeft;
    exports.scaleOutRight = scaleOutRight;
    exports.scaleOutTl = scaleOutTl;
    exports.scaleOutTop = scaleOutTop;
    exports.scaleOutTr = scaleOutTr;
    exports.scaleOutVerBottom = scaleOutVerBottom;
    exports.scaleOutVerCenter = scaleOutVerCenter;
    exports.scaleOutVerTop = scaleOutVerTop;
    exports.shakeBl = shakeBl;
    exports.shakeBottom = shakeBottom;
    exports.shakeBr = shakeBr;
    exports.shakeCenter = shakeCenter;
    exports.shakeHor = shakeHor;
    exports.shakeLeft = shakeLeft;
    exports.shakeRight = shakeRight;
    exports.shakeTl = shakeTl;
    exports.shakeTop = shakeTop;
    exports.shakeTr = shakeTr;
    exports.shakeVer = shakeVer;
    exports.slideInBl = slideInBl;
    exports.slideInBottom = slideInBottom;
    exports.slideInBr = slideInBr;
    exports.slideInLeft = slideInLeft;
    exports.slideInRight = slideInRight;
    exports.slideInTl = slideInTl;
    exports.slideInTop = slideInTop;
    exports.slideInTr = slideInTr;
    exports.slideOutBl = slideOutBl;
    exports.slideOutBottom = slideOutBottom;
    exports.slideOutBr = slideOutBr;
    exports.slideOutLeft = slideOutLeft;
    exports.slideOutRight = slideOutRight;
    exports.slideOutTl = slideOutTl;
    exports.slideOutTop = slideOutTop;
    exports.slideOutTr = slideOutTr;
    exports.swingInBottomBck = swingInBottomBck;
    exports.swingInBottomFwd = swingInBottomFwd;
    exports.swingInLeftBck = swingInLeftBck;
    exports.swingInLeftFwd = swingInLeftFwd;
    exports.swingInRightBck = swingInRightBck;
    exports.swingInRightFwd = swingInRightFwd;
    exports.swingInTopBck = swingInTopBck;
    exports.swingInTopFwd = swingInTopFwd;
    exports.swingOutBottomBck = swingOutBottomBck;
    exports.swingOutBottomFwd = swingOutBottomFwd;
    exports.swingOutLeftBck = swingOutLeftBck;
    exports.swingOutLefttFwd = swingOutLefttFwd;
    exports.swingOutRightBck = swingOutRightBck;
    exports.swingOutRightFwd = swingOutRightFwd;
    exports.swingOutTopBck = swingOutTopBck;
    exports.swingOutTopFwd = swingOutTopFwd;
    exports.weekDay = weekDay;
    exports.ɵ0 = ɵ0;
    exports.ɵ1 = ɵ1;
    exports.ɵ2 = ɵ2;
    exports.ɵa = IGX_DROPDOWN_BASE;
    exports.ɵba = IgxExpansionPanelIconDirective;
    exports.ɵbb = IgxCalendarBaseDirective;
    exports.ɵbc = IgxDaysViewNavigationService;
    exports.ɵbd = IgxDayItemComponent;
    exports.ɵbe = IgxMonthViewSlotsCalendar;
    exports.ɵbf = IgxGetViewDateCalendar;
    exports.ɵbg = IgxCarouselIndicatorDirective;
    exports.ɵbh = IgxCarouselNextButtonDirective;
    exports.ɵbi = IgxCarouselPrevButtonDirective;
    exports.ɵbj = IgxSlideComponent;
    exports.ɵbk = IgxComboAPIService;
    exports.ɵbl = IGX_COMBO_COMPONENT;
    exports.ɵbn = IgxComboDropDownComponent;
    exports.ɵbo = IgxComboItemComponent;
    exports.ɵbp = IgxComboHeaderDirective;
    exports.ɵbq = IgxComboFooterDirective;
    exports.ɵbr = IgxComboItemDirective;
    exports.ɵbs = IgxComboEmptyDirective;
    exports.ɵbt = IgxComboHeaderItemDirective;
    exports.ɵbu = IgxComboAddItemDirective;
    exports.ɵbv = IgxComboToggleIconDirective;
    exports.ɵbw = IgxComboClearIconDirective;
    exports.ɵbx = IgxComboFilteringPipe;
    exports.ɵby = IgxComboGroupingPipe;
    exports.ɵbz = IgxComboAddItemComponent;
    exports.ɵc = IgxColumnHidingItemDirective;
    exports.ɵca = IgxDatePickerTemplateDirective;
    exports.ɵcb = IgxDatePickerActionsDirective;
    exports.ɵcc = IgxCalendarContainerComponent;
    exports.ɵcd = DatePickerDisplayValuePipe;
    exports.ɵce = DatePickerInputValuePipe;
    exports.ɵcf = IGX_DATE_PICKER_COMPONENT;
    exports.ɵch = IgxDialogTitleDirective;
    exports.ɵci = IgxDialogActionsDirective;
    exports.ɵcj = ColumnChooserBaseDirective;
    exports.ɵck = ItemPropertyValueChangedDirective;
    exports.ɵcl = ColumnChooserItemBaseDirective;
    exports.ɵcm = IgxGridSharedModules;
    exports.ɵcn = IgxTemplateOutletDirective;
    exports.ɵco = IgxTemplateOutletModule;
    exports.ɵcp = IgxProcessBarTextTemplateDirective;
    exports.ɵcq = IgxProgressBarGradientDirective;
    exports.ɵcr = DIR_DOCUMENT;
    exports.ɵcs = DIR_DOCUMENT_FACTORY;
    exports.ɵct = IgxDirectionality;
    exports.ɵcu = IgxSelectItemNavigationDirective;
    exports.ɵcv = WatchChanges;
    exports.ɵcw = WatchColumnChanges;
    exports.ɵcx = notifyChanges;
    exports.ɵcy = IgxGridColumnResizerComponent;
    exports.ɵcz = IgxColumnResizingService;
    exports.ɵda = IgxColumnResizerDirective;
    exports.ɵdb = IgxExcelStyleSortingTemplateDirective;
    exports.ɵdc = IgxExcelStyleMovingTemplateDirective;
    exports.ɵdd = IgxExcelStyleHidingTemplateDirective;
    exports.ɵde = IgxExcelStylePinningTemplateDirective;
    exports.ɵdf = IgxGridExcelStyleFilteringComponent;
    exports.ɵdg = IgxExcelStyleLoadingValuesTemplateDirective;
    exports.ɵdh = IgxExcelStyleSearchComponent;
    exports.ɵdi = IgxGridHeaderGroupComponent;
    exports.ɵdj = IgxGridHeaderComponent;
    exports.ɵdk = IgxFilteringService;
    exports.ɵdl = IgxGridFilteringCellComponent;
    exports.ɵdm = IgxChipsAreaComponent;
    exports.ɵdn = IgxChipComponent;
    exports.ɵdo = IgxSummaryRowComponent;
    exports.ɵdp = IgxSummaryCellComponent;
    exports.ɵdq = HammerGesturesManager;
    exports.ɵdr = IgxGridCRUDService;
    exports.ɵds = IgxGridSelectionService;
    exports.ɵdt = IgxGridToolbarCustomContentDirective;
    exports.ɵdu = IgxRowSelectorDirective;
    exports.ɵdv = IgxHeadSelectorDirective;
    exports.ɵdw = IgxRowDragDirective;
    exports.ɵdx = IgxDragIndicatorIconDirective;
    exports.ɵdy = IgxRowDragGhostDirective;
    exports.ɵdz = IgxRowDragModule;
    exports.ɵe = IGX_EXPANSION_PANEL_COMPONENT;
    exports.ɵea = IgxGridFilteringRowComponent;
    exports.ɵeb = IgxRowEditTemplateDirective;
    exports.ɵec = IgxRowEditTextDirective;
    exports.ɵed = IgxRowEditActionsDirective;
    exports.ɵee = IgxRowEditTabStopDirective;
    exports.ɵef = IgxGridToolbarComponent;
    exports.ɵeg = IgxGridNavigationService;
    exports.ɵeh = IgxGridSummaryService;
    exports.ɵei = ConnectedPositioningStrategy;
    exports.ɵej = IgxGridFooterComponent;
    exports.ɵek = IgxAdvancedFilteringDialogComponent;
    exports.ɵel = IgxColumnPinningModule;
    exports.ɵem = IgxColumnPinningItemDirective;
    exports.ɵen = IgxGridColumnModule;
    exports.ɵeo = IgxGridHeadersModule;
    exports.ɵep = IgxGridFilteringModule;
    exports.ɵeq = IgxGridPipesModule;
    exports.ɵer = IgxGridCellStyleClassesPipe;
    exports.ɵes = IgxGridCellStylesPipe;
    exports.ɵet = IgxGridNotGroupedPipe;
    exports.ɵeu = IgxGridTopLevelColumns;
    exports.ɵev = IgxGridFilterConditionPipe;
    exports.ɵew = IgxGridTransactionPipe;
    exports.ɵex = IgxGridPaginatorOptionsPipe;
    exports.ɵey = IgxHasVisibleColumnsPipe;
    exports.ɵez = IgxDatePipeComponent;
    exports.ɵf = PlatformUtil;
    exports.ɵfa = IgxDecimalPipeComponent;
    exports.ɵfb = IgxColumnMovingModule;
    exports.ɵfc = IgxColumnMovingDropDirective;
    exports.ɵfd = IgxColumnMovingService;
    exports.ɵfe = IgxColumnMovingDragDirective;
    exports.ɵff = IgxGridResizingModule;
    exports.ɵfg = IgxResizeHandleDirective;
    exports.ɵfh = IgxGridExcelStyleFilteringModule;
    exports.ɵfi = IgxDropDownComponent;
    exports.ɵfj = IgxExcelStyleCustomDialogComponent;
    exports.ɵfk = IgxExcelStyleDefaultExpressionComponent;
    exports.ɵfl = IgxExcelStyleDateExpressionComponent;
    exports.ɵfm = IgxListComponent;
    exports.ɵfn = IgxExcelStyleSortingComponent;
    exports.ɵfo = IgxExcelStyleColumnMovingComponent;
    exports.ɵfp = IgxExcelStyleSearchFilterPipe;
    exports.ɵfq = IgxGridSelectionModule;
    exports.ɵfr = IgxGridDragSelectDirective;
    exports.ɵfs = IgxGridSummaryModule;
    exports.ɵft = IgxSummaryDataPipe;
    exports.ɵfu = IgxGridToolbarModule;
    exports.ɵfv = IgxGridSortingPipe;
    exports.ɵfw = IgxGridGroupingPipe;
    exports.ɵfx = IgxGridPagingPipe;
    exports.ɵfy = IgxGridFilteringPipe;
    exports.ɵfz = IgxGridSummaryPipe;
    exports.ɵg = exports["ɵg"];
    exports.ɵga = IgxGridDetailsPipe;
    exports.ɵgb = IgxGridExpandableCellComponent;
    exports.ɵgc = IgxTreeGridNavigationService;
    exports.ɵgd = IgxRowLoadingIndicatorTemplateDirective;
    exports.ɵge = IgxTreeGridHierarchizingPipe;
    exports.ɵgf = IgxTreeGridFlatteningPipe;
    exports.ɵgg = IgxTreeGridSortingPipe;
    exports.ɵgh = IgxTreeGridPagingPipe;
    exports.ɵgi = IgxTreeGridTransactionPipe;
    exports.ɵgj = IgxTreeGridFilteringPipe;
    exports.ɵgk = IgxTreeGridSummaryPipe;
    exports.ɵgl = IgxHierarchicalGridNavigationService;
    exports.ɵgm = GridBaseAPIService;
    exports.ɵgn = IgxChildGridRowComponent;
    exports.ɵgo = IgxGridHierarchicalPipe;
    exports.ɵgp = IgxGridHierarchicalPagingPipe;
    exports.ɵgq = IgxSliderThumbComponent;
    exports.ɵgr = IgxThumbLabelComponent;
    exports.ɵgs = IgxTicksComponent;
    exports.ɵgt = IgxTickLabelsPipe;
    exports.ɵgu = IgxTabsBase;
    exports.ɵgv = IgxTabItemBase;
    exports.ɵgw = IgxTabsGroupBase;
    exports.ɵgx = IGX_TIME_PICKER_COMPONENT;
    exports.ɵgz = IgxItemListDirective;
    exports.ɵh = exports["ɵh"];
    exports.ɵha = IgxHourItemDirective;
    exports.ɵhb = IgxMinuteItemDirective;
    exports.ɵhc = IgxSecondsItemDirective;
    exports.ɵhd = IgxAmPmItemDirective;
    exports.ɵhe = IgxTimePickerTemplateDirective;
    exports.ɵhf = IgxTimePickerActionsDirective;
    exports.ɵhg = TimeDisplayFormatPipe;
    exports.ɵhh = TimeInputFormatPipe;
    exports.ɵi = IgxInputGroupBase;
    exports.ɵj = IgxForOfSyncService;
    exports.ɵk = IgxForOfScrollSyncService;
    exports.ɵl = DeprecateMethod;
    exports.ɵm = DeprecateProperty;
    exports.ɵn = IgxSelectionAPIService;
    exports.ɵo = IgxDragHandleDirective;
    exports.ɵp = DisplayContainerComponent;
    exports.ɵq = VirtualHelperComponent;
    exports.ɵr = VirtualHelperBaseDirective;
    exports.ɵs = HVirtualHelperComponent;
    exports.ɵt = IgxScrollInertiaDirective;
    exports.ɵu = IgxScrollInertiaModule;
    exports.ɵv = isHierarchyMatch;
    exports.ɵw = getHierarchy;
    exports.ɵx = IgxBannerActionsDirective;
    exports.ɵy = IgxExpansionPanelTitleDirective;
    exports.ɵz = IgxExpansionPanelDescriptionDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=igniteui-angular.umd.js.map
